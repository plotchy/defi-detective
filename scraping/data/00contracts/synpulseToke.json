[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn\\u0027t rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length \\u003e 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\r\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\r\\n     *\\r\\n     * _Available since v4.8._\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                // only check isContract if the call was successful and the return data is empty\\r\\n                // otherwise we already know that it was a contract\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\r\\n     * revert reason or using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length \\u003e 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"IERC1820Registry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/introspection/IERC1820Registry.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the global ERC1820 Registry, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\\r\\n * implementers for interfaces in this registry, as well as query support.\\r\\n *\\r\\n * Implementers may be shared by multiple accounts, and can also implement more\\r\\n * than a single interface for each account. Contracts can implement interfaces\\r\\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\\r\\n * contract.\\r\\n *\\r\\n * {IERC165} interfaces can also be queried via the registry.\\r\\n *\\r\\n * For an in-depth explanation and source code analysis, see the EIP text.\\r\\n */\\r\\ninterface IERC1820Registry {\\r\\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\\r\\n\\r\\n    event ManagerChanged(address indexed account, address indexed newManager);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\\r\\n     * account is able to set interface implementers for it.\\r\\n     *\\r\\n     * By default, each account is its own manager. Passing a value of `0x0` in\\r\\n     * `newManager` will reset the manager to this initial state.\\r\\n     *\\r\\n     * Emits a {ManagerChanged} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the current manager for `account`.\\r\\n     */\\r\\n    function setManager(address account, address newManager) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the manager for `account`.\\r\\n     *\\r\\n     * See {setManager}.\\r\\n     */\\r\\n    function getManager(address account) external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the `implementer` contract as ``account``\\u0027s implementer for\\r\\n     * `interfaceHash`.\\r\\n     *\\r\\n     * `account` being the zero address is an alias for the caller\\u0027s address.\\r\\n     * The zero address can also be used in `implementer` to remove an old one.\\r\\n     *\\r\\n     * See {interfaceHash} to learn how these are created.\\r\\n     *\\r\\n     * Emits an {InterfaceImplementerSet} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the current manager for `account`.\\r\\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\\r\\n     * end in 28 zeroes).\\r\\n     * - `implementer` must implement {IERC1820Implementer} and return true when\\r\\n     * queried for support, unless `implementer` is the caller. See\\r\\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\\r\\n     */\\r\\n    function setInterfaceImplementer(\\r\\n        address account,\\r\\n        bytes32 _interfaceHash,\\r\\n        address implementer\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\\r\\n     * implementer is registered, returns the zero address.\\r\\n     *\\r\\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\\r\\n     * zeroes), `account` will be queried for support of it.\\r\\n     *\\r\\n     * `account` being the zero address is an alias for the caller\\u0027s address.\\r\\n     */\\r\\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\\r\\n     * corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\\r\\n     */\\r\\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\\r\\n     * @param account Address of the contract for which to update the cache.\\r\\n     * @param interfaceId ERC165 interface for which to update the cache.\\r\\n     */\\r\\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Checks whether a contract implements an ERC165 interface or not.\\r\\n     * If the result is not cached a direct lookup on the contract address is performed.\\r\\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\\r\\n     * {updateERC165Cache} with the contract address.\\r\\n     * @param account Address of the contract to check.\\r\\n     * @param interfaceId ERC165 interface to check.\\r\\n     * @return True if `account` implements `interfaceId`, false otherwise.\\r\\n     */\\r\\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\\r\\n     * @param account Address of the contract to check.\\r\\n     * @param interfaceId ERC165 interface to check.\\r\\n     * @return True if `account` implements `interfaceId`, false otherwise.\\r\\n     */\\r\\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"IERC777.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC777/IERC777.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\r\\n *\\r\\n * This contract uses the\\r\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\r\\n * token holders and recipients react to token movements by using setting implementers\\r\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\r\\n * {ERC1820Implementer}.\\r\\n */\\r\\ninterface IERC777 {\\r\\n    /**\\r\\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\\r\\n     *\\r\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\r\\n     */\\r\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\\r\\n     *\\r\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\r\\n     */\\r\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `operator` is made operator for `tokenHolder`\\r\\n     */\\r\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`\\r\\n     */\\r\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest part of the token that is not divisible. This\\r\\n     * means all token operations (creation, movement and destruction) must have\\r\\n     * amounts that are a multiple of this number.\\r\\n     *\\r\\n     * For most token contracts, this value will equal 1.\\r\\n     */\\r\\n    function granularity() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * If send or receive hooks are registered for the caller and `recipient`,\\r\\n     * the corresponding functions will be called with `data` and empty\\r\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\r\\n     *\\r\\n     * Emits a {Sent} event.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - the caller must have at least `amount` tokens.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\r\\n     * interface.\\r\\n     */\\r\\n    function send(\\r\\n        address recipient,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from the caller\\u0027s account, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * If a send hook is registered for the caller, the corresponding function\\r\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\r\\n     *\\r\\n     * Emits a {Burned} event.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - the caller must have at least `amount` tokens.\\r\\n     */\\r\\n    function burn(uint256 amount, bytes calldata data) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\r\\n     * Operators can send and burn tokens on behalf of their owners. All\\r\\n     * accounts are their own operator.\\r\\n     *\\r\\n     * See {operatorSend} and {operatorBurn}.\\r\\n     */\\r\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Make an account an operator of the caller.\\r\\n     *\\r\\n     * See {isOperatorFor}.\\r\\n     *\\r\\n     * Emits an {AuthorizedOperator} event.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `operator` cannot be calling address.\\r\\n     */\\r\\n    function authorizeOperator(address operator) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revoke an account\\u0027s operator status for the caller.\\r\\n     *\\r\\n     * See {isOperatorFor} and {defaultOperators}.\\r\\n     *\\r\\n     * Emits a {RevokedOperator} event.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `operator` cannot be calling address.\\r\\n     */\\r\\n    function revokeOperator(address operator) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the list of default operators. These accounts are operators\\r\\n     * for all token holders, even if {authorizeOperator} was never called on\\r\\n     * them.\\r\\n     *\\r\\n     * This list is immutable, but individual holders may revoke these via\\r\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\r\\n     */\\r\\n    function defaultOperators() external view returns (address[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\r\\n     * be an operator of `sender`.\\r\\n     *\\r\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\r\\n     * the corresponding functions will be called with `data` and\\r\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\r\\n     *\\r\\n     * Emits a {Sent} event.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `sender` must have at least `amount` tokens.\\r\\n     * - the caller must be an operator for `sender`.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\r\\n     * interface.\\r\\n     */\\r\\n    function operatorSend(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount,\\r\\n        bytes calldata data,\\r\\n        bytes calldata operatorData\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\r\\n     * The caller must be an operator of `account`.\\r\\n     *\\r\\n     * If a send hook is registered for `account`, the corresponding function\\r\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\r\\n     *\\r\\n     * Emits a {Burned} event.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     * - the caller must be an operator for `account`.\\r\\n     */\\r\\n    function operatorBurn(\\r\\n        address account,\\r\\n        uint256 amount,\\r\\n        bytes calldata data,\\r\\n        bytes calldata operatorData\\r\\n    ) external;\\r\\n\\r\\n    event Sent(\\r\\n        address indexed operator,\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 amount,\\r\\n        bytes data,\\r\\n        bytes operatorData\\r\\n    );\\r\\n}\"},\"Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which allows children to implement an emergency stop\\r\\n * mechanism that can be triggered by an authorized account.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the\\r\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\r\\n * the functions of your contract. Note that they will not be pausable by\\r\\n * simply including this module, only once the modifiers are put in place.\\r\\n */\\r\\nabstract contract Pausable is Context {\\r\\n    /**\\r\\n     * @dev Emitted when the pause is triggered by `account`.\\r\\n     */\\r\\n    event Paused(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pause is lifted by `account`.\\r\\n     */\\r\\n    event Unpaused(address account);\\r\\n\\r\\n    bool private _paused;\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract in unpaused state.\\r\\n     */\\r\\n    constructor() {\\r\\n        _paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the contract is paused, and false otherwise.\\r\\n     */\\r\\n    function paused() public view virtual returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        require(!paused(), \\\"Pausable: paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        require(paused(), \\\"Pausable: not paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers stopped state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    function _pause() internal virtual whenNotPaused {\\r\\n        _paused = true;\\r\\n        emit Paused(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns to normal state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    function _unpause() internal virtual whenPaused {\\r\\n        _paused = false;\\r\\n        emit Unpaused(_msgSender());\\r\\n    }\\r\\n}\"},\"synERC777.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// This contract was adapted from the ERC777 standard contract and deployed by : Janis M. Heibel, Roy Hove and Adil Anees on behalf of Synpulse.\\r\\n// This following piece of code complements synpulseTokenGlobal contract. \\r\\n// It specifies the roles as well as the on / off function of the overall token contract.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC777.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./IERC1820Registry.sol\\\";\\r\\nimport \\\"./synRoles.sol\\\";\\r\\n\\r\\n // @dev Implementation of the {IERC777} interface.\\r\\n //\\r\\n // This implementation is agnostic to the way tokens are created. This means\\r\\n // that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n //\\r\\n // Support for ERC20 is included in this contract, as specified by the EIP: both\\r\\n // the ERC777 and ERC20 interfaces can be safely used when interacting with it.\\r\\n // Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\\r\\n // movements.\\r\\n //\\r\\n // Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\\r\\n // are no special restrictions in the amount of tokens that created, moved, or\\r\\n // destroyed. This makes integration with ERC20 applications seamless.\\r\\n \\r\\ncontract synERC777 is IERC777, IERC20, synRoles {\\r\\n    using Address for address;\\r\\n\\r\\n    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\\r\\n\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    // This isn\\u0027t ever read from - it\\u0027s only used to respond to the defaultOperators query.\\r\\n    address[] private _defaultOperatorsArray;\\r\\n\\r\\n    // No longer immutable and accounts may not revoke them\\r\\n    mapping(address =\\u003e bool) private _defaultOperators;    \\r\\n\\r\\n    // ERC20-allowances\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    // @dev `defaultOperators` may be an empty array.\\r\\n     \\r\\n    constructor(\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        address[] memory defaultOperators_\\r\\n    ) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n\\r\\n        _defaultOperatorsArray = defaultOperators_;\\r\\n        for (uint256 i = 0; i \\u003c defaultOperators_.length; i++) {\\r\\n            _defaultOperators[defaultOperators_[i]] = true;\\r\\n        }\\r\\n\\r\\n        // register interfaces\\r\\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\\\"ERC777Token\\\"), address(this));\\r\\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\\\"ERC20Token\\\"), address(this));\\r\\n    }\\r\\n\\r\\n     // @dev See {IERC777-name}.\\r\\n     \\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n     // @dev See {IERC777-symbol}.\\r\\n     \\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {ERC20-decimals}.\\r\\n     //\\r\\n     // Always returns 18, as per the\\r\\n     // [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\\r\\n     \\r\\n    function decimals() public pure virtual returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC777-granularity}.\\r\\n     //\\r\\n     // This implementation always returns `1`.\\r\\n     \\r\\n    function granularity() public view virtual override returns (uint256) {\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC777-totalSupply}.\\r\\n     \\r\\n    function totalSupply() public view virtual override(IERC20, IERC777) returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev Returns the amount of tokens owned by an account (`tokenHolder`).\\r\\n    \\r\\n    function balanceOf(address tokenHolder) public view virtual override(IERC20, IERC777) returns (uint256) {\\r\\n        return _balances[tokenHolder];\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC777-send}.\\r\\n     //\\r\\n     // Also emits a {IERC20-Transfer} event for ERC20 compatibility.\\r\\n     // Has whitelist and pause restrictions.\\r\\n     \\r\\n    function send(\\r\\n        address recipient,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) public virtual override whenNotPaused {\\r\\n        require(whitelistEnabled, \\\"Nice try, but user transfers are not enabled.\\\");\\r\\n        require(isWhitelistedAddress[recipient], \\\"Oops, the recipient is not a whitelisted address.\\\");\\r\\n       \\r\\n        _send(_msgSender(), recipient, amount, data, \\\"\\\", true);      \\r\\n \\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC20-transfer}.\\r\\n     //\\r\\n     // Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\\r\\n     // interface if it is a contract.\\r\\n     // Has whitelist and pause restrictions.\\r\\n     // Also emits a {Sent} event.\\r\\n     \\r\\n    function transfer(address recipient, uint256 amount\\r\\n    ) public virtual override whenNotPaused returns (bool) {\\r\\n        require(whitelistEnabled, \\\"Nice try, but user transfers are not enabled.\\\");\\r\\n        require(isWhitelistedAddress[recipient], \\\"Oops, the recipient is not a whitelisted address.\\\");\\r\\n        require(recipient != address(0), \\\"Are you really trying to burn this precious token? No way! You cannot transfer to the zero address.\\\");\\r\\n\\r\\n        address from = _msgSender();\\r\\n\\r\\n        _move(from, from, recipient, amount, \\\"\\\", \\\"\\\");\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC777-burn}.\\r\\n     //\\r\\n     // Also emits a {IERC20-Transfer} event for ERC20 compatibility.\\r\\n     // \\r\\n     // vault and paused restrictions.\\r\\n     \\r\\n    function burn(uint256 amount, bytes memory data) public virtual override onlyVault whenNotPaused {\\r\\n        _burn(_msgSender(), amount, data, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC777-isOperatorFor}.\\r\\n     // Only looks at the _defaultOperator array. \\r\\n     // Although unnecessary, tokenHolder input is required to maintain IERC777 compatability.\\r\\n     \\r\\n    function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) {\\r\\n        return _defaultOperators[operator];\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC777-authorizeOperator}.\\r\\n     // Only looks at the _defaultOperator array. \\r\\n     // vault and administrator restrictions.\\r\\n    \\r\\n    function authorizeOperator(address operator) public virtual override {\\r\\n        require(\\r\\n            _msgSender() == administrator || _msgSender() == vaultContract, \\r\\n            \\\"With great power comes great responsibility. You have neither. Only the admin or vault can do this!\\\"\\r\\n        );\\r\\n        _defaultOperators[operator] = true;\\r\\n        if (!isInArray(operator, _defaultOperatorsArray)) {\\r\\n            _defaultOperatorsArray.push(operator);\\r\\n        }\\r\\n\\r\\n        emit AuthorizedOperator(operator, _msgSender());\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC777-revokeOperator}.\\r\\n     // Only looks at the _defaultOperator array. \\r\\n     // vault and administrator restrictions. \\r\\n     \\r\\n    function revokeOperator(address operator) public virtual override {\\r\\n        require(\\r\\n            _msgSender() == administrator || _msgSender() == vaultContract, \\r\\n            \\\"Tut, tut. You cannot take powers you do not even have yourself. Only the admin or vault can do this!\\\"\\r\\n        );\\r\\n        _defaultOperators[operator] = false;\\r\\n        removeAddress(operator, _defaultOperatorsArray);\\r\\n\\r\\n        emit RevokedOperator(operator, _msgSender());\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC777-defaultOperators}.\\r\\n     \\r\\n    function defaultOperators() public view virtual override returns (address[] memory) {\\r\\n        return _defaultOperatorsArray;\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC777-operatorSend}.\\r\\n     //\\r\\n     // Emits {Sent} and {IERC20-Transfer} events.\\r\\n    \\r\\n    function operatorSend(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount,\\r\\n        bytes memory data,\\r\\n        bytes memory operatorData\\r\\n    ) public virtual override {\\r\\n        require(isOperatorFor(_msgSender(), sender), \\\"ERC777: caller is not an operator for holder\\\");\\r\\n        _send(sender, recipient, amount, data, operatorData, true);\\r\\n    }\\r\\n\\r\\n   \\r\\n     // @dev See {IERC777-operatorBurn}.\\r\\n     //\\r\\n     // Emits {Burned} and {IERC20-Transfer} events.\\r\\n     \\r\\n    function operatorBurn(\\r\\n        address account,\\r\\n        uint256 amount,\\r\\n        bytes memory data,\\r\\n        bytes memory operatorData\\r\\n    ) public virtual override {\\r\\n        require(isOperatorFor(_msgSender(), account), \\\"ERC777: caller is not an operator for holder\\\");\\r\\n        _burn(account, amount, data, operatorData);\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC20-allowance}.\\r\\n     //\\r\\n     // Note that operator and allowance concepts are orthogonal: operators may\\r\\n     // not have allowance, and accounts with allowance may not be operators\\r\\n     // themselves.\\r\\n     \\r\\n    function allowance(address holder, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[holder][spender];\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC20-approve}.\\r\\n     //\\r\\n     // Note that accounts cannot have allowance issued by their operators.\\r\\n     \\r\\n    function approve(address spender, uint256 value) public virtual override returns (bool) {\\r\\n        address holder = _msgSender();\\r\\n        _approve(holder, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {IERC20-transferFrom}.\\r\\n     //\\r\\n     // Note that operator and allowance concepts are orthogonal: operators cannot\\r\\n     // call `transferFrom` (unless they have allowance), and accounts with\\r\\n     // allowance cannot call `operatorSend` (unless they are operators).\\r\\n     //\\r\\n     // Has whitelist and pause restrictions.\\r\\n     // Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\\r\\n     \\r\\n    function transferFrom(\\r\\n        address holder,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override whenNotPaused returns (bool) {\\r\\n        require(whitelistEnabled, \\\"Nice try, but user transfers are not enabled.\\\");\\r\\n        require(isWhitelistedAddress[recipient], \\\"Oops, the recipient is not a whitelisted address.\\\");\\r\\n        require(recipient != address(0), \\\"Are you really trying to burn this precious token? No way! You cannot transfer to the zero address.\\\");\\r\\n        require(holder != address(0), \\\"Let the dead rest in peace, this also counts for tokens.\\\");\\r\\n\\r\\n        address spender = _msgSender();\\r\\n\\r\\n        _move(spender, holder, recipient, amount, \\\"\\\", \\\"\\\");\\r\\n\\r\\n        uint256 currentAllowance = _allowances[holder][spender];\\r\\n        require(currentAllowance \\u003e= amount, \\\"ERC777: transfer amount exceeds allowance.\\\");\\r\\n        _approve(holder, spender, currentAllowance - amount);\\r\\n\\r\\n        return true;       \\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     // the total supply.\\r\\n     //\\r\\n     // If a send hook is registered for `account`, the corresponding function\\r\\n     // will be called with `operator`, `data` and `operatorData`.\\r\\n     //\\r\\n     // See {IERC777Sender} and {IERC777Recipient}.\\r\\n     //\\r\\n     // Emits {Minted} and {IERC20-Transfer} events.\\r\\n     //\\r\\n     // Requirements\\r\\n     //\\r\\n     // - `account` cannot be the zero address.\\r\\n     // - if `account` is a contract, it must implement the {IERC777Recipient}\\r\\n     // interface.\\r\\n    \\r\\n    function _mint(\\r\\n        address account,\\r\\n        uint256 amount,\\r\\n        bytes memory userData,\\r\\n        bytes memory operatorData\\r\\n    ) internal virtual {\\r\\n        _mint(account, amount, userData, operatorData, true);\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     // the total supply.\\r\\n     //\\r\\n     // If `requireReceptionAck` is set to true, and if a send hook is\\r\\n     // registered for `account`, the corresponding function will be called with\\r\\n     // `operator`, `data` and `operatorData`.\\r\\n     //\\r\\n     // See {IERC777Sender} and {IERC777Recipient}.\\r\\n     //\\r\\n     // Emits {Minted} and {IERC20-Transfer} events.\\r\\n     //\\r\\n     // Requirements\\r\\n     //\\r\\n     // - `account` cannot be the zero address.\\r\\n     // - if `account` is a contract, it must implement the {IERC777Recipient}\\r\\n     // interface.\\r\\n     \\r\\n    function _mint(\\r\\n        address account,\\r\\n        uint256 amount,\\r\\n        bytes memory userData,\\r\\n        bytes memory operatorData,\\r\\n        bool requireReceptionAck\\r\\n    ) internal virtual {\\r\\n        require(account != address(0), \\\"ERC777: mint to the zero address.\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, address(0), account, amount);\\r\\n\\r\\n        // Update state variables\\r\\n        _totalSupply += amount;\\r\\n        _balances[account] += amount;\\r\\n\\r\\n        emit Minted(operator, account, amount, userData, operatorData);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev Send tokens\\r\\n     // @param from address token holder address\\r\\n     // @param to address recipient address\\r\\n     // @param amount uint256 amount of tokens to transfer\\r\\n     // @param userData bytes extra information provided by the token holder (if any)\\r\\n     // @param operatorData bytes extra information provided by the operator (if any)\\r\\n     // @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\\r\\n     \\r\\n    function _send(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        bytes memory userData,\\r\\n        bytes memory operatorData,\\r\\n        bool requireReceptionAck\\r\\n    ) internal virtual {\\r\\n        require(from != address(0), \\\"ERC777: send from the zero address.\\\");\\r\\n        require(to != address(0), \\\"ERC777: send to the zero address.\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _move(operator, from, to, amount, userData, operatorData);\\r\\n\\r\\n    }\\r\\n\\r\\n   \\r\\n     // @dev Burn tokens\\r\\n     // @param from address token holder address\\r\\n     // @param amount uint256 amount of tokens to burn\\r\\n     // @param data bytes extra information provided by the token holder\\r\\n     // @param operatorData bytes extra information provided by the operator (if any)\\r\\n    \\r\\n    function _burn(\\r\\n        address from,\\r\\n        uint256 amount,\\r\\n        bytes memory data,\\r\\n        bytes memory operatorData\\r\\n    ) internal virtual {\\r\\n        require(from != address(0), \\\"ERC777: burn from the zero address.\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, address(0), amount);\\r\\n\\r\\n        // Update state variables\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(fromBalance \\u003e= amount, \\\"ERC777: burn amount exceeds balance.\\\");\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n        }\\r\\n        _totalSupply -= amount;\\r\\n\\r\\n        emit Burned(operator, from, amount, data, operatorData);\\r\\n        emit Transfer(from, address(0), amount);\\r\\n    }\\r\\n\\r\\n    function _move(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        bytes memory userData,\\r\\n        bytes memory operatorData\\r\\n    ) private {\\r\\n        _beforeTokenTransfer(operator, from, to, amount);\\r\\n\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(fromBalance \\u003e= amount, \\\"ERC777: transfer amount exceeds balance.\\\");\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n        }\\r\\n        _balances[to] += amount;\\r\\n\\r\\n        emit Sent(operator, from, to, amount, userData, operatorData);\\r\\n        emit Transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev See {ERC20-_approve}.\\r\\n     //\\r\\n     // Note that accounts cannot have allowance issued by their operators.\\r\\n     \\r\\n    function _approve(\\r\\n        address holder,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        require(holder != address(0), \\\"ERC777: approve from the zero address.\\\");\\r\\n        require(spender != address(0), \\\"ERC777: approve to the zero address.\\\");\\r\\n\\r\\n        _allowances[holder][spender] = value;\\r\\n        emit Approval(holder, spender, value);\\r\\n    }\\r\\n\\r\\n    \\r\\n     // @dev Hook that is called before any token transfer. This includes\\r\\n     // calls to {send}, {transfer}, {operatorSend}, minting and burning.\\r\\n     //\\r\\n     // Calling conditions:\\r\\n     //\\r\\n     // - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\r\\n     // will be to transferred to `to`.\\r\\n     // - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     // - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\r\\n     // - `from` and `to` are never both zero.\\r\\n     //\\r\\n     // To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     \\r\\n    function _beforeTokenTransfer(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\"},\"synpulseTokenGlobal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// This contract was designed and deployed by : Janis M. Heibel, Roy Hove and Adil Anees on behalf of Synpulse.\\r\\n// This is the deployment contract of the Synpulse Global Token where mints and contract specific functions are defined. \\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./synERC777.sol\\\";\\r\\n\\r\\ncontract synpulseToken is synERC777 {\\r\\n    constructor(uint256 initialSupply, address[] memory defaultOperators)\\r\\n        synERC777(\\\"Synpulse Token\\\", \\\"SYN\\\", defaultOperators) {\\r\\n        require(defaultOperators[0] != defaultOperators[1], \\\"The vaultContract cannot be the administrator\\\");\\r\\n        vaultContract = defaultOperators[0]; // companyName Vault, set in deploy function.\\r\\n        administrator = defaultOperators[1]; // CFO, set in deploy function.\\r\\n\\r\\n        _mint(vaultContract, initialSupply, \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    event Payout (\\r\\n        uint256 date,\\r\\n        address indexed from,\\r\\n        uint256 amount,\\r\\n        bytes data\\r\\n    );\\r\\n\\r\\n    // This function is called by the vaultContract in order to remove the old administrator and add a new one.\\r\\n    function setAdministrator(address administrator_to_set\\r\\n    ) public onlyVault returns (bool) {\\r\\n        require(\\r\\n            administrator_to_set != vaultContract,\\r\\n            \\\"The vaultContract cannot be the admin\\\"\\r\\n        );\\r\\n        revokeOperator(administrator);\\r\\n        authorizeOperator(administrator_to_set);\\r\\n        administrator = administrator_to_set;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // This function is called by the vaultContract in order to remove the old vaultContract and add a new one.\\r\\n    function setVault(address vault_to_set\\r\\n    ) public onlyVault returns (bool) {\\r\\n        require(\\r\\n            vault_to_set != administrator,\\r\\n            \\\"The vaultContract cannot be the admin\\\"\\r\\n        );\\r\\n        revokeOperator(vaultContract);\\r\\n        authorizeOperator(vault_to_set);\\r\\n        vaultContract = vault_to_set;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // This function is called by an operator in order to mint tokens to the vaultContract.\\r\\n    function mintTokensToVault(uint256 amount\\r\\n    ) public whenNotPaused {\\r\\n        require(\\r\\n            isOperatorFor(_msgSender(), _msgSender()),\\r\\n            \\\"Money printer for the Fed goes brrrr, but not for you. You are not an operator.\\\"\\r\\n        );\\r\\n        _mint(vaultContract, amount, \\\"\\\", \\\"\\\");\\r\\n    }\\r\\n\\r\\n    // This function is called by the vaultContract or administrator in order to airdrop tokens via batch transfer.\\r\\n    // The amount must be the same for each recipient.\\r\\n    // This uses the _send() function that does not require the whitelistEnabled flag to be true.\\r\\n    function sendTokensToMultipleAddresses(\\r\\n        address[] memory listOfAddresses_ToSend_To,\\r\\n        uint256 amountToSend,\\r\\n        bytes memory data\\r\\n    ) public whenNotPaused {\\r\\n        // Ensure that the total amount of tokens to send are present in the wallet sending.\\r\\n        require(\\r\\n            _msgSender() == administrator || _msgSender() == vaultContract, \\r\\n            \\\"Sneaky, but not smart. Only the admin or vault can perform this action!\\\"\\r\\n        );\\r\\n        require(\\r\\n            balanceOf(vaultContract) \\u003e= listOfAddresses_ToSend_To.length * amountToSend,\\r\\n            \\\"Insufficient tokens\\\"\\r\\n        );\\r\\n        for (uint256 z = 0; z \\u003c listOfAddresses_ToSend_To.length; z++) {\\r\\n            _send(\\r\\n                vaultContract,\\r\\n                listOfAddresses_ToSend_To[z],\\r\\n                amountToSend,\\r\\n                data,\\r\\n                \\\"\\\",\\r\\n                true\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // This function is called by the vaultContract or administrator in order to send tokens to an individual address.\\r\\n    // This uses the _send() function that does not require the whitelistEnabled flag to be true.\\r\\n    function sendTokensToIndividualAddress(\\r\\n        address recipient,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) public whenNotPaused {\\r\\n        require(\\r\\n            _msgSender() == administrator || _msgSender() == vaultContract, \\r\\n            \\\"Sneaky, but not smart. Only the admin or vault can perform this action!\\\"\\r\\n        );\\r\\n        _send(vaultContract, recipient, amount, data, \\\"\\\", true);\\r\\n    }\\r\\n\\r\\n    // This function is public and sends tokens directly to the vaultContract.\\r\\n    // Emits payout event for linking automated requests to finance teams.\\r\\n    function requestPayout(uint256 amount, bytes memory data\\r\\n    ) public whenNotPaused {\\r\\n        _send(_msgSender(), vaultContract, amount, data, \\\"\\\", true);\\r\\n       if (amount != 0) {\\r\\n            emit Payout(block.timestamp, _msgSender(), amount, data);\\r\\n            }\\r\\n    }\\r\\n\\r\\n    // This function is called by defaultOperators in order to remove tokens from individuals.\\r\\n    // It can only send tokens to the vaultContract.\\r\\n    // Emits payout event for linking automated requests to finance teams.\\r\\n    function operatorSend(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount,\\r\\n        bytes memory data,\\r\\n        bytes memory operatorData\\r\\n    ) public virtual override whenNotPaused {\\r\\n        require(\\r\\n            isOperatorFor(_msgSender(), sender),\\r\\n            \\\"You are not the boss of me. You are not the boss of anyone. Only an operator can move funds.\\\"\\r\\n        );\\r\\n        require(\\r\\n            recipient == vaultContract,\\r\\n            \\\"Watch yourself! An operator can only send tokens to the vaultContract.\\\"\\r\\n        );\\r\\n        _send(sender, recipient, amount, data, operatorData, true);\\r\\n        if (amount != 0) {\\r\\n            emit Payout(block.timestamp, sender, amount, data);\\r\\n            }\\r\\n    }\\r\\n\\r\\n    // This functions is called by defaultOperators in order to burn tokens.\\r\\n    // It can only burn tokens in the vaultContract.\\r\\n    function operatorBurn(\\r\\n        address account,\\r\\n        uint256 amount,\\r\\n        bytes memory data,\\r\\n        bytes memory operatorData\\r\\n    ) public virtual override whenNotPaused {\\r\\n        require(\\r\\n            isOperatorFor(_msgSender(), account),\\r\\n            \\\"M.C. Hammer: Duh da ra-duh duh-da duh-da, Cant Touch This. You are not an operator.\\\"\\r\\n        );\\r\\n        require(\\r\\n            account == vaultContract,\\r\\n            \\\"Trying to be mean? An operator can only burn tokens in the vaultContract.\\\"\\r\\n        );\\r\\n        _burn(account, amount, data, operatorData);\\r\\n    }\\r\\n\\r\\n    // This function is called by defaultOperators in order to whitelist all listed addresses.\\r\\n    // It works by changing the isWhitelistedAddress flag -\\u003e true.\\r\\n    // It only changes the boolean flag for addresses in the listed input.\\r\\n    function whitelistUsers(address[] memory arr\\r\\n    ) public whenNotPaused {\\r\\n        require(\\r\\n            isOperatorFor(_msgSender(), _msgSender()),\\r\\n            \\\"Gotta ask the host before you add +1s. You are not an operator.\\\"\\r\\n        );\\r\\n        for (uint256 i = 0; i \\u003c arr.length; i++) {\\r\\n            isWhitelistedAddress[arr[i]] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // This function is called by defaultOperators in order to un-whitelist all listed addresses.\\r\\n    // It works by changing the isWhitelistedAddress flag -\\u003e false.\\r\\n    // It only changes the boolean flag for addresses in the listed input.\\r\\n    function removeFromWhitelist(address[] memory arr\\r\\n    ) public whenNotPaused {\\r\\n        require(\\r\\n            isOperatorFor(_msgSender(), _msgSender()),\\r\\n            \\\"Do you not like them? Host your own party if you want to kick them out. You are not an operator.\\\"\\r\\n        );\\r\\n        for (uint256 i = 0; i \\u003c arr.length; i++) {\\r\\n            isWhitelistedAddress[arr[i]] = false;\\r\\n            if (balanceOf(arr[i]) \\u003e 0) {\\r\\n                operatorSend(arr[i], vaultContract, balanceOf(arr[i]), \\\"\\\", \\\"\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"synRoles.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// This contract was designed and deployed by : Janis M. Heibel, Roy Hove and Adil Anees on behalf of Synpulse.\\r\\n// This following piece of code complements synpulseTokenGlobal contract. \\r\\n// It specifies the roles as well as the on / off function of the overall token contract.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Pausable.sol\\\";\\r\\n\\r\\ncontract synRoles is Pausable {\\r\\n    address public vaultContract;\\r\\n    address public administrator;\\r\\n    bool public whitelistEnabled = false;\\r\\n    mapping(address =\\u003e bool) public isWhitelistedAddress;\\r\\n\\r\\n    // This function checks if an address is in an array of addresses and returns \\\"true\\\" if yes, else \\\"false\\\".\\r\\n    function isInArray(\\r\\n        address address_to_check, \\r\\n        address[] memory target_Array \\r\\n    ) internal pure returns (bool)\\r\\n    {\\r\\n        for (uint256 x = 0; x \\u003c target_Array.length; x++) {\\r\\n            if (target_Array[x] == address_to_check) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // This function removes an address from an array of addresses.\\r\\n    function removeAddress(\\r\\n        address address_to_remove,\\r\\n        address[] storage target_Array\\r\\n    ) internal {\\r\\n        for (uint256 x = 0; x \\u003c target_Array.length; x++) {\\r\\n            if (target_Array[x] == address_to_remove) {\\r\\n                target_Array[x] = target_Array[target_Array.length - 1];\\r\\n                target_Array.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // The administrator can pause and unpause the contract, enable and disable the whitelisting control settings as well as add and remove defaultOperators.\\r\\n    // In addition, the administrator is a defaultOperator itself on deployment.\\r\\n    modifier onlyAdministrator() {\\r\\n        require(\\r\\n            _msgSender() == administrator,\\r\\n            \\\"You are missing a promotion to the board of directors. Only the admin can perform this action!\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // The vaultContract can update the administrator address as well as update the address of the vaultContract.\\r\\n    // In addition, the vaultContract is a defaultOperator itself on deployment.\\r\\n    modifier onlyVault() {\\r\\n        require(\\r\\n            _msgSender() == vaultContract,\\r\\n            \\\"Getting power hungry? Only the vault contract can perform this action!\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    // This function is called by the administrator to enable transfers between whitelisted addresses.\\r\\n    function activateWhitelist() public onlyAdministrator\\r\\n    {\\r\\n        whitelistEnabled = true;\\r\\n    }\\r\\n\\r\\n    // This function is called by the administrator to disable transfers between whitelisted addresses.\\r\\n    function deactivateWhitelist() public onlyAdministrator {\\r\\n        whitelistEnabled = false;\\r\\n    }\\r\\n\\r\\n    // This function is called by the administrator to pause the contract and preserve the current state of the holdings.\\r\\n    // It is to be called in case the vested Token contract needs to be updated.\\r\\n    function pauseContract () public whenNotPaused onlyAdministrator {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    // This function is called by the administrator to unpause the contract.\\r\\n    function unpauseContract() public whenPaused onlyAdministrator {\\r\\n        _unpause();\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"defaultOperators\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Payout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activateWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"administrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivateWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelistedAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintTokensToVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"arr\",\"type\":\"address[]\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"requestPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendTokensToIndividualAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"listOfAddresses_ToSend_To\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amountToSend\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendTokensToMultipleAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"administrator_to_set\",\"type\":\"address\"}],\"name\":\"setAdministrator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_to_set\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"arr\",\"type\":\"address[]\"}],\"name\":\"whitelistUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"synpulseToken","CompilerVersion":"v0.8.14+commit.80d49f37","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000007eff474f44d384ee5d48a89cd5a473ac6fe24ce2000000000000000000000000afc3973ca0a79f94c476689c9e9e39cbf83131f4","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://854115693351f9b63f639b36971446ba80a9c5c4429ae97078d5ff6d77063494"}]