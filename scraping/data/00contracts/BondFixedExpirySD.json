[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/BondFixedExpirySDA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.15;\\n\\nimport {BondBaseSDA, IBondAggregator, Authority} from \\\"./bases/BondBaseSDA.sol\\\";\\nimport {IBondTeller} from \\\"./interfaces/IBondTeller.sol\\\";\\nimport {IBondFixedExpiryTeller} from \\\"./interfaces/IBondFixedExpiryTeller.sol\\\";\\n\\n/// @title Bond Fixed-Expiry Sequential Dutch Auctioneer\\n/// @notice Bond Fixed-Expiry Sequential Dutch Auctioneer Contract\\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\\n///      for any token pair. The markets do not require maintenance and will manage\\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\\n///      receive Bond Tokens to represent their position while their bond vests.\\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\\n///\\n/// @dev The Fixed-Expiry Auctioneer is an implementation of the\\n///      Bond Base Sequential Dutch Auctioneer contract specific to creating bond markets where\\n///      all purchases on that market vest at a certain timestamp.\\n///\\n/// @author Oighty, Zeus, Potted Meat, indigo\\ncontract BondFixedExpirySDA is BondBaseSDA {\\n    /* ========== CONSTRUCTOR ========== */\\n    constructor(\\n        IBondTeller teller_,\\n        IBondAggregator aggregator_,\\n        address guardian_,\\n        Authority authority_\\n    ) BondBaseSDA(teller_, aggregator_, guardian_, authority_) {}\\n\\n    /// @inheritdoc BondBaseSDA\\n    function createMarket(bytes calldata params_) external override returns (uint256) {\\n        MarketParams memory params = abi.decode(params_, (MarketParams));\\n        uint256 marketId = _createMarket(params);\\n\\n        // Create bond token (ERC20 for fixed expiry)\\n        IBondFixedExpiryTeller(address(_teller)).deploy(params.payoutToken, params.vesting);\\n\\n        return marketId;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bases/BondBaseSDA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.15;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {ReentrancyGuard} from \\\"solmate/utils/ReentrancyGuard.sol\\\";\\nimport {Auth, Authority} from \\\"solmate/auth/Auth.sol\\\";\\n\\nimport {IBondSDA, IBondAuctioneer} from \\\"../interfaces/IBondSDA.sol\\\";\\nimport {IBondTeller} from \\\"../interfaces/IBondTeller.sol\\\";\\nimport {IBondCallback} from \\\"../interfaces/IBondCallback.sol\\\";\\nimport {IBondAggregator} from \\\"../interfaces/IBondAggregator.sol\\\";\\n\\nimport {TransferHelper} from \\\"../lib/TransferHelper.sol\\\";\\nimport {FullMath} from \\\"../lib/FullMath.sol\\\";\\n\\n/// @title Bond Sequential Dutch Auctioneer (SDA)\\n/// @notice Bond Sequential Dutch Auctioneer Base Contract\\n/// @dev Bond Protocol is a system to create Olympus-style bond markets\\n///      for any token pair. The markets do not require maintenance and will manage\\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\\n///      receive Bond Tokens to represent their position while their bond vests.\\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\\n///\\n/// @dev The Auctioneer contract allows users to create and manage bond markets.\\n///      All bond pricing logic and market data is stored in the Auctioneer.\\n///      A Auctioneer is dependent on a Teller to serve external users and\\n///      an Aggregator to register new markets. This implementation of the Auctioneer\\n///      uses a Sequential Dutch Auction pricing system to buy a target amount of quote\\n///      tokens or sell a target amount of payout tokens over the duration of a market.\\n///\\n/// @author Oighty, Zeus, Potted Meat, indigo\\nabstract contract BondBaseSDA is IBondSDA, Auth {\\n    using TransferHelper for ERC20;\\n    using FullMath for uint256;\\n\\n    /* ========== ERRORS ========== */\\n\\n    error Auctioneer_OnlyMarketOwner();\\n    error Auctioneer_InitialPriceLessThanMin();\\n    error Auctioneer_MarketConcluded(uint256 conclusion_);\\n    error Auctioneer_MaxPayoutExceeded();\\n    error Auctioneer_AmountLessThanMinimum();\\n    error Auctioneer_NotEnoughCapacity();\\n    error Auctioneer_InvalidCallback();\\n    error Auctioneer_BadExpiry();\\n    error Auctioneer_InvalidParams();\\n    error Auctioneer_NotAuthorized();\\n    error Auctioneer_NewMarketsNotAllowed();\\n\\n    /* ========== EVENTS ========== */\\n\\n    event MarketCreated(\\n        uint256 indexed id,\\n        address indexed payoutToken,\\n        address indexed quoteToken,\\n        uint48 vesting,\\n        uint256 initialPrice\\n    );\\n    event MarketClosed(uint256 indexed id);\\n    event Tuned(uint256 indexed id, uint256 oldControlVariable, uint256 newControlVariable);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    /// @notice Main information pertaining to bond market\\n    mapping(uint256 => BondMarket) public markets;\\n\\n    /// @notice Information used to control how a bond market changes\\n    mapping(uint256 => BondTerms) public terms;\\n\\n    /// @notice Data needed for tuning bond market\\n    mapping(uint256 => BondMetadata) public metadata;\\n\\n    /// @notice Control variable changes\\n    mapping(uint256 => Adjustment) public adjustments;\\n\\n    /// @notice New address to designate as market owner. They must accept ownership to transfer permissions.\\n    mapping(uint256 => address) public newOwners;\\n\\n    /// @notice Whether or not the auctioneer allows new markets to be created\\n    /// @dev    Changing to false will sunset the auctioneer after all active markets end\\n    bool public allowNewMarkets;\\n\\n    /// @notice Whether or not the market creator is authorized to use a callback address\\n    mapping(address => bool) public callbackAuthorized;\\n\\n    /// Sane defaults for tuning. Can be adjusted for a specific market via setters.\\n    uint32 public defaultTuneInterval;\\n    uint32 public defaultTuneAdjustment;\\n    /// Minimum values for decay, deposit interval, market duration and debt buffer.\\n    uint32 public minDebtDecayInterval;\\n    uint32 public minDepositInterval;\\n    uint32 public minMarketDuration;\\n    uint32 public minDebtBuffer;\\n\\n    // A 'vesting' param longer than 50 years is considered a timestamp for fixed expiry.\\n    uint48 internal constant MAX_FIXED_TERM = 52 weeks * 50;\\n    uint48 internal constant FEE_DECIMALS = 1e5; // one percent equals 1000.\\n\\n    // BondAggregator contract with utility functions\\n    IBondAggregator internal immutable _aggregator;\\n\\n    // BondTeller contract that handles interactions with users and issues tokens\\n    IBondTeller internal immutable _teller;\\n\\n    constructor(\\n        IBondTeller teller_,\\n        IBondAggregator aggregator_,\\n        address guardian_,\\n        Authority authority_\\n    ) Auth(guardian_, authority_) {\\n        _aggregator = aggregator_;\\n        _teller = teller_;\\n\\n        defaultTuneInterval = 24 hours;\\n        defaultTuneAdjustment = 1 hours;\\n        minDebtDecayInterval = 3 days;\\n        minDepositInterval = 1 hours;\\n        minMarketDuration = 1 days;\\n        minDebtBuffer = 10000; // 10%\\n\\n        allowNewMarkets = true;\\n    }\\n\\n    /* ========== MARKET FUNCTIONS ========== */\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function createMarket(bytes calldata params_) external virtual returns (uint256);\\n\\n    /// @notice core market creation logic, see IBondAuctioneer.createMarket documentation\\n    function _createMarket(MarketParams memory params_) internal returns (uint256) {\\n        {\\n            // Check that the auctioneer is allowing new markets to be created\\n            if (!allowNewMarkets) revert Auctioneer_NewMarketsNotAllowed();\\n\\n            // Ensure params are in bounds\\n            uint8 payoutTokenDecimals = params_.payoutToken.decimals();\\n            uint8 quoteTokenDecimals = params_.quoteToken.decimals();\\n\\n            if (payoutTokenDecimals < 6 || payoutTokenDecimals > 18)\\n                revert Auctioneer_InvalidParams();\\n            if (quoteTokenDecimals < 6 || quoteTokenDecimals > 18)\\n                revert Auctioneer_InvalidParams();\\n            if (params_.scaleAdjustment < -24 || params_.scaleAdjustment > 24)\\n                revert Auctioneer_InvalidParams();\\n\\n            // Restrict the use of a callback address unless allowed\\n            if (!callbackAuthorized[msg.sender] && params_.callbackAddr != address(0))\\n                revert Auctioneer_NotAuthorized();\\n        }\\n\\n        // Unit to scale calculation for this market by to ensure reasonable values\\n        // for price, debt, and control variable without under/overflows.\\n        // See IBondAuctioneer for more details.\\n        //\\n        // scaleAdjustment should be equal to (payoutDecimals - quoteDecimals) - ((payoutPriceDecimals - quotePriceDecimals) / 2)\\n        uint256 scale;\\n        unchecked {\\n            scale = 10**uint8(36 + params_.scaleAdjustment);\\n        }\\n\\n        if (params_.formattedInitialPrice < params_.formattedMinimumPrice)\\n            revert Auctioneer_InitialPriceLessThanMin();\\n\\n        // Record new market into array for later retrieval and get marketId\\n        uint256 marketId = _aggregator.registerMarket(params_.payoutToken, params_.quoteToken);\\n\\n        uint32 secondsToConclusion;\\n        uint32 debtDecayInterval;\\n        {\\n            secondsToConclusion = uint32(params_.conclusion - block.timestamp);\\n            if (\\n                secondsToConclusion < minMarketDuration ||\\n                params_.depositInterval < minDepositInterval\\n            ) revert Auctioneer_InvalidParams();\\n\\n            // At minimum, the interval is how long it takes for price to drop to 0. In reality, a 50% drop is likely a guaranteed\\n            // bond sale. So debt decay interval needs to be long enough to allow a bond to adjust if oversold.\\n            // Needs to be some multiple of deposit interval because you don't want to go from 100 to 0 during the time frame\\n            // you expected to sell a single bond. 5 is a sane default observed from running OP v1 bond markets.\\n            uint32 userDebtDecay = params_.depositInterval * 5;\\n            debtDecayInterval = minDebtDecayInterval > userDebtDecay\\n                ? minDebtDecayInterval\\n                : userDebtDecay;\\n\\n            uint256 tuneIntervalCapacity = params_.capacity.mulDiv(\\n                uint256(\\n                    params_.depositInterval > defaultTuneInterval\\n                        ? params_.depositInterval\\n                        : defaultTuneInterval\\n                ),\\n                uint256(secondsToConclusion)\\n            );\\n\\n            metadata[marketId] = BondMetadata({\\n                lastTune: uint48(block.timestamp),\\n                lastDecay: uint48(block.timestamp),\\n                length: secondsToConclusion,\\n                depositInterval: params_.depositInterval,\\n                tuneInterval: params_.depositInterval > defaultTuneInterval\\n                    ? params_.depositInterval\\n                    : defaultTuneInterval,\\n                tuneAdjustmentDelay: defaultTuneAdjustment,\\n                debtDecayInterval: debtDecayInterval,\\n                tuneIntervalCapacity: tuneIntervalCapacity,\\n                tuneBelowCapacity: params_.capacity - tuneIntervalCapacity,\\n                lastTuneDebt: (\\n                    params_.capacityInQuote\\n                        ? params_.capacity.mulDiv(scale, params_.formattedInitialPrice)\\n                        : params_.capacity\\n                ).mulDiv(uint256(debtDecayInterval), uint256(secondsToConclusion))\\n            });\\n        }\\n\\n        // Initial target debt is equal to capacity scaled by the ratio of the debt decay interval and the length of the market.\\n        // This is the amount of debt that should be decayed over the decay interval if no purchases are made.\\n        // Note price should be passed in a specific format:\\n        // price = (payoutPriceCoefficient / quotePriceCoefficient)\\n        //         * 10**(36 + scaleAdjustment + quoteDecimals - payoutDecimals + payoutPriceDecimals - quotePriceDecimals)\\n        // See IBondAuctioneer for more details and variable definitions.\\n        uint256 targetDebt;\\n        uint256 maxPayout;\\n        {\\n            uint256 capacity = params_.capacityInQuote\\n                ? params_.capacity.mulDiv(scale, params_.formattedInitialPrice)\\n                : params_.capacity;\\n\\n            targetDebt = capacity.mulDiv(uint256(debtDecayInterval), uint256(secondsToConclusion));\\n\\n            // Max payout is the amount of capacity that should be utilized in a deposit\\n            // interval. for example, if capacity is 1,000 TOKEN, there are 10 days to conclusion,\\n            // and the preferred deposit interval is 1 day, max payout would be 100 TOKEN.\\n            maxPayout = capacity.mulDiv(\\n                uint256(params_.depositInterval),\\n                uint256(secondsToConclusion)\\n            );\\n        }\\n\\n        markets[marketId] = BondMarket({\\n            owner: msg.sender,\\n            payoutToken: params_.payoutToken,\\n            quoteToken: params_.quoteToken,\\n            callbackAddr: params_.callbackAddr,\\n            capacityInQuote: params_.capacityInQuote,\\n            capacity: params_.capacity,\\n            totalDebt: targetDebt,\\n            minPrice: params_.formattedMinimumPrice,\\n            maxPayout: maxPayout,\\n            purchased: 0,\\n            sold: 0,\\n            scale: scale\\n        });\\n\\n        // Max debt serves as a circuit breaker for the market. let's say the quote token is a stablecoin,\\n        // and that stablecoin depegs. without max debt, the market would continue to buy until it runs\\n        // out of capacity. this is configurable with a 3 decimal buffer (1000 = 1% above initial price).\\n        // Note that its likely advisable to keep this buffer wide.\\n        // Note that the buffer is above 100%. i.e. 10% buffer = initial debt * 1.1\\n        // 1e5 = 100,000. 10,000 / 100,000 = 10%.\\n        uint256 minDebtBuffer_ = maxPayout.mulDiv(FEE_DECIMALS, targetDebt) > minDebtBuffer\\n            ? maxPayout.mulDiv(FEE_DECIMALS, targetDebt)\\n            : minDebtBuffer;\\n        uint256 maxDebt = targetDebt +\\n            targetDebt.mulDiv(\\n                uint256(params_.debtBuffer > minDebtBuffer_ ? params_.debtBuffer : minDebtBuffer_),\\n                1e5\\n            );\\n\\n        // The control variable is set so that initial price equals the desired initial price. the control\\n        // variable is the ultimate determinant of price, so we compute this last.\\n        //\\n        // price = control variable * debt / scale\\n        // therefore, control variable = price * scale / debt\\n        uint256 controlVariable = params_.formattedInitialPrice.mulDiv(scale, targetDebt);\\n\\n        terms[marketId] = BondTerms({\\n            controlVariable: controlVariable,\\n            maxDebt: maxDebt,\\n            vesting: params_.vesting,\\n            conclusion: params_.conclusion\\n        });\\n\\n        emit MarketCreated(\\n            marketId,\\n            address(params_.payoutToken),\\n            address(params_.quoteToken),\\n            params_.vesting,\\n            params_.formattedInitialPrice\\n        );\\n\\n        return marketId;\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function setIntervals(uint256 id_, uint32[3] calldata intervals_) external override {\\n        // Check that the intervals are non-zero\\n        if (intervals_[0] == 0 || intervals_[1] == 0 || intervals_[2] == 0)\\n            revert Auctioneer_InvalidParams();\\n\\n        // Check that tuneInterval >= tuneAdjustmentDelay\\n        if (intervals_[0] < intervals_[1]) revert Auctioneer_InvalidParams();\\n\\n        BondMetadata storage meta = metadata[id_];\\n        // Check that tuneInterval >= depositInterval\\n        if (intervals_[0] < meta.depositInterval) revert Auctioneer_InvalidParams();\\n\\n        // Check that debtDecayInterval >= minDebtDecayInterval\\n        if (intervals_[2] < minDebtDecayInterval) revert Auctioneer_InvalidParams();\\n\\n        // Check that sender is market owner\\n        BondMarket memory market = markets[id_];\\n        if (msg.sender != market.owner) revert Auctioneer_OnlyMarketOwner();\\n\\n        // Update intervals\\n        meta.tuneInterval = intervals_[0];\\n        meta.tuneIntervalCapacity = market.capacity.mulDiv(\\n            uint256(intervals_[0]),\\n            uint256(terms[id_].conclusion) - block.timestamp\\n        ); // don't have a stored value for market duration, this will update tuneIntervalCapacity based on time remaining\\n        meta.tuneAdjustmentDelay = intervals_[1];\\n        meta.debtDecayInterval = intervals_[2];\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function pushOwnership(uint256 id_, address newOwner_) external override {\\n        if (msg.sender != markets[id_].owner) revert Auctioneer_OnlyMarketOwner();\\n        newOwners[id_] = newOwner_;\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function pullOwnership(uint256 id_) external override {\\n        if (msg.sender != newOwners[id_]) revert Auctioneer_NotAuthorized();\\n        markets[id_].owner = newOwners[id_];\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function setDefaults(uint32[6] memory defaults_) external override requiresAuth {\\n        // Restricted to authorized addresses, initially restricted to policy\\n        defaultTuneInterval = defaults_[0];\\n        defaultTuneAdjustment = defaults_[1];\\n        minDebtDecayInterval = defaults_[2];\\n        minDepositInterval = defaults_[3];\\n        minMarketDuration = defaults_[4];\\n        minDebtBuffer = defaults_[5];\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function setAllowNewMarkets(bool status_) external override requiresAuth {\\n        // Restricted to authorized addresses, initially restricted to guardian\\n        allowNewMarkets = status_;\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function setCallbackAuthStatus(address creator_, bool status_) external override requiresAuth {\\n        // Restricted to authorized addresses, initially restricted to guardian\\n        callbackAuthorized[creator_] = status_;\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function closeMarket(uint256 id_) external override {\\n        if (msg.sender != markets[id_].owner) revert Auctioneer_OnlyMarketOwner();\\n        _close(id_);\\n    }\\n\\n    /* ========== TELLER FUNCTIONS ========== */\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function purchaseBond(\\n        uint256 id_,\\n        uint256 amount_,\\n        uint256 minAmountOut_\\n    ) external override returns (uint256 payout) {\\n        if (msg.sender != address(_teller)) revert Auctioneer_NotAuthorized();\\n\\n        BondMarket storage market = markets[id_];\\n        BondTerms memory term = terms[id_];\\n\\n        // Markets end at a defined timestamp\\n        uint48 currentTime = uint48(block.timestamp);\\n        if (currentTime >= term.conclusion) revert Auctioneer_MarketConcluded(term.conclusion);\\n\\n        uint256 price;\\n        (price, payout) = _decayAndGetPrice(id_, amount_, uint48(block.timestamp)); // Debt and the control variable decay over time\\n\\n        // Payout must be greater than user inputted minimum\\n        if (payout < minAmountOut_) revert Auctioneer_AmountLessThanMinimum();\\n\\n        // Markets have a max payout amount, capping size because deposits\\n        // do not experience slippage. max payout is recalculated upon tuning\\n        if (payout > market.maxPayout) revert Auctioneer_MaxPayoutExceeded();\\n\\n        // Update Capacity and Debt values\\n\\n        // Capacity is either the number of payout tokens that the market can sell\\n        // (if capacity in quote is false),\\n        //\\n        // or the number of quote tokens that the market can buy\\n        // (if capacity in quote is true)\\n\\n        // If amount/payout is greater than capacity remaining, revert\\n        if (market.capacityInQuote ? amount_ > market.capacity : payout > market.capacity)\\n            revert Auctioneer_NotEnoughCapacity();\\n        unchecked {\\n            // Capacity is decreased by the deposited or paid amount\\n            market.capacity -= market.capacityInQuote ? amount_ : payout;\\n\\n            // Incrementing total debt raises the price of the next bond\\n            market.totalDebt += payout + 1; // add 1 to satisfy price inequality\\n\\n            // Markets keep track of how many quote tokens have been\\n            // purchased, and how many payout tokens have been sold\\n            market.purchased += amount_;\\n            market.sold += payout;\\n        }\\n\\n        // Circuit breaker. If max debt is breached, the market is closed\\n        if (term.maxDebt < market.totalDebt) {\\n            _close(id_);\\n        } else {\\n            // If market will continue, the control variable is tuned to hit targets on time\\n            _tune(id_, currentTime, price);\\n        }\\n    }\\n\\n    /* ========== INTERNAL DEPO FUNCTIONS ========== */\\n\\n    /// @notice          Close a market\\n    /// @dev             Closing a market sets capacity to 0 and immediately stops bonding\\n    function _close(uint256 id_) internal {\\n        terms[id_].conclusion = uint48(block.timestamp);\\n        markets[id_].capacity = 0;\\n\\n        emit MarketClosed(id_);\\n    }\\n\\n    /// @notice                 Decay debt, and adjust control variable if there is an active change\\n    /// @param id_              ID of market\\n    /// @param amount_          Amount of quote tokens being purchased\\n    /// @param time_            Current timestamp (saves gas when passed in)\\n    /// @return marketPrice_    Current market price of bond, accounting for decay\\n    /// @return payout_         Amount of payout tokens received at current price\\n    function _decayAndGetPrice(\\n        uint256 id_,\\n        uint256 amount_,\\n        uint48 time_\\n    ) internal returns (uint256 marketPrice_, uint256 payout_) {\\n        BondMarket memory market = markets[id_];\\n\\n        // Debt is a time-decayed sum of tokens spent in a market\\n        // Debt is added when deposits occur and removed over time\\n        // |\\n        // |    debt falls with\\n        // |   / \\\\  inactivity        / \\\\\\n        // | /     \\\\              /\\\\ /   \\\\\\n        // |         \\\\           /        \\\\ / \\\\\\n        // |           \\\\      /\\\\/\\n        // |             \\\\  /  and rises\\n        // |                with deposits\\n        // |\\n        // |------------------------------------| t\\n        if (uint256(metadata[id_].lastDecay) <= block.timestamp)\\n            markets[id_].totalDebt -= _debtDecay(id_);\\n\\n        // Control variable decay\\n\\n        // The bond control variable is continually tuned. When it is lowered (which\\n        // lowers the market price), the change is carried out smoothly over time.\\n        if (adjustments[id_].active) {\\n            Adjustment storage adjustment = adjustments[id_];\\n\\n            (uint256 adjustBy, uint48 secondsSince, bool stillActive) = _controlDecay(id_);\\n            terms[id_].controlVariable -= adjustBy;\\n\\n            if (stillActive) {\\n                adjustment.change -= adjustBy;\\n                adjustment.timeToAdjusted -= secondsSince;\\n                adjustment.lastAdjustment = time_;\\n            } else {\\n                adjustment.active = false;\\n            }\\n        }\\n\\n        // Price is not allowed to be lower than the minimum price\\n        marketPrice_ = _currentMarketPrice(id_);\\n        uint256 minPrice = market.minPrice;\\n        if (marketPrice_ < minPrice) marketPrice_ = minPrice;\\n\\n        // Payout for the deposit = amount / price\\n        //\\n        // where:\\n        // payout = payout tokens out\\n        // amount = quote tokens in\\n        // price = quote tokens : payout token (i.e. 200 QUOTE : BASE), adjusted for scaling\\n        payout_ = amount_.mulDiv(market.scale, marketPrice_);\\n\\n        // Set last decay timestamp based on size of purchase to linearize decay\\n        // 1e9 is used a scaling constant since the decay interval is unlikely to exceed 1e9 seconds (> 30 years)\\n        // It is also low enough to avoid overflows from high debt values\\n        uint256 debtPerSecond = metadata[id_].lastTuneDebt.mulDiv(\\n            1e9,\\n            uint256(metadata[id_].debtDecayInterval)\\n        );\\n\\n        metadata[id_].lastDecay += uint48(payout_.mulDivUp(1e9, debtPerSecond));\\n    }\\n\\n    /// @notice             Auto-adjust control variable to hit capacity/spend target\\n    /// @param id_          ID of market\\n    /// @param time_        Timestamp (saves gas when passed in)\\n    /// @param price_       Current price of the market\\n    function _tune(\\n        uint256 id_,\\n        uint48 time_,\\n        uint256 price_\\n    ) internal {\\n        BondMetadata memory meta = metadata[id_];\\n        BondMarket memory market = markets[id_];\\n\\n        // Market tunes in 2 situations:\\n        // 1. If capacity has exceeded target since last tune adjustment and the market is oversold\\n        // 2. If a tune interval has passed since last tune adjustment and the market is undersold\\n        //\\n        // Intuition:\\n        // Markets are created with a target capacity with the expectation that capacity will\\n        // be utilized evenly over the duration of the market.\\n        // The intuition with tuning is:\\n        // - When the market is ahead of target capacity, we should tune based on capacity.\\n        // - When the market is behind target capacity, we should tune based on time.\\n\\n        // Compute seconds remaining until market will conclude\\n        uint256 timeRemaining = uint256(terms[id_].conclusion - time_);\\n\\n        // Standardize capacity into an payout token amount\\n        uint256 capacity = market.capacityInQuote\\n            ? market.capacity.mulDiv(market.scale, price_)\\n            : market.capacity;\\n        // Calculate initial capacity based on remaining capacity and amount sold/purchased up to this point\\n        uint256 initialCapacity = capacity +\\n            (market.capacityInQuote ? market.purchased.mulDiv(market.scale, price_) : market.sold);\\n\\n        // Calculate timeNeutralCapacity as the capacity expected to be sold up to this point and the current capacity\\n        // Higher than initial capacity means the market is undersold, lower than initial capacity means the market is oversold\\n        uint256 timeNeutralCapacity = initialCapacity.mulDiv(\\n            uint256(meta.length) - timeRemaining,\\n            uint256(meta.length)\\n        ) + capacity;\\n\\n        if (\\n            (market.capacity < meta.tuneBelowCapacity && timeNeutralCapacity < initialCapacity) ||\\n            (time_ >= meta.lastTune + meta.tuneInterval && timeNeutralCapacity > initialCapacity)\\n        ) {\\n            // Calculate the correct payout to complete on time assuming each bond\\n            // will be max size in the desired deposit interval for the remaining time\\n            //\\n            // i.e. market has 10 days remaining. deposit interval is 1 day. capacity\\n            // is 10,000 TOKEN. max payout would be 1,000 TOKEN (10,000 * 1 / 10).\\n            markets[id_].maxPayout = capacity.mulDiv(uint256(meta.depositInterval), timeRemaining);\\n\\n            // Calculate ideal target debt to satisty capacity in the remaining time\\n            // The target debt is based on whether the market is under or oversold at this point in time\\n            // This target debt will ensure price is reactive while ensuring the magnitude of being over/undersold\\n            // doesn't cause larger fluctuations towards the end of the market.\\n            //\\n\\n            // Calculate target debt from the timeNeutralCapacity and the ratio of debt decay interval and the length of the market\\n            uint256 targetDebt = timeNeutralCapacity.mulDiv(\\n                uint256(meta.debtDecayInterval),\\n                uint256(meta.length)\\n            );\\n\\n            // Derive a new control variable from the target debt\\n            uint256 controlVariable = terms[id_].controlVariable;\\n            uint256 newControlVariable = price_.mulDivUp(market.scale, targetDebt);\\n\\n            emit Tuned(id_, controlVariable, newControlVariable);\\n\\n            if (newControlVariable < controlVariable) {\\n                // If decrease, control variable change will be carried out over the tune interval\\n                // this is because price will be lowered\\n                uint256 change = controlVariable - newControlVariable;\\n                adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true);\\n            } else {\\n                // Tune up immediately\\n                terms[id_].controlVariable = newControlVariable;\\n                // Set current adjustment to inactive (e.g. if we are re-tuning early)\\n                adjustments[id_].active = false;\\n            }\\n\\n            metadata[id_].lastTune = time_;\\n            metadata[id_].tuneBelowCapacity = market.capacity > meta.tuneIntervalCapacity\\n                ? market.capacity - meta.tuneIntervalCapacity\\n                : 0;\\n            metadata[id_].lastTuneDebt = targetDebt;\\n        }\\n    }\\n\\n    /* ========== INTERNAL VIEW FUNCTIONS ========== */\\n\\n    /// @notice             Calculate current market price of payout token in quote tokens\\n    /// @dev                See marketPrice() in IBondAuctioneer for explanation of price computation\\n    /// @dev                Uses info from storage because data has been updated before call (vs marketPrice())\\n    /// @param id_          Market ID\\n    /// @return             Price for market in payout token decimals\\n    function _currentMarketPrice(uint256 id_) internal view returns (uint256) {\\n        BondMarket memory market = markets[id_];\\n        return terms[id_].controlVariable.mulDiv(market.totalDebt, market.scale);\\n    }\\n\\n    /// @notice             Amount of debt to decay from total debt for market ID\\n    /// @param id_          ID of market\\n    /// @return             Amount of debt to decay\\n    function _debtDecay(uint256 id_) internal view returns (uint256) {\\n        BondMetadata memory meta = metadata[id_];\\n        uint256 lastDecay = uint256(meta.lastDecay);\\n        uint256 currentTime = block.timestamp;\\n        uint256 secondsSince;\\n        unchecked {\\n            secondsSince = currentTime > lastDecay ? currentTime - lastDecay : 0;\\n        }\\n        return\\n            secondsSince > meta.debtDecayInterval\\n                ? markets[id_].totalDebt\\n                : markets[id_].totalDebt.mulDiv(secondsSince, uint256(meta.debtDecayInterval));\\n    }\\n\\n    /// @notice                 Amount to decay control variable by\\n    /// @param id_              ID of market\\n    /// @return decay           change in control variable\\n    /// @return secondsSince    seconds since last change in control variable\\n    /// @return active          whether or not change remains active\\n    function _controlDecay(uint256 id_)\\n        internal\\n        view\\n        returns (\\n            uint256 decay,\\n            uint48 secondsSince,\\n            bool active\\n        )\\n    {\\n        Adjustment memory info = adjustments[id_];\\n        if (!info.active) return (0, 0, false);\\n\\n        secondsSince = uint48(block.timestamp) - info.lastAdjustment;\\n        active = secondsSince < info.timeToAdjusted;\\n        decay = active\\n            ? info.change.mulDiv(uint256(secondsSince), uint256(info.timeToAdjusted))\\n            : info.change;\\n    }\\n\\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function getMarketInfoForPurchase(uint256 id_)\\n        external\\n        view\\n        returns (\\n            address owner,\\n            address callbackAddr,\\n            ERC20 payoutToken,\\n            ERC20 quoteToken,\\n            uint48 vesting,\\n            uint256 maxPayout\\n        )\\n    {\\n        BondMarket memory market = markets[id_];\\n        return (\\n            market.owner,\\n            market.callbackAddr,\\n            market.payoutToken,\\n            market.quoteToken,\\n            terms[id_].vesting,\\n            market.maxPayout\\n        );\\n    }\\n\\n    /// @inheritdoc IBondSDA\\n    function marketPrice(uint256 id_) public view override returns (uint256) {\\n        uint256 price = currentControlVariable(id_).mulDivUp(currentDebt(id_), markets[id_].scale);\\n\\n        return (price > markets[id_].minPrice) ? price : markets[id_].minPrice;\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function marketScale(uint256 id_) external view override returns (uint256) {\\n        return markets[id_].scale;\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function payoutFor(\\n        uint256 amount_,\\n        uint256 id_,\\n        address referrer_\\n    ) public view override returns (uint256) {\\n        // Calculate the payout for the given amount of tokens\\n        uint256 fee = amount_.mulDiv(_teller.getFee(referrer_), 1e5);\\n        uint256 payout = (amount_ - fee).mulDiv(markets[id_].scale, marketPrice(id_));\\n\\n        // Check that the payout is less than or equal to the maximum payout,\\n        // Revert if not, otherwise return the payout\\n        if (payout > markets[id_].maxPayout) {\\n            revert Auctioneer_MaxPayoutExceeded();\\n        } else {\\n            return payout;\\n        }\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function maxAmountAccepted(uint256 id_, address referrer_) external view returns (uint256) {\\n        // Calculate maximum amount of quote tokens that correspond to max bond size\\n        // Maximum of the maxPayout and the remaining capacity converted to quote tokens\\n        BondMarket memory market = markets[id_];\\n        uint256 price = marketPrice(id_);\\n        uint256 quoteCapacity = market.capacityInQuote\\n            ? market.capacity\\n            : market.capacity.mulDiv(price, market.scale);\\n        uint256 maxQuote = market.maxPayout.mulDiv(price, market.scale);\\n        uint256 amountAccepted = quoteCapacity < maxQuote ? quoteCapacity : maxQuote;\\n\\n        // Take into account teller fees and return\\n        // Estimate fee based on amountAccepted. Fee taken will be slightly larger than\\n        // this given it will be taken off the larger amount, but this avoids rounding\\n        // errors with trying to calculate the exact amount.\\n        // Therefore, the maxAmountAccepted is slightly conservative.\\n        uint256 estimatedFee = amountAccepted.mulDiv(_teller.getFee(referrer_), 1e5);\\n\\n        return amountAccepted + estimatedFee;\\n    }\\n\\n    /// @inheritdoc IBondSDA\\n    function currentDebt(uint256 id_) public view override returns (uint256) {\\n        return markets[id_].totalDebt - _debtDecay(id_);\\n    }\\n\\n    /// @inheritdoc IBondSDA\\n    function currentControlVariable(uint256 id_) public view override returns (uint256) {\\n        (uint256 decay, , ) = _controlDecay(id_);\\n        return terms[id_].controlVariable - decay;\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function isInstantSwap(uint256 id_) public view returns (bool) {\\n        uint256 vesting = terms[id_].vesting;\\n        return (vesting <= MAX_FIXED_TERM) ? vesting == 0 : vesting <= block.timestamp;\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function isLive(uint256 id_) public view override returns (bool) {\\n        return (markets[id_].capacity != 0 && terms[id_].conclusion > block.timestamp);\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function ownerOf(uint256 id_) external view override returns (address) {\\n        return markets[id_].owner;\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function getTeller() external view override returns (IBondTeller) {\\n        return _teller;\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function getAggregator() external view override returns (IBondAggregator) {\\n        return _aggregator;\\n    }\\n\\n    /// @inheritdoc IBondAuctioneer\\n    function currentCapacity(uint256 id_) external view override returns (uint256) {\\n        return markets[id_].capacity;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondTeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\ninterface IBondTeller {\\n    /// @notice                 Exchange quote tokens for a bond in a specified market\\n    /// @param recipient_       Address of recipient of bond. Allows deposits for other addresses\\n    /// @param referrer_        Address of referrer who will receive referral fee. For frontends to fill.\\n    ///                         Direct calls can use the zero address for no referrer fee.\\n    /// @param id_              ID of the Market the bond is being purchased from\\n    /// @param amount_          Amount to deposit in exchange for bond\\n    /// @param minAmountOut_    Minimum acceptable amount of bond to receive. Prevents frontrunning\\n    /// @return                 Amount of payout token to be received from the bond\\n    /// @return                 Timestamp at which the bond token can be redeemed for the underlying token\\n    function purchase(\\n        address recipient_,\\n        address referrer_,\\n        uint256 id_,\\n        uint256 amount_,\\n        uint256 minAmountOut_\\n    ) external returns (uint256, uint48);\\n\\n    /// @notice          Get current fee charged by the teller based on the combined protocol and referrer fee\\n    /// @param referrer_ Address of the referrer\\n    /// @return          Fee in basis points (3 decimal places)\\n    function getFee(address referrer_) external view returns (uint48);\\n\\n    /// @notice         Set protocol fee\\n    /// @notice         Must be guardian\\n    /// @param fee_     Protocol fee in basis points (3 decimal places)\\n    function setProtocolFee(uint48 fee_) external;\\n\\n    /// @notice         Set your fee as a referrer to the protocol\\n    /// @notice         Fee is set for sending address\\n    /// @param fee_     Referrer fee in basis points (3 decimal places)\\n    function setReferrerFee(uint48 fee_) external;\\n\\n    /// @notice         Claim fees accrued for input tokens and sends to protocol\\n    /// @notice         Must be guardian\\n    /// @param tokens_  Array of tokens to claim fees for\\n    /// @param to_      Address to send fees to\\n    function claimFees(ERC20[] memory tokens_, address to_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondFixedExpiryTeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20BondToken} from \\\"../ERC20BondToken.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\ninterface IBondFixedExpiryTeller {\\n    /// @notice          Redeem a fixed-expiry bond token for the underlying token (bond token must have matured)\\n    /// @param token_    Token to redeem\\n    /// @param amount_   Amount to redeem\\n    function redeem(ERC20BondToken token_, uint256 amount_) external;\\n\\n    /// @notice              Deposit an ERC20 token and mint a future-dated ERC20 bond token\\n    /// @param underlying_   ERC20 token redeemable when the bond token vests\\n    /// @param expiry_       Timestamp at which the bond token can be redeemed for the underlying token\\n    /// @param amount_       Amount of underlying tokens to deposit\\n    /// @return              Address of the ERC20 bond token received\\n    /// @return              Amount of the ERC20 bond token received\\n    function create(\\n        ERC20 underlying_,\\n        uint48 expiry_,\\n        uint256 amount_\\n    ) external returns (ERC20BondToken, uint256);\\n\\n    /// @notice             Deploy a new ERC20 bond token for an (underlying, expiry) pair and return its address\\n    /// @dev                ERC20 used for fixed-expiry\\n    /// @dev                If a bond token exists for the (underlying, expiry) pair, it returns that address\\n    /// @param underlying_  ERC20 token redeemable when the bond token vests\\n    /// @param expiry_      Timestamp at which the bond token can be redeemed for the underlying token\\n    /// @return             Address of the ERC20 bond token being created\\n    function deploy(ERC20 underlying_, uint48 expiry_) external returns (ERC20BondToken);\\n\\n    /// @notice         Get the OlympusERC20BondToken contract corresponding to a market\\n    /// @param id_      ID of the market\\n    /// @return         ERC20BondToken contract address\\n    function getBondTokenForMarket(uint256 id_) external view returns (ERC20BondToken);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondSDA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {IBondAuctioneer} from \\\"../interfaces/IBondAuctioneer.sol\\\";\\n\\ninterface IBondSDA is IBondAuctioneer {\\n    /// @notice Main information pertaining to bond market\\n    struct BondMarket {\\n        address owner; // market owner. sends payout tokens, receives quote tokens (defaults to creator)\\n        ERC20 payoutToken; // token to pay depositors with\\n        ERC20 quoteToken; // token to accept as payment\\n        address callbackAddr; // address to call for any operations on bond purchase. Must inherit to IBondCallback.\\n        bool capacityInQuote; // capacity limit is in payment token (true) or in payout (false, default)\\n        uint256 capacity; // capacity remaining\\n        uint256 totalDebt; // total payout token debt from market\\n        uint256 minPrice; // minimum price (debt will stop decaying to maintain this)\\n        uint256 maxPayout; // max payout tokens out in one order\\n        uint256 sold; // payout tokens out\\n        uint256 purchased; // quote tokens in\\n        uint256 scale; // scaling factor for the market (see MarketParams struct)\\n    }\\n\\n    /// @notice Information used to control how a bond market changes\\n    struct BondTerms {\\n        uint256 controlVariable; // scaling variable for price\\n        uint256 maxDebt; // max payout token debt accrued\\n        uint48 vesting; // length of time from deposit to expiry if fixed-term, vesting timestamp if fixed-expiry\\n        uint48 conclusion; // timestamp when market no longer offered\\n    }\\n\\n    /// @notice Data needed for tuning bond market\\n    /// @dev Has timestamps in uint32 (not int32), so is not subject to Y2K38 overflow\\n    struct BondMetadata {\\n        uint48 lastTune; // last timestamp when control variable was tuned\\n        uint48 lastDecay; // last timestamp when market was created and debt was decayed\\n        uint32 length; // time from creation to conclusion.\\n        uint32 depositInterval; // target frequency of deposits\\n        uint32 tuneInterval; // frequency of tuning\\n        uint32 tuneAdjustmentDelay; // time to implement downward tuning adjustments\\n        uint32 debtDecayInterval; // interval over which debt should decay completely\\n        uint256 tuneIntervalCapacity; // capacity expected to be used during a tuning interval\\n        uint256 tuneBelowCapacity; // capacity that the next tuning will occur at\\n        uint256 lastTuneDebt; // target debt calculated at last tuning\\n    }\\n\\n    /// @notice Control variable adjustment data\\n    struct Adjustment {\\n        uint256 change;\\n        uint48 lastAdjustment;\\n        uint48 timeToAdjusted; // how long until adjustment happens\\n        bool active;\\n    }\\n\\n    /// @notice             Parameters to create a new bond market\\n    /// @dev                Note price should be passed in a specific format:\\n    ///                     formatted price = (payoutPriceCoefficient / quotePriceCoefficient)\\n    ///                             * 10**(36 + scaleAdjustment + quoteDecimals - payoutDecimals + payoutPriceDecimals - quotePriceDecimals)\\n    ///                     where:\\n    ///                         payoutDecimals - Number of decimals defined for the payoutToken in its ERC20 contract\\n    ///                         quoteDecimals - Number of decimals defined for the quoteToken in its ERC20 contract\\n    ///                         payoutPriceCoefficient - The coefficient of the payoutToken price in scientific notation (also known as the significant digits)\\n    ///                         payoutPriceDecimals - The significand of the payoutToken price in scientific notation (also known as the base ten exponent)\\n    ///                         quotePriceCoefficient - The coefficient of the quoteToken price in scientific notation (also known as the significant digits)\\n    ///                         quotePriceDecimals - The significand of the quoteToken price in scientific notation (also known as the base ten exponent)\\n    ///                         scaleAdjustment - see below\\n    ///                         * In the above definitions, the \\\"prices\\\" need to have the same unit of account (i.e. both in OHM, $, ETH, etc.)\\n    ///                         If price is not provided in this format, the market will not behave as intended.\\n    /// @param params_      Encoded bytes array, with the following elements\\n    /// @dev                    0. Payout Token (token paid out)\\n    /// @dev                    1. Quote Token (token to be received)\\n    /// @dev                    2. Callback contract address, should conform to IBondCallback. If 0x00, tokens will be transferred from market.owner\\n    /// @dev                    3. Is Capacity in Quote Token?\\n    /// @dev                    4. Capacity (amount in quoteDecimals or amount in payoutDecimals)\\n    /// @dev                    5. Formatted initial price (see note above)\\n    /// @dev                    6. Formatted minimum price (see note above)\\n    /// @dev                    7. Debt buffer. Percent with 3 decimals. Percentage over the initial debt to allow the market to accumulate at anyone time.\\n    /// @dev                       Works as a circuit breaker for the market in case external conditions incentivize massive buying (e.g. stablecoin depeg).\\n    /// @dev                       Minimum is the greater of 10% or initial max payout as a percentage of capacity.\\n    /// @dev                       If the value is too small, the market will not be able function normally and close prematurely.\\n    /// @dev                       If the value is too large, the market will not circuit break when intended. The value must be > 10% but can exceed 100% if desired.\\n    /// @dev                    8. Is fixed term ? Vesting length (seconds) : Vesting expiry (timestamp).\\n    /// @dev                        A 'vesting' param longer than 50 years is considered a timestamp for fixed expiry.\\n    /// @dev                    9. Conclusion (timestamp)\\n    /// @dev                    10. Deposit interval (seconds)\\n    /// @dev                    11. Market scaling factor adjustment, ranges from -24 to +24 within the configured market bounds.\\n    /// @dev                        Should be calculated as: (payoutDecimals - quoteDecimals) - ((payoutPriceDecimals - quotePriceDecimals) / 2)\\n    /// @dev                        Providing a scaling factor adjustment that doesn't follow this formula could lead to under or overflow errors in the market.\\n    /// @return                 ID of new bond market\\n    struct MarketParams {\\n        ERC20 payoutToken;\\n        ERC20 quoteToken;\\n        address callbackAddr;\\n        bool capacityInQuote;\\n        uint256 capacity;\\n        uint256 formattedInitialPrice;\\n        uint256 formattedMinimumPrice;\\n        uint32 debtBuffer;\\n        uint48 vesting;\\n        uint48 conclusion;\\n        uint32 depositInterval;\\n        int8 scaleAdjustment;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /// @notice             Calculate current market price of payout token in quote tokens\\n    /// @dev                Accounts for debt and control variable decay since last deposit (vs _marketPrice())\\n    /// @param id_          ID of market\\n    /// @return             Price for market in configured decimals (see MarketParams)\\n    //\\n    // price is derived from the equation\\n    //\\n    // p = c * d\\n    //\\n    // where\\n    // p = price\\n    // c = control variable\\n    // d = debt\\n    //\\n    // d -= ( d * (dt / l) )\\n    //\\n    // where\\n    // dt = change in time\\n    // l = length of program\\n    //\\n    // if price is below minimum price, minimum price is returned\\n    // this is enforced on deposits by manipulating total debt (see _decay())\\n    function marketPrice(uint256 id_) external view override returns (uint256);\\n\\n    /// @notice             Calculate debt factoring in decay\\n    /// @dev                Accounts for debt decay since last deposit\\n    /// @param id_          ID of market\\n    /// @return             Current debt for market in payout token decimals\\n    function currentDebt(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Up to date control variable\\n    /// @dev                Accounts for control variable adjustment\\n    /// @param id_          ID of market\\n    /// @return             Control variable for market in payout token decimals\\n    function currentControlVariable(uint256 id_) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\ninterface IBondCallback {\\n    /// @notice                 Send payout tokens to Teller while allowing market owners to perform custom logic on received or paid out tokens\\n    /// @notice                 Market ID on Teller must be whitelisted\\n    /// @param id_              ID of the market\\n    /// @param inputAmount_     Amount of quote tokens bonded to the market\\n    /// @param outputAmount_    Amount of payout tokens to be paid out to the market\\n    /// @dev Must transfer the output amount of payout tokens back to the Teller\\n    /// @dev Should check that the quote tokens have been transferred to the contract in the _callback function\\n    function callback(\\n        uint256 id_,\\n        uint256 inputAmount_,\\n        uint256 outputAmount_\\n    ) external;\\n\\n    /// @notice         Returns the number of quote tokens received and payout tokens paid out for a market\\n    /// @param id_      ID of the market\\n    /// @return in_     Amount of quote tokens bonded to the market\\n    /// @return out_    Amount of payout tokens paid out to the market\\n    function amountsForMarket(uint256 id_) external view returns (uint256 in_, uint256 out_);\\n\\n    /// @notice         Whitelist a teller and market ID combination\\n    /// @notice         Must be callback owner\\n    /// @param teller_  Address of the Teller contract which serves the market\\n    /// @param id_      ID of the market\\n    function whitelist(address teller_, uint256 id_) external;\\n\\n    /// @notice         Withdraw tokens from the callback and update balances\\n    /// @notice         Only callback owner\\n    /// @param to_      Address of the recipient\\n    /// @param token_   Address of the token to withdraw\\n    /// @param amount_  Amount of tokens to withdraw\\n    function withdraw(\\n        address to_,\\n        ERC20 token_,\\n        uint256 amount_\\n    ) external;\\n\\n    /// @notice         Deposit tokens to the callback and update balances\\n    /// @notice         Only callback owner\\n    /// @param token_   Address of the token to deposit\\n    /// @param amount_  Amount of tokens to deposit\\n    function deposit(ERC20 token_, uint256 amount_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {IBondAuctioneer} from \\\"../interfaces/IBondAuctioneer.sol\\\";\\nimport {IBondTeller} from \\\"../interfaces/IBondTeller.sol\\\";\\n\\ninterface IBondAggregator {\\n    /// @notice             Register a auctioneer with the aggregator\\n    /// @notice             Only Guardian\\n    /// @param auctioneer_  Address of the Auctioneer to register\\n    /// @dev                A auctioneer must be registered with an aggregator to create markets\\n    function registerAuctioneer(IBondAuctioneer auctioneer_) external;\\n\\n    /// @notice             Register a new market with the aggregator\\n    /// @notice             Only registered depositories\\n    /// @param payoutToken_ Token to be paid out by the market\\n    /// @param quoteToken_  Token to be accepted by the market\\n    /// @param marketId     ID of the market being created\\n    function registerMarket(ERC20 payoutToken_, ERC20 quoteToken_)\\n        external\\n        returns (uint256 marketId);\\n\\n    /// @notice     Get the auctioneer for the provided market ID\\n    /// @param id_  ID of Market\\n    function getAuctioneer(uint256 id_) external view returns (IBondAuctioneer);\\n\\n    /// @notice             Calculate current market price of payout token in quote tokens\\n    /// @dev                Accounts for debt and control variable decay since last deposit (vs _marketPrice())\\n    /// @param id_          ID of market\\n    /// @return             Price for market (see the specific auctioneer for units)\\n    //\\n    // if price is below minimum price, minimum price is returned\\n    // this is enforced on deposits by manipulating total debt (see _decay())\\n    function marketPrice(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Scale value to use when converting between quote token and payout token amounts with marketPrice()\\n    /// @param id_          ID of market\\n    /// @return             Scaling factor for market in configured decimals\\n    function marketScale(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Payout due for amount of quote tokens\\n    /// @dev                Accounts for debt and control variable decay so it is up to date\\n    /// @param amount_      Amount of quote tokens to spend\\n    /// @param id_          ID of market\\n    /// @param referrer_    Address of referrer, used to get fees to calculate accurate payout amount.\\n    ///                     Inputting the zero address will take into account just the protocol fee.\\n    /// @return             amount of payout tokens to be paid\\n    function payoutFor(\\n        uint256 amount_,\\n        uint256 id_,\\n        address referrer_\\n    ) external view returns (uint256);\\n\\n    /// @notice             Returns maximum amount of quote token accepted by the market\\n    /// @param id_          ID of market\\n    /// @param referrer_    Address of referrer, used to get fees to calculate accurate payout amount.\\n    ///                     Inputting the zero address will take into account just the protocol fee.\\n    function maxAmountAccepted(uint256 id_, address referrer_) external view returns (uint256);\\n\\n    /// @notice             Does market send payout immediately\\n    /// @param id_          Market ID to search for\\n    function isInstantSwap(uint256 id_) external view returns (bool);\\n\\n    /// @notice             Is a given market accepting deposits\\n    /// @param id_          ID of market\\n    function isLive(uint256 id_) external view returns (bool);\\n\\n    /// @notice             Returns array of active market IDs within a range\\n    /// @dev                Should be used if length exceeds max to query entire array\\n    function liveMarketsBetween(uint256 firstIndex_, uint256 lastIndex_)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /// @notice             Returns an array of all active market IDs for a given quote token\\n    /// @param token_       Address of token to query by\\n    /// @param isPayout_    If true, search by payout token, else search for quote token\\n    function liveMarketsFor(address token_, bool isPayout_)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /// @notice             Returns an array of all active market IDs for a given owner\\n    /// @param owner_       Address of owner to query by\\n    function liveMarketsBy(address owner_) external view returns (uint256[] memory);\\n\\n    /// @notice             Returns an array of all active market IDs for a given payout and quote token\\n    /// @param payout_      Address of payout token\\n    /// @param quote_       Address of quote token\\n    function marketsFor(address payout_, address quote_) external view returns (uint256[] memory);\\n\\n    /// @notice                 Returns the market ID with the highest current payoutToken payout for depositing quoteToken\\n    /// @param payout_          Address of payout token\\n    /// @param quote_           Address of quote token\\n    /// @param amountIn_        Amount of quote tokens to deposit\\n    /// @param minAmountOut_    Minimum amount of payout tokens to receive as payout\\n    /// @param maxExpiry_       Latest acceptable vesting timestamp for bond\\n    ///                         Inputting the zero address will take into account just the protocol fee.\\n    function findMarketFor(\\n        address payout_,\\n        address quote_,\\n        uint256 amountIn_,\\n        uint256 minAmountOut_,\\n        uint256 maxExpiry_\\n    ) external view returns (uint256 id);\\n\\n    /// @notice             Returns the Teller that services the market ID\\n    function getTeller(uint256 id_) external view returns (IBondTeller);\\n\\n    /// @notice             Returns current capacity of a market\\n    function currentCapacity(uint256 id_) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/lib/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ERC20 and ETH transfer library that safely handles missing return values.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\n/// @author Taken from Solmate.\\nlibrary TransferHelper {\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(ERC20.transferFrom.selector, from, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(ERC20.transfer.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    // function safeApprove(\\n    //     ERC20 token,\\n    //     address to,\\n    //     uint256 amount\\n    // ) internal {\\n    //     (bool success, bytes memory data) = address(token).call(\\n    //         abi.encodeWithSelector(ERC20.approve.selector, to, amount)\\n    //     );\\n\\n    //     require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\n    // }\\n\\n    // function safeTransferETH(address to, uint256 amount) internal {\\n    //     (bool success, ) = to.call{value: amount}(new bytes(0));\\n\\n    //     require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    // }\\n}\\n\"\r\n    },\r\n    \"src/lib/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        unchecked {\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ERC20BondToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.15;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {CloneERC20} from \\\"./lib/CloneERC20.sol\\\";\\n\\n/// @title ERC20 Bond Token\\n/// @notice ERC20 Bond Token Contract\\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\\n///      for any token pair. The markets do not require maintenance and will manage\\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\\n///      receive Bond Tokens to represent their position while their bond vests.\\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\\n///\\n/// @dev The ERC20 Bond Token contract is issued by a Fixed Expiry Teller to\\n///      represent bond positions until they vest. Bond tokens can be redeemed for\\n//       the underlying token 1:1 at or after expiry.\\n///\\n/// @dev This contract uses Clones (https://github.com/wighawag/clones-with-immutable-args)\\n///      to save gas on deployment and is based on VestedERC20 (https://github.com/ZeframLou/vested-erc20)\\n///\\n/// @author Oighty, Zeus, Potted Meat, indigo\\ncontract ERC20BondToken is CloneERC20 {\\n    /* ========== ERRORS ========== */\\n    error BondToken_OnlyTeller();\\n\\n    /* ========== IMMUTABLE PARAMETERS ========== */\\n\\n    /// @notice The token to be redeemed when the bond vests\\n    /// @return _underlying The address of the underlying token\\n    function underlying() external pure returns (ERC20 _underlying) {\\n        return ERC20(_getArgAddress(0x41));\\n    }\\n\\n    /// @notice Timestamp at which the BondToken can be redeemed for the underlying\\n    /// @return _expiry The vest start timestamp\\n    function expiry() external pure returns (uint48 _expiry) {\\n        return uint48(_getArgUint256(0x55));\\n    }\\n\\n    /// @notice Address of the Teller that created the token\\n    function teller() internal pure returns (address _teller) {\\n        return _getArgAddress(0x75);\\n    }\\n\\n    /* ========== MINT/BURN ========== */\\n\\n    function mint(address to, uint256 amount) external {\\n        if (msg.sender != teller()) revert BondToken_OnlyTeller();\\n        _mint(to, amount);\\n    }\\n\\n    function burn(address from, uint256 amount) external {\\n        if (msg.sender != teller()) revert BondToken_OnlyTeller();\\n        _burn(from, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondAuctioneer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {IBondTeller} from \\\"../interfaces/IBondTeller.sol\\\";\\nimport {IBondAggregator} from \\\"../interfaces/IBondAggregator.sol\\\";\\n\\ninterface IBondAuctioneer {\\n    /// @notice                 Creates a new bond market\\n    /// @param params_          Configuration data needed for market creation, encoded in a bytes array\\n    /// @dev                    See specific auctioneer implementations for details on encoding the parameters.\\n    /// @return id              ID of new bond market\\n    function createMarket(bytes memory params_) external returns (uint256);\\n\\n    /// @notice                 Disable existing bond market\\n    /// @notice                 Must be market owner\\n    /// @param id_              ID of market to close\\n    function closeMarket(uint256 id_) external;\\n\\n    /// @notice                 Exchange quote tokens for a bond in a specified market\\n    /// @notice                 Must be teller\\n    /// @param id_              ID of the Market the bond is being purchased from\\n    /// @param amount_          Amount to deposit in exchange for bond (after fee has been deducted)\\n    /// @param minAmountOut_    Minimum acceptable amount of bond to receive. Prevents frontrunning\\n    /// @return payout          Amount of payout token to be received from the bond\\n    function purchaseBond(\\n        uint256 id_,\\n        uint256 amount_,\\n        uint256 minAmountOut_\\n    ) external returns (uint256 payout);\\n\\n    /// @notice                         Set market intervals to different values than the defaults\\n    /// @notice                         Must be market owner\\n    /// @dev                            Changing the intervals could cause markets to behave in unexpected way\\n    ///                                 tuneInterval should be greater than tuneAdjustmentDelay\\n    /// @param id_                      Market ID\\n    /// @param intervals_               Array of intervals (3)\\n    ///                                 1. Tune interval - Frequency of tuning\\n    ///                                 2. Tune adjustment delay - Time to implement downward tuning adjustments\\n    ///                                 3. Debt decay interval - Interval over which debt should decay completely\\n    function setIntervals(uint256 id_, uint32[3] calldata intervals_) external;\\n\\n    /// @notice                      Designate a new owner of a market\\n    /// @notice                      Must be market owner\\n    /// @dev                         Doesn't change permissions until newOwner calls pullOwnership\\n    /// @param id_                   Market ID\\n    /// @param newOwner_             New address to give ownership to\\n    function pushOwnership(uint256 id_, address newOwner_) external;\\n\\n    /// @notice                      Accept ownership of a market\\n    /// @notice                      Must be market newOwner\\n    /// @dev                         The existing owner must call pushOwnership prior to the newOwner calling this function\\n    /// @param id_                   Market ID\\n    function pullOwnership(uint256 id_) external;\\n\\n    /// @notice             Set the auctioneer defaults\\n    /// @notice             Must be policy\\n    /// @param defaults_    Array of default values\\n    ///                     1. Tune interval - amount of time between tuning adjustments\\n    ///                     2. Tune adjustment delay - amount of time to apply downward tuning adjustments\\n    ///                     3. Minimum debt decay interval - minimum amount of time to let debt decay to zero\\n    ///                     4. Minimum deposit interval - minimum amount of time to wait between deposits\\n    ///                     5. Minimum market duration - minimum amount of time a market can be created for\\n    ///                     6. Minimum debt buffer - the minimum amount of debt over the initial debt to trigger a market shutdown\\n    /// @dev                The defaults set here are important to avoid edge cases in market behavior, e.g. a very short market reacts doesn't tune well\\n    /// @dev                Only applies to new markets that are created after the change\\n    function setDefaults(uint32[6] memory defaults_) external;\\n\\n    /// @notice             Change the status of the auctioneer to allow creation of new markets\\n    /// @dev                Setting to false and allowing active markets to end will sunset the auctioneer\\n    /// @param status_      Allow market creation (true) : Disallow market creation (false)\\n    function setAllowNewMarkets(bool status_) external;\\n\\n    /// @notice             Change whether a market creator is allowed to use a callback address in their markets or not\\n    /// @notice             Must be guardian\\n    /// @dev                Callback is believed to be safe, but a whitelist is implemented to prevent abuse\\n    /// @param creator_     Address of market creator\\n    /// @param status_      Allow callback (true) : Disallow callback (false)\\n    function setCallbackAuthStatus(address creator_, bool status_) external;\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /// @notice                 Provides information for the Teller to execute purchases on a Market\\n    /// @param id_              Market ID\\n    /// @return owner           Address of the market owner (tokens transferred from this address if no callback)\\n    /// @return callbackAddr    Address of the callback contract to get tokens for payouts\\n    /// @return payoutToken     Payout Token (token paid out) for the Market\\n    /// @return quoteToken      Quote Token (token received) for the Market\\n    /// @return vesting         Timestamp or duration for vesting, implementation-dependent\\n    /// @return maxPayout       Maximum amount of payout tokens you can purchase in one transaction\\n    function getMarketInfoForPurchase(uint256 id_)\\n        external\\n        view\\n        returns (\\n            address owner,\\n            address callbackAddr,\\n            ERC20 payoutToken,\\n            ERC20 quoteToken,\\n            uint48 vesting,\\n            uint256 maxPayout\\n        );\\n\\n    /// @notice             Calculate current market price of payout token in quote tokens\\n    /// @param id_          ID of market\\n    /// @return             Price for market in configured decimals\\n    //\\n    // if price is below minimum price, minimum price is returned\\n    // this is enforced on deposits by manipulating total debt (see _decay())\\n    function marketPrice(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Scale value to use when converting between quote token and payout token amounts with marketPrice()\\n    /// @param id_          ID of market\\n    /// @return             Scaling factor for market in configured decimals\\n    function marketScale(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Payout due for amount of quote tokens\\n    /// @dev                Accounts for debt and control variable decay so it is up to date\\n    /// @param amount_      Amount of quote tokens to spend\\n    /// @param id_          ID of market\\n    /// @param referrer_    Address of referrer, used to get fees to calculate accurate payout amount.\\n    ///                     Inputting the zero address will take into account just the protocol fee.\\n    /// @return             amount of payout tokens to be paid\\n    function payoutFor(\\n        uint256 amount_,\\n        uint256 id_,\\n        address referrer_\\n    ) external view returns (uint256);\\n\\n    /// @notice             Returns maximum amount of quote token accepted by the market\\n    /// @param id_          ID of market\\n    /// @param referrer_    Address of referrer, used to get fees to calculate accurate payout amount.\\n    ///                     Inputting the zero address will take into account just the protocol fee.\\n    function maxAmountAccepted(uint256 id_, address referrer_) external view returns (uint256);\\n\\n    /// @notice             Does market send payout immediately\\n    /// @param id_          Market ID to search for\\n    function isInstantSwap(uint256 id_) external view returns (bool);\\n\\n    /// @notice             Is a given market accepting deposits\\n    /// @param id_          ID of market\\n    function isLive(uint256 id_) external view returns (bool);\\n\\n    /// @notice             Returns the address of the market owner\\n    /// @param id_          ID of market\\n    function ownerOf(uint256 id_) external view returns (address);\\n\\n    /// @notice             Returns the Teller that services the Auctioneer\\n    function getTeller() external view returns (IBondTeller);\\n\\n    /// @notice             Returns the Aggregator that services the Auctioneer\\n    function getAggregator() external view returns (IBondAggregator);\\n\\n    /// @notice             Returns current capacity of a market\\n    function currentCapacity(uint256 id_) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/lib/CloneERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {Clone} from \\\"clones/Clone.sol\\\";\\n\\n/// @notice Modern and gas efficient ERC20 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract CloneERC20 is Clone {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               METADATA\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external pure returns (string memory) {\\n        return string(abi.encodePacked(_getArgUint256(0)));\\n    }\\n\\n    function symbol() external pure returns (string memory) {\\n        return string(abi.encodePacked(_getArgUint256(0x20)));\\n    }\\n\\n    function decimals() external pure returns (uint8) {\\n        return _getArgUint8(0x40);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    function _getImmutableVariablesOffset() internal pure returns (uint256 offset) {\\n        assembly {\\n            offset := sub(calldatasize(), add(shr(240, calldataload(sub(calldatasize(), 2))), 2))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/clones-with-immutable-args/src/Clone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD\\npragma solidity ^0.8.4;\\n\\n/// @title Clone\\n/// @author zefram.eth\\n/// @notice Provides helper functions for reading immutable args from calldata\\ncontract Clone {\\n    /// @notice Reads an immutable arg with type address\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgAddress(uint256 argOffset)\\n        internal\\n        pure\\n        returns (address arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        assembly {\\n            arg := shr(0x60, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint256\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint256(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint256 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := calldataload(add(offset, argOffset))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint64\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint64(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint64 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xc0, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint8\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xf8, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @return offset The offset of the packed immutable args in calldata\\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            offset := sub(\\n                calldatasize(),\\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\\n            )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"clones-with-immutable-args/=lib/clones-with-immutable-args/src/\",\r\n      \"clones/=lib/clones-with-immutable-args/src/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"weird-erc20/=lib/solmate/lib/weird-erc20/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IBondTeller\",\"name\":\"teller_\",\"type\":\"address\"},{\"internalType\":\"contract IBondAggregator\",\"name\":\"aggregator_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardian_\",\"type\":\"address\"},{\"internalType\":\"contract Authority\",\"name\":\"authority_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Auctioneer_AmountLessThanMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Auctioneer_BadExpiry\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Auctioneer_InitialPriceLessThanMin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Auctioneer_InvalidCallback\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Auctioneer_InvalidParams\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"conclusion_\",\"type\":\"uint256\"}],\"name\":\"Auctioneer_MarketConcluded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Auctioneer_MaxPayoutExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Auctioneer_NewMarketsNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Auctioneer_NotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Auctioneer_NotEnoughCapacity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Auctioneer_OnlyMarketOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"MarketClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payoutToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"vesting\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialPrice\",\"type\":\"uint256\"}],\"name\":\"MarketCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldControlVariable\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newControlVariable\",\"type\":\"uint256\"}],\"name\":\"Tuned\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"adjustments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"change\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"lastAdjustment\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"timeToAdjusted\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowNewMarkets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"callbackAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"closeMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params_\",\"type\":\"bytes\"}],\"name\":\"createMarket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"currentCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"currentControlVariable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"currentDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultTuneAdjustment\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultTuneInterval\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAggregator\",\"outputs\":[{\"internalType\":\"contract IBondAggregator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"getMarketInfoForPurchase\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callbackAddr\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"payoutToken\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"vesting\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"maxPayout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTeller\",\"outputs\":[{\"internalType\":\"contract IBondTeller\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"isInstantSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"isLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"marketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"marketScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"markets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"payoutToken\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callbackAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"capacityInQuote\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"capacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scale\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer_\",\"type\":\"address\"}],\"name\":\"maxAmountAccepted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"lastTune\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"lastDecay\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"length\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"depositInterval\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"tuneInterval\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"tuneAdjustmentDelay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"debtDecayInterval\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"tuneIntervalCapacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tuneBelowCapacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTuneDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDebtBuffer\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDebtDecayInterval\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDepositInterval\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minMarketDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"newOwners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer_\",\"type\":\"address\"}],\"name\":\"payoutFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"pullOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut_\",\"type\":\"uint256\"}],\"name\":\"purchaseBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"pushOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status_\",\"type\":\"bool\"}],\"name\":\"setAllowNewMarkets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status_\",\"type\":\"bool\"}],\"name\":\"setCallbackAuthStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[6]\",\"name\":\"defaults_\",\"type\":\"uint32[6]\"}],\"name\":\"setDefaults\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint32[3]\",\"name\":\"intervals_\",\"type\":\"uint32[3]\"}],\"name\":\"setIntervals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"terms\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"controlVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"vesting\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"conclusion\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BondFixedExpirySDA","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"000000000000000000000000007fe7c498a2cf30971ad8f2cbc36bd14ac51156000000000000000000000000007a66b9e719b3abb2f3917eb47d4231a17f5a0d000000000000000000000000007bd11fca0daaeadd455b51826f9a015f2f0969000000000000000000000000007a0f3b057945db86408197daa7c04373b5a94a","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]