[{"SourceCode":"contract Partner {\r\n    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _RequestedTokens);\r\n}\r\n\r\ncontract COE {\r\n\r\n    string public name = \"CoEval\";\r\n    uint8 public decimals = 18;\r\n    string public symbol = \"COE\";\r\n\r\n\r\n    address public _owner;\r\n    address public _dev = 0xC96CfB18C39DC02FBa229B6EA698b1AD5576DF4c;\r\n    address public _devFeesAddr;\r\n    uint256 public _tokePerEth = 177000000000000000;\r\n    bool public _coldStorage = true;\r\n    bool public _receiveEth = true;\r\n\r\n    // fees vars - added for future extensibility purposes only\r\n    bool _feesEnabled = false;\r\n    bool _payFees = false;\r\n    uint256 _fees;  // the calculation expects % * 100 (so 10% is 1000)\r\n    uint256 _lifeVal = 0;\r\n    uint256 _feeLimit = 0;\r\n    uint256 _devFees = 0;\r\n\r\n    uint256 public _totalSupply = 100000 * 1 ether;\r\n    uint256 public _circulatingSupply = 0;\r\n    uint256 public _frozenTokens = 0;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Exchanged(address indexed _from, address indexed _to, uint _value);\r\n    // Storage\r\n    mapping (address => uint256) public balances;\r\n\r\n    // list of contract addresses that can request tokens\r\n    // use add/remove functions to update\r\n    mapping (address => bool) public exchangePartners;\r\n\r\n    // permitted exch partners and associated token rates\r\n    // rate is X target tokens per Y incoming so newTokens = Tokens/Rate\r\n    mapping (address => uint256) public exchangeRates;\r\n\r\n    function COE() {\r\n        _owner = msg.sender;\r\n        preMine();\r\n    }\r\n\r\n    function preMine() internal {\r\n        balances[_owner] = 32664750000000000000000;\r\n        Transfer(this, _owner, 32664750000000000000000);\r\n        _totalSupply = sub(_totalSupply, 32664750000000000000000);\r\n        _circulatingSupply = add(_circulatingSupply, 32664750000000000000000);\r\n    }\r\n\r\n    function transfer(address _to, uint _value, bytes _data) public {\r\n        // sender must have enough tokens to transfer\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        if(_to == address(this)) {\r\n            // WARNING: if you transfer tokens back to the contract you will lose them\r\n            _totalSupply = add(_totalSupply, _value);\r\n            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\r\n            Transfer(msg.sender, _to, _value);\r\n        }\r\n        else {\r\n            uint codeLength;\r\n\r\n            assembly {\r\n                codeLength := extcodesize(_to)\r\n            }\r\n\r\n            if(codeLength != 0) {\r\n                // only allow transfer to exchange partner contracts - this is handled by another function\r\n                exchange(_to, _value);\r\n            }\r\n            else {\r\n                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\r\n                balances[_to] = add(balances[_to], _value);\r\n\r\n                Transfer(msg.sender, _to, _value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public {\r\n        /// sender must have enough tokens to transfer\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        if(_to == address(this)) {\r\n            // WARNING: if you transfer tokens back to the contract you will lose them\r\n            // use the exchange function to exchange for tokens with approved partner contracts\r\n            _totalSupply = add(_totalSupply, _value);\r\n            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\r\n            Transfer(msg.sender, _to, _value);\r\n        }\r\n        else {\r\n            uint codeLength;\r\n\r\n            assembly {\r\n                codeLength := extcodesize(_to)\r\n            }\r\n\r\n            if(codeLength != 0) {\r\n                // only allow transfer to exchange partner contracts - this is handled by another function\r\n                exchange(_to, _value);\r\n            }\r\n            else {\r\n                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\r\n                balances[_to] = add(balances[_to], _value);\r\n\r\n                Transfer(msg.sender, _to, _value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function exchange(address _partner, uint _amount) internal {\r\n        require(exchangePartners[_partner]);\r\n        require(requestTokensFromOtherContract(_partner, this, msg.sender, _amount));\r\n\r\n        if(_coldStorage) {\r\n            // put the tokens from this contract into cold storage if we need to\r\n            // (NB: if these are in reality to be burnt, we just never defrost them)\r\n            _frozenTokens = add(_frozenTokens, _amount);\r\n        }\r\n        else {\r\n            // or return them to the available supply if not\r\n            _totalSupply = add(_totalSupply, _amount);\r\n        }\r\n\r\n        balances[msg.sender] = sub(balanceOf(msg.sender), _amount);\r\n        _circulatingSupply = sub(_circulatingSupply, _amount);\r\n        Exchanged(msg.sender, _partner, _amount);\r\n        Transfer(msg.sender, this, _amount);\r\n    }\r\n\r\n    // fallback to receive ETH into contract and send tokens back based on current exchange rate\r\n    function () payable public {\r\n        require((msg.value > 0) && (_receiveEth));\r\n        uint256 _tokens = mul(div(msg.value, 1 ether),_tokePerEth);\r\n        require(_totalSupply >= _tokens);//, \"Insufficient tokens available at current exchange rate\");\r\n        _totalSupply = sub(_totalSupply, _tokens);\r\n        balances[msg.sender] = add(balances[msg.sender], _tokens);\r\n        _circulatingSupply = add(_circulatingSupply, _tokens);\r\n        Transfer(this, msg.sender, _tokens);\r\n        _lifeVal = add(_lifeVal, msg.value);\r\n\r\n        if(_feesEnabled) {\r\n            if(!_payFees) {\r\n                // then check whether fees are due and set _payFees accordingly\r\n                if(_lifeVal >= _feeLimit) _payFees = true;\r\n            }\r\n\r\n            if(_payFees) {\r\n                _devFees = add(_devFees, ((msg.value * _fees) / 10000));\r\n            }\r\n        }\r\n    }\r\n\r\n    function requestTokensFromOtherContract(address _targetContract, address _sourceContract, address _recipient, uint256 _value) internal returns (bool){\r\n        Partner p = Partner(_targetContract);\r\n        p.exchangeTokensFromOtherContract(_sourceContract, _recipient, _value);\r\n        return true;\r\n    }\r\n\r\n    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _RequestedTokens) {\r\n        require(exchangeRates[msg.sender] > 0);\r\n        uint256 _exchanged = mul(_RequestedTokens, exchangeRates[_source]);\r\n        require(_exchanged <= _totalSupply);\r\n        balances[_recipient] = add(balances[_recipient],_exchanged);\r\n        _totalSupply = sub(_totalSupply, _exchanged);\r\n        _circulatingSupply = add(_circulatingSupply, _exchanged);\r\n        Exchanged(_source, _recipient, _exchanged);\r\n        Transfer(this, _recipient, _exchanged);\r\n    }\r\n\r\n    function changePayRate(uint256 _newRate) public {\r\n        require(((msg.sender == _owner) || (msg.sender == _dev)) && (_newRate >= 0));\r\n        _tokePerEth = _newRate;\r\n    }\r\n\r\n    function safeWithdrawal(address _receiver, uint256 _value) public {\r\n        require((msg.sender == _owner));\r\n        uint256 valueAsEth = mul(_value,1 ether);\r\n\r\n        // if fees are enabled send the dev fees\r\n        if(_feesEnabled) {\r\n            if(_payFees) _devFeesAddr.transfer(_devFees);\r\n            _devFees = 0;\r\n        }\r\n\r\n        // check balance before transferring\r\n        require(valueAsEth <= this.balance);\r\n        _receiver.transfer(valueAsEth);\r\n    }\r\n\r\n    function balanceOf(address _receiver) public constant returns (uint balance) {\r\n        return balances[_receiver];\r\n    }\r\n\r\n    function changeOwner(address _receiver) public {\r\n        require(msg.sender == _owner);\r\n        _dev = _receiver;\r\n    }\r\n\r\n    function changeDev(address _receiver) public {\r\n        require(msg.sender == _dev);\r\n        _owner = _receiver;\r\n    }\r\n\r\n    function changeDevFeesAddr(address _receiver) public {\r\n        require(msg.sender == _dev);\r\n        _devFeesAddr = _receiver;\r\n    }\r\n\r\n    function toggleReceiveEth() public {\r\n        require((msg.sender == _dev) || (msg.sender == _owner));\r\n        if(!_receiveEth) {\r\n            _receiveEth = true;\r\n        }\r\n        else {\r\n            _receiveEth = false;\r\n        }\r\n    }\r\n\r\n    function toggleFreezeTokensFlag() public {\r\n        require((msg.sender == _dev) || (msg.sender == _owner));\r\n        if(!_coldStorage) {\r\n            _coldStorage = true;\r\n        }\r\n        else {\r\n            _coldStorage = false;\r\n        }\r\n    }\r\n\r\n    function defrostFrozenTokens() public {\r\n        require((msg.sender == _dev) || (msg.sender == _owner));\r\n        _totalSupply = add(_totalSupply, _frozenTokens);\r\n        _frozenTokens = 0;\r\n    }\r\n\r\n    function addExchangePartnerAddressAndRate(address _partner, uint256 _rate) {\r\n        require((msg.sender == _dev) || (msg.sender == _owner));\r\n        uint codeLength;\r\n        assembly {\r\n            codeLength := extcodesize(_partner)\r\n        }\r\n        require(codeLength > 0);\r\n        exchangeRates[_partner] = _rate;\r\n    }\r\n\r\n    function addExchangePartnerTargetAddress(address _partner) public {\r\n        require((msg.sender == _dev) || (msg.sender == _owner));\r\n        exchangePartners[_partner] = true;\r\n    }\r\n\r\n    function removeExchangePartnerTargetAddress(address _partner) public {\r\n        require((msg.sender == _dev) || (msg.sender == _owner));\r\n        exchangePartners[_partner] = false;\r\n    }\r\n\r\n    function canExchange(address _targetContract) public constant returns (bool) {\r\n        return exchangePartners[_targetContract];\r\n    }\r\n\r\n    function contractExchangeRate(address _exchangingContract) public constant returns (uint256) {\r\n        return exchangeRates[_exchangingContract];\r\n    }\r\n\r\n    function totalSupply() public constant returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function getBalance() public constant returns (uint256) {\r\n        return this.balance;\r\n    }\r\n\r\n    function getLifeVal() public constant returns (uint256) {\r\n        require((msg.sender == _owner) || (msg.sender == _dev));\r\n        return _lifeVal;\r\n    }\r\n\r\n    function getCirculatingSupply() public constant returns (uint256) {\r\n        return _circulatingSupply;\r\n    }\r\n\r\n    function payFeesToggle() {\r\n        require((msg.sender == _dev) || (msg.sender == _owner));\r\n        if(_payFees) {\r\n            _payFees = false;\r\n        }\r\n        else {\r\n            _payFees = true;\r\n        }\r\n    }\r\n\r\n    // enables fee update - must be between 0 and 100 (%)\r\n    function updateFeeAmount(uint _newFee) public {\r\n        require((msg.sender == _dev) || (msg.sender == _owner));\r\n        require((_newFee >= 0) && (_newFee <= 100));\r\n        _fees = _newFee * 100;\r\n    }\r\n\r\n    function withdrawDevFees() public {\r\n        require(_payFees);\r\n        _devFeesAddr.transfer(_devFees);\r\n        _devFees = 0;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_devFeesAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"changeDevFeesAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDevFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_coldStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_source\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_RequestedTokens\",\"type\":\"uint256\"}],\"name\":\"exchangeTokensFromOtherContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_partner\",\"type\":\"address\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"addExchangePartnerAddressAndRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"addExchangePartnerTargetAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"defrostFrozenTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleReceiveEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLifeVal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_frozenTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchangeRates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"changeDev\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_receiveEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"updateFeeAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_circulatingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleFreezeTokensFlag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_exchangingContract\",\"type\":\"address\"}],\"name\":\"contractExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payFeesToggle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"safeWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_tokePerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"changePayRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_targetContract\",\"type\":\"address\"}],\"name\":\"canExchange\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_dev\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchangePartners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"removeExchangePartnerTargetAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Exchanged\",\"type\":\"event\"}]","ContractName":"COE","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://cd5629cf179b90d28992eee4c745ba727fdfd0e437f27170305d6b75d4bcf271"}]