[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.4;\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n\n\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\ninterface ICodex {\n    function init(address vault) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address,\n        bytes32,\n        uint256\n    ) external;\n\n    function credit(address) external view returns (uint256);\n\n    function unbackedDebt(address) external view returns (uint256);\n\n    function balances(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function vaults(address vault)\n        external\n        view\n        returns (\n            uint256 totalNormalDebt,\n            uint256 rate,\n            uint256 debtCeiling,\n            uint256 debtFloor\n        );\n\n    function positions(\n        address vault,\n        uint256 tokenId,\n        address position\n    ) external view returns (uint256 collateral, uint256 normalDebt);\n\n    function globalDebt() external view returns (uint256);\n\n    function globalUnbackedDebt() external view returns (uint256);\n\n    function globalDebtCeiling() external view returns (uint256);\n\n    function delegates(address, address) external view returns (uint256);\n\n    function grantDelegate(address) external;\n\n    function revokeDelegate(address) external;\n\n    function modifyBalance(\n        address,\n        uint256,\n        address,\n        int256\n    ) external;\n\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function settleUnbackedDebt(uint256 debt) external;\n\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external;\n\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 rate\n    ) external;\n\n    function lock() external;\n}interface IPriceFeed {\n    function peek() external returns (bytes32, bool);\n\n    function read() external view returns (bytes32);\n}\n\ninterface ICollybus {\n    function vaults(address) external view returns (uint128, uint128);\n\n    function spots(address) external view returns (uint256);\n\n    function rates(uint256) external view returns (uint256);\n\n    function rateIds(address, uint256) external view returns (uint256);\n\n    function redemptionPrice() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint128 data\n    ) external;\n\n    function setParam(\n        address vault,\n        uint256 tokenId,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function updateDiscountRate(uint256 rateId, uint256 rate) external;\n\n    function updateSpot(address token, uint256 spot) external;\n\n    function read(\n        address vault,\n        address underlier,\n        uint256 tokenId,\n        uint256 maturity,\n        bool net\n    ) external view returns (uint256 price);\n\n    function lock() external;\n}\n\ninterface IVault {\n    function codex() external view returns (ICodex);\n\n    function collybus() external view returns (ICollybus);\n\n    function token() external view returns (address);\n\n    function tokenScale() external view returns (uint256);\n\n    function underlierToken() external view returns (address);\n\n    function underlierScale() external view returns (uint256);\n\n    function vaultType() external view returns (bytes32);\n\n    function live() external view returns (uint256);\n\n    function lock() external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function maturity(uint256 tokenId) external returns (uint256);\n\n    function fairPrice(\n        uint256 tokenId,\n        bool net,\n        bool face\n    ) external view returns (uint256);\n\n    function enter(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n\n    function exit(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n}// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\n\n\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\ninterface IFIATExcl {\n    function mint(address to, uint256 amount) external;\n\n    function burn(address from, uint256 amount) external;\n}\n\ninterface IFIAT is IFIATExcl, IERC20, IERC20Permit, IERC20Metadata {}\n\ninterface IMoneta {\n    function codex() external view returns (ICodex);\n\n    function fiat() external view returns (IFIAT);\n\n    function live() external view returns (uint256);\n\n    function lock() external;\n\n    function enter(address user, uint256 amount) external;\n\n    function exit(address user, uint256 amount) external;\n}// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\nuint256 constant MLN = 10**6;\nuint256 constant BLN = 10**9;\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**18;\nuint256 constant RAD = 10**18;\n\n/* solhint-disable func-visibility, no-inline-assembly */\n\nerror Math__toInt256_overflow(uint256 x);\n\nfunction toInt256(uint256 x) pure returns (int256) {\n    if (x > uint256(type(int256).max)) revert Math__toInt256_overflow(x);\n    return int256(x);\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x <= y ? x : y;\n    }\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x >= y ? x : y;\n    }\n}\n\nerror Math__diff_overflow(uint256 x, uint256 y);\n\nfunction diff(uint256 x, uint256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) - int256(y);\n        if (!(int256(x) >= 0 && int256(y) >= 0)) revert Math__diff_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow(uint256 x, uint256 y);\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add_overflow(x, y);\n    }\n}\n\nerror Math__add48_overflow(uint256 x, uint256 y);\n\nfunction add48(uint48 x, uint48 y) pure returns (uint48 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add48_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow_signed(uint256 x, int256 y);\n\nfunction add(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x + uint256(y);\n        if (!(y >= 0 || z <= x)) revert Math__add_overflow_signed(x, y);\n        if (!(y <= 0 || z >= x)) revert Math__add_overflow_signed(x, y);\n    }\n}\n\nerror Math__sub_overflow(uint256 x, uint256 y);\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x - y) > x) revert Math__sub_overflow(x, y);\n    }\n}\n\nerror Math__sub_overflow_signed(uint256 x, int256 y);\n\nfunction sub(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x - uint256(y);\n        if (!(y <= 0 || z <= x)) revert Math__sub_overflow_signed(x, y);\n        if (!(y >= 0 || z >= x)) revert Math__sub_overflow_signed(x, y);\n    }\n}\n\nerror Math__mul_overflow(uint256 x, uint256 y);\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (!(y == 0 || (z = x * y) / y == x)) revert Math__mul_overflow(x, y);\n    }\n}\n\nerror Math__mul_overflow_signed(uint256 x, int256 y);\n\nfunction mul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) * y;\n        if (int256(x) < 0) revert Math__mul_overflow_signed(x, y);\n        if (!(y == 0 || z / y == int256(x))) revert Math__mul_overflow_signed(x, y);\n    }\n}\n\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, y) / WAD;\n    }\n}\n\nfunction wmul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = mul(x, y) / int256(WAD);\n    }\n}\n\nerror Math__div_overflow(uint256 x, uint256 y);\n\nfunction div(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (y == 0) revert Math__div_overflow(x, y);\n        return x / y;\n    }\n}\n\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, WAD) / y;\n    }\n}\n\n// optimized version from dss PR #78\nfunction wpow(\n    uint256 x,\n    uint256 n,\n    uint256 b\n) pure returns (uint256 z) {\n    unchecked {\n        assembly {\n            switch n\n            case 0 {\n                z := b\n            }\n            default {\n                switch x\n                case 0 {\n                    z := 0\n                }\n                default {\n                    switch mod(n, 2)\n                    case 0 {\n                        z := b\n                    }\n                    default {\n                        z := x\n                    }\n                    let half := div(b, 2) // for rounding.\n                    for {\n                        n := div(n, 2)\n                    } n {\n                        n := div(n, 2)\n                    } {\n                        let xx := mul(x, x)\n                        if shr(128, x) {\n                            revert(0, 0)\n                        }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) {\n                            revert(0, 0)\n                        }\n                        x := div(xxRound, b)\n                        if mod(n, 2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                                revert(0, 0)\n                            }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) {\n                                revert(0, 0)\n                            }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* solhint-disable func-visibility, no-inline-assembly */\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\n\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\n\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\n\n\n\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\n\n\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\ninterface IDebtAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function tokenToSellBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function aer() external view returns (address);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(\n        address recipient,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock() external;\n\n    function cancelAuction(uint256 id) external;\n}\ninterface ISurplusAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(uint256 creditToSell, uint256 bid) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 creditToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock(uint256 credit) external;\n\n    function cancelAuction(uint256 id) external;\n}\n\ninterface IAer {\n    function codex() external view returns (ICodex);\n\n    function surplusAuction() external view returns (ISurplusAuction);\n\n    function debtAuction() external view returns (IDebtAuction);\n\n    function debtQueue(uint256) external view returns (uint256);\n\n    function queuedDebt() external view returns (uint256);\n\n    function debtOnAuction() external view returns (uint256);\n\n    function auctionDelay() external view returns (uint256);\n\n    function debtAuctionSellSize() external view returns (uint256);\n\n    function debtAuctionBidSize() external view returns (uint256);\n\n    function surplusAuctionSellSize() external view returns (uint256);\n\n    function surplusBuffer() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function queueDebt(uint256 debt) external;\n\n    function unqueueDebt(uint256 queuedAt) external;\n\n    function settleDebtWithSurplus(uint256 debt) external;\n\n    function settleAuctionedDebt(uint256 debt) external;\n\n    function startDebtAuction() external returns (uint256 auctionId);\n\n    function startSurplusAuction() external returns (uint256 auctionId);\n\n    function transferCredit(address to, uint256 credit) external;\n\n    function lock() external;\n}\n\ninterface IPublican {\n    function vaults(address vault) external view returns (uint256, uint256);\n\n    function codex() external view returns (ICodex);\n\n    function aer() external view returns (IAer);\n\n    function baseInterest() external view returns (uint256);\n\n    function init(address vault) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function virtualRate(address vault) external returns (uint256 rate);\n\n    function collect(address vault) external returns (uint256 rate);\n}\n/// @title VaultActions\n/// @notice A set of base vault actions to inherited from\nabstract contract VaultActions {\n    /// ======== Custom Errors ======== ///\n\n    error VaultActions__exitMoneta_zeroUserAddress();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Codex\n    ICodex public immutable codex;\n    /// @notice Moneta\n    IMoneta public immutable moneta;\n    /// @notice FIAT token\n    IFIAT public immutable fiat;\n    /// @notice Publican\n    IPublican public immutable publican;\n\n    constructor(\n        address codex_,\n        address moneta_,\n        address fiat_,\n        address publican_\n    ) {\n        codex = ICodex(codex_);\n        moneta = IMoneta(moneta_);\n        fiat = IFIAT(fiat_);\n        publican = IPublican(publican_);\n    }\n\n    /// @notice Sets `amount` as the allowance of `spender` over the UserProxy's FIAT\n    /// @param spender Address of the spender\n    /// @param amount Amount of tokens to approve [wad]\n    function approveFIAT(address spender, uint256 amount) external {\n        fiat.approve(spender, amount);\n    }\n\n    /// @dev Redeems FIAT for internal credit\n    /// @param to Address of the recipient\n    /// @param amount Amount of FIAT to exit [wad]\n    function exitMoneta(address to, uint256 amount) public {\n        if (to == address(0)) revert VaultActions__exitMoneta_zeroUserAddress();\n\n        // proxy needs to delegate ability to transfer internal credit on its behalf to Moneta first\n        if (codex.delegates(address(this), address(moneta)) != 1) codex.grantDelegate(address(moneta));\n\n        moneta.exit(to, amount);\n    }\n\n    /// @dev The user needs to previously call approveFIAT with the address of Moneta as the spender\n    /// @param from Address of the account which provides FIAT\n    /// @param amount Amount of FIAT to enter [wad]\n    function enterMoneta(address from, uint256 amount) public {\n        // if `from` is set to an external address then transfer amount to the proxy first\n        // requires `from` to have set an allowance for the proxy\n        if (from != address(0) && from != address(this)) fiat.transferFrom(from, address(this), amount);\n\n        moneta.enter(address(this), amount);\n    }\n\n    /// @notice Deposits `amount` of `token` with `tokenId` from `from` into the `vault`\n    /// @dev Virtual method to be implement in token specific UserAction contracts\n    function enterVault(\n        address vault,\n        address token,\n        uint256 tokenId,\n        address from,\n        uint256 amount\n    ) public virtual;\n\n    /// @notice Withdraws `amount` of `token` with `tokenId` to `to` from the `vault`\n    /// @dev Virtual method to be implement in token specific UserAction contracts\n    function exitVault(\n        address vault,\n        address token,\n        uint256 tokenId,\n        address to,\n        uint256 amount\n    ) public virtual;\n\n    /// @notice method for adjusting collateral and debt balances of a position.\n    /// 1. updates the interest rate accumulator for the given vault\n    /// 2. enters FIAT into Moneta if deltaNormalDebt is negative (applies rate to deltaNormalDebt)\n    /// 3. enters Collateral into Vault if deltaCollateral is positive\n    /// 3. modifies collateral and debt balances in Codex\n    /// 4. exits FIAT from Moneta if deltaNormalDebt is positive (applies rate to deltaNormalDebt)\n    /// 5. exits Collateral from Vault if deltaCollateral is negative\n    /// @dev The user needs to previously approve the UserProxy for spending collateral tokens or FIAT tokens\n    /// If `position` is not the UserProxy, the `position` owner needs grant a delegate to UserProxy via Codex\n    /// @param vault Address of the Vault\n    /// @param token Address of the vault's collateral token\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param position Address of the position's owner\n    /// @param collateralizer Address of who puts up or receives the collateral delta\n    /// @param creditor Address of who provides or receives the FIAT delta for the debt delta\n    /// @param deltaCollateral Amount of collateral to put up (+) for or remove (-) from this Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) for this Position [wad]\n    function modifyCollateralAndDebt(\n        address vault,\n        address token,\n        uint256 tokenId,\n        address position,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) public {\n        // update the interest rate accumulator in Codex for the vault\n        if (deltaNormalDebt != 0) publican.collect(vault);\n\n        if (deltaNormalDebt < 0) {\n            // add due interest from normal debt\n            (, uint256 rate, , ) = codex.vaults(vault);\n            enterMoneta(creditor, uint256(-wmul(rate, deltaNormalDebt)));\n        }\n\n        // transfer tokens to be used as collateral into Vault\n        if (deltaCollateral > 0) {\n            enterVault(\n                vault,\n                token,\n                tokenId,\n                collateralizer,\n                wmul(uint256(deltaCollateral), IVault(vault).tokenScale())\n            );\n        }\n\n        // update collateral and debt balanaces\n        codex.modifyCollateralAndDebt(\n            vault,\n            tokenId,\n            position,\n            address(this),\n            address(this),\n            deltaCollateral,\n            deltaNormalDebt\n        );\n\n        // redeem newly generated internal credit for FIAT\n        if (deltaNormalDebt > 0) {\n            // forward all generated credit by applying rate\n            (, uint256 rate, , ) = codex.vaults(vault);\n            exitMoneta(creditor, wmul(uint256(deltaNormalDebt), rate));\n        }\n\n        // withdraw tokens not be used as collateral anymore from Vault\n        if (deltaCollateral < 0) {\n            exitVault(\n                vault,\n                token,\n                tokenId,\n                collateralizer,\n                wmul(uint256(-deltaCollateral), IVault(vault).tokenScale())\n            );\n        }\n    }\n}\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// WARNING: These functions meant to be used as a a library for a PRBProxy. Some are unsafe if you call them directly.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n/// @title Vault20Actions\n/// @notice A set of vault actions for modifying positions collateralized by ERC20 tokens\ncontract Vault20Actions is VaultActions {\n    using SafeERC20 for IERC20;\n\n    /// ======== Custom Errors ======== ///\n\n    error VaultActions__enterVault_zeroVaultAddress();\n    error VaultActions__enterVault_zeroTokenAddress();\n    error VaultActions__exitVault_zeroVaultAddress();\n    error VaultActions__exitVault_zeroTokenAddress();\n    error VaultActions__exitVault_zeroToAddress();\n\n    constructor(\n        address codex_,\n        address moneta_,\n        address fiat_,\n        address publican_\n    ) VaultActions(codex_, moneta_, fiat_, publican_) {}\n\n    /// @notice Deposits amount of `token` with `tokenId` from `from` into the `vault`\n    /// @dev Implements virtual method defined in VaultActions for ERC20 tokens\n    /// @param vault Address of the Vault to enter\n    /// @param token Address of the collateral token\n    /// @param *tokenId ERC1155 TokenId (leave empty for ERC20 tokens)\n    /// @param from Address from which to take the deposit from\n    /// @param amount Amount of collateral tokens to deposit [tokenScale]\n    function enterVault(\n        address vault,\n        address token,\n        uint256, /* tokenId */\n        address from,\n        uint256 amount\n    ) public virtual override {\n        if (vault == address(0)) revert VaultActions__enterVault_zeroVaultAddress();\n        if (token == address(0)) revert VaultActions__enterVault_zeroTokenAddress();\n\n        // if `from` is set to an external address then transfer amount to the proxy first\n        // requires `from` to have set an allowance for the proxy\n        if (from != address(0) && from != address(this)) {\n            IERC20(token).safeTransferFrom(from, address(this), amount);\n        }\n\n        IERC20(token).approve(vault, amount);\n        IVault(vault).enter(0, address(this), amount);\n    }\n\n    /// @notice Withdraws amount of `token` with `tokenId` to `to` from the `vault`\n    /// @dev Implements virtual method defined in VaultActions for ERC20 tokens\n    /// @param vault Address of the Vault to exit\n    /// @param token Address of the collateral token\n    /// @param *tokenId ERC1155 TokenId (leave empty for ERC20 tokens)\n    /// @param to Address which receives the withdrawn collateral tokens\n    /// @param amount Amount of collateral tokens to exit [tokenScale]\n    function exitVault(\n        address vault,\n        address token,\n        uint256, /* tokenId */\n        address to,\n        uint256 amount\n    ) public virtual override {\n        if (vault == address(0)) revert VaultActions__exitVault_zeroVaultAddress();\n        if (token == address(0)) revert VaultActions__exitVault_zeroTokenAddress();\n        if (to == address(0)) revert VaultActions__exitVault_zeroToAddress();\n\n        IVault(vault).exit(0, to, amount);\n    }\n}\ninterface IBalancerVault {\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    enum PoolSpecialization {\n        GENERAL,\n        MINIMAL_SWAP_INFO,\n        TWO_TOKEN\n    }\n\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n}\n\ninterface IConvergentCurvePool {\n    function solveTradeInvariant(\n        uint256 amountX,\n        uint256 reserveX,\n        uint256 reserveY,\n        bool out\n    ) external view returns (uint256);\n\n    function percentFee() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n\ninterface ITranche {\n    function withdrawPrincipal(uint256 _amount, address _destination) external returns (uint256);\n}\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// WARNING: These functions meant to be used as a a library for a PRBProxy. Some are unsafe if you call them directly.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n/// @title VaultEPTActions\n/// @notice A set of vault actions for modifying positions collateralized by Element Finance pTokens\ncontract VaultEPTActions is Vault20Actions {\n    using SafeERC20 for IERC20;\n\n    /// ======== Custom Errors ======== ///\n\n    error VaultEPTActions__buyCollateralAndModifyDebt_zeroUnderlierAmount();\n    error VaultEPTActions__sellCollateralAndModifyDebt_zeroPTokenAmount();\n    error VaultEPTActions__redeemCollateralAndModifyDebt_zeroPTokenAmount();\n    error VaultEPTActions__solveTradeInvariant_tokenMismatch();\n\n    /// ======== Types ======== ///\n\n    // Swap data\n    struct SwapParams {\n        // Address of the Balancer Vault\n        address balancerVault;\n        // Id of the Element Convergent Curve Pool containing the collateral token\n        bytes32 poolId;\n        // Underlier token address when adding collateral and `collateral` when removing\n        address assetIn;\n        // Collateral token address when adding collateral and `underlier` when removing\n        address assetOut;\n        // Min. amount of tokens we would accept to receive from the swap, whether it is collateral or underlier\n        uint256 minOutput; // The\n        // Timestamp at which swap must be confirmed by [seconds]\n        uint256 deadline;\n        // Amount of `assetIn` to approve for `balancerVault` for swapping `assetIn` for `assetOut`\n        uint256 approve;\n    }\n\n    constructor(\n        address codex_,\n        address moneta_,\n        address fiat_,\n        address publican_\n    ) Vault20Actions(codex_, moneta_, fiat_, publican_) {}\n\n    /// ======== Position Management ======== ///\n\n    /// @notice Buys pTokens from underliers before it modifies a Position's collateral\n    /// and debt balances and mints/burns FIAT using the underlier token.\n    /// The underlier is swapped to pTokens token used as collateral.\n    /// @dev The user needs to previously approve the UserProxy for spending collateral tokens or FIAT tokens\n    /// If `position` is not the UserProxy, the `position` owner needs grant a delegate to UserProxy via Codex\n    /// @param vault Address of the Vault\n    /// @param position Address of the position's owner\n    /// @param collateralizer Address of who puts up or receives the collateral delta as underlier tokens\n    /// @param creditor Address of who provides or receives the FIAT delta for the debt delta\n    /// @param underlierAmount Amount of underlier to swap for pTokens to put up for collateral [underlierScale]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    /// @param swapParams Parameters of the underlier to pToken swap\n    function buyCollateralAndModifyDebt(\n        address vault,\n        address position,\n        address collateralizer,\n        address creditor,\n        uint256 underlierAmount,\n        int256 deltaNormalDebt,\n        SwapParams calldata swapParams\n    ) public {\n        if (underlierAmount == 0) revert VaultEPTActions__buyCollateralAndModifyDebt_zeroUnderlierAmount();\n\n        // buy pToken according to `swapParams` data and transfer tokens to be used as collateral into VaultEPT\n        uint256 pTokenAmount = _buyPToken(underlierAmount, collateralizer, swapParams);\n        int256 deltaCollateral = toInt256(wdiv(pTokenAmount, IVault(vault).tokenScale()));\n\n        // enter pToken and collateralize position\n        modifyCollateralAndDebt(\n            vault,\n            swapParams.assetOut,\n            0,\n            position,\n            address(this),\n            creditor,\n            deltaCollateral,\n            deltaNormalDebt\n        );\n    }\n\n    /// @notice Sells pTokens for underliers after it modifies a Position's collateral and debt balances\n    /// and mints/burns FIAT using the underlier token. This method allows for selling pTokens even after maturity.\n    /// @dev The user needs to previously approve the UserProxy for spending collateral tokens or FIAT tokens\n    /// If `position` is not the UserProxy, the `position` owner needs grant a delegate to UserProxy via Codex\n    /// @param vault Address of the Vault\n    /// @param position Address of the position's owner\n    /// @param collateralizer Address of who puts up or receives the collateral delta as underlier tokens\n    /// @param creditor Address of who provides or receives the FIAT delta for the debt delta\n    /// @param pTokenAmount Amount of pToken to remove as collateral and to swap for underlier [tokenScale]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    /// @param swapParams Parameters of the underlier to pToken swap\n    function sellCollateralAndModifyDebt(\n        address vault,\n        address position,\n        address collateralizer,\n        address creditor,\n        uint256 pTokenAmount,\n        int256 deltaNormalDebt,\n        SwapParams calldata swapParams\n    ) public {\n        if (pTokenAmount == 0) revert VaultEPTActions__sellCollateralAndModifyDebt_zeroPTokenAmount();\n\n        int256 deltaCollateral = -toInt256(wdiv(pTokenAmount, IVault(vault).tokenScale()));\n\n        // withdraw pToken from the position\n        modifyCollateralAndDebt(\n            vault,\n            swapParams.assetIn,\n            0,\n            position,\n            address(this),\n            creditor,\n            deltaCollateral,\n            deltaNormalDebt\n        );\n\n        // sell pToken according to `swapParams`\n        _sellPToken(pTokenAmount, collateralizer, swapParams);\n    }\n\n    /// @notice Redeems pTokens for underliers after it modifies a Position's collateral\n    /// and debt balances and mints/burns FIAT using the underlier token. Fails if pToken hasn't matured yet.\n    /// @dev The user needs to previously approve the UserProxy for spending collateral tokens or FIAT tokens\n    /// If `position` is not the UserProxy, the `position` owner needs grant a delegate to UserProxy via Codex\n    /// @param vault Address of the Vault\n    /// @param token Address of the collateral token (pToken)\n    /// @param position Address of the position's owner\n    /// @param collateralizer Address of who puts up or receives the collateral delta as underlier tokens\n    /// @param creditor Address of who provides or receives the FIAT delta for the debt delta\n    /// @param pTokenAmount Amount of pToken to remove as collateral and to swap or redeem for underlier [tokenScale]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    function redeemCollateralAndModifyDebt(\n        address vault,\n        address token,\n        address position,\n        address collateralizer,\n        address creditor,\n        uint256 pTokenAmount,\n        int256 deltaNormalDebt\n    ) public {\n        if (pTokenAmount == 0) revert VaultEPTActions__redeemCollateralAndModifyDebt_zeroPTokenAmount();\n\n        int256 deltaCollateral = -toInt256(wdiv(pTokenAmount, IVault(vault).tokenScale()));\n\n        // withdraw pToken from the position\n        modifyCollateralAndDebt(vault, token, 0, position, address(this), creditor, deltaCollateral, deltaNormalDebt);\n\n        // redeem pToken for underlier\n        ITranche(token).withdrawPrincipal(pTokenAmount, collateralizer);\n    }\n\n    function _buyPToken(\n        uint256 underlierAmount,\n        address from,\n        SwapParams calldata swapParams\n    ) internal returns (uint256) {\n        // if `from` is set to an external address then transfer amount to the proxy first\n        // requires `from` to have set an allowance for the proxy\n        if (from != address(0) && from != address(this)) {\n            IERC20(swapParams.assetIn).safeTransferFrom(from, address(this), underlierAmount);\n        }\n\n        IBalancerVault.SingleSwap memory singleSwap = IBalancerVault.SingleSwap(\n            swapParams.poolId,\n            IBalancerVault.SwapKind.GIVEN_IN,\n            swapParams.assetIn,\n            swapParams.assetOut,\n            underlierAmount, // note precision\n            new bytes(0)\n        );\n        IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement(\n            address(this),\n            false,\n            payable(address(this)),\n            false\n        );\n\n        if (swapParams.approve != 0) {\n            // approve balancer vault to transfer underlier tokens on behalf of proxy\n            IERC20(swapParams.assetIn).approve(swapParams.balancerVault, swapParams.approve);\n        }\n\n        // kind == `GIVE_IN` use `minOutput` as `limit` to enforce min. amount of pTokens to receive\n        return\n            IBalancerVault(swapParams.balancerVault).swap(singleSwap, funds, swapParams.minOutput, swapParams.deadline);\n    }\n\n    function _sellPToken(\n        uint256 pTokenAmount,\n        address to,\n        SwapParams calldata swapParams\n    ) internal returns (uint256) {\n        // approve Balancer to transfer PToken\n        IERC20(swapParams.assetIn).approve(swapParams.balancerVault, pTokenAmount);\n\n        IBalancerVault.SingleSwap memory singleSwap = IBalancerVault.SingleSwap(\n            swapParams.poolId,\n            IBalancerVault.SwapKind.GIVEN_IN,\n            swapParams.assetIn,\n            swapParams.assetOut,\n            pTokenAmount,\n            new bytes(0)\n        );\n        IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement(\n            address(this),\n            false,\n            payable(to),\n            false\n        );\n\n        if (swapParams.approve != 0) {\n            // approve balancer vault to transfer pTokens on behalf of proxy\n            IERC20(swapParams.assetIn).approve(swapParams.balancerVault, swapParams.approve);\n        }\n\n        // kind == `GIVE_IN` use `minOutput` as `limit` to enforce min. amount of underliers to receive\n        return\n            IBalancerVault(swapParams.balancerVault).swap(singleSwap, funds, swapParams.minOutput, swapParams.deadline);\n    }\n\n    /// ======== View Methods ======== ///\n\n    /// @notice Returns an amount of pToken for a given an amount of the pTokens underlier token (e.g. USDC)\n    /// @param vault Address of the Vault (FIAT)\n    /// @param balancerVault Address of the Balancer V2 vault\n    /// @param curvePoolId Id of the ConvergentCurvePool\n    /// @param underlierAmount Amount of underlier [underlierScale]\n    /// @return Amount of pToken [tokenScale]\n    function underlierToPToken(\n        address vault,\n        address balancerVault,\n        bytes32 curvePoolId,\n        uint256 underlierAmount\n    ) external view returns (uint256) {\n        return _solveTradeInvariant(underlierAmount, vault, balancerVault, curvePoolId, true);\n    }\n\n    /// @notice Returns an amount of the pTokens underlier token for a given an amount of pToken (e.g. USDC pToken)\n    /// @param vault Address of the Vault (FIAT)\n    /// @param balancerVault Address of the Balancer V2 vault\n    /// @param curvePoolId Id of the ConvergentCurvePool\n    /// @param pTokenAmount Amount of token [tokenScale]\n    /// @return Amount of underlier [underlierScale]\n    function pTokenToUnderlier(\n        address vault,\n        address balancerVault,\n        bytes32 curvePoolId,\n        uint256 pTokenAmount\n    ) external view returns (uint256) {\n        return _solveTradeInvariant(pTokenAmount, vault, balancerVault, curvePoolId, false);\n    }\n\n    /// @dev Adapted from https://github.com/element-fi/elf-contracts/blob/main/contracts/ConvergentCurvePool.sol#L150\n    function _solveTradeInvariant(\n        uint256 amountIn_,\n        address vault,\n        address balancerVault,\n        bytes32 poolId,\n        bool fromUnderlier\n    ) internal view returns (uint256) {\n        uint256 tokenScale = IVault(vault).tokenScale();\n        uint256 underlierScale = IVault(vault).underlierScale();\n\n        // convert from either underlierScale or tokenScale to scale used by elf (== wad)\n        uint256 amountIn = (fromUnderlier) ? wdiv(amountIn_, underlierScale) : wdiv(amountIn_, tokenScale);\n\n        uint256 currentBalanceTokenIn;\n        uint256 currentBalanceTokenOut;\n        {\n            (address[] memory tokens, uint256[] memory balances, ) = IBalancerVault(balancerVault).getPoolTokens(\n                poolId\n            );\n            address token = IVault(vault).token();\n            address underlier = IVault(vault).underlierToken();\n\n            if (tokens[0] == underlier && tokens[1] == token) {\n                currentBalanceTokenIn = (fromUnderlier)\n                    ? wdiv(balances[0], underlierScale)\n                    : wdiv(balances[1], tokenScale);\n                currentBalanceTokenOut = (fromUnderlier)\n                    ? wdiv(balances[1], tokenScale)\n                    : wdiv(balances[0], underlierScale);\n            } else if (tokens[0] == token && tokens[1] == underlier) {\n                currentBalanceTokenIn = (fromUnderlier)\n                    ? wdiv(balances[1], underlierScale)\n                    : wdiv(balances[0], tokenScale);\n                currentBalanceTokenOut = (fromUnderlier)\n                    ? wdiv(balances[0], tokenScale)\n                    : wdiv(balances[1], underlierScale);\n            } else {\n                revert VaultEPTActions__solveTradeInvariant_tokenMismatch();\n            }\n        }\n\n        (address pool, ) = IBalancerVault(balancerVault).getPool(poolId);\n        IConvergentCurvePool ccp = IConvergentCurvePool(pool);\n\n        // https://github.com/element-fi/elf-contracts/blob/main/contracts/ConvergentCurvePool.sol#L680\n        if (fromUnderlier) {\n            unchecked {\n                currentBalanceTokenOut += ccp.totalSupply();\n            }\n        } else {\n            unchecked {\n                currentBalanceTokenIn += ccp.totalSupply();\n            }\n        }\n\n        uint256 amountOut = ccp.solveTradeInvariant(amountIn, currentBalanceTokenIn, currentBalanceTokenOut, true);\n        uint256 impliedYieldFee = wmul(\n            ccp.percentFee(),\n            fromUnderlier\n                ? sub(amountOut, amountIn) // If the output is token the implied yield is out - in\n                : sub(amountIn, amountOut) // If the output is underlier the implied yield is in - out\n        );\n\n        // convert from wad to either tokenScale or underlierScale\n        return wmul(sub(amountOut, impliedYieldFee), (fromUnderlier) ? tokenScale : underlierScale);\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"codex_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"moneta_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fiat_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"publican_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__mul_overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"Math__mul_overflow_signed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__sub_overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"Math__toInt256_overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultActions__enterVault_zeroTokenAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultActions__enterVault_zeroVaultAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultActions__exitMoneta_zeroUserAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultActions__exitVault_zeroToAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultActions__exitVault_zeroTokenAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultActions__exitVault_zeroVaultAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultEPTActions__buyCollateralAndModifyDebt_zeroUnderlierAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultEPTActions__redeemCollateralAndModifyDebt_zeroPTokenAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultEPTActions__sellCollateralAndModifyDebt_zeroPTokenAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultEPTActions__solveTradeInvariant_tokenMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveFIAT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralizer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlierAmount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"balancerVault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"assetIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approve\",\"type\":\"uint256\"}],\"internalType\":\"struct VaultEPTActions.SwapParams\",\"name\":\"swapParams\",\"type\":\"tuple\"}],\"name\":\"buyCollateralAndModifyDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"codex\",\"outputs\":[{\"internalType\":\"contract ICodex\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"enterMoneta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"enterVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exitMoneta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exitVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fiat\",\"outputs\":[{\"internalType\":\"contract IFIAT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralizer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"deltaCollateral\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"}],\"name\":\"modifyCollateralAndDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moneta\",\"outputs\":[{\"internalType\":\"contract IMoneta\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"balancerVault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"curvePoolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"pTokenAmount\",\"type\":\"uint256\"}],\"name\":\"pTokenToUnderlier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publican\",\"outputs\":[{\"internalType\":\"contract IPublican\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralizer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"}],\"name\":\"redeemCollateralAndModifyDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralizer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"balancerVault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"assetIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approve\",\"type\":\"uint256\"}],\"internalType\":\"struct VaultEPTActions.SwapParams\",\"name\":\"swapParams\",\"type\":\"tuple\"}],\"name\":\"sellCollateralAndModifyDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"balancerVault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"curvePoolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"underlierAmount\",\"type\":\"uint256\"}],\"name\":\"underlierToPToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VaultEPTActions","CompilerVersion":"v0.8.13+commit.abaa5c0e","OptimizationUsed":"1","Runs":"8000","ConstructorArguments":"0000000000000000000000006bf5eb06201e4ea7c315b1c23bfe79fae30541f9000000000000000000000000ea8efd605845f4cfaa8ee6c757390196e1b3f736000000000000000000000000586aa273f262909eef8fa02d90ab65f5015e05160000000000000000000000003ff548c77a82b377258b5220164e7ae267ed8978","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]