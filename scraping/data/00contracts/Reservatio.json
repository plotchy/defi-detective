[{"SourceCode":"//File: node_modules/zeppelin-solidity/contracts/ownership/Ownable.sol\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n//File: node_modules/zeppelin-solidity/contracts/lifecycle/Pausable.sol\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n//File: node_modules/zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n//File: node_modules/zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n//File: node_modules/zeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n//File: node_modules/zeppelin-solidity/contracts/ownership/CanReclaimToken.sol\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20Basic compatible tokens\r\n   * @param token ERC20Basic The address of the token contract\r\n   */\r\n  function reclaimToken(ERC20Basic token) external onlyOwner {\r\n    uint256 balance = token.balanceOf(this);\r\n    token.safeTransfer(owner, balance);\r\n  }\r\n\r\n}\r\n\r\n//File: node_modules/zeppelin-solidity/contracts/math/SafeMath.sol\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n//File: src/contracts/ico/KYCBase.sol\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n// Abstract base contract\r\ncontract KYCBase {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => bool) public isKycSigner;\r\n    mapping (uint64 => uint256) public alreadyPayed;\r\n\r\n    event KycVerified(address indexed signer, address buyerAddress, uint64 buyerId, uint maxAmount);\r\n\r\n    function KYCBase(address [] kycSigners) internal {\r\n        for (uint i = 0; i < kycSigners.length; i++) {\r\n            isKycSigner[kycSigners[i]] = true;\r\n        }\r\n    }\r\n\r\n    // Must be implemented in descending contract to assign tokens to the buyers. Called after the KYC verification is passed\r\n    function releaseTokensTo(address buyer) internal returns(bool);\r\n\r\n    // This method can be overridden to enable some sender to buy token for a different address\r\n    function senderAllowedFor(address buyer)\r\n        internal view returns(bool)\r\n    {\r\n        return buyer == msg.sender;\r\n    }\r\n\r\n    function buyTokensFor(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\r\n        public payable returns (bool)\r\n    {\r\n        require(senderAllowedFor(buyerAddress));\r\n        return buyImplementation(buyerAddress, buyerId, maxAmount, v, r, s);\r\n    }\r\n\r\n    function buyTokens(uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\r\n        public payable returns (bool)\r\n    {\r\n        return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s);\r\n    }\r\n\r\n    function buyImplementation(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\r\n        private returns (bool)\r\n    {\r\n        // check the signature\r\n        bytes32 hash = sha256(\"Eidoo icoengine authorization\", this, buyerAddress, buyerId, maxAmount);\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (!isKycSigner[signer]) {\r\n            revert();\r\n        } else {\r\n            uint256 totalPayed = alreadyPayed[buyerId].add(msg.value);\r\n            require(totalPayed <= maxAmount);\r\n            alreadyPayed[buyerId] = totalPayed;\r\n            KycVerified(signer, buyerAddress, buyerId, maxAmount);\r\n            return releaseTokensTo(buyerAddress);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // No payable fallback function, the tokens must be buyed using the functions buyTokens and buyTokensFor\r\n    function () public {\r\n        revert();\r\n    }\r\n}\r\n//File: src/contracts/ico/ICOEngineInterface.sol\r\npragma solidity ^0.4.19;\r\n\r\n\r\ncontract ICOEngineInterface {\r\n\r\n    // false if the ico is not started, true if the ico is started and running, true if the ico is completed\r\n    function started() public view returns(bool);\r\n\r\n    // false if the ico is not started, false if the ico is started and running, true if the ico is completed\r\n    function ended() public view returns(bool);\r\n\r\n    // time stamp of the starting time of the ico, must return 0 if it depends on the block number\r\n    function startTime() public view returns(uint);\r\n\r\n    // time stamp of the ending time of the ico, must retrun 0 if it depends on the block number\r\n    function endTime() public view returns(uint);\r\n\r\n    // Optional function, can be implemented in place of startTime\r\n    // Returns the starting block number of the ico, must return 0 if it depends on the time stamp\r\n    // function startBlock() public view returns(uint);\r\n\r\n    // Optional function, can be implemented in place of endTime\r\n    // Returns theending block number of the ico, must retrun 0 if it depends on the time stamp\r\n    // function endBlock() public view returns(uint);\r\n\r\n    // returns the total number of the tokens available for the sale, must not change when the ico is started\r\n    function totalTokens() public view returns(uint);\r\n\r\n    // returns the number of the tokens available for the ico. At the moment that the ico starts it must be equal to totalTokens(),\r\n    // then it will decrease. It is used to calculate the percentage of sold tokens as remainingTokens() / totalTokens()\r\n    function remainingTokens() public view returns(uint);\r\n\r\n    // return the price as number of tokens released for each ether\r\n    function price() public view returns(uint);\r\n}\r\n//File: src/contracts/ico/CrowdsaleBase.sol\r\n/**\r\n * @title CrowdsaleBase\r\n * @dev Base crowdsale contract to be inherited by the UacCrowdsale and Reservation contracts.\r\n *\r\n * @version 1.0\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CrowdsaleBase is Pausable, CanReclaimToken, ICOEngineInterface, KYCBase {\r\n\r\n    /*** CONSTANTS ***/\r\n    uint256 public constant USD_PER_TOKEN = 2;                        //\r\n    uint256 public constant USD_PER_ETHER = 795;                      // \r\n\r\n    uint256 public start;                                             // ICOEngineInterface\r\n    uint256 public end;                                               // ICOEngineInterface\r\n    uint256 public cap;                                               // ICOEngineInterface\r\n    address public wallet;\r\n    uint256 public tokenPerEth;\r\n    uint256 public availableTokens;                                   // ICOEngineInterface\r\n    address[] public kycSigners;                                      // KYCBase\r\n    bool public capReached;\r\n    uint256 public weiRaised;\r\n    uint256 public tokensSold;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _start The start time of the sale.\r\n     * @param _end The end time of the sale.\r\n     * @param _cap The maximum amount of tokens to be sold during the sale.\r\n     * @param _wallet The address where funds should be transferred.\r\n     * @param _kycSigners Array of the signers addresses required by the KYCBase constructor, provided by Eidoo.\r\n     * See https://github.com/eidoo/icoengine\r\n     */\r\n    function CrowdsaleBase(\r\n        uint256 _start,\r\n        uint256 _end,\r\n        uint256 _cap,\r\n        address _wallet,\r\n        address[] _kycSigners\r\n    )\r\n        public\r\n        KYCBase(_kycSigners)\r\n    {\r\n        require(_end >= _start);\r\n        require(_cap > 0);\r\n\r\n        start = _start;\r\n        end = _end;\r\n        cap = _cap;\r\n        wallet = _wallet;\r\n        tokenPerEth = USD_PER_ETHER.div(USD_PER_TOKEN);\r\n        availableTokens = _cap;\r\n        kycSigners = _kycSigners;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the ICOEngineInterface.\r\n     * @return False if the ico is not started, true if the ico is started and running, true if the ico is completed.\r\n     */\r\n    function started() public view returns(bool) {\r\n        if (block.timestamp >= start) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the ICOEngineInterface.\r\n     * @return False if the ico is not started, false if the ico is started and running, true if the ico is completed.\r\n     */\r\n    function ended() public view returns(bool) {\r\n        if (block.timestamp >= end) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the ICOEngineInterface.\r\n     * @return Timestamp of the ico start time.\r\n     */\r\n    function startTime() public view returns(uint) {\r\n        return start;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the ICOEngineInterface.\r\n     * @return Timestamp of the ico end time.\r\n     */\r\n    function endTime() public view returns(uint) {\r\n        return end;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the ICOEngineInterface.\r\n     * @return The total number of the tokens available for the sale, must not change when the ico is started.\r\n     */\r\n    function totalTokens() public view returns(uint) {\r\n        return cap;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the ICOEngineInterface.\r\n     * @return The number of the tokens available for the ico. At the moment the ico starts it must be equal to totalTokens(),\r\n     * then it will decrease.\r\n     */\r\n    function remainingTokens() public view returns(uint) {\r\n        return availableTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the KYCBase senderAllowedFor function to enable a sender to buy tokens for a different address.\r\n     * @return true.\r\n     */\r\n    function senderAllowedFor(address buyer) internal view returns(bool) {\r\n        require(buyer != address(0));\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the KYCBase releaseTokensTo function to mint tokens for an investor. Called after the KYC process has passed.\r\n     * @return A bollean that indicates if the operation was successful.\r\n     */\r\n    function releaseTokensTo(address buyer) internal returns(bool) {\r\n        require(validPurchase());\r\n\r\n        uint256 overflowTokens;\r\n        uint256 refundWeiAmount;\r\n\r\n        uint256 weiAmount = msg.value;\r\n        uint256 tokenAmount = weiAmount.mul(price());\r\n\r\n        if (tokenAmount >= availableTokens) {\r\n            capReached = true;\r\n            overflowTokens = tokenAmount.sub(availableTokens);\r\n            tokenAmount = tokenAmount.sub(overflowTokens);\r\n            refundWeiAmount = overflowTokens.div(price());\r\n            weiAmount = weiAmount.sub(refundWeiAmount);\r\n            buyer.transfer(refundWeiAmount);\r\n        }\r\n\r\n        weiRaised = weiRaised.add(weiAmount);\r\n        tokensSold = tokensSold.add(tokenAmount);\r\n        availableTokens = availableTokens.sub(tokenAmount);\r\n        mintTokens(buyer, tokenAmount);\r\n        forwardFunds(weiAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Fired by the releaseTokensTo function after minting tokens, to forward the raised wei to the address that collects funds.\r\n     * @param _weiAmount Amount of wei send by the investor.\r\n     */\r\n    function forwardFunds(uint256 _weiAmount) internal {\r\n        wallet.transfer(_weiAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Validates an incoming purchase. Required statements revert state when conditions are not met.\r\n     * @return true If the transaction can buy tokens.\r\n     */\r\n    function validPurchase() internal view returns (bool) {\r\n        require(!paused && !capReached);\r\n        require(block.timestamp >= start && block.timestamp <= end);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Abstract function to mint tokens, to be implemented in the Crowdsale and Reservation contracts.\r\n    * @param to The address that will receive the minted tokens.\r\n    * @param amount The amount of tokens to mint.\r\n    */\r\n    function mintTokens(address to, uint256 amount) private;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//File: node_modules/zeppelin-solidity/contracts/token/ERC20/TokenVesting.sol\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenVesting\r\n * @dev A token holder contract that can release its token balance gradually like a\r\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\r\n * owner.\r\n */\r\ncontract TokenVesting is Ownable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  event Released(uint256 amount);\r\n  event Revoked();\r\n\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n\r\n  uint256 public cliff;\r\n  uint256 public start;\r\n  uint256 public duration;\r\n\r\n  bool public revocable;\r\n\r\n  mapping (address => uint256) public released;\r\n  mapping (address => bool) public revoked;\r\n\r\n  /**\r\n   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\r\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\r\n   * of the balance will have vested.\r\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\r\n   * @param _duration duration in seconds of the period in which the tokens will vest\r\n   * @param _revocable whether the vesting is revocable or not\r\n   */\r\n  function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {\r\n    require(_beneficiary != address(0));\r\n    require(_cliff <= _duration);\r\n\r\n    beneficiary = _beneficiary;\r\n    revocable = _revocable;\r\n    duration = _duration;\r\n    cliff = _start.add(_cliff);\r\n    start = _start;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers vested tokens to beneficiary.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function release(ERC20Basic token) public {\r\n    uint256 unreleased = releasableAmount(token);\r\n\r\n    require(unreleased > 0);\r\n\r\n    released[token] = released[token].add(unreleased);\r\n\r\n    token.safeTransfer(beneficiary, unreleased);\r\n\r\n    Released(unreleased);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n   * remain in the contract, the rest are returned to the owner.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function revoke(ERC20Basic token) public onlyOwner {\r\n    require(revocable);\r\n    require(!revoked[token]);\r\n\r\n    uint256 balance = token.balanceOf(this);\r\n\r\n    uint256 unreleased = releasableAmount(token);\r\n    uint256 refund = balance.sub(unreleased);\r\n\r\n    revoked[token] = true;\r\n\r\n    token.safeTransfer(owner, refund);\r\n\r\n    Revoked();\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function releasableAmount(ERC20Basic token) public view returns (uint256) {\r\n    return vestedAmount(token).sub(released[token]);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the amount that has already vested.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function vestedAmount(ERC20Basic token) public view returns (uint256) {\r\n    uint256 currentBalance = token.balanceOf(this);\r\n    uint256 totalBalance = currentBalance.add(released[token]);\r\n\r\n    if (now < cliff) {\r\n      return 0;\r\n    } else if (now >= start.add(duration) || revoked[token]) {\r\n      return totalBalance;\r\n    } else {\r\n      return totalBalance.mul(now.sub(start)).div(duration);\r\n    }\r\n  }\r\n}\r\n\r\n//File: node_modules/zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n//File: node_modules/zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n//File: node_modules/zeppelin-solidity/contracts/token/ERC20/MintableToken.sol\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner canMint public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n//File: node_modules/zeppelin-solidity/contracts/token/ERC20/PausableToken.sol\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\r\n    return super.decreaseApproval(_spender, _subtractedValue);\r\n  }\r\n}\r\n\r\n//File: src/contracts/ico/UacToken.sol\r\n/**\r\n * @title Ubiatar Coin token\r\n *\r\n * @version 1.0\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\ncontract UacToken is CanReclaimToken, MintableToken, PausableToken {\r\n    string public constant name = \"Ubiatar Coin\";\r\n    string public constant symbol = \"UAC\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    /**\r\n     * @dev Constructor of UacToken that instantiates a new Mintable Pausable Token\r\n     */\r\n    function UacToken() public {\r\n        // token should not be transferrable until after all tokens have been issued\r\n        paused = true;\r\n    }\r\n}\r\n\r\n//File: src/contracts/ico/UbiatarPlayVault.sol\r\n/**\r\n * @title UbiatarPlayVault\r\n * @dev A token holder contract that allows the release of tokens to the UbiatarPlay Wallet.\r\n *\r\n * @version 1.0\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract UbiatarPlayVault {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for UacToken;\r\n\r\n    uint256[6] public vesting_offsets = [\r\n        90 days,\r\n        180 days,\r\n        270 days,\r\n        360 days,\r\n        540 days,\r\n        720 days\r\n    ];\r\n\r\n    uint256[6] public vesting_amounts = [\r\n        2e6 * 1e18,\r\n        4e6 * 1e18,\r\n        6e6 * 1e18,\r\n        8e6 * 1e18,\r\n        10e6 * 1e18,\r\n        20.5e6 * 1e18\r\n    ];\r\n\r\n    address public ubiatarPlayWallet;\r\n    UacToken public token;\r\n    uint256 public start;\r\n    uint256 public released;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _ubiatarPlayWallet The address that will receive the vested tokens.\r\n     * @param _token The UAC Token, which is being vested.\r\n     * @param _start The start time from which each release time will be calculated.\r\n     */\r\n    function UbiatarPlayVault(\r\n        address _ubiatarPlayWallet,\r\n        address _token,\r\n        uint256 _start\r\n    )\r\n        public\r\n    {\r\n        ubiatarPlayWallet = _ubiatarPlayWallet;\r\n        token = UacToken(_token);\r\n        start = _start;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers vested tokens to ubiatarPlayWallet.\r\n     */\r\n    function release() public {\r\n        uint256 unreleased = releasableAmount();\r\n        require(unreleased > 0);\r\n\r\n        released = released.add(unreleased);\r\n\r\n        token.safeTransfer(ubiatarPlayWallet, unreleased);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n     */\r\n    function releasableAmount() public view returns (uint256) {\r\n        return vestedAmount().sub(released);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested.\r\n     */\r\n    function vestedAmount() public view returns (uint256) {\r\n        uint256 vested = 0;\r\n\r\n        for (uint256 i = 0; i < vesting_offsets.length; i = i.add(1)) {\r\n            if (block.timestamp > start.add(vesting_offsets[i])) {\r\n                vested = vested.add(vesting_amounts[i]);\r\n            }\r\n        }\r\n\r\n        return vested;\r\n    }\r\n}\r\n\r\n\r\n\r\n//File: src/contracts/ico/PresaleTokenVault.sol\r\n/**\r\n * @title PresaleTokenVault\r\n * @dev A token holder contract that allows multiple beneficiaries to extract their tokens after a given release time.\r\n *\r\n * @version 1.0\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\npragma solidity ^0.4.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PresaleTokenVault {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20Basic;\r\n\r\n    /*** CONSTANTS ***/\r\n    uint256 public constant VESTING_OFFSET = 90 days;                   // starting of vesting\r\n    uint256 public constant VESTING_DURATION = 180 days;                // duration of vesting\r\n\r\n    uint256 public start;\r\n    uint256 public cliff;\r\n    uint256 public end;\r\n\r\n    ERC20Basic public token;\r\n\r\n    struct Investment {\r\n        address beneficiary;\r\n        uint256 totalBalance;\r\n        uint256 released;\r\n    }\r\n\r\n    Investment[] public investments;\r\n\r\n    // key: investor address; value: index in investments array.\r\n    mapping(address => uint256) public investorLUT;\r\n\r\n    function init(address[] beneficiaries, uint256[] balances, uint256 startTime, address _token) public {\r\n        // makes sure this function is only called once\r\n        require(token == address(0));\r\n        require(beneficiaries.length == balances.length);\r\n\r\n        start = startTime;\r\n        cliff = start.add(VESTING_OFFSET);\r\n        end = cliff.add(VESTING_DURATION);\r\n\r\n        token = ERC20Basic(_token);\r\n\r\n        for (uint256 i = 0; i < beneficiaries.length; i = i.add(1)) {\r\n            investorLUT[beneficiaries[i]] = investments.length;\r\n            investments.push(Investment(beneficiaries[i], balances[i], 0));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Allows a sender to transfer vested tokens to the beneficiary's address.\r\n     * @param beneficiary The address that will receive the vested tokens.\r\n     */\r\n    function release(address beneficiary) public {\r\n        uint256 unreleased = releasableAmount(beneficiary);\r\n        require(unreleased > 0);\r\n\r\n        uint256 investmentIndex = investorLUT[beneficiary];\r\n        investments[investmentIndex].released = investments[investmentIndex].released.add(unreleased);\r\n        token.safeTransfer(beneficiary, unreleased);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers vested tokens to the sender's address.\r\n     */\r\n    function release() public {\r\n        release(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n     * @param beneficiary The address that will receive the vested tokens.\r\n     */\r\n    function releasableAmount(address beneficiary) public view returns (uint256) {\r\n        uint256 investmentIndex = investorLUT[beneficiary];\r\n\r\n        return vestedAmount(beneficiary).sub(investments[investmentIndex].released);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested.\r\n     * @param beneficiary The address that will receive the vested tokens.\r\n     */\r\n    function vestedAmount(address beneficiary) public view returns (uint256) {\r\n\r\n        uint256 investmentIndex = investorLUT[beneficiary];\r\n\r\n        uint256 vested = 0;\r\n\r\n        if (block.timestamp >= start) {\r\n            // after start -> 1/3 released (fixed)\r\n            vested = investments[investmentIndex].totalBalance.div(3);\r\n        }\r\n        if (block.timestamp >= cliff && block.timestamp < end) {\r\n            // after cliff -> linear vesting over time\r\n            uint256 p1 = investments[investmentIndex].totalBalance.div(3);\r\n            uint256 p2 = investments[investmentIndex].totalBalance;\r\n\r\n            /*\r\n              released amount:  r\r\n              1/3:              p1\r\n              all:              p2\r\n              current time:     t\r\n              cliff:            c\r\n              end:              e\r\n\r\n              r = p1 +  / d_time * time\r\n                = p1 + (p2-p1) / (e-c) * (t-c)\r\n            */\r\n            uint256 d_token = p2.sub(p1);\r\n            uint256 time = block.timestamp.sub(cliff);\r\n            uint256 d_time = end.sub(cliff);\r\n\r\n            vested = vested.add(d_token.mul(time).div(d_time));\r\n        }\r\n        if (block.timestamp >= end) {\r\n            // after end -> all vested\r\n            vested = investments[investmentIndex].totalBalance;\r\n        }\r\n        return vested;\r\n    }\r\n}\r\n\r\n//File: src/contracts/ico/UacCrowdsale.sol\r\n/**\r\n * @title UacCrowdsale\r\n *\r\n * @version 1.0\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract UacCrowdsale is CrowdsaleBase {\r\n\r\n    /*** CONSTANTS ***/\r\n    uint256 public constant START_TIME = 1525856400;                     // 9 May 2018 09:00:00 GMT\r\n    uint256 public constant END_TIME = 1528448400;                       // 8 June 2018 09:00:00 GMT\r\n    uint256 public constant PRESALE_VAULT_START = END_TIME + 7 days;\r\n    uint256 public constant PRESALE_CAP = 17584778551358900100698693;\r\n    uint256 public constant TOTAL_MAX_CAP = 15e6 * 1e18;                // Reservation plus main sale tokens\r\n    uint256 public constant CROWDSALE_CAP = 7.5e6 * 1e18;\r\n    uint256 public constant FOUNDERS_CAP = 12e6 * 1e18;\r\n    uint256 public constant UBIATARPLAY_CAP = 50.5e6 * 1e18;\r\n    uint256 public constant ADVISORS_CAP = 4915221448641099899301307;\r\n\r\n    // Eidoo interface requires price as tokens/ether, therefore the discounts are presented as bonus tokens.\r\n    uint256 public constant BONUS_TIER1 = 108;                           // 8% during first 3 hours\r\n    uint256 public constant BONUS_TIER2 = 106;                           // 6% during next 9 hours\r\n    uint256 public constant BONUS_TIER3 = 104;                           // 4% during next 30 hours\r\n    uint256 public constant BONUS_DURATION_1 = 3 hours;\r\n    uint256 public constant BONUS_DURATION_2 = 12 hours;\r\n    uint256 public constant BONUS_DURATION_3 = 42 hours;\r\n\r\n    uint256 public constant FOUNDERS_VESTING_CLIFF = 1 years;\r\n    uint256 public constant FOUNDERS_VESTING_DURATION = 2 years;\r\n\r\n    Reservation public reservation;\r\n\r\n    // Vesting contracts.\r\n    PresaleTokenVault public presaleTokenVault;\r\n    TokenVesting public foundersVault;\r\n    UbiatarPlayVault public ubiatarPlayVault;\r\n\r\n    // Vesting wallets.\r\n    address public foundersWallet;\r\n    address public advisorsWallet;\r\n    address public ubiatarPlayWallet;\r\n\r\n    address public wallet;\r\n\r\n    UacToken public token;\r\n\r\n    // Lets owner manually end crowdsale.\r\n    bool public didOwnerEndCrowdsale;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _foundersWallet address Wallet holding founders tokens.\r\n     * @param _advisorsWallet address Wallet holding advisors tokens.\r\n     * @param _ubiatarPlayWallet address Wallet holding ubiatarPlay tokens.\r\n     * @param _wallet The address where funds should be transferred.\r\n     * @param _kycSigners Array of the signers addresses required by the KYCBase constructor, provided by Eidoo.\r\n     * See https://github.com/eidoo/icoengine\r\n     */\r\n    function UacCrowdsale(\r\n        address _token,\r\n        address _reservation,\r\n        address _presaleTokenVault,\r\n        address _foundersWallet,\r\n        address _advisorsWallet,\r\n        address _ubiatarPlayWallet,\r\n        address _wallet,\r\n        address[] _kycSigners\r\n    )\r\n        public\r\n        CrowdsaleBase(START_TIME, END_TIME, TOTAL_MAX_CAP, _wallet, _kycSigners)\r\n    {\r\n        token = UacToken(_token);\r\n        reservation = Reservation(_reservation);\r\n        presaleTokenVault = PresaleTokenVault(_presaleTokenVault);\r\n        foundersWallet = _foundersWallet;\r\n        advisorsWallet = _advisorsWallet;\r\n        ubiatarPlayWallet = _ubiatarPlayWallet;\r\n        wallet = _wallet;\r\n        // Create founders vault contract\r\n        foundersVault = new TokenVesting(foundersWallet, END_TIME, FOUNDERS_VESTING_CLIFF, FOUNDERS_VESTING_DURATION, false);\r\n\r\n        // Create Ubiatar Play vault contract\r\n        ubiatarPlayVault = new UbiatarPlayVault(ubiatarPlayWallet, address(token), END_TIME);\r\n    }\r\n\r\n    function mintPreAllocatedTokens() public onlyOwner {\r\n        mintTokens(address(foundersVault), FOUNDERS_CAP);\r\n        mintTokens(advisorsWallet, ADVISORS_CAP);\r\n        mintTokens(address(ubiatarPlayVault), UBIATARPLAY_CAP);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates the presale vault contract.\r\n     * @param beneficiaries Array of the presale investors addresses to whom vested tokens are transferred.\r\n     * @param balances Array of token amount per beneficiary.\r\n     */\r\n    function initPresaleTokenVault(address[] beneficiaries, uint256[] balances) public onlyOwner {\r\n        require(beneficiaries.length == balances.length);\r\n\r\n        presaleTokenVault.init(beneficiaries, balances, PRESALE_VAULT_START, token);\r\n\r\n        uint256 totalPresaleBalance = 0;\r\n        uint256 balancesLength = balances.length;\r\n        for(uint256 i = 0; i < balancesLength; i++) {\r\n            totalPresaleBalance = totalPresaleBalance.add(balances[i]);\r\n        }\r\n\r\n        mintTokens(presaleTokenVault, totalPresaleBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the price function from EidooEngineInterface.\r\n     * @notice Calculates the price as tokens/ether based on the corresponding bonus bracket.\r\n     * @return Price as tokens/ether.\r\n     */\r\n    function price() public view returns (uint256 _price) {\r\n        if (block.timestamp <= start.add(BONUS_DURATION_1)) {\r\n            return tokenPerEth.mul(BONUS_TIER1).div(1e2);\r\n        } else if (block.timestamp <= start.add(BONUS_DURATION_2)) {\r\n            return tokenPerEth.mul(BONUS_TIER2).div(1e2);\r\n        } else if (block.timestamp <= start.add(BONUS_DURATION_3)) {\r\n            return tokenPerEth.mul(BONUS_TIER3).div(1e2);\r\n        }\r\n        return tokenPerEth;\r\n    }\r\n\r\n    /**\r\n     * @dev Mints tokens being sold during the reservation phase, as part of the implementation of the releaseTokensTo function\r\n     * from the KYCBase contract.\r\n     * Also, updates tokensSold and availableTokens in the crowdsale contract.\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param amount The amount of tokens to mint.\r\n     */\r\n    function mintReservationTokens(address to, uint256 amount) public {\r\n        require(msg.sender == address(reservation));\r\n        tokensSold = tokensSold.add(amount);\r\n        availableTokens = availableTokens.sub(amount);\r\n        mintTokens(to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints tokens being sold during the crowdsale phase as part of the implementation of releaseTokensTo function\r\n     * from the KYCBase contract.\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param amount The amount of tokens to mint.\r\n     */\r\n    function mintTokens(address to, uint256 amount) private {\r\n        token.mint(to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to close the crowdsale manually before the end time.\r\n     */\r\n    function closeCrowdsale() public onlyOwner {\r\n        require(block.timestamp >= START_TIME && block.timestamp < END_TIME);\r\n        didOwnerEndCrowdsale = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to unpause tokens, stop minting and transfer ownership of the token contract.\r\n     */\r\n    function finalise() public onlyOwner {\r\n        require(didOwnerEndCrowdsale || block.timestamp > end || capReached);\r\n        token.finishMinting();\r\n        token.unpause();\r\n\r\n        // Token contract extends CanReclaimToken so the owner can recover any ERC20 token received in this contract by mistake.\r\n        // So far, the owner of the token contract is the crowdsale contract.\r\n        // We transfer the ownership so the owner of the crowdsale is also the owner of the token.\r\n        token.transferOwnership(owner);\r\n    }\r\n}\r\n\r\n\r\n//File: src/contracts/ico/Reservation.sol\r\n/**\r\n * @title Reservation\r\n *\r\n * @version 1.0\r\n * @author Validity Labs AG <info@validitylabs.org>\r\n */\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\ncontract Reservation is CrowdsaleBase {\r\n\r\n    /*** CONSTANTS ***/\r\n    uint256 public constant START_TIME = 1525683600;                     // 7 May 2018 09:00:00 GMT\r\n    uint256 public constant END_TIME = 1525856400;                       // 9 May 2018 09:00:00 GMT\r\n    uint256 public constant RESERVATION_CAP = 7.5e6 * 1e18;\r\n    uint256 public constant BONUS = 110;                                 // 10% bonus\r\n\r\n    UacCrowdsale public crowdsale;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @notice Unsold tokens should add up to the crowdsale hard cap.\r\n     * @param _wallet The address where funds should be transferred.\r\n     * @param _kycSigners Array of the signers addresses required by the KYCBase constructor, provided by Eidoo.\r\n     * See https://github.com/eidoo/icoengine\r\n     */\r\n    function Reservation(\r\n        address _wallet,\r\n        address[] _kycSigners\r\n    )\r\n        public\r\n        CrowdsaleBase(START_TIME, END_TIME, RESERVATION_CAP, _wallet, _kycSigners)\r\n    {\r\n    }\r\n\r\n    function setCrowdsale(address _crowdsale) public {\r\n        require(crowdsale == address(0));\r\n        crowdsale = UacCrowdsale(_crowdsale);\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the price function from EidooEngineInterface.\r\n     * @notice Calculates the price as tokens/ether based on the corresponding bonus.\r\n     * @return Price as tokens/ether.\r\n     */\r\n    function price() public view returns (uint256) {\r\n        return tokenPerEth.mul(BONUS).div(1e2);\r\n    }\r\n\r\n    /**\r\n     * @dev Fires the mintReservationTokens function on the crowdsale contract to mint the tokens being sold during the reservation phase.\r\n     * This function is called by the releaseTokensTo function, as part of the KYCBase implementation.\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param amount The amount of tokens to mint.\r\n     */\r\n    function mintTokens(address to, uint256 amount) private {\r\n        crowdsale.mintReservationTokens(to, amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isKycSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ended\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"started\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kycSigners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsale\",\"type\":\"address\"}],\"name\":\"setCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USD_PER_ETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"alreadyPayed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESERVATION_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyerAddress\",\"type\":\"address\"},{\"name\":\"buyerId\",\"type\":\"uint64\"},{\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"buyTokensFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USD_PER_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"START_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyerId\",\"type\":\"uint64\"},{\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_kycSigners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"name\":\"KycVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Reservation","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a2d9103d8882578cfb597ec1c9675a7335edcc2700000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000dd5ecefcaa0cb5d75f7b72dc9d2ce446d6d005200000000000000000000000004e315e5de2abbf7b745d9628ee60e4355c0fab86","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://2022f082985d3bb2602523b2aa9869481a4f38f802efbd2688d6624341e132e2"}]