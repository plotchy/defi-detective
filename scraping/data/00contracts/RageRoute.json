[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/// @dev Contract Helpers.\r\n\r\n/// @notice Contract helper for ERC1155 safeTransferFrom.\r\nabstract contract ERC1155STF {\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) public virtual;\r\n}\r\n\r\n/// @notice Contract helper for remote token (ERC20/721/1155) burns.\r\n/// @dev These functions are opinionated to OpenZeppelin implementations.\r\nabstract contract TokenBurn {\r\n    /// @dev ERC20.\r\n    function burnFrom(address from, uint256 amount) public virtual;\r\n\r\n    /// @dev ERC721.\r\n    function burn(uint256 id) public virtual;\r\n\r\n    /// @dev ERC1155.\r\n    function burn(address from, uint256 id, uint256 amount) public virtual;\r\n}\r\n\r\n/// @notice Contract helper for fetching token (ERC20/721/1155) balances and supply.\r\nabstract contract TokenSupply {\r\n    /// @dev ERC20/721.\r\n\r\n    function balanceOf(address account) public view virtual returns (uint256);\r\n\r\n    function totalSupply() public view virtual returns (uint256);\r\n\r\n    /// @dev ERC721.\r\n\r\n    function ownerOf(uint256 id) public view virtual returns (address);\r\n\r\n    /// @dev ERC1155.\r\n\r\n    function balanceOf(\r\n        address account,\r\n        uint256 id\r\n    ) public view virtual returns (uint256);\r\n\r\n    function totalSupply(uint256 id) public view virtual returns (uint256);\r\n}\r\n\r\n/// @dev Free functions.\r\n\r\n/// @notice Arithmetic free function collection with operations for fixed-point numbers.\r\n/// @author Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/FixedPointMath.sol)\r\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\r\n\r\n/// @dev The multiply-divide operation failed, either due to a\r\n/// multiplication overflow, or a division by a zero.\r\nerror MulDivFailed();\r\n\r\n/// @dev The maximum possible integer.\r\nuint256 constant MAX_UINT256 = 2**256 - 1;\r\n\r\n/// @dev Returns `floor(x * y / denominator)`.\r\n/// Reverts if `x * y` overflows, or `denominator` is zero.\r\nfunction mulDivDown(\r\n    uint256 x,\r\n    uint256 y,\r\n    uint256 denominator\r\n) pure returns (uint256 z) {\r\n    assembly {\r\n        // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\r\n        if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\r\n            // Store the function selector of `MulDivFailed()`.\r\n            mstore(0x00, 0xad251c27)\r\n            // Revert with (offset, size).\r\n            revert(0x1c, 0x04)\r\n        }\r\n\r\n        // Divide x * y by the denominator.\r\n        z := div(mul(x, y), denominator)\r\n    }\r\n}\r\n\r\n/// @notice Safe ETH and ERC20 free function transfer collection that gracefully handles missing return values.\r\n/// @author Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/SafeTransfer.sol)\r\n/// @author Modified from Zolidity (https://github.com/z0r0z/zolidity/blob/main/src/utils/SafeTransfer.sol)\r\n\r\n/// @dev The ERC20 `transferFrom` has failed.\r\nerror TransferFromFailed();\r\n\r\n/// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\r\n/// Reverts upon failure.\r\n///\r\n/// The `from` account must have at least `amount` approved for\r\n/// the current contract to manage.\r\nfunction safeTransferFrom(\r\n    address token,\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n) {\r\n    assembly {\r\n        // We'll write our calldata to this slot below, but restore it later.\r\n        let memPointer := mload(0x40)\r\n\r\n        // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n        mstore(0x00, 0x23b872dd)\r\n        mstore(0x20, from) // Append the \"from\" argument.\r\n        mstore(0x40, to) // Append the \"to\" argument.\r\n        mstore(0x60, amount) // Append the \"amount\" argument.\r\n\r\n        if iszero(\r\n            and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(eq(mload(0x00), 1), iszero(returndatasize())),\r\n                // We use 0x64 because that's the total length of our calldata (0x04 + 0x20 * 3)\r\n                // Counterintuitively, this call() must be positioned after the or() in the\r\n                // surrounding and() because and() evaluates its arguments from right to left.\r\n                call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\r\n            )\r\n        ) {\r\n            // Store the function selector of `TransferFromFailed()`.\r\n            mstore(0x00, 0x7939f424)\r\n            // Revert with (offset, size).\r\n            revert(0x1c, 0x04)\r\n        }\r\n\r\n        mstore(0x60, 0) // Restore the zero slot to zero.\r\n        mstore(0x40, memPointer) // Restore the memPointer.\r\n    }\r\n}\r\n\r\n/// @dev Contracts.\r\n\r\n/// @notice Contract helper for any EIP-2612, EIP-4494 or Dai-style token permit.\r\n/// @author Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/Permit.sol)\r\nabstract contract Permit {\r\n    /// @dev ERC20.\r\n\r\n    /// @notice Permit to spend tokens for EIP-2612 permit signatures.\r\n    /// @param owner The address of the token holder.\r\n    /// @param spender The address of the token permit holder.\r\n    /// @param value The amount permitted to spend.\r\n    /// @param deadline The unix timestamp before which permit must be spent.\r\n    /// @param v Must produce valid secp256k1 signature from the `owner` along with `r` and `s`.\r\n    /// @param r Must produce valid secp256k1 signature from the `owner` along with `v` and `s`.\r\n    /// @param s Must produce valid secp256k1 signature from the `owner` along with `r` and `v`.\r\n    /// @dev This permit will work for certain ERC721 supporting EIP-2612-style permits,\r\n    /// such as Uniswap V3 position and Solbase NFTs.\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual;\r\n\r\n    /// @notice Permit to spend tokens for permit signatures that have the `allowed` parameter.\r\n    /// @param owner The address of the token holder.\r\n    /// @param spender The address of the token permit holder.\r\n    /// @param nonce The current nonce of the `owner`.\r\n    /// @param deadline The unix timestamp before which permit must be spent.\r\n    /// @param allowed If true, `spender` will be given permission to spend `owner`'s tokens.\r\n    /// @param v Must produce valid secp256k1 signature from the `owner` along with `r` and `s`.\r\n    /// @param r Must produce valid secp256k1 signature from the `owner` along with `v` and `s`.\r\n    /// @param s Must produce valid secp256k1 signature from the `owner` along with `r` and `v`.\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 nonce,\r\n        uint256 deadline,\r\n        bool allowed,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual;\r\n\r\n    /// @dev ERC721.\r\n\r\n    /// @notice Permit to spend specific NFT `tokenId` for EIP-2612-style permit signatures.\r\n    /// @param spender The address of the token permit holder.\r\n    /// @param tokenId The ID of the token that is being approved for permit.\r\n    /// @param deadline The unix timestamp before which permit must be spent.\r\n    /// @param v Must produce valid secp256k1 signature from the `owner` along with `r` and `s`.\r\n    /// @param r Must produce valid secp256k1 signature from the `owner` along with `v` and `s`.\r\n    /// @param s Must produce valid secp256k1 signature from the `owner` along with `r` and `v`.\r\n    /// @dev Modified from Uniswap\r\n    /// (https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/IERC721Permit.sol).\r\n    function permit(\r\n        address spender,\r\n        uint256 tokenId,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual;\r\n\r\n    /// @notice Permit to spend specific NFT `tokenId` for EIP-4494 permit signatures.\r\n    /// @param spender The address of the token permit holder.\r\n    /// @param tokenId The ID of the token that is being approved for permit.\r\n    /// @param deadline The unix timestamp before which permit must be spent.\r\n    /// @param sig A traditional or EIP-2098 signature.\r\n    function permit(\r\n        address spender,\r\n        uint256 tokenId,\r\n        uint256 deadline,\r\n        bytes calldata sig\r\n    ) public virtual;\r\n\r\n    /// @dev ERC1155.\r\n\r\n    /// @notice Permit to spend multitoken IDs for EIP-2612-style permit signatures.\r\n    /// @param owner The address of the token holder.\r\n    /// @param operator The address of the token permit holder.\r\n    /// @param approved If true, `operator` will be given permission to spend `owner`'s tokens.\r\n    /// @param deadline The unix timestamp before which permit must be spent.\r\n    /// @param v Must produce valid secp256k1 signature from the `owner` along with `r` and `s`.\r\n    /// @param r Must produce valid secp256k1 signature from the `owner` along with `v` and `s`.\r\n    /// @param s Must produce valid secp256k1 signature from the `owner` along with `r` and `v`.\r\n    function permit(\r\n        address owner,\r\n        address operator,\r\n        bool approved,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual;\r\n}\r\n\r\n/// @notice Self helper for any EIP-2612, EIP-4494 or Dai-style token permit.\r\n/// @author Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/SelfPermit.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/SelfPermit.sol)\r\n/// @dev These functions are expected to be embedded in multicall to allow EOAs to approve a contract and call a function\r\n/// that requires an approval in a single transaction.\r\nabstract contract SelfPermit {\r\n    /// @dev ERC20.\r\n\r\n    /// @notice Permits this contract to spend a given EIP-2612 `token` from `msg.sender`.\r\n    /// @dev The `owner` is always `msg.sender` and the `spender` is always `address(this)`.\r\n    /// @param token The address of the asset spent.\r\n    /// @param value The amount permitted to spend.\r\n    /// @param deadline The unix timestamp before which permit must be spent.\r\n    /// @param v Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `s`.\r\n    /// @param r Must produce valid secp256k1 signature from the `msg.sender` along with `v` and `s`.\r\n    /// @param s Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `v`.\r\n    function selfPermit(\r\n        Permit token,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        token.permit(msg.sender, address(this), value, deadline, v, r, s);\r\n    }\r\n\r\n    /// @notice Permits this contract to spend a given Dai-style `token` from `msg.sender`.\r\n    /// @dev The `owner` is always `msg.sender` and the `spender` is always `address(this)`.\r\n    /// @param token The address of the asset spent.\r\n    /// @param nonce The current nonce of the `owner`.\r\n    /// @param deadline The unix timestamp before which permit must be spent.\r\n    /// @param v Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `s`.\r\n    /// @param r Must produce valid secp256k1 signature from the `msg.sender` along with `v` and `s`.\r\n    /// @param s Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `v`.\r\n    function selfPermitAllowed(\r\n        Permit token,\r\n        uint256 nonce,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        token.permit(msg.sender, address(this), nonce, deadline, true, v, r, s);\r\n    }\r\n\r\n    /// @dev ERC721.\r\n\r\n    /// @notice Permits this contract to spend a given EIP-2612-style NFT `tokenID` from `msg.sender`.\r\n    /// @dev The `spender` is always `address(this)`.\r\n    /// @param token The address of the asset spent.\r\n    /// @param tokenId The ID of the token that is being approved for permit.\r\n    /// @param deadline The unix timestamp before which permit must be spent.\r\n    /// @param v Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `s`.\r\n    /// @param r Must produce valid secp256k1 signature from the `msg.sender` along with `v` and `s`.\r\n    /// @param s Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `v`.\r\n    function selfPermit721(\r\n        Permit token,\r\n        uint256 tokenId,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        token.permit(address(this), tokenId, deadline, v, r, s);\r\n    }\r\n\r\n    /// @notice Permits this contract to spend a given EIP-4494 NFT `tokenID`.\r\n    /// @dev The `spender` is always `address(this)`.\r\n    /// @param token The address of the asset spent.\r\n    /// @param tokenId The ID of the token that is being approved for permit.\r\n    /// @param deadline The unix timestamp before which permit must be spent.\r\n    /// @param sig A traditional or EIP-2098 signature.\r\n    function selfPermit721(\r\n        Permit token,\r\n        uint256 tokenId,\r\n        uint256 deadline,\r\n        bytes calldata sig\r\n    ) public virtual {\r\n        token.permit(address(this), tokenId, deadline, sig);\r\n    }\r\n\r\n    /// @dev ERC1155.\r\n\r\n    /// @notice Permits this contract to spend a given EIP-2612-style multitoken.\r\n    /// @dev The `owner` is always `msg.sender` and the `operator` is always `address(this)`.\r\n    /// @param token The address of the asset spent.\r\n    /// @param deadline The unix timestamp before which permit must be spent.\r\n    /// @param v Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `s`.\r\n    /// @param r Must produce valid secp256k1 signature from the `msg.sender` along with `v` and `s`.\r\n    /// @param s Must produce valid secp256k1 signature from the `msg.sender` along with `r` and `v`.\r\n    function selfPermit1155(\r\n        Permit token,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        token.permit(msg.sender, address(this), true, deadline, v, r, s);\r\n    }\r\n}\r\n\r\n/// @notice Contract that enables a single call to call multiple methods on itself.\r\n/// @author Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/Multicallable.sol)\r\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Multicallable.sol)\r\n/// @dev WARNING!\r\n/// Multicallable is NOT SAFE for use in contracts with checks / requires on `msg.value`\r\n/// (e.g. in NFT minting / auction contracts) without a suitable nonce mechanism.\r\n/// It WILL open up your contract to double-spend vulnerabilities / exploits.\r\n/// See: (https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/)\r\nabstract contract Multicallable {\r\n    /// @dev Apply `DELEGATECALL` with the current contract to each calldata in `data`,\r\n    /// and store the `abi.encode` formatted results of each `DELEGATECALL` into `results`.\r\n    /// If any of the `DELEGATECALL`s reverts, the entire transaction is reverted,\r\n    /// and the error is bubbled up.\r\n    function multicall(bytes[] calldata data) public payable returns (bytes[] memory results) {\r\n        assembly {\r\n            if data.length {\r\n                results := mload(0x40) // Point `results` to start of free memory.\r\n                mstore(results, data.length) // Store `data.length` into `results`.\r\n                results := add(results, 0x20)\r\n\r\n                // `shl` 5 is equivalent to multiplying by 0x20.\r\n                let end := shl(5, data.length)\r\n                // Copy the offsets from calldata into memory.\r\n                calldatacopy(results, data.offset, end)\r\n                // Pointer to the top of the memory (i.e. start of the free memory).\r\n                let memPtr := add(results, end)\r\n                end := add(results, end)\r\n\r\n                // prettier-ignore\r\n                for {} 1 {} {\r\n                    // The offset of the current bytes in the calldata.\r\n                    let o := add(data.offset, mload(results))\r\n                    // Copy the current bytes from calldata to the memory.\r\n                    calldatacopy(\r\n                        memPtr,\r\n                        add(o, 0x20), // The offset of the current bytes' bytes.\r\n                        calldataload(o) // The length of the current bytes.\r\n                    )\r\n                    if iszero(delegatecall(gas(), address(), memPtr, calldataload(o), 0x00, 0x00)) {\r\n                        // Bubble up the revert if the delegatecall reverts.\r\n                        returndatacopy(0x00, 0x00, returndatasize())\r\n                        revert(0x00, returndatasize())\r\n                    }\r\n                    // Append the current `memPtr` into `results`.\r\n                    mstore(results, memPtr)\r\n                    results := add(results, 0x20)\r\n                    // Append the `returndatasize()`, and the return data.\r\n                    mstore(memPtr, returndatasize())\r\n                    returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\r\n                    // Advance the `memPtr` by `returndatasize() + 0x20`,\r\n                    // rounded up to the next multiple of 32.\r\n                    memPtr := and(add(add(memPtr, returndatasize()), 0x3f), 0xffffffffffffffe0)\r\n                    // prettier-ignore\r\n                    if iszero(lt(results, end)) { break }\r\n                }\r\n                // Restore `results` and allocate memory for it.\r\n                results := mload(0x40)\r\n                mstore(0x40, memPtr)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Gas-optimized reentrancy protection for smart contracts.\r\n/// @author Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/ReentrancyGuard.sol)\r\nabstract contract ReentrancyGuard {\r\n    error Reentrancy();\r\n\r\n    uint256 private locked = 1;\r\n\r\n    modifier nonReentrant() virtual {\r\n        if (locked == 2) revert Reentrancy();\r\n\r\n        locked = 2;\r\n\r\n        _;\r\n\r\n        locked = 1;\r\n    }\r\n}\r\n\r\n/// @title Rage Router\r\n/// @notice Fair share ragequit redemption for any token burn.\r\n\r\nenum Standard {\r\n    ERC20,\r\n    ERC721,\r\n    ERC1155\r\n}\r\n\r\nstruct Redemption {\r\n    address burner;\r\n    address token;\r\n    uint88 start;\r\n    Standard std;\r\n    uint256 id;\r\n}\r\n\r\nstruct Withdrawal {\r\n    address asset;\r\n    Standard std;\r\n    uint256 id;\r\n}\r\n\r\n/// @author z0r0z.eth\r\n/// @custom:coauthor ameen.eth\r\n/// @custom:coauthor mick.eth\r\ncontract RageRouter is SelfPermit, Multicallable, ReentrancyGuard {\r\n    /// -----------------------------------------------------------------------\r\n    /// Events\r\n    /// -----------------------------------------------------------------------\r\n\r\n    event RagequitSet(\r\n        address indexed treasury,\r\n        address indexed burner,\r\n        address indexed token,\r\n        Standard std,\r\n        uint256 id,\r\n        uint256 start\r\n    );\r\n\r\n    event Ragequit(\r\n        address indexed redeemer,\r\n        address indexed treasury,\r\n        Withdrawal[] withdrawals,\r\n        uint256 amount\r\n    );\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Custom Errors\r\n    /// -----------------------------------------------------------------------\r\n\r\n    error NotStarted();\r\n\r\n    error InvalidAssetOrder();\r\n\r\n    error NotOwner();\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Ragequit Storage\r\n    /// -----------------------------------------------------------------------\r\n\r\n    mapping(address => Redemption) public redemptions;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Configuration Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @dev Gas savings.\r\n    constructor() payable {}\r\n\r\n    /// @notice Configuration for ragequittable treasuries.\r\n    /// @param burner The redemption sink for burnt `token`.\r\n    /// @param token The redemption `token` that will be burnt.\r\n    /// @param std The EIP interface for the redemption `token`.\r\n    /// @param id The ID to set redemption configuration against.\r\n    /// @param start The unix timestamp at which redemption starts.\r\n    /// @dev The caller of this function will be set as the `treasury`.\r\n    /// If `burner` is zero address, ragequit will trigger `token` burn.\r\n    /// Otherwise, the user will have `token` pulled to `burner` and supply\r\n    /// will be calculated with respect to `burner` balance before ragequit.\r\n    /// `id` will be used if the `token` follows ERC1155 std. Kali slays Moloch.\r\n    function setRagequit(\r\n        address burner,\r\n        address token,\r\n        Standard std,\r\n        uint256 id,\r\n        uint256 start\r\n    ) public payable virtual {\r\n        redemptions[msg.sender] = Redemption({\r\n            burner: burner,\r\n            token: token,\r\n            start: uint88(start),\r\n            std: std,\r\n            id: id\r\n        });\r\n\r\n        emit RagequitSet(msg.sender, burner, token, std, id, start);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Ragequit Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice Allows ragequit redemption against `treasury`.\r\n    /// @param treasury The vault holding `assets` for redemption.\r\n    /// @param withdrawals Withdrawal instructions for `treasury`.\r\n    /// @param quitAmount The amount of redemption tokens to be burned.\r\n    /// @dev `quitAmount` acts as the token ID where redemption is ERC721.\r\n    function ragequit(\r\n        address treasury,\r\n        Withdrawal[] calldata withdrawals,\r\n        uint256 quitAmount\r\n    ) public payable virtual nonReentrant {\r\n        Redemption storage red = redemptions[treasury];\r\n\r\n        if (block.timestamp < red.start) revert NotStarted();\r\n\r\n        emit Ragequit(msg.sender, treasury, withdrawals, quitAmount);\r\n\r\n        uint256 supply;\r\n\r\n        // Branch on `Standard` of `token` burned in redemption\r\n        // and whether `burner` is zero address.\r\n        if (red.std == Standard.ERC20) {\r\n            if (red.burner == address(0)) {\r\n                supply = TokenSupply(red.token).totalSupply();\r\n\r\n                TokenBurn(red.token).burnFrom(msg.sender, quitAmount);\r\n            } else {\r\n                // The `burner` balance cannot exceed total supply.\r\n                unchecked {\r\n                    supply =\r\n                        TokenSupply(red.token).totalSupply() -\r\n                        TokenSupply(red.token).balanceOf(red.burner);\r\n                }\r\n\r\n                safeTransferFrom(red.token, msg.sender, red.burner, quitAmount);\r\n            }\r\n        } else if (red.std == Standard.ERC721) {\r\n            // Use `quitAmount` as `id`.\r\n            if (msg.sender != TokenSupply(red.token).ownerOf(quitAmount))\r\n                revert NotOwner();\r\n\r\n            if (red.burner == address(0)) {\r\n                supply = TokenSupply(red.token).totalSupply();\r\n\r\n                TokenBurn(red.token).burn(quitAmount);\r\n            } else {\r\n                // The `burner` balance cannot exceed total supply.\r\n                unchecked {\r\n                    supply =\r\n                        TokenSupply(red.token).totalSupply() -\r\n                        TokenSupply(red.token).balanceOf(red.burner);\r\n                }\r\n\r\n                safeTransferFrom(red.token, msg.sender, red.burner, quitAmount);\r\n            }\r\n\r\n            // Overwrite `quitAmount` `id` to 1 for single NFT burn.\r\n            quitAmount = 1;\r\n        } else {\r\n            if (red.burner == address(0)) {\r\n                supply = TokenSupply(red.token).totalSupply(red.id);\r\n\r\n                TokenBurn(red.token).burn(msg.sender, red.id, quitAmount);\r\n            } else {\r\n                // The `burner` balance cannot exceed total supply.\r\n                unchecked {\r\n                    supply =\r\n                        TokenSupply(red.token).totalSupply(red.id) -\r\n                        TokenSupply(red.token).balanceOf(red.burner, red.id);\r\n                }\r\n\r\n                ERC1155STF(red.token).safeTransferFrom(\r\n                    msg.sender,\r\n                    red.burner,\r\n                    red.id,\r\n                    quitAmount,\r\n                    \"\"\r\n                );\r\n            }\r\n        }\r\n\r\n        address prevAddr;\r\n        Withdrawal calldata draw;\r\n\r\n        for (uint256 i; i < withdrawals.length; ) {\r\n            draw = withdrawals[i];\r\n\r\n            // Prevent null and duplicate `asset`.\r\n            if (prevAddr >= draw.asset) revert InvalidAssetOrder();\r\n\r\n            prevAddr = draw.asset;\r\n\r\n            // Calculate fair share of given `asset` for `quitAmount`.\r\n            uint256 amountToRedeem = mulDivDown(\r\n                quitAmount,\r\n                draw.std == Standard.ERC20\r\n                    ? TokenSupply(draw.asset).balanceOf(treasury)\r\n                    : TokenSupply(draw.asset).balanceOf(treasury, draw.id),\r\n                supply\r\n            );\r\n\r\n            // Transfer fair share from `treasury` to caller.\r\n            if (amountToRedeem != 0) {\r\n                draw.std == Standard.ERC20\r\n                    ? safeTransferFrom(\r\n                        draw.asset,\r\n                        treasury,\r\n                        msg.sender,\r\n                        amountToRedeem\r\n                    )\r\n                    : ERC1155STF(draw.asset).safeTransferFrom(\r\n                        treasury,\r\n                        msg.sender,\r\n                        draw.id,\r\n                        amountToRedeem,\r\n                        \"\"\r\n                    );\r\n            }\r\n\r\n            // An array can't have a total length\r\n            // larger than the max uint256 value.\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidAssetOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"enum Standard\",\"name\":\"std\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Withdrawal[]\",\"name\":\"withdrawals\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Ragequit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum Standard\",\"name\":\"std\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"RagequitSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"enum Standard\",\"name\":\"std\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct Withdrawal[]\",\"name\":\"withdrawals\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"quitAmount\",\"type\":\"uint256\"}],\"name\":\"ragequit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"redemptions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"start\",\"type\":\"uint88\"},{\"internalType\":\"enum Standard\",\"name\":\"std\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Permit\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Permit\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermit1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Permit\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"selfPermit721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Permit\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermit721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Permit\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermitAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"enum Standard\",\"name\":\"std\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"setRagequit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"RageRouter","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"9999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3e43a9721804c2e990319556e7e136ca4007599a0da30dbcc8417f68273c8c0c"}]