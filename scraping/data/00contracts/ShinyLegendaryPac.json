[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract Governable {\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    address public governor;\r\n    bool public paused = false;\r\n\r\n    constructor() public {\r\n        governor = msg.sender;\r\n    }\r\n\r\n    function setGovernor(address _gov) public onlyGovernor {\r\n        governor = _gov;\r\n    }\r\n\r\n    modifier onlyGovernor {\r\n        require(msg.sender == governor);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyGovernor whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyGovernor whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n\r\n}\r\n\r\ncontract CardBase is Governable {\r\n\r\n\r\n    struct Card {\r\n        uint16 proto;\r\n        uint16 purity;\r\n    }\r\n\r\n    function getCard(uint id) public view returns (uint16 proto, uint16 purity) {\r\n        Card memory card = cards[id];\r\n        return (card.proto, card.purity);\r\n    }\r\n\r\n    function getShine(uint16 purity) public pure returns (uint8) {\r\n        return uint8(purity / 1000);\r\n    }\r\n\r\n    Card[] public cards;\r\n    \r\n}\r\n\r\ncontract CardProto is CardBase {\r\n\r\n    event NewProtoCard(\r\n        uint16 id, uint8 season, uint8 god, \r\n        Rarity rarity, uint8 mana, uint8 attack, \r\n        uint8 health, uint8 cardType, uint8 tribe, bool packable\r\n    );\r\n\r\n    struct Limit {\r\n        uint64 limit;\r\n        bool exists;\r\n    }\r\n\r\n    // limits for mythic cards\r\n    mapping(uint16 => Limit) public limits;\r\n\r\n    // can only set limits once\r\n    function setLimit(uint16 id, uint64 limit) public onlyGovernor {\r\n        Limit memory l = limits[id];\r\n        require(!l.exists);\r\n        limits[id] = Limit({\r\n            limit: limit,\r\n            exists: true\r\n        });\r\n    }\r\n\r\n    function getLimit(uint16 id) public view returns (uint64 limit, bool set) {\r\n        Limit memory l = limits[id];\r\n        return (l.limit, l.exists);\r\n    }\r\n\r\n    // could make these arrays to save gas\r\n    // not really necessary - will be update a very limited no of times\r\n    mapping(uint8 => bool) public seasonTradable;\r\n    mapping(uint8 => bool) public seasonTradabilityLocked;\r\n    uint8 public currentSeason;\r\n\r\n    function makeTradeable(uint8 season) public onlyGovernor {\r\n        seasonTradable[season] = true;\r\n    }\r\n\r\n    function makeUntradable(uint8 season) public onlyGovernor {\r\n        require(!seasonTradabilityLocked[season]);\r\n        seasonTradable[season] = false;\r\n    }\r\n\r\n    function makePermanantlyTradable(uint8 season) public onlyGovernor {\r\n        require(seasonTradable[season]);\r\n        seasonTradabilityLocked[season] = true;\r\n    }\r\n\r\n    function isTradable(uint16 proto) public view returns (bool) {\r\n        return seasonTradable[protos[proto].season];\r\n    }\r\n\r\n    function nextSeason() public onlyGovernor {\r\n        //Seasons shouldn't go to 0 if there is more than the uint8 should hold, the governor should know this ¯\\_(ツ)_/¯ -M\r\n        require(currentSeason <= 255); \r\n\r\n        currentSeason++;\r\n        mythic.length = 0;\r\n        legendary.length = 0;\r\n        epic.length = 0;\r\n        rare.length = 0;\r\n        common.length = 0;\r\n    }\r\n\r\n    enum Rarity {\r\n        Common,\r\n        Rare,\r\n        Epic,\r\n        Legendary, \r\n        Mythic\r\n    }\r\n\r\n    uint8 constant SPELL = 1;\r\n    uint8 constant MINION = 2;\r\n    uint8 constant WEAPON = 3;\r\n    uint8 constant HERO = 4;\r\n\r\n    struct ProtoCard {\r\n        bool exists;\r\n        uint8 god;\r\n        uint8 season;\r\n        uint8 cardType;\r\n        Rarity rarity;\r\n        uint8 mana;\r\n        uint8 attack;\r\n        uint8 health;\r\n        uint8 tribe;\r\n    }\r\n\r\n    // there is a particular design decision driving this:\r\n    // need to be able to iterate over mythics only for card generation\r\n    // don't store 5 different arrays: have to use 2 ids\r\n    // better to bear this cost (2 bytes per proto card)\r\n    // rather than 1 byte per instance\r\n\r\n    uint16 public protoCount;\r\n    \r\n    mapping(uint16 => ProtoCard) protos;\r\n\r\n    uint16[] public mythic;\r\n    uint16[] public legendary;\r\n    uint16[] public epic;\r\n    uint16[] public rare;\r\n    uint16[] public common;\r\n\r\n    function addProtos(\r\n        uint16[] externalIDs, uint8[] gods, Rarity[] rarities, uint8[] manas, uint8[] attacks, uint8[] healths, uint8[] cardTypes, uint8[] tribes, bool[] packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        for (uint i = 0; i < externalIDs.length; i++) {\r\n\r\n            ProtoCard memory card = ProtoCard({\r\n                exists: true,\r\n                god: gods[i],\r\n                season: currentSeason,\r\n                cardType: cardTypes[i],\r\n                rarity: rarities[i],\r\n                mana: manas[i],\r\n                attack: attacks[i],\r\n                health: healths[i],\r\n                tribe: tribes[i]\r\n            });\r\n\r\n            _addProto(externalIDs[i], card, packable[i]);\r\n        }\r\n        \r\n    }\r\n\r\n    function addProto(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 cardType, uint8 tribe, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: cardType,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addWeapon(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 durability, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: WEAPON,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: durability,\r\n            tribe: 0\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addSpell(uint16 externalID, uint8 god, Rarity rarity, uint8 mana, bool packable) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: SPELL,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: 0,\r\n            health: 0,\r\n            tribe: 0\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addMinion(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: MINION,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function _addProto(uint16 externalID, ProtoCard memory card, bool packable) internal {\r\n\r\n        require(!protos[externalID].exists);\r\n\r\n        card.exists = true;\r\n\r\n        protos[externalID] = card;\r\n\r\n        protoCount++;\r\n\r\n        emit NewProtoCard(\r\n            externalID, currentSeason, card.god, \r\n            card.rarity, card.mana, card.attack, \r\n            card.health, card.cardType, card.tribe, packable\r\n        );\r\n\r\n        if (packable) {\r\n            Rarity rarity = card.rarity;\r\n            if (rarity == Rarity.Common) {\r\n                common.push(externalID);\r\n            } else if (rarity == Rarity.Rare) {\r\n                rare.push(externalID);\r\n            } else if (rarity == Rarity.Epic) {\r\n                epic.push(externalID);\r\n            } else if (rarity == Rarity.Legendary) {\r\n                legendary.push(externalID);\r\n            } else if (rarity == Rarity.Mythic) {\r\n                mythic.push(externalID);\r\n            } else {\r\n                require(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getProto(uint16 id) public view returns(\r\n        bool exists, uint8 god, uint8 season, uint8 cardType, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe\r\n    ) {\r\n        ProtoCard memory proto = protos[id];\r\n        return (\r\n            proto.exists,\r\n            proto.god,\r\n            proto.season,\r\n            proto.cardType,\r\n            proto.rarity,\r\n            proto.mana,\r\n            proto.attack,\r\n            proto.health,\r\n            proto.tribe\r\n        );\r\n    }\r\n\r\n    function getRandomCard(Rarity rarity, uint16 random) public view returns (uint16) {\r\n        // modulo bias is fine - creates rarity tiers etc\r\n        // will obviously revert is there are no cards of that type: this is expected - should never happen\r\n        if (rarity == Rarity.Common) {\r\n            return common[random % common.length];\r\n        } else if (rarity == Rarity.Rare) {\r\n            return rare[random % rare.length];\r\n        } else if (rarity == Rarity.Epic) {\r\n            return epic[random % epic.length];\r\n        } else if (rarity == Rarity.Legendary) {\r\n            return legendary[random % legendary.length];\r\n        } else if (rarity == Rarity.Mythic) {\r\n            // make sure a mythic is available\r\n            uint16 id;\r\n            uint64 limit;\r\n            bool set;\r\n            for (uint i = 0; i < mythic.length; i++) {\r\n                id = mythic[(random + i) % mythic.length];\r\n                (limit, set) = getLimit(id);\r\n                if (set && limit > 0){\r\n                    return id;\r\n                }\r\n            }\r\n            // if not, they get a legendary :(\r\n            return legendary[random % legendary.length];\r\n        }\r\n        require(false);\r\n        return 0;\r\n    }\r\n\r\n    // can never adjust tradable cards\r\n    // each season gets a 'balancing beta'\r\n    // totally immutable: season, rarity\r\n    function replaceProto(\r\n        uint16 index, uint8 god, uint8 cardType, uint8 mana, uint8 attack, uint8 health, uint8 tribe\r\n    ) public onlyGovernor {\r\n        ProtoCard memory pc = protos[index];\r\n        require(!seasonTradable[pc.season]);\r\n        protos[index] = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: pc.season,\r\n            cardType: cardType,\r\n            rarity: pc.rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n    }\r\n\r\n}\r\n\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs    owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract ERC721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public payable;\r\n    function transfer(address _to, uint256 _tokenId) public payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public payable;\r\n    function approve(address _to, uint256 _tokenId) public payable;\r\n    function setApprovalForAll(address _to, bool _approved) public;\r\n    function getApproved(uint256 _tokenId) public view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n}\r\n\r\ncontract NFT is ERC721, ERC165, ERC721Metadata, ERC721Enumerable {}\r\n\r\ncontract CardOwnership is NFT, CardProto {\r\n\r\n    // doing this strategy doesn't save gas\r\n    // even setting the length to the max and filling in\r\n    // unfortunately - maybe if we stop it boundschecking\r\n    // address[] owners;\r\n    mapping(uint => address) owners;\r\n    mapping(uint => address) approved;\r\n    // support multiple operators\r\n    mapping(address => mapping(address => bool)) operators;\r\n\r\n    // save space, limits us to 2^40 tokens (>1t)\r\n    mapping(address => uint40[]) public ownedTokens;\r\n\r\n    mapping(uint => string) uris;\r\n\r\n    // save space, limits us to 2^24 tokens per user (~17m)\r\n    uint24[] indices;\r\n\r\n    uint public burnCount;\r\n\r\n    /**\r\n    * @return the name of this token\r\n    */\r\n    function name() public view returns (string) {\r\n        return \"Gods Unchained\";\r\n    }\r\n\r\n    /**\r\n    * @return the symbol of this token\r\n    */  \r\n    function symbol() public view returns (string) {\r\n        return \"GODS\";\r\n    }\r\n\r\n    /**\r\n    * @return the total number of cards in circulation\r\n    */\r\n    function totalSupply() public view returns (uint) {\r\n        return cards.length - burnCount;\r\n    }\r\n\r\n    /**\r\n    * @param to : the address to which the card will be transferred\r\n    * @param id : the id of the card to be transferred\r\n    */\r\n    function transfer(address to, uint id) public payable {\r\n        require(owns(msg.sender, id));\r\n        require(isTradable(cards[id].proto));\r\n        require(to != address(0));\r\n        _transfer(msg.sender, to, id);\r\n    }\r\n\r\n    /**\r\n    * internal transfer function which skips checks - use carefully\r\n    * @param from : the address from which the card will be transferred\r\n    * @param to : the address to which the card will be transferred\r\n    * @param id : the id of the card to be transferred\r\n    */\r\n    function _transfer(address from, address to, uint id) internal {\r\n        approved[id] = address(0);\r\n        owners[id] = to;\r\n        _addToken(to, id);\r\n        _removeToken(from, id);\r\n        emit Transfer(from, to, id);\r\n    }\r\n\r\n    /**\r\n    * initial internal transfer function which skips checks and saves gas - use carefully\r\n    * @param to : the address to which the card will be transferred\r\n    * @param id : the id of the card to be transferred\r\n    */\r\n    function _create(address to, uint id) internal {\r\n        owners[id] = to;\r\n        _addToken(to, id);\r\n        emit Transfer(address(0), to, id);\r\n    }\r\n\r\n    /**\r\n    * @param to : the address to which the cards will be transferred\r\n    * @param ids : the ids of the cards to be transferred\r\n    */\r\n    function transferAll(address to, uint[] ids) public payable {\r\n        for (uint i = 0; i < ids.length; i++) {\r\n            transfer(to, ids[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @param proposed : the claimed owner of the cards\r\n    * @param ids : the ids of the cards to check\r\n    * @return whether proposed owns all of the cards \r\n    */\r\n    function ownsAll(address proposed, uint[] ids) public view returns (bool) {\r\n        for (uint i = 0; i < ids.length; i++) {\r\n            if (!owns(proposed, ids[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @param proposed : the claimed owner of the card\r\n    * @param id : the id of the card to check\r\n    * @return whether proposed owns the card\r\n    */\r\n    function owns(address proposed, uint id) public view returns (bool) {\r\n        return ownerOf(id) == proposed;\r\n    }\r\n\r\n    /**\r\n    * @param id : the id of the card\r\n    * @return the address of the owner of the card\r\n    */\r\n    function ownerOf(uint id) public view returns (address) {\r\n        return owners[id];\r\n    }\r\n\r\n    /**\r\n    * @param id : the index of the token to burn\r\n    */\r\n    function burn(uint id) public {\r\n        // require(isTradable(cards[id].proto));\r\n        require(owns(msg.sender, id));\r\n        burnCount++;\r\n        // use the internal transfer function as the external\r\n        // has a guard to prevent transfers to 0x0\r\n        _transfer(msg.sender, address(0), id);\r\n    }\r\n\r\n    /**\r\n    * @param ids : the indices of the tokens to burn\r\n    */\r\n    function burnAll(uint[] ids) public {\r\n        for (uint i = 0; i < ids.length; i++){\r\n            burn(ids[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @param to : the address to approve for transfer\r\n    * @param id : the index of the card to be approved\r\n    */\r\n    function approve(address to, uint id) public payable {\r\n        require(owns(msg.sender, id));\r\n        require(isTradable(cards[id].proto));\r\n        approved[id] = to;\r\n        emit Approval(msg.sender, to, id);\r\n    }\r\n\r\n    /**\r\n    * @param to : the address to approve for transfer\r\n    * @param ids : the indices of the cards to be approved\r\n    */\r\n    function approveAll(address to, uint[] ids) public payable {\r\n        for (uint i = 0; i < ids.length; i++) {\r\n            approve(to, ids[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @param id : the index of the token to check\r\n    * @return the address approved to transfer this token\r\n    */\r\n    function getApproved(uint id) public view returns(address) {\r\n        return approved[id];\r\n    }\r\n\r\n    /**\r\n    * @param owner : the address to check\r\n    * @return the number of tokens controlled by owner\r\n    */\r\n    function balanceOf(address owner) public view returns (uint) {\r\n        return ownedTokens[owner].length;\r\n    }\r\n\r\n    /**\r\n    * @param id : the index of the proposed token\r\n    * @return whether the token is owned by a non-zero address\r\n    */\r\n    function exists(uint id) public view returns (bool) {\r\n        return owners[id] != address(0);\r\n    }\r\n\r\n    /**\r\n    * @param to : the address to which the token should be transferred\r\n    * @param id : the index of the token to transfer\r\n    */\r\n    function transferFrom(address from, address to, uint id) public payable {\r\n        \r\n        require(to != address(0));\r\n        require(to != address(this));\r\n\r\n        // TODO: why is this necessary\r\n        // if you're approved, why does it matter where it comes from?\r\n        require(ownerOf(id) == from);\r\n\r\n        require(isSenderApprovedFor(id));\r\n\r\n        require(isTradable(cards[id].proto));\r\n\r\n        _transfer(ownerOf(id), to, id);\r\n    }\r\n\r\n    /**\r\n    * @param to : the address to which the tokens should be transferred\r\n    * @param ids : the indices of the tokens to transfer\r\n    */\r\n    function transferAllFrom(address to, uint[] ids) public payable {\r\n        for (uint i = 0; i < ids.length; i++) {\r\n            transferFrom(address(0), to, ids[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the number of cards which have been burned\r\n     */\r\n    function getBurnCount() public view returns (uint) {\r\n        return burnCount;\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return operators[owner][operator];\r\n    }\r\n\r\n    function setApprovalForAll(address to, bool toApprove) public {\r\n        require(to != msg.sender);\r\n        operators[msg.sender][to] = toApprove;\r\n        emit ApprovalForAll(msg.sender, to, toApprove);\r\n    }\r\n\r\n    bytes4 constant magic = bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"));\r\n\r\n    function safeTransferFrom(address from, address to, uint id, bytes data) public payable {\r\n        require(to != address(0));\r\n        transferFrom(from, to, id);\r\n        if (_isContract(to)) {\r\n            bytes4 response = ERC721TokenReceiver(to).onERC721Received.gas(50000)(from, id, data);\r\n            require(response == magic);\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint id) public payable {\r\n        safeTransferFrom(from, to, id, \"\");\r\n    }\r\n\r\n    function _addToken(address to, uint id) private {\r\n        uint pos = ownedTokens[to].push(uint40(id)) - 1;\r\n        indices.push(uint24(pos));\r\n    }\r\n\r\n    function _removeToken(address from, uint id) public payable {\r\n        uint24 index = indices[id];\r\n        uint lastIndex = ownedTokens[from].length - 1;\r\n        uint40 lastId = ownedTokens[from][lastIndex];\r\n\r\n        ownedTokens[from][index] = lastId;\r\n        ownedTokens[from][lastIndex] = 0;\r\n        ownedTokens[from].length--;\r\n    }\r\n\r\n    function isSenderApprovedFor(uint256 id) internal view returns (bool) {\r\n        return owns(msg.sender, id) || getApproved(id) == msg.sender || isApprovedForAll(ownerOf(id), msg.sender);\r\n    }\r\n\r\n    function _isContract(address test) internal view returns (bool) {\r\n        uint size; \r\n        assembly {\r\n            size := extcodesize(test)\r\n        }\r\n        return (size > 0);\r\n    }\r\n\r\n    function tokenURI(uint id) public view returns (string) {\r\n        return uris[id];\r\n    }\r\n    \r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 _tokenId){\r\n        return ownedTokens[owner][index];\r\n    }\r\n\r\n    function tokenByIndex(uint256 index) external view returns (uint256){\r\n        return index;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public view returns (bool) {\r\n        return (\r\n            interfaceID == this.supportsInterface.selector || // ERC165\r\n            interfaceID == 0x5b5e139f || // ERC721Metadata\r\n            interfaceID == 0x6466353c || // ERC-721 on 3/7/2018\r\n            interfaceID == 0x780e9d63\r\n        ); // ERC721Enumerable\r\n    }\r\n\r\n    function implementsERC721() external pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function getOwnedTokens(address user) public view returns (uint40[]) {\r\n        return ownedTokens[user];\r\n    }\r\n    \r\n\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address\r\n    /// @param _tokenId The NFT identifier which is being transfered\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n\tfunction onERC721Received(address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\n\r\n\r\ncontract CardIntegration is CardOwnership {\r\n    \r\n    CardPack[] packs;\r\n\r\n    event CardCreated(uint indexed id, uint16 proto, uint16 purity, address owner);\r\n\r\n    function addPack(CardPack approved) public onlyGovernor {\r\n        packs.push(approved);\r\n    }\r\n\r\n    modifier onlyApprovedPacks {\r\n        require(_isApprovedPack());\r\n        _;\r\n    }\r\n\r\n    function _isApprovedPack() private view returns (bool) {\r\n        for (uint i = 0; i < packs.length; i++) {\r\n            if (msg.sender == address(packs[i])) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function createCard(address owner, uint16 proto, uint16 purity) public whenNotPaused onlyApprovedPacks returns (uint) {\r\n        ProtoCard memory card = protos[proto];\r\n        require(card.season == currentSeason);\r\n        if (card.rarity == Rarity.Mythic) {\r\n            uint64 limit;\r\n            bool exists;\r\n            (limit, exists) = getLimit(proto);\r\n            require(!exists || limit > 0);\r\n            limits[proto].limit--;\r\n        }\r\n        return _createCard(owner, proto, purity);\r\n    }\r\n\r\n    function _createCard(address owner, uint16 proto, uint16 purity) internal returns (uint) {\r\n        Card memory card = Card({\r\n            proto: proto,\r\n            purity: purity\r\n        });\r\n\r\n        uint id = cards.push(card) - 1;\r\n\r\n        _create(owner, id);\r\n        \r\n        emit CardCreated(id, proto, purity, owner);\r\n\r\n        return id;\r\n    }\r\n\r\n    /*function combineCards(uint[] ids) public whenNotPaused {\r\n        require(ids.length == 5);\r\n        require(ownsAll(msg.sender, ids));\r\n        Card memory first = cards[ids[0]];\r\n        uint16 proto = first.proto;\r\n        uint8 shine = _getShine(first.purity);\r\n        require(shine < shineLimit);\r\n        uint16 puritySum = first.purity - (shine * 1000);\r\n        burn(ids[0]);\r\n        for (uint i = 1; i < ids.length; i++) {\r\n            Card memory next = cards[ids[i]];\r\n            require(next.proto == proto);\r\n            require(_getShine(next.purity) == shine);\r\n            puritySum += (next.purity - (shine * 1000));\r\n            burn(ids[i]);\r\n        }\r\n        uint16 newPurity = uint16(((shine + 1) * 1000) + (puritySum / ids.length));\r\n        _createCard(msg.sender, proto, newPurity);\r\n    }*/\r\n\r\n\r\n    // PURITY NOTES\r\n    // currently, we only\r\n    // however, to protect rarity, you'll never be abl\r\n    // this is enforced by the restriction in the create-card function\r\n    // no cards above this point can be found in packs\r\n\r\n    \r\n\r\n}\r\n\r\ncontract CardPack {\r\n\r\n    CardIntegration public integration;\r\n    uint public creationBlock;\r\n\r\n    constructor(CardIntegration _integration) public payable {\r\n        integration = _integration;\r\n        creationBlock = block.number;\r\n    }\r\n\r\n    event Referral(address indexed referrer, uint value, address purchaser);\r\n\r\n    /**\r\n    * purchase 'count' of this type of pack\r\n    */\r\n    function purchase(uint16 packCount, address referrer) public payable;\r\n\r\n    // store purity and shine as one number to save users gas\r\n    function _getPurity(uint16 randOne, uint16 randTwo) internal pure returns (uint16) {\r\n        if (randOne >= 998) {\r\n            return 3000 + randTwo;\r\n        } else if (randOne >= 988) {\r\n            return 2000 + randTwo;\r\n        } else if (randOne >= 938) {\r\n            return 1000 + randTwo;\r\n        } else {\r\n            return randTwo;\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable {\r\n\r\n   address public owner;\r\n\r\n   constructor() public {\r\n       owner = msg.sender;\r\n   }\r\n\r\n   function setOwner(address _owner) public onlyOwner {\r\n       owner = _owner;\r\n   }\r\n\r\n   modifier onlyOwner {\r\n       require(msg.sender == owner);\r\n       _;\r\n   }\r\n\r\n}\r\n\r\ncontract Vault is Ownable {\r\n\r\n   function () public payable {\r\n\r\n   }\r\n\r\n   function getBalance() public view returns (uint) {\r\n       return address(this).balance;\r\n   }\r\n\r\n   function withdraw(uint amount) public onlyOwner {\r\n       require(address(this).balance >= amount);\r\n       owner.transfer(amount);\r\n   }\r\n\r\n   function withdrawAll() public onlyOwner {\r\n       withdraw(address(this).balance);\r\n   }\r\n}\r\n\r\ncontract CappedVault is Vault { \r\n\r\n    uint public limit;\r\n    uint withdrawn = 0;\r\n\r\n    constructor() public {\r\n        limit = 33333 ether;\r\n    }\r\n\r\n    function () public payable {\r\n        require(total() + msg.value <= limit);\r\n    }\r\n\r\n    function total() public view returns(uint) {\r\n        return getBalance() + withdrawn;\r\n    }\r\n\r\n    function withdraw(uint amount) public onlyOwner {\r\n        require(address(this).balance >= amount);\r\n        owner.transfer(amount);\r\n        withdrawn += amount;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Pausable is Ownable {\r\n    \r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\ncontract PresalePack is CardPack, Pausable {\r\n\r\n    CappedVault public vault;\r\n\r\n    Purchase[] purchases;\r\n\r\n    struct Purchase {\r\n        uint16 current;\r\n        uint16 count;\r\n        address user;\r\n        uint randomness;\r\n        uint64 commit;\r\n    }\r\n\r\n    event PacksPurchased(uint indexed id, address indexed user, uint16 count);\r\n    event PackOpened(uint indexed id, uint16 startIndex, address indexed user, uint[] cardIDs);\r\n    event RandomnessReceived(uint indexed id, address indexed user, uint16 count, uint randomness);\r\n\r\n    constructor(CardIntegration integration, CappedVault _vault) public payable CardPack(integration) {\r\n        vault = _vault;\r\n    }\r\n\r\n    function basePrice() public returns (uint);\r\n    function getCardDetails(uint16 packIndex, uint8 cardIndex, uint result) public view returns (uint16 proto, uint16 purity);\r\n    \r\n    function packSize() public view returns (uint8) {\r\n        return 5;\r\n    }\r\n\r\n    function packsPerClaim() public view returns (uint16) {\r\n        return 15;\r\n    }\r\n\r\n    // start in bytes, length in bytes\r\n    function extract(uint num, uint length, uint start) internal pure returns (uint) {\r\n        return (((1 << (length * 8)) - 1) & (num >> ((start * 8) - 1)));\r\n    }\r\n\r\n    uint public purchaseCount;\r\n    uint public totalCount;\r\n\r\n    function purchase(uint16 packCount, address referrer) whenNotPaused public payable {\r\n\r\n        require(packCount > 0);\r\n        require(referrer != msg.sender);\r\n\r\n        uint price = calculatePrice(basePrice(), packCount);\r\n\r\n        require(msg.value >= price);\r\n\r\n        Purchase memory p = Purchase({\r\n            user: msg.sender,\r\n            count: packCount,\r\n            commit: uint64(block.number),\r\n            randomness: 0,\r\n            current: 0\r\n        });\r\n\r\n        uint id = purchases.push(p) - 1;\r\n\r\n        emit PacksPurchased(id, msg.sender, packCount);\r\n\r\n        if (referrer != address(0)) {\r\n            uint commission = price / 10;\r\n            referrer.transfer(commission);\r\n            price -= commission;\r\n            emit Referral(referrer, commission, msg.sender);\r\n        }\r\n        \r\n        address(vault).transfer(price); \r\n    }\r\n\r\n    // can be called by anybody\r\n    function callback(uint id) public {\r\n\r\n        Purchase storage p = purchases[id];\r\n\r\n        require(p.randomness == 0);\r\n\r\n        bytes32 bhash = blockhash(p.commit);\r\n\r\n        uint random = uint(keccak256(abi.encodePacked(totalCount, bhash)));\r\n\r\n        totalCount += p.count;\r\n\r\n        if (uint(bhash) == 0) {\r\n            // should never happen (must call within next 256 blocks)\r\n            // if it does, just give them 1: will become common and therefore less valuable\r\n            // set to 1 rather than 0 to avoid calling claim before randomness\r\n            p.randomness = 1;\r\n        } else {\r\n            p.randomness = random;\r\n        }\r\n\r\n        emit RandomnessReceived(id, p.user, p.count, p.randomness);\r\n    }\r\n\r\n    \r\n\r\n    function claim(uint id) public {\r\n        \r\n        Purchase storage p = purchases[id];\r\n\r\n        require(canClaim);\r\n\r\n        uint16 proto;\r\n        uint16 purity;\r\n        uint16 count = p.count;\r\n        uint result = p.randomness;\r\n        uint8 size = packSize();\r\n\r\n        address user = p.user;\r\n        uint16 current = p.current;\r\n\r\n        require(result != 0); // have to wait for the callback\r\n        // require(user == msg.sender); // not needed\r\n        require(count > 0);\r\n\r\n        uint[] memory ids = new uint[](size);\r\n\r\n        uint16 end = current + packsPerClaim() > count ? count : current + packsPerClaim();\r\n\r\n        require(end > current);\r\n\r\n        for (uint16 i = current; i < end; i++) {\r\n            for (uint8 j = 0; j < size; j++) {\r\n                (proto, purity) = getCardDetails(i, j, result);\r\n                ids[j] = integration.createCard(user, proto, purity);\r\n            }\r\n            emit PackOpened(id, (i * size), user, ids);\r\n        }\r\n        p.current += (end - current);\r\n    }\r\n\r\n    function predictPacks(uint id) external view returns (uint16[] protos, uint16[] purities) {\r\n\r\n        Purchase memory p = purchases[id];\r\n\r\n        uint16 proto;\r\n        uint16 purity;\r\n        uint16 count = p.count;\r\n        uint result = p.randomness;\r\n        uint8 size = packSize();\r\n\r\n        purities = new uint16[](size * count);\r\n        protos = new uint16[](size * count);\r\n\r\n        for (uint16 i = 0; i < count; i++) {\r\n            for (uint8 j = 0; j < size; j++) {\r\n                (proto, purity) = getCardDetails(i, j, result);\r\n                purities[(i * size) + j] = purity;\r\n                protos[(i * size) + j] = proto;\r\n            }\r\n        }\r\n        return (protos, purities);\r\n    }\r\n\r\n    function calculatePrice(uint base, uint16 packCount) public view returns (uint) {\r\n        // roughly 6k blocks per day\r\n        uint difference = block.number - creationBlock;\r\n        uint numDays = difference / 6000;\r\n        if (20 > numDays) {\r\n            return (base - (((20 - numDays) * base) / 100)) * packCount;\r\n        }\r\n        return base * packCount;\r\n    }\r\n\r\n    function _getCommonPlusRarity(uint32 rand) internal pure returns (CardProto.Rarity) {\r\n        if (rand == 999999) {\r\n            return CardProto.Rarity.Mythic;\r\n        } else if (rand >= 998345) {\r\n            return CardProto.Rarity.Legendary;\r\n        } else if (rand >= 986765) {\r\n            return CardProto.Rarity.Epic;\r\n        } else if (rand >= 924890) {\r\n            return CardProto.Rarity.Rare;\r\n        } else {\r\n            return CardProto.Rarity.Common;\r\n        }\r\n    }\r\n\r\n    function _getRarePlusRarity(uint32 rand) internal pure returns (CardProto.Rarity) {\r\n        if (rand == 999999) {\r\n            return CardProto.Rarity.Mythic;\r\n        } else if (rand >= 981615) {\r\n            return CardProto.Rarity.Legendary;\r\n        } else if (rand >= 852940) {\r\n            return CardProto.Rarity.Epic;\r\n        } else {\r\n            return CardProto.Rarity.Rare;\r\n        } \r\n    }\r\n\r\n    function _getEpicPlusRarity(uint32 rand) internal pure returns (CardProto.Rarity) {\r\n        if (rand == 999999) {\r\n            return CardProto.Rarity.Mythic;\r\n        } else if (rand >= 981615) {\r\n            return CardProto.Rarity.Legendary;\r\n        } else {\r\n            return CardProto.Rarity.Epic;\r\n        }\r\n    }\r\n\r\n    function _getLegendaryPlusRarity(uint32 rand) internal pure returns (CardProto.Rarity) {\r\n        if (rand == 999999) {\r\n            return CardProto.Rarity.Mythic;\r\n        } else {\r\n            return CardProto.Rarity.Legendary;\r\n        } \r\n    }\r\n\r\n    bool public canClaim = true;\r\n\r\n    function setCanClaim(bool claim) public onlyOwner {\r\n        canClaim = claim;\r\n    }\r\n\r\n    function getComponents(\r\n        uint16 i, uint8 j, uint rand\r\n    ) internal returns (\r\n        uint random, uint32 rarityRandom, uint16 purityOne, uint16 purityTwo, uint16 protoRandom\r\n    ) {\r\n        random = uint(keccak256(abi.encodePacked(i, rand, j)));\r\n        rarityRandom = uint32(extract(random, 4, 10) % 1000000);\r\n        purityOne = uint16(extract(random, 2, 4) % 1000);\r\n        purityTwo = uint16(extract(random, 2, 6) % 1000);\r\n        protoRandom = uint16(extract(random, 2, 8) % (2**16-1));\r\n        return (random, rarityRandom, purityOne, purityTwo, protoRandom);\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n}\r\n\r\ncontract ERC20 {\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    \r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n    \r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    \r\n  \r\n}\r\n\r\npragma solidity 0.4.24;\r\n\r\n// from OZ\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract TournamentPass is ERC20, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    Vault vault;\r\n\r\n    constructor(Vault _vault) public {\r\n        vault = _vault;\r\n    }\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    address[] public minters;\r\n    uint256 supply;\r\n    uint mintLimit = 20000;\r\n    \r\n    function name() public view returns (string){\r\n        return \"GU Tournament Passes\";\r\n    }\r\n\r\n    function symbol() public view returns (string) {\r\n        return \"PASS\";\r\n    }\r\n\r\n    function addMinter(address minter) public onlyOwner {\r\n        minters.push(minter);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return supply;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function isMinter(address test) internal view returns (bool) {\r\n        for (uint i = 0; i < minters.length; i++) {\r\n            if (minters[i] == test) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function mint(address to, uint amount) public returns (bool) {\r\n        require(isMinter(msg.sender));\r\n        if (amount.add(supply) > mintLimit) {\r\n            return false;\r\n        } \r\n        supply = supply.add(amount);\r\n        balances[to] = balances[to].add(amount);\r\n        emit Transfer(address(0), to, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address spender, uint256 addedValue) public returns (bool) {\r\n        allowed[msg.sender][spender] = allowed[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address spender, uint256 subtractedValue) public returns (bool) {\r\n        uint256 oldValue = allowed[msg.sender][spender];\r\n        if (subtractedValue > oldValue) {\r\n            allowed[msg.sender][spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][spender] = oldValue.sub(subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    uint public price = 250 finney;\r\n\r\n    function purchase(uint amount) public payable {\r\n        \r\n        require(msg.value >= price.mul(amount));\r\n        require(supply.add(amount) <= mintLimit);\r\n\r\n        supply = supply.add(amount);\r\n        balances[msg.sender] = balances[msg.sender].add(amount);\r\n        emit Transfer(address(0), msg.sender, amount);\r\n\r\n        address(vault).transfer(msg.value);\r\n    }\r\n\r\n}\r\n\r\ncontract ShinyLegendaryPack is PresalePack {\r\n\r\n    TournamentPass pass;\r\n\r\n    constructor(CardIntegration integration, CappedVault _vault, TournamentPass _pass) public payable PresalePack(integration, _vault) {\r\n        pass = _pass;\r\n    }\r\n\r\n    function purchase(uint16 packCount, address referrer) public payable {\r\n        super.purchase(packCount, referrer);\r\n        pass.mint(msg.sender, packCount);\r\n    }\r\n\r\n    function basePrice() public returns (uint) {\r\n        return 4 ether;\r\n    }\r\n\r\n    function getCardDetails(uint16 packIndex, uint8 cardIndex, uint result) public view returns (uint16 proto, uint16 purity) {\r\n        uint random;\r\n        uint32 rarityRandom;\r\n        uint16 protoRandom;\r\n        uint16 purityOne;\r\n        uint16 purityTwo;\r\n        CardProto.Rarity rarity;\r\n\r\n        (random, rarityRandom, purityOne, purityTwo, protoRandom) = getComponents(packIndex, cardIndex, result);\r\n\r\n        if (cardIndex == 4) {\r\n            rarity = _getLegendaryPlusRarity(rarityRandom);\r\n            purity = _getShinyPurity(purityOne, purityTwo);\r\n        } else if (cardIndex == 3) {\r\n            rarity = _getRarePlusRarity(rarityRandom);\r\n            purity = _getPurity(purityOne, purityTwo);\r\n        } else {\r\n            rarity = _getCommonPlusRarity(rarityRandom);\r\n            purity = _getPurity(purityOne, purityTwo);\r\n        }\r\n    \r\n        proto = integration.getRandomCard(rarity, protoRandom);\r\n\r\n        return (proto, purity);\r\n    } \r\n\r\n    function _getShinyPurity(uint16 randOne, uint16 randTwo) public pure returns (uint16) {\r\n        if (randOne >= 998) {\r\n            return 3000 + randTwo;\r\n        } else if (randOne >= 748) {\r\n            return 2000 + randTwo;\r\n        } else {\r\n            return 1000 + randTwo;\r\n        }\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"packSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"purchaseCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"packCount\",\"type\":\"uint16\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"integration\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"packsPerClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"packIndex\",\"type\":\"uint16\"},{\"name\":\"cardIndex\",\"type\":\"uint8\"},{\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"getCardDetails\",\"outputs\":[{\"name\":\"proto\",\"type\":\"uint16\"},{\"name\":\"purity\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"claim\",\"type\":\"bool\"}],\"name\":\"setCanClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"predictPacks\",\"outputs\":[{\"name\":\"protos\",\"type\":\"uint16[]\"},{\"name\":\"purities\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"base\",\"type\":\"uint256\"},{\"name\":\"packCount\",\"type\":\"uint16\"}],\"name\":\"calculatePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"randOne\",\"type\":\"uint16\"},{\"name\":\"randTwo\",\"type\":\"uint16\"}],\"name\":\"_getShinyPurity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"integration\",\"type\":\"address\"},{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_pass\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"PacksPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startIndex\",\"type\":\"uint16\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cardIDs\",\"type\":\"uint256[]\"}],\"name\":\"PackOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"RandomnessReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"purchaser\",\"type\":\"address\"}],\"name\":\"Referral\",\"type\":\"event\"}]","ContractName":"ShinyLegendaryPack","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000512fbd15bde6570ff09e4438af27ede60402451500000000000000000000000091b9d2835ad914bc1dcfe09bd1816febd04fd68900000000000000000000000022365168c8705e95b2d08876c23a8c13e3ad72e2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://5f191df44c73dd19904cf676903bd6744195038bc5903e3a84a05dbaacf87b8a"}]