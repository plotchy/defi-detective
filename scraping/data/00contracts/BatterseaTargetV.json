[{"SourceCode":"{\"Address.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title Address\\n * @author Paul Razvan Berg\\n * @notice Collection of functions related to the address type.\\n * @dev Forked from OpenZeppelin\\n * https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v3.1.0/contracts/utils/Address.sol\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`.\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        /* solhint-disable-next-line no-inline-assembly */\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n}\\n\"},\"AggregatorV3Interface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title AggregatorV3Interface\\n * @author Hifi\\n * @dev Forked from Chainlink\\n * https://github.com/smartcontractkit/chainlink/blob/v0.9.9/evm-contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\\n */\\ninterface AggregatorV3Interface {\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    /*\\n     * getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n     * if they do not have data to report, instead of returning unset values\\n     * which could be misinterpreted as actual reported values.\\n     */\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\"},\"BalanceSheetInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalanceSheetStorage.sol\\\";\\n\\n/**\\n * @title BalanceSheetInterface\\n * @author Hifi\\n */\\nabstract contract BalanceSheetInterface is BalanceSheetStorage {\\n    /**\\n     * CONSTANT FUNCTIONS\\n     */\\n    function getClutchableCollateral(FyTokenInterface fyToken, uint256 repayAmount)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getCurrentCollateralizationRatio(FyTokenInterface fyToken, address borrower)\\n        public\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function getHypotheticalCollateralizationRatio(\\n        FyTokenInterface fyToken,\\n        address borrower,\\n        uint256 lockedCollateral,\\n        uint256 debt\\n    ) public view virtual returns (uint256);\\n\\n    function getVault(FyTokenInterface fyToken, address borrower)\\n        external\\n        view\\n        virtual\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            bool\\n        );\\n\\n    function getVaultDebt(FyTokenInterface fyToken, address borrower) external view virtual returns (uint256);\\n\\n    function getVaultLockedCollateral(FyTokenInterface fyToken, address borrower)\\n        external\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    function isAccountUnderwater(FyTokenInterface fyToken, address borrower) external view virtual returns (bool);\\n\\n    function isVaultOpen(FyTokenInterface fyToken, address borrower) external view virtual returns (bool);\\n\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n\\n    function clutchCollateral(\\n        FyTokenInterface fyToken,\\n        address liquidator,\\n        address borrower,\\n        uint256 clutchedCollateralAmount\\n    ) external virtual returns (bool);\\n\\n    function depositCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);\\n\\n    function freeCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);\\n\\n    function lockCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);\\n\\n    function openVault(FyTokenInterface fyToken) external virtual returns (bool);\\n\\n    function setVaultDebt(\\n        FyTokenInterface fyToken,\\n        address borrower,\\n        uint256 newVaultDebt\\n    ) external virtual returns (bool);\\n\\n    function withdrawCollateral(FyTokenInterface fyToken, uint256 collateralAmount) external virtual returns (bool);\\n\\n    /**\\n     * EVENTS\\n     */\\n\\n    event ClutchCollateral(\\n        FyTokenInterface indexed fyToken,\\n        address indexed liquidator,\\n        address indexed borrower,\\n        uint256 clutchedCollateralAmount\\n    );\\n\\n    event DepositCollateral(FyTokenInterface indexed fyToken, address indexed borrower, uint256 collateralAmount);\\n\\n    event FreeCollateral(FyTokenInterface indexed fyToken, address indexed borrower, uint256 collateralAmount);\\n\\n    event LockCollateral(FyTokenInterface indexed fyToken, address indexed borrower, uint256 collateralAmount);\\n\\n    event OpenVault(FyTokenInterface indexed fyToken, address indexed borrower);\\n\\n    event SetVaultDebt(FyTokenInterface indexed fyToken, address indexed borrower, uint256 oldDebt, uint256 newDebt);\\n\\n    event WithdrawCollateral(FyTokenInterface indexed fyToken, address indexed borrower, uint256 collateralAmount);\\n}\\n\"},\"BalanceSheetStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./FyTokenInterface.sol\\\";\\n\\n/**\\n * @title BalanceSheetStorage\\n * @author Hifi\\n */\\nabstract contract BalanceSheetStorage {\\n    struct Vault {\\n        uint256 debt;\\n        uint256 freeCollateral;\\n        uint256 lockedCollateral;\\n        bool isOpen;\\n    }\\n\\n    /**\\n     * @notice The unique Fintroller associated with this contract.\\n     */\\n    FintrollerInterface public fintroller;\\n\\n    /**\\n     * @dev One vault for each fyToken for each account.\\n     */\\n    mapping(address =\\u003e mapping(address =\\u003e Vault)) internal vaults;\\n\\n    /**\\n     * @notice Indicator that this is a BalanceSheet contract, for inspection.\\n     */\\n    bool public constant isBalanceSheet = true;\\n}\\n\"},\"BatterseaTargetV1.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./CarefulMath.sol\\\";\\nimport \\\"./Erc20Interface.sol\\\";\\nimport \\\"./SafeErc20.sol\\\";\\n\\nimport \\\"./BatterseaTargetV1Interface.sol\\\";\\nimport \\\"./BalanceSheetInterface.sol\\\";\\nimport \\\"./FyTokenInterface.sol\\\";\\nimport \\\"./RedemptionPoolInterface.sol\\\";\\nimport \\\"./ExchangeProxyInterface.sol\\\";\\nimport \\\"./TokenInterface.sol\\\";\\nimport \\\"./WethInterface.sol\\\";\\n\\n/**\\n * @title BatterseaTargetV1\\n * @author Hifi\\n * @notice Target contract with scripts for the Battersea release of the protocol.\\n * @dev Meant to be used with a DSProxy contract via delegatecall.\\n */\\ncontract BatterseaTargetV1 is\\n    CarefulMath, /* no dependency */\\n    BatterseaTargetV1Interface /* one dependency */\\n{\\n    using SafeErc20 for Erc20Interface;\\n    using SafeErc20 for FyTokenInterface;\\n\\n    /**\\n     * @notice Borrows fyTokens.\\n     *\\n     * @param fyToken The address of the FyToken contract.\\n     * @param borrowAmount The amount of fyTokens to borrow.\\n     */\\n    function borrow(FyTokenInterface fyToken, uint256 borrowAmount) public {\\n        fyToken.borrow(borrowAmount);\\n        fyToken.safeTransfer(msg.sender, borrowAmount);\\n    }\\n\\n    /**\\n     * @notice Borrows fyTokens and sells them on Balancer in exchange for underlying.\\n     *\\n     * @dev Emits a {BorrowAndSellFyTokens} event.\\n     *\\n     * This is a payable function so it can receive ETH transfers.\\n     *\\n     * @param fyToken The address of the FyToken contract.\\n     * @param borrowAmount The amount of fyTokens to borrow.\\n     * @param underlyingAmount The amount of underlying to sell fyTokens for.\\n     */\\n    function borrowAndSellFyTokens(\\n        FyTokenInterface fyToken,\\n        uint256 borrowAmount,\\n        uint256 underlyingAmount\\n    ) public payable {\\n        Erc20Interface underlying = fyToken.underlying();\\n\\n        /* Borrow the fyTokens. */\\n        fyToken.borrow(borrowAmount);\\n\\n        /* Allow the Balancer contract to spend fyTokens if allowance not enough. */\\n        uint256 allowance = fyToken.allowance(address(this), EXCHANGE_PROXY_ADDRESS);\\n        if (allowance \\u003c borrowAmount) {\\n            fyToken.approve(EXCHANGE_PROXY_ADDRESS, type(uint256).max);\\n        }\\n\\n        /* Prepare the parameters for calling Balancer. */\\n        TokenInterface tokenIn = TokenInterface(address(fyToken));\\n        TokenInterface tokenOut = TokenInterface(address(underlying));\\n        uint256 totalAmountOut = underlyingAmount;\\n        uint256 maxTotalAmountIn = borrowAmount;\\n        uint256 nPools = 1;\\n\\n        /* Recall that Balancer reverts when the swap is not successful. */\\n        uint256 totalAmountIn =\\n            ExchangeProxyInterface(EXCHANGE_PROXY_ADDRESS).smartSwapExactOut(\\n                tokenIn,\\n                tokenOut,\\n                totalAmountOut,\\n                maxTotalAmountIn,\\n                nPools\\n            );\\n\\n        /* When we get a better price than the worst that we assumed we would, not all fyTokens are sold. */\\n        MathError mathErr;\\n        uint256 fyTokenDelta;\\n        (mathErr, fyTokenDelta) = subUInt(borrowAmount, totalAmountIn);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_BORROW_AND_SELL_FYTOKENS_MATH_ERROR\\\");\\n\\n        /* If the fyToken delta is non-zero, we use it to partially repay the borrow. */\\n        /* Note: this is not gas-efficient. */\\n        if (fyTokenDelta \\u003e 0) {\\n            fyToken.repayBorrow(fyTokenDelta);\\n        }\\n\\n        /* Finally, transfer the recently bought underlying to the end user. */\\n        underlying.safeTransfer(msg.sender, underlyingAmount);\\n\\n        emit BorrowAndSellFyTokens(msg.sender, borrowAmount, fyTokenDelta, underlyingAmount);\\n    }\\n\\n    /**\\n     * @notice Deposits collateral into the BalanceSheet contract.\\n     *\\n     * @dev Requirements:\\n     * - The caller must have allowed the DSProxy to spend `collateralAmount` tokens.\\n     *\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     * @param collateralAmount The amount of collateral to deposit.\\n     */\\n    function depositCollateral(\\n        BalanceSheetInterface balanceSheet,\\n        FyTokenInterface fyToken,\\n        uint256 collateralAmount\\n    ) public {\\n        /* Transfer the collateral to the DSProxy. */\\n        fyToken.collateral().safeTransferFrom(msg.sender, address(this), collateralAmount);\\n\\n        /* Deposit the collateral into the BalanceSheet contract. */\\n        depositCollateralInternal(balanceSheet, fyToken, collateralAmount);\\n    }\\n\\n    /**\\n     * @notice Deposits and locks collateral into the BalanceSheet contract.\\n     *\\n     * @dev Requirements:\\n     * - The caller must have allowed the DSProxy to spend `collateralAmount` tokens.\\n     *\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     * @param collateralAmount The amount of collateral to deposit and lock.\\n     */\\n    function depositAndLockCollateral(\\n        BalanceSheetInterface balanceSheet,\\n        FyTokenInterface fyToken,\\n        uint256 collateralAmount\\n    ) public {\\n        depositCollateral(balanceSheet, fyToken, collateralAmount);\\n        balanceSheet.lockCollateral(fyToken, collateralAmount);\\n    }\\n\\n    /**\\n     * @notice Deposits and locks collateral into the vault via the BalanceSheet contract\\n     * and borrows fyTokens.\\n     *\\n     * @dev This is a payable function so it can receive ETH transfers.\\n     *\\n     * Requirements:\\n     * - The caller must have allowed the DSProxy to spend `collateralAmount` tokens.\\n     *\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     * @param collateralAmount The amount of collateral to deposit and lock.\\n     * @param borrowAmount The amount of fyTokens to borrow.\\n     */\\n    function depositAndLockCollateralAndBorrow(\\n        BalanceSheetInterface balanceSheet,\\n        FyTokenInterface fyToken,\\n        uint256 collateralAmount,\\n        uint256 borrowAmount\\n    ) public payable {\\n        depositAndLockCollateral(balanceSheet, fyToken, collateralAmount);\\n        borrow(fyToken, borrowAmount);\\n    }\\n\\n    /**\\n     * @notice Deposits and locks collateral into the vault via the BalanceSheet contract, borrows fyTokens\\n     * and sells them on Balancer in exchange for underlying.\\n     *\\n     * @dev This is a payable function so it can receive ETH transfers.\\n     *\\n     * Requirements:\\n     * - The caller must have allowed the DSProxy to spend `collateralAmount` tokens.\\n     *\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     * @param collateralAmount The amount of collateral to deposit and lock.\\n     * @param borrowAmount The amount of fyTokens to borrow.\\n     * @param underlyingAmount The amount of underlying to sell fyTokens for.\\n     */\\n    function depositAndLockCollateralAndBorrowAndSellFyTokens(\\n        BalanceSheetInterface balanceSheet,\\n        FyTokenInterface fyToken,\\n        uint256 collateralAmount,\\n        uint256 borrowAmount,\\n        uint256 underlyingAmount\\n    ) external payable {\\n        depositAndLockCollateral(balanceSheet, fyToken, collateralAmount);\\n        borrowAndSellFyTokens(fyToken, borrowAmount, underlyingAmount);\\n    }\\n\\n    /**\\n     * @notice Frees collateral from the vault in the BalanceSheet contract.\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     * @param collateralAmount The amount of collateral to free.\\n     */\\n    function freeCollateral(\\n        BalanceSheetInterface balanceSheet,\\n        FyTokenInterface fyToken,\\n        uint256 collateralAmount\\n    ) external {\\n        balanceSheet.freeCollateral(fyToken, collateralAmount);\\n    }\\n\\n    /**\\n     * @notice Frees collateral from the vault and withdraws it from the\\n     * BalanceSheet contract.\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     * @param collateralAmount The amount of collateral to free and withdraw.\\n     */\\n    function freeAndWithdrawCollateral(\\n        BalanceSheetInterface balanceSheet,\\n        FyTokenInterface fyToken,\\n        uint256 collateralAmount\\n    ) external {\\n        balanceSheet.freeCollateral(fyToken, collateralAmount);\\n        withdrawCollateral(balanceSheet, fyToken, collateralAmount);\\n    }\\n\\n    /**\\n     * @notice Locks collateral in the vault in the BalanceSheet contract.\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     * @param collateralAmount The amount of collateral to lock.\\n     */\\n    function lockCollateral(\\n        BalanceSheetInterface balanceSheet,\\n        FyTokenInterface fyToken,\\n        uint256 collateralAmount\\n    ) external {\\n        balanceSheet.lockCollateral(fyToken, collateralAmount);\\n    }\\n\\n    /**\\n     * @notice Locks collateral into the vault in the BalanceSheet contract\\n     * and draws debt via the FyToken contract.\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     * @param collateralAmount The amount of collateral to lock.\\n     * @param borrowAmount The amount of fyTokens to borrow.\\n     * @param underlyingAmount The amount of underlying to sell fyTokens for.\\n     */\\n    function lockCollateralAndBorrow(\\n        BalanceSheetInterface balanceSheet,\\n        FyTokenInterface fyToken,\\n        uint256 collateralAmount,\\n        uint256 borrowAmount,\\n        uint256 underlyingAmount\\n    ) external {\\n        balanceSheet.lockCollateral(fyToken, collateralAmount);\\n        borrowAndSellFyTokens(fyToken, borrowAmount, underlyingAmount);\\n    }\\n\\n    /**\\n     * @notice Open the vaults in the BalanceSheet contract for the given fyToken.\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     */\\n    function openVault(BalanceSheetInterface balanceSheet, FyTokenInterface fyToken) external {\\n        balanceSheet.openVault(fyToken);\\n    }\\n\\n    /**\\n     * @notice Redeems fyTokens in exchange for underlying tokens.\\n     *\\n     * @dev Requirements:\\n     * - The caller must have allowed the DSProxy to spend `repayAmount` fyTokens.\\n     *\\n     * @param fyToken The address of the FyToken contract.\\n     * @param fyTokenAmount The amount of fyTokens to redeem.\\n     */\\n    function redeemFyTokens(FyTokenInterface fyToken, uint256 fyTokenAmount) public {\\n        Erc20Interface underlying = fyToken.underlying();\\n        RedemptionPoolInterface redemptionPool = fyToken.redemptionPool();\\n\\n        /* Transfer the fyTokens to the DSProxy. */\\n        fyToken.safeTransferFrom(msg.sender, address(this), fyTokenAmount);\\n\\n        /* Redeem the fyTokens. */\\n        uint256 preUnderlyingBalance = underlying.balanceOf(address(this));\\n        redemptionPool.redeemFyTokens(fyTokenAmount);\\n\\n        /* Calculate how many underlying have been redeemed. */\\n        uint256 postUnderlyigBalance = underlying.balanceOf(address(this));\\n        MathError mathErr;\\n        uint256 underlyingAmount;\\n        (mathErr, underlyingAmount) = subUInt(postUnderlyigBalance, preUnderlyingBalance);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_REDEEM_FYTOKENS_MATH_ERROR\\\");\\n\\n        /* The underlying is now in the DSProxy, so we relay it to the end user. */\\n        underlying.safeTransfer(msg.sender, underlyingAmount);\\n    }\\n\\n    /**\\n     * @notice Repays the fyToken borrow.\\n     *\\n     * @dev Requirements:\\n     * - The caller must have allowed the DSProxy to spend `repayAmount` fyTokens.\\n     *\\n     * @param fyToken The address of the FyToken contract.\\n     * @param repayAmount The amount of fyTokens to repay.\\n     */\\n    function repayBorrow(FyTokenInterface fyToken, uint256 repayAmount) public {\\n        /* Transfer the fyTokens to the DSProxy. */\\n        fyToken.safeTransferFrom(msg.sender, address(this), repayAmount);\\n\\n        /* Repay the borrow. */\\n        fyToken.repayBorrow(repayAmount);\\n    }\\n\\n    /**\\n     * @notice Market sells underlying and repays the borrows via the FyToken contract.\\n     *\\n     * @dev Requirements:\\n     * - The caller must have allowed the DSProxy to spend `underlyingAmount` tokens.\\n     *\\n     * @param fyToken The address of the FyToken contract.\\n     * @param underlyingAmount The amount of underlying to sell.\\n     * @param repayAmount The amount of fyTokens to repay.\\n     */\\n    function sellUnderlyingAndRepayBorrow(\\n        FyTokenInterface fyToken,\\n        uint256 underlyingAmount,\\n        uint256 repayAmount\\n    ) external {\\n        Erc20Interface underlying = fyToken.underlying();\\n\\n        /* Transfer the underlying to the DSProxy. */\\n        underlying.safeTransferFrom(msg.sender, address(this), underlyingAmount);\\n\\n        /* Allow the Balancer contract to spend underlying if allowance not enough. */\\n        uint256 allowance = underlying.allowance(address(this), EXCHANGE_PROXY_ADDRESS);\\n        if (allowance \\u003c underlyingAmount) {\\n            underlying.approve(EXCHANGE_PROXY_ADDRESS, type(uint256).max);\\n        }\\n\\n        /* Prepare the parameters for calling Balancer. */\\n        TokenInterface tokenIn = TokenInterface(address(underlying));\\n        TokenInterface tokenOut = TokenInterface(address(fyToken));\\n        uint256 totalAmountOut = repayAmount;\\n        uint256 maxTotalAmountIn = underlyingAmount;\\n        uint256 nPools = 1;\\n\\n        /* Recall that Balancer reverts when the swap is not successful. */\\n        uint256 totalAmountIn =\\n            ExchangeProxyInterface(EXCHANGE_PROXY_ADDRESS).smartSwapExactOut(\\n                tokenIn,\\n                tokenOut,\\n                totalAmountOut,\\n                maxTotalAmountIn,\\n                nPools\\n            );\\n\\n        /* Use the recently bought fyTokens to repay the borrow. */\\n        fyToken.repayBorrow(repayAmount);\\n\\n        /* When we get a better price than the worst that we assumed we would, not all underlying is sold. */\\n        MathError mathErr;\\n        uint256 underlyingDelta;\\n        (mathErr, underlyingDelta) = subUInt(underlyingAmount, totalAmountIn);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_SELL_UNDERLYING_AND_REPAY_BORROW_MATH_ERROR\\\");\\n\\n        /* If the underlying delta is non-zero, send it back to the user. */\\n        if (underlyingDelta \\u003e 0) {\\n            underlying.safeTransfer(msg.sender, underlyingDelta);\\n        }\\n    }\\n\\n    /**\\n     * @notice Supplies the underlying to the RedemptionPool contract and mints fyTokens.\\n     * @param fyToken The address of the FyToken contract.\\n     * @param underlyingAmount The amount of underlying to supply.\\n     */\\n    function supplyUnderlying(FyTokenInterface fyToken, uint256 underlyingAmount) public {\\n        uint256 preFyTokenBalance = fyToken.balanceOf(address(this));\\n        supplyUnderlyingInternal(fyToken, underlyingAmount);\\n\\n        /* Calculate how many fyTokens have been minted. */\\n        uint256 postFyTokenBalance = fyToken.balanceOf(address(this));\\n        MathError mathErr;\\n        uint256 fyTokenAmount;\\n        (mathErr, fyTokenAmount) = subUInt(postFyTokenBalance, preFyTokenBalance);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_SUPPLY_UNDERLYING_MATH_ERROR\\\");\\n\\n        /* The fyTokens are now in the DSProxy, so we relay them to the end user. */\\n        fyToken.safeTransfer(msg.sender, fyTokenAmount);\\n    }\\n\\n    /**\\n     * @notice Supplies the underlying to the RedemptionPool contract, mints fyTokens\\n     * and repays the borrow.\\n     *\\n     * @dev Requirements:\\n     * - The caller must have allowed the DSProxy to spend `underlyingAmount` tokens.\\n     *\\n     * @param fyToken The address of the FyToken contract.\\n     * @param underlyingAmount The amount of underlying to supply.\\n     */\\n    function supplyUnderlyingAndRepayBorrow(FyTokenInterface fyToken, uint256 underlyingAmount) external {\\n        uint256 preFyTokenBalance = fyToken.balanceOf(address(this));\\n        supplyUnderlyingInternal(fyToken, underlyingAmount);\\n\\n        /* Calculate how many fyTokens have been minted. */\\n        uint256 postFyTokenBalance = fyToken.balanceOf(address(this));\\n        MathError mathErr;\\n        uint256 fyTokenAmount;\\n        (mathErr, fyTokenAmount) = subUInt(postFyTokenBalance, preFyTokenBalance);\\n        require(mathErr == MathError.NO_ERROR, \\\"ERR_SUPPLY_UNDERLYING_AND_REPAY_BORROW_MATH_ERROR\\\");\\n\\n        /* Use the newly minted fyTokens to repay the debt. */\\n        fyToken.repayBorrow(fyTokenAmount);\\n    }\\n\\n    /**\\n     * @notice Withdraws collateral from the vault in the BalanceSheet contract.\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     * @param collateralAmount The amount of collateral to withdraw.\\n     */\\n    function withdrawCollateral(\\n        BalanceSheetInterface balanceSheet,\\n        FyTokenInterface fyToken,\\n        uint256 collateralAmount\\n    ) public {\\n        balanceSheet.withdrawCollateral(fyToken, collateralAmount);\\n\\n        /* The collateral is now in the DSProxy, so we relay it to the end user. */\\n        Erc20Interface collateral = fyToken.collateral();\\n        collateral.safeTransfer(msg.sender, collateralAmount);\\n    }\\n\\n    /**\\n     * @notice Wraps ETH into WETH and deposits into the BalanceSheet contract.\\n     *\\n     * @dev This is a payable function so it can receive ETH transfers.\\n     *\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     */\\n    function wrapEthAndDepositCollateral(BalanceSheetInterface balanceSheet, FyTokenInterface fyToken) public payable {\\n        uint256 collateralAmount = msg.value;\\n\\n        /* Convert the received ETH to WETH. */\\n        WethInterface(WETH_ADDRESS).deposit{ value: collateralAmount }();\\n\\n        /* Deposit the collateral into the BalanceSheet contract. */\\n        depositCollateralInternal(balanceSheet, fyToken, collateralAmount);\\n    }\\n\\n    /**\\n     * @notice Wraps ETH into WETH, deposits and locks collateral into the BalanceSheet contract\\n     * and borrows fyTokens.\\n     *\\n     * @dev This is a payable function so it can receive ETH transfers.\\n     *\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     */\\n    function wrapEthAndDepositAndLockCollateral(BalanceSheetInterface balanceSheet, FyTokenInterface fyToken)\\n        public\\n        payable\\n    {\\n        uint256 collateralAmount = msg.value;\\n        wrapEthAndDepositCollateral(balanceSheet, fyToken);\\n        balanceSheet.lockCollateral(fyToken, collateralAmount);\\n    }\\n\\n    /**\\n     * @notice Wraps ETH into WETH, deposits and locks collateral into the vault in the BalanceSheet\\n     * contracts and borrows fyTokens.\\n     *\\n     * @dev This is a payable function so it can receive ETH transfers.\\n     *\\n     * @param balanceSheet The address of the BalanceSheet contract.\\n     * @param fyToken The address of the FyToken contract.\\n     * @param borrowAmount The amount of fyTokens to borrow.\\n     * @param underlyingAmount The amount of underlying to sell fyTokens for.\\n     */\\n    function wrapEthAndDepositAndLockCollateralAndBorrow(\\n        BalanceSheetInterface balanceSheet,\\n        FyTokenInterface fyToken,\\n        uint256 borrowAmount,\\n        uint256 underlyingAmount\\n    ) external payable {\\n        wrapEthAndDepositAndLockCollateral(balanceSheet, fyToken);\\n        borrowAndSellFyTokens(fyToken, borrowAmount, underlyingAmount);\\n    }\\n\\n    /**\\n     * INTERNAL FUNCTIONS\\n     */\\n\\n    /**\\n     * @dev See the documentation for the public functions that call this internal function.\\n     */\\n    function depositCollateralInternal(\\n        BalanceSheetInterface balanceSheet,\\n        FyTokenInterface fyToken,\\n        uint256 collateralAmount\\n    ) internal {\\n        /* Allow the BalanceSheet contract to spend tokens if allowance not enough. */\\n        Erc20Interface collateral = fyToken.collateral();\\n        uint256 allowance = collateral.allowance(address(this), address(balanceSheet));\\n        if (allowance \\u003c collateralAmount) {\\n            collateral.approve(address(balanceSheet), type(uint256).max);\\n        }\\n\\n        /* Open the vault if not already open. */\\n        bool isVaultOpen = balanceSheet.isVaultOpen(fyToken, address(this));\\n        if (isVaultOpen == false) {\\n            balanceSheet.openVault(fyToken);\\n        }\\n\\n        /* Deposit the collateral into the BalanceSheet contract. */\\n        balanceSheet.depositCollateral(fyToken, collateralAmount);\\n    }\\n\\n    /**\\n     * @dev See the documentation for the public functions that call this internal function.\\n     */\\n    function supplyUnderlyingInternal(FyTokenInterface fyToken, uint256 underlyingAmount) internal {\\n        RedemptionPoolInterface redemptionPool = fyToken.redemptionPool();\\n        Erc20Interface underlying = fyToken.underlying();\\n\\n        /* Transfer the underlying to the DSProxy. */\\n        underlying.safeTransferFrom(msg.sender, address(this), underlyingAmount);\\n\\n        /* Allow the RedemptionPool contract to spend tokens if allowance not enough. */\\n        uint256 allowance = underlying.allowance(address(this), address(redemptionPool));\\n        if (allowance \\u003c underlyingAmount) {\\n            underlying.approve(address(redemptionPool), type(uint256).max);\\n        }\\n\\n        /* Supply the underlying and mint fyTokens. */\\n        redemptionPool.supplyUnderlying(underlyingAmount);\\n    }\\n}\\n\"},\"BatterseaTargetV1Interface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BatterseaTargetV1Storage.sol\\\";\\n\\n/**\\n * @title BatterseaTargetV1Interface\\n * @author Hifi\\n * @notice Storage contract for BatterseaTargetV1.\\n */\\nabstract contract BatterseaTargetV1Interface is BatterseaTargetV1Storage {\\n    event BorrowAndSellFyTokens(\\n        address indexed borrower,\\n        uint256 borrowAmount,\\n        uint256 fyTokenDelta,\\n        uint256 underlyingAmount\\n    );\\n}\\n\"},\"BatterseaTargetV1Storage.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title BatterseaTargetV1Storage\\n * @author Hifi\\n * @notice Storage contract for BatterseaTargetV1.\\n */\\nabstract contract BatterseaTargetV1Storage {\\n    /**\\n     * @notice The contract that enables trading on the Balancer Exchange.\\n     * @dev This is the mainnet version of the Exchange Proxy. Change it with the testnet version when needed.\\n     */\\n    address public constant EXCHANGE_PROXY_ADDRESS = 0x3E66B66Fd1d0b02fDa6C811Da9E0547970DB2f21;\\n\\n    /**\\n     * @notice The contract that enables wrapping ETH into ERC-20 form.\\n     * @dev This is the mainnet version of WETH. Change it with the testnet version when needed.\\n     */\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n}\\n\"},\"CarefulMath.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @notice Possible error codes that can be returned.\\n */\\nenum MathError { NO_ERROR, DIVISION_BY_ZERO, INTEGER_OVERFLOW, INTEGER_UNDERFLOW, MODULO_BY_ZERO }\\n\\n/**\\n * @title CarefulMath\\n * @author Paul Razvan Berg\\n * @notice Exponential module for storing fixed-precision decimals.\\n * @dev Forked from Compound\\n * https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CarefulMath.sol\\n */\\nabstract contract CarefulMath {\\n    /**\\n     * @notice Adds two numbers, returns an error on overflow.\\n     */\\n    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        uint256 c = a + b;\\n\\n        if (c \\u003e= a) {\\n            return (MathError.NO_ERROR, c);\\n        } else {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n     * @notice Add `a` and `b` and then subtract `c`.\\n     */\\n    function addThenSubUInt(\\n        uint256 a,\\n        uint256 b,\\n        uint256 c\\n    ) internal pure returns (MathError, uint256) {\\n        (MathError err0, uint256 sum) = addUInt(a, b);\\n\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, 0);\\n        }\\n\\n        return subUInt(sum, c);\\n    }\\n\\n    /**\\n     * @notice Integer division of two numbers, truncating the quotient.\\n     */\\n    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        if (b == 0) {\\n            return (MathError.DIVISION_BY_ZERO, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, a / b);\\n    }\\n\\n    /**\\n     * @notice Returns the remainder of dividing two numbers.\\n     * @dev Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     */\\n    function modUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        if (b == 0) {\\n            return (MathError.MODULO_BY_ZERO, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, a % b);\\n    }\\n\\n    /**\\n     * @notice Multiplies two numbers, returns an error on overflow.\\n     */\\n    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        if (a == 0) {\\n            return (MathError.NO_ERROR, 0);\\n        }\\n\\n        uint256 c = a * b;\\n\\n        if (c / a != b) {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        } else {\\n            return (MathError.NO_ERROR, c);\\n        }\\n    }\\n\\n    /**\\n     * @notice Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        if (b \\u003c= a) {\\n            return (MathError.NO_ERROR, a - b);\\n        } else {\\n            return (MathError.INTEGER_UNDERFLOW, 0);\\n        }\\n    }\\n}\\n\"},\"ChainlinkOperatorInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./CarefulMath.sol\\\";\\nimport \\\"./Erc20Interface.sol\\\";\\n\\nimport \\\"./ChainlinkOperatorStorage.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\n/**\\n * @title ChainlinkOperatorInterface\\n * @author Hifi\\n */\\nabstract contract ChainlinkOperatorInterface is ChainlinkOperatorStorage {\\n    /**\\n     * EVENTS\\n     */\\n    event DeleteFeed(Erc20Interface indexed asset, AggregatorV3Interface indexed feed);\\n\\n    event SetFeed(Erc20Interface indexed asset, AggregatorV3Interface indexed feed);\\n\\n    /**\\n     * CONSTANT FUNCTIONS.\\n     */\\n    function getAdjustedPrice(string memory symbol) external view virtual returns (uint256);\\n\\n    function getFeed(string memory symbol)\\n        external\\n        view\\n        virtual\\n        returns (\\n            Erc20Interface,\\n            AggregatorV3Interface,\\n            bool\\n        );\\n\\n    function getPrice(string memory symbol) public view virtual returns (uint256);\\n\\n    /**\\n     * NON-CONSTANT FUNCTIONS.\\n     */\\n    function deleteFeed(string memory symbol) external virtual returns (bool);\\n\\n    function setFeed(Erc20Interface asset, AggregatorV3Interface feed) external virtual returns (bool);\\n}\\n\"},\"ChainlinkOperatorStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Interface.sol\\\";\\n\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\n/**\\n * @title ChainlinkOperatorStorage\\n * @author Hifi\\n */\\nabstract contract ChainlinkOperatorStorage {\\n    struct Feed {\\n        Erc20Interface asset;\\n        AggregatorV3Interface id;\\n        bool isSet;\\n    }\\n\\n    /**\\n     * @dev Mapping between Erc20 symbols and Feed structs.\\n     */\\n    mapping(string =\\u003e Feed) internal feeds;\\n\\n    /**\\n     * @notice Chainlink price precision for USD-quoted data.\\n     */\\n    uint256 public constant pricePrecision = 8;\\n\\n    /**\\n     * @notice The ratio between mantissa precision (1e18) and the Chainlink price precision (1e8).\\n     */\\n    uint256 public constant pricePrecisionScalar = 1.0e10;\\n}\\n\"},\"Erc20Interface.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Storage.sol\\\";\\n\\n/**\\n * @title Erc20Interface\\n * @author Paul Razvan Berg\\n * @notice Interface of the Erc20 standard\\n * @dev Forked from OpenZeppelin\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/token/ERC20/IERC20.sol\\n */\\nabstract contract Erc20Interface is Erc20Storage {\\n    /**\\n     * CONSTANT FUNCTIONS\\n     */\\n    function allowance(address owner, address spender) external view virtual returns (uint256);\\n\\n    function balanceOf(address account) external view virtual returns (uint256);\\n\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n    function approve(address spender, uint256 amount) external virtual returns (bool);\\n\\n    function transfer(address recipient, uint256 amount) external virtual returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external virtual returns (bool);\\n\\n    /**\\n     * EVENTS\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    event Burn(address indexed holder, uint256 burnAmount);\\n\\n    event Mint(address indexed beneficiary, uint256 mintAmount);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n}\\n\"},\"Erc20Storage.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title ExponentialStorage\\n * @author Paul Razvan Berg\\n * @notice The storage interface ancillary to an Erc20 contract.\\n */\\nabstract contract Erc20Storage {\\n    /**\\n     * @notice Returns the number of decimals used to get its user representation.\\n     */\\n    uint8 public decimals;\\n\\n    /**\\n     * @notice Returns the name of the token.\\n     */\\n    string public name;\\n\\n    /**\\n     * @notice Returns the symbol of the token, usually a shorter version of\\n     * the name.\\n     */\\n    string public symbol;\\n\\n    /**\\n     * @notice Returns the amount of tokens in existence.\\n     */\\n    uint256 public totalSupply;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal allowances;\\n\\n    mapping(address =\\u003e uint256) internal balances;\\n}\\n\"},\"ExchangeProxyInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./TokenInterface.sol\\\";\\n\\n/**\\n * @title ExchangeProxyInterface\\n * @author Hifi\\n */\\ninterface ExchangeProxyInterface {\\n    function smartSwapExactIn(\\n        TokenInterface tokenIn,\\n        TokenInterface tokenOut,\\n        uint256 totalAmountIn,\\n        uint256 minTotalAmountOut,\\n        uint256 nPools\\n    ) external payable returns (uint256 totalAmountOut);\\n\\n    function smartSwapExactOut(\\n        TokenInterface tokenIn,\\n        TokenInterface tokenOut,\\n        uint256 totalAmountOut,\\n        uint256 maxTotalAmountIn,\\n        uint256 nPools\\n    ) external payable returns (uint256 totalAmountIn);\\n}\\n\"},\"Exponential.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./CarefulMath.sol\\\";\\nimport \\\"./ExponentialStorage.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals.\\n * @author Paul Razvan Berg\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n * Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is: `Exp({mantissa: 5100000000000000000})`.\\n * @dev Forked from Compound\\n * https://github.com/compound-finance/compound-protocol/blob/v2.6/contracts/Exponential.sol\\n */\\nabstract contract Exponential is\\n    CarefulMath, /* no dependency */\\n    ExponentialStorage /* no dependency */\\n{\\n    /**\\n     * @dev Adds two exponentials, returning a new exponential.\\n     */\\n    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n        (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({ mantissa: result }));\\n    }\\n\\n    /**\\n     * @dev Divides two exponentials, returning a new exponential.\\n     * (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b.\\n     * NOTE: Returns an error if (`num` * 10e18) \\u003e MAX_INT, or if `denom` is zero.\\n     */\\n    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n        (MathError err0, uint256 scaledNumerator) = mulUInt(a.mantissa, expScale);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({ mantissa: 0 }));\\n        }\\n\\n        (MathError err1, uint256 rational) = divUInt(scaledNumerator, b.mantissa);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({ mantissa: 0 }));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({ mantissa: rational }));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials, returning a new exponential.\\n     */\\n    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n        (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({ mantissa: 0 }));\\n        }\\n\\n        /*\\n         * We add half the scale before dividing so that we get rounding instead of truncation.\\n         * See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717\\n         * Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\\n         */\\n        (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({ mantissa: 0 }));\\n        }\\n\\n        (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);\\n        /* The only possible error `div` is MathError.DIVISION_BY_ZERO but we control `expScale` and it\\u0027s not zero. */\\n        assert(err2 == MathError.NO_ERROR);\\n\\n        return (MathError.NO_ERROR, Exp({ mantissa: product }));\\n    }\\n\\n    /**\\n     * @dev Multiplies three exponentials, returning a new exponential.\\n     */\\n    function mulExp3(\\n        Exp memory a,\\n        Exp memory b,\\n        Exp memory c\\n    ) internal pure returns (MathError, Exp memory) {\\n        (MathError err, Exp memory ab) = mulExp(a, b);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, ab);\\n        }\\n        return mulExp(ab, c);\\n    }\\n\\n    /**\\n     * @dev Subtracts two exponentials, returning a new exponential.\\n     */\\n    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n        (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({ mantissa: result }));\\n    }\\n}\\n\"},\"ExponentialStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: LPGL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title ExponentialStorage\\n * @author Paul Razvan Berg\\n * @notice The storage interface ancillary to an Exponential contract.\\n */\\nabstract contract ExponentialStorage {\\n    struct Exp {\\n        uint256 mantissa;\\n    }\\n\\n    /**\\n     * @dev In Exponential denomination, 1e18 is 1.\\n     */\\n    uint256 internal constant expScale = 1e18;\\n    uint256 internal constant halfExpScale = expScale / 2;\\n    uint256 internal constant mantissaOne = expScale;\\n}\\n\"},\"FintrollerInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LPGL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./FintrollerStorage.sol\\\";\\nimport \\\"./FyTokenInterface.sol\\\";\\nimport \\\"./ChainlinkOperatorInterface.sol\\\";\\n\\nabstract contract FintrollerInterface is FintrollerStorage {\\n    /**\\n     * CONSTANT FUNCTIONS\\n     */\\n\\n    function getBond(FyTokenInterface fyToken)\\n        external\\n        view\\n        virtual\\n        returns (\\n            uint256 debtCeiling,\\n            uint256 collateralizationRatioMantissa,\\n            bool isBorrowAllowed,\\n            bool isDepositCollateralAllowed,\\n            bool isLiquidateBorrowAllowed,\\n            bool isListed,\\n            bool isRedeemFyTokenAllowed,\\n            bool isRepayBorrowAllowed,\\n            bool isSupplyUnderlyingAllowed\\n        );\\n\\n    function getBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);\\n\\n    function getBondCollateralizationRatio(FyTokenInterface fyToken) external view virtual returns (uint256);\\n\\n    function getBondDebtCeiling(FyTokenInterface fyToken) external view virtual returns (uint256);\\n\\n    function getDepositCollateralAllowed(FyTokenInterface fyToken) external view virtual returns (bool);\\n\\n    function getLiquidateBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);\\n\\n    function getRedeemFyTokensAllowed(FyTokenInterface fyToken) external view virtual returns (bool);\\n\\n    function getRepayBorrowAllowed(FyTokenInterface fyToken) external view virtual returns (bool);\\n\\n    function getSupplyUnderlyingAllowed(FyTokenInterface fyToken) external view virtual returns (bool);\\n\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n\\n    function listBond(FyTokenInterface fyToken) external virtual returns (bool);\\n\\n    function setBondCollateralizationRatio(FyTokenInterface fyToken, uint256 newCollateralizationRatioMantissa)\\n        external\\n        virtual\\n        returns (bool);\\n\\n    function setBondDebtCeiling(FyTokenInterface fyToken, uint256 newDebtCeiling) external virtual returns (bool);\\n\\n    function setBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);\\n\\n    function setDepositCollateralAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);\\n\\n    function setLiquidateBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);\\n\\n    function setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external virtual returns (bool);\\n\\n    function setOracle(ChainlinkOperatorInterface newOracle) external virtual returns (bool);\\n\\n    function setRedeemFyTokensAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);\\n\\n    function setRepayBorrowAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);\\n\\n    function setSupplyUnderlyingAllowed(FyTokenInterface fyToken, bool state) external virtual returns (bool);\\n\\n    /**\\n     * EVENTS\\n     */\\n    event ListBond(address indexed admin, FyTokenInterface indexed fyToken);\\n\\n    event SetBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);\\n\\n    event SetBondCollateralizationRatio(\\n        address indexed admin,\\n        FyTokenInterface indexed fyToken,\\n        uint256 oldCollateralizationRatio,\\n        uint256 newCollateralizationRatio\\n    );\\n\\n    event SetBondDebtCeiling(\\n        address indexed admin,\\n        FyTokenInterface indexed fyToken,\\n        uint256 oldDebtCeiling,\\n        uint256 newDebtCeiling\\n    );\\n\\n    event SetDepositCollateralAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);\\n\\n    event SetLiquidateBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);\\n\\n    event SetLiquidationIncentive(\\n        address indexed admin,\\n        uint256 oldLiquidationIncentive,\\n        uint256 newLiquidationIncentive\\n    );\\n\\n    event SetRedeemFyTokensAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);\\n\\n    event SetRepayBorrowAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);\\n\\n    event SetOracle(address indexed admin, address oldOracle, address newOracle);\\n\\n    event SetSupplyUnderlyingAllowed(address indexed admin, FyTokenInterface indexed fyToken, bool state);\\n}\\n\"},\"FintrollerStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Exponential.sol\\\";\\n\\nimport \\\"./FyTokenInterface.sol\\\";\\nimport \\\"./ChainlinkOperatorInterface.sol\\\";\\n\\n/**\\n * @title FintrollerStorage\\n * @author Hifi\\n */\\nabstract contract FintrollerStorage is Exponential {\\n    struct Bond {\\n        Exp collateralizationRatio;\\n        uint256 debtCeiling;\\n        bool isBorrowAllowed;\\n        bool isDepositCollateralAllowed;\\n        bool isLiquidateBorrowAllowed;\\n        bool isListed;\\n        bool isRedeemFyTokenAllowed;\\n        bool isRepayBorrowAllowed;\\n        bool isSupplyUnderlyingAllowed;\\n    }\\n\\n    /**\\n     * @dev Maps the fyToken address to the Bond structs.\\n     */\\n    mapping(FyTokenInterface =\\u003e Bond) internal bonds;\\n\\n    /**\\n     * @notice The contract that provides price data for the collateral and the underlying asset.\\n     */\\n    ChainlinkOperatorInterface public oracle;\\n\\n    /**\\n     * @notice Multiplier representing the discount on collateral that a liquidator receives.\\n     */\\n    uint256 public liquidationIncentiveMantissa;\\n\\n    /**\\n     * @dev The threshold below which the collateralization ratio cannot be set, equivalent to 100%.\\n     */\\n    uint256 internal constant collateralizationRatioLowerBoundMantissa = 1.0e18;\\n\\n    /**\\n     * @dev The threshold above which the collateralization ratio cannot be set, equivalent to 10,000%.\\n     */\\n    uint256 internal constant collateralizationRatioUpperBoundMantissa = 1.0e20;\\n\\n    /**\\n     * @dev The dafault collateralization ratio set when a new bond is listed, equivalent to 150%.\\n     */\\n    uint256 internal constant defaultCollateralizationRatioMantissa = 1.5e18;\\n\\n    /**\\n     * @dev The threshold below which the liquidation incentive cannot be set, equivalent to 100%.\\n     */\\n    uint256 internal constant liquidationIncentiveLowerBoundMantissa = 1.0e18;\\n\\n    /**\\n     * @dev The threshold above which the liquidation incentive cannot be set, equivalent to 150%.\\n     */\\n    uint256 internal constant liquidationIncentiveUpperBoundMantissa = 1.5e18;\\n\\n    /**\\n     * @notice Indicator that this is a Fintroller contract, for inspection.\\n     */\\n    bool public constant isFintroller = true;\\n}\\n\"},\"FyTokenInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Interface.sol\\\";\\nimport \\\"./FyTokenStorage.sol\\\";\\n\\n/**\\n * @title FyTokenInterface\\n * @author Hifi\\n */\\nabstract contract FyTokenInterface is\\n    FyTokenStorage, /* no dependency */\\n    Erc20Interface /* one dependency */\\n{\\n    /**\\n     * CONSTANT FUNCTIONS\\n     */\\n    function isMatured() public view virtual returns (bool);\\n\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n    function borrow(uint256 borrowAmount) external virtual returns (bool);\\n\\n    function burn(address holder, uint256 burnAmount) external virtual returns (bool);\\n\\n    function liquidateBorrow(address borrower, uint256 repayAmount) external virtual returns (bool);\\n\\n    function mint(address beneficiary, uint256 mintAmount) external virtual returns (bool);\\n\\n    function repayBorrow(uint256 repayAmount) external virtual returns (bool);\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (bool);\\n\\n    function _setFintroller(FintrollerInterface newFintroller) external virtual returns (bool);\\n\\n    /**\\n     * EVENTS\\n     */\\n    event Borrow(address indexed borrower, uint256 borrowAmount);\\n\\n    event LiquidateBorrow(\\n        address indexed liquidator,\\n        address indexed borrower,\\n        uint256 repayAmount,\\n        uint256 clutchedCollateralAmount\\n    );\\n\\n    event RepayBorrow(address indexed payer, address indexed borrower, uint256 repayAmount, uint256 newDebt);\\n\\n    event SetFintroller(address indexed admin, FintrollerInterface oldFintroller, FintrollerInterface newFintroller);\\n}\\n\"},\"FyTokenStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Interface.sol\\\";\\nimport \\\"./BalanceSheetInterface.sol\\\";\\nimport \\\"./FintrollerInterface.sol\\\";\\nimport \\\"./RedemptionPoolInterface.sol\\\";\\n\\n/**\\n * @title FyTokenStorage\\n * @author Hifi\\n */\\nabstract contract FyTokenStorage {\\n    /**\\n     * STORAGE PROPERTIES\\n     */\\n\\n    /**\\n     * @notice The global debt registry.\\n     */\\n    BalanceSheetInterface public balanceSheet;\\n\\n    /**\\n     * @notice The Erc20 asset that backs the borrows of this fyToken.\\n     */\\n    Erc20Interface public collateral;\\n\\n    /**\\n     * @notice The ratio between mantissa precision (1e18) and the collateral precision.\\n     */\\n    uint256 public collateralPrecisionScalar;\\n\\n    /**\\n     * @notice Unix timestamp in seconds for when this token expires.\\n     */\\n    uint256 public expirationTime;\\n\\n    /**\\n     * @notice The unique Fintroller associated with this contract.\\n     */\\n    FintrollerInterface public fintroller;\\n\\n    /**\\n     * @notice The unique Redemption Pool associated with this contract.\\n     */\\n    RedemptionPoolInterface public redemptionPool;\\n\\n    /**\\n     * @notice The Erc20 underlying, or target, asset for this fyToken.\\n     */\\n    Erc20Interface public underlying;\\n\\n    /**\\n     * @notice The ratio between mantissa precision (1e18) and the underlying precision.\\n     */\\n    uint256 public underlyingPrecisionScalar;\\n\\n    /**\\n     * @notice Indicator that this is a FyToken contract, for inspection.\\n     */\\n    bool public constant isFyToken = true;\\n}\\n\"},\"RedemptionPoolInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./RedemptionPoolStorage.sol\\\";\\n\\n/**\\n * @title RedemptionPoolInterface\\n * @author Hifi\\n */\\nabstract contract RedemptionPoolInterface is RedemptionPoolStorage {\\n    /**\\n     * NON-CONSTANT FUNCTIONS\\n     */\\n    function redeemFyTokens(uint256 fyTokenAmount) external virtual returns (bool);\\n\\n    function supplyUnderlying(uint256 underlyingAmount) external virtual returns (bool);\\n\\n    /**\\n     * EVENTS\\n     */\\n    event RedeemFyTokens(address indexed account, uint256 fyTokenAmount, uint256 underlyingAmount);\\n\\n    event SupplyUnderlying(address indexed account, uint256 underlyingAmount, uint256 fyTokenAmount);\\n}\\n\"},\"RedemptionPoolStorage.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./FintrollerInterface.sol\\\";\\nimport \\\"./FyTokenInterface.sol\\\";\\n\\n/**\\n * @title RedemptionPoolStorage\\n * @author Hifi\\n */\\nabstract contract RedemptionPoolStorage {\\n    /**\\n     * @notice The unique Fintroller associated with this contract.\\n     */\\n    FintrollerInterface public fintroller;\\n\\n    /**\\n     * @notice The amount of the underlying asset available to be redeemed after maturation.\\n     */\\n    uint256 public totalUnderlyingSupply;\\n\\n    /**\\n     * The unique fyToken associated with this Redemption Pool.\\n     */\\n    FyTokenInterface public fyToken;\\n\\n    /**\\n     * @notice Indicator that this is a Redemption Pool contract, for inspection.\\n     */\\n    bool public constant isRedemptionPool = true;\\n}\\n\"},\"SafeErc20.sol\":{\"content\":\"/* SPDX-License-Identifier: MIT */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Interface.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeErc20.sol\\n * @author Paul Razvan Berg\\n * @notice Wraps around Erc20 operations that throw on failure (when the token contract\\n * returns false). Tokens that return no value (and instead revert or throw\\n * on failure) are also supported, non-reverting calls are assumed to be successful.\\n *\\n * To use this library you can add a `using SafeErc20 for Erc20Interface;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n *\\n * @dev Forked from OpenZeppelin\\n * https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v3.1.0/contracts/utils/Address.sol\\n */\\nlibrary SafeErc20 {\\n    using Address for address;\\n\\n    /**\\n     * INTERNAL FUNCTIONS\\n     */\\n\\n    function safeTransfer(\\n        Erc20Interface token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, amount));\\n    }\\n\\n    function safeTransferFrom(\\n        Erc20Interface token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\\n    }\\n\\n    /**\\n     * PRIVATE FUNCTIONS\\n     */\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it cannot be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(Erc20Interface token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n        bytes memory returndata = functionCall(address(token), data, \\\"ERR_SAFE_ERC20_LOW_LEVEL_CALL\\\");\\n        if (returndata.length \\u003e 0) {\\n            /* Return data is optional. */\\n            require(abi.decode(returndata, (bool)), \\\"ERR_SAFE_ERC20_ERC20_OPERATION\\\");\\n        }\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) private returns (bytes memory) {\\n        require(target.isContract(), \\\"ERR_SAFE_ERC20_CALL_TO_NON_CONTRACT\\\");\\n\\n        /* solhint-disable-next-line avoid-low-level-calls */\\n        (bool success, bytes memory returndata) = target.call(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            /* Look for revert reason and bubble it up if present */\\n            if (returndata.length \\u003e 0) {\\n                /* The easiest way to bubble the revert reason is using memory via assembly. */\\n\\n                /* solhint-disable-next-line no-inline-assembly */\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"TokenInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title TokenInterface\\n * @author Hifi\\n * @dev Forked from Balancer\\n * https://github.com/balancer-labs/balancer-registry/blob/3d5fc37/contracts/ExchangeProxy.sol\\n */\\ninterface TokenInterface {\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function allowance(address, address) external view returns (uint256);\\n\\n    function approve(address, uint256) external returns (bool);\\n\\n    function transfer(address, uint256) external returns (bool);\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\\n\"},\"WethInterface.sol\":{\"content\":\"/* SPDX-License-Identifier: LGPL-3.0-or-later */\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Erc20Interface.sol\\\";\\n\\n/**\\n * @title WethInterface\\n * @author Hifi\\n */\\ninterface WethInterface {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fyTokenDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"BorrowAndSellFyTokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EXCHANGE_PROXY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"borrowAndSellFyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"depositAndLockCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"depositAndLockCollateralAndBorrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"depositAndLockCollateralAndBorrowAndSellFyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"depositCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"freeAndWithdrawCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"freeCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"lockCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"lockCollateralAndBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"}],\"name\":\"openVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fyTokenAmount\",\"type\":\"uint256\"}],\"name\":\"redeemFyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repayBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"sellUnderlyingAndRepayBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"supplyUnderlying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"supplyUnderlyingAndRepayBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"}],\"name\":\"wrapEthAndDepositAndLockCollateral\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"wrapEthAndDepositAndLockCollateralAndBorrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BalanceSheetInterface\",\"name\":\"balanceSheet\",\"type\":\"address\"},{\"internalType\":\"contract FyTokenInterface\",\"name\":\"fyToken\",\"type\":\"address\"}],\"name\":\"wrapEthAndDepositCollateral\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"BatterseaTargetV1","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e968fc353d6d9a4775722a0ede4b55e4c4ddb6e67a0fd73f106d4ae3e0ebcc61"}]