[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\ninterface P3D {\r\n  function() payable external;\r\n  function buy(address _playerAddress) payable external returns(uint256);\r\n  function sell(uint256 _amountOfTokens) external;\r\n  function reinvest() external;\r\n  function withdraw() external;\r\n  function exit() external;\r\n  function dividendsOf(address _playerAddress) external view returns(uint256);\r\n  function balanceOf(address _playerAddress) external view returns(uint256);\r\n  function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\r\n  function stakingRequirement() external view returns(uint256);\r\n  function myDividends(bool _includeReferralBonus) external view returns(uint256);\r\n}\r\n\r\ncontract ProxyCrop {\r\n    address public owner;\r\n    bool public disabled;\r\n\r\n    constructor(address _owner, address _referrer) public payable {\r\n      owner = _owner;\r\n\r\n      // plant some seeds\r\n      if (msg.value > 0) {\r\n        P3D(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe).buy.value(msg.value)(_referrer);\r\n      }\r\n    }\r\n\r\n    function() public payable {\r\n      assembly {\r\n        // Copy msg.data. We take full control of memory in this inline assembly\r\n        // block because it will not return to Solidity code. We overwrite the\r\n        // Solidity scratch pad at memory position 0.\r\n        calldatacopy(0, 0, calldatasize)\r\n\r\n        // Call the implementation.\r\n        // out and outsize are 0 because we don't know the size yet.\r\n        let result := delegatecall(gas, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, calldatasize, 0, 0)\r\n\r\n        // Copy the returned data.\r\n        returndatacopy(0, 0, returndatasize)\r\n\r\n        switch result\r\n        // delegatecall returns 0 on error.\r\n        case 0 { revert(0, returndatasize) }\r\n        default { return(0, returndatasize) }\r\n      }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"disabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_referrer\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ProxyCrop","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003bd131a9df9a681330c2d39bddf0eede3fef356c0000000000000000000000003bd131a9df9a681330c2d39bddf0eede3fef356c","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"1","Implementation":"0x0d6c969d0004b431189f834203ce0f5530e06259","SwarmSource":"bzzr://3be87f20164327ab3c3cd1a589de4687882c771dd10607c31bbeb550485c8f12"}]