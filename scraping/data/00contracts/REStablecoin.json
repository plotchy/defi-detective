[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Base/IERC20Full.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\r\\n\\r\\ninterface IERC20Full is IERC20Metadata, IERC20Permit {\\r\\n    /** This function might not exist */\\r\\n    function version() external view returns (string memory);\\r\\n}\"\r\n    },\r\n    \"contracts/Base/IOwned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\ninterface IOwned\\r\\n{\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    \\r\\n    error NotOwner();\\r\\n    error AlreadyInitialized();\\r\\n\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n    function transferOwnership(address newOwner) external;\\r\\n    function claimOwnership() external;\\r\\n}\"\r\n    },\r\n    \"contracts/Base/IRECoverable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"../Library/CheapSafeERC20.sol\\\";\\r\\n\\r\\ninterface IRECoverable\\r\\n{\\r\\n    error NotRECoverableOwner();\\r\\n    \\r\\n    function recoverERC20(IERC20 token) external;\\r\\n    function recoverNative() external;\\r\\n}\"\r\n    },\r\n    \"contracts/Base/IUpgradeableBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./IUUPSUpgradeableVersion.sol\\\";\\r\\nimport \\\"./IRECoverable.sol\\\";\\r\\nimport \\\"./IOwned.sol\\\";\\r\\n\\r\\ninterface IUpgradeableBase is IUUPSUpgradeableVersion, IRECoverable, IOwned\\r\\n{\\r\\n}\"\r\n    },\r\n    \"contracts/Base/IUUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\ninterface IUUPSUpgradeable\\r\\n{\\r\\n    event Upgraded(address newImplementation);\\r\\n\\r\\n    error ProxyDelegateCallRequired();\\r\\n    error DelegateCallForbidden();\\r\\n    error ProxyNotActive();\\r\\n    error NotUUPS();\\r\\n    error UnsupportedProxiableUUID();\\r\\n    error UpgradeCallFailed();\\r\\n    \\r\\n    function proxiableUUID() external view returns (bytes32);\\r\\n    \\r\\n    function upgradeTo(address newImplementation) external;\\r\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external;\\r\\n}\"\r\n    },\r\n    \"contracts/Base/IUUPSUpgradeableVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./IUUPSUpgradeable.sol\\\";\\r\\n\\r\\ninterface IUUPSUpgradeableVersion is IUUPSUpgradeable\\r\\n{\\r\\n    error UpgradeToSameVersion();\\r\\n\\r\\n    function contractVersion() external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/Base/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./IOwned.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\r\\n\\r\\n/**\\r\\n    Allows contract ownership, but not renunciation\\r\\n */\\r\\nabstract contract Owned is IOwned\\r\\n{\\r\\n    bytes32 private constant OwnerSlot = keccak256(\\\"SLOT:Owned:owner\\\");\\r\\n    bytes32 private constant PendingOwnerSlot = keccak256(\\\"SLOT:Owned:pendingOwner\\\");\\r\\n\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\r\\n    address private immutable firstOwner = msg.sender;\\r\\n\\r\\n    function owner() public view returns (address)\\r\\n    {\\r\\n        address o = StorageSlot.getAddressSlot(OwnerSlot).value;\\r\\n        return o == address(0) ? firstOwner : o;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        StorageSlot.getAddressSlot(PendingOwnerSlot).value = newOwner;\\r\\n    }\\r\\n\\r\\n    function claimOwnership()\\r\\n        public\\r\\n    {\\r\\n        StorageSlot.AddressSlot storage pending = StorageSlot.getAddressSlot(PendingOwnerSlot);\\r\\n        if (pending.value != msg.sender) { revert NotOwner(); }\\r\\n        emit OwnershipTransferred(owner(), msg.sender);\\r\\n        pending.value = address(0);\\r\\n        StorageSlot.getAddressSlot(OwnerSlot).value = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() \\r\\n    {\\r\\n        if (msg.sender != owner()) { revert NotOwner(); }\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Base/RECoverable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./IRECoverable.sol\\\";\\r\\n\\r\\nusing CheapSafeERC20 for IERC20;\\r\\n\\r\\n/**\\r\\n    Allows for recovery of funds\\r\\n */\\r\\nabstract contract RECoverable is IRECoverable \\r\\n{\\r\\n    // Probably implemented using \\\"Owned\\\" contract functions\\r\\n    function getRECoverableOwner() internal virtual view returns (address);\\r\\n\\r\\n    function recoverERC20(IERC20 token)\\r\\n        public\\r\\n    {\\r\\n        if (msg.sender != getRECoverableOwner()) { revert NotRECoverableOwner(); }\\r\\n        beforeRecoverERC20(token);\\r\\n        token.safeTransfer(msg.sender, token.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function beforeRecoverERC20(IERC20 token) internal virtual {}\\r\\n\\r\\n    function recoverNative()\\r\\n        public\\r\\n    {\\r\\n        if (msg.sender != getRECoverableOwner()) { revert NotRECoverableOwner(); }\\r\\n        beforeRecoverNative();\\r\\n        (bool success,) = msg.sender.call{ value: address(this).balance }(\\\"\\\"); \\r\\n        assert(success);\\r\\n    }\\r\\n\\r\\n    function beforeRecoverNative() internal virtual {}\\r\\n}\"\r\n    },\r\n    \"contracts/Base/UpgradeableBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./UUPSUpgradeableVersion.sol\\\";\\r\\nimport \\\"./RECoverable.sol\\\";\\r\\nimport \\\"./Owned.sol\\\";\\r\\nimport \\\"./IUpgradeableBase.sol\\\";\\r\\n\\r\\n/**\\r\\n    All deployable upgradeable contracts should derive from this\\r\\n */\\r\\nabstract contract UpgradeableBase is UUPSUpgradeableVersion, RECoverable, Owned, IUpgradeableBase\\r\\n{\\r\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n    constructor(uint256 __contractVersion)\\r\\n        UUPSUpgradeableVersion(__contractVersion)\\r\\n    {\\r\\n    }\\r\\n\\r\\n    function getRECoverableOwner() internal override view returns (address) { return owner(); }\\r\\n    \\r\\n    function beforeUpgradeVersion(address newImplementation)\\r\\n        internal\\r\\n        override\\r\\n        view\\r\\n        onlyOwner\\r\\n    {\\r\\n        checkUpgradeBase(newImplementation);\\r\\n    }\\r\\n\\r\\n    function checkUpgradeBase(address newImplementation) internal virtual view;\\r\\n}\"\r\n    },\r\n    \"contracts/Base/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\r\\nimport \\\"./IUUPSUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n    Adapted from openzeppelin's UUPSUpgradeable\\r\\n\\r\\n    However, with some notable differences\\r\\n        \\r\\n        We don't use the whole \\\"initializers\\\" scheme.  It's error-prone and awkward.  A couple contracts\\r\\n        may have an initialize function, but it's not some special built-in scheme that can be screwed up.\\r\\n\\r\\n        We don't use beacons, and we don't need to upgrade from old UUPS or other types of proxies.  We\\r\\n        only support UUPS.  We don't support rollbacks.\\r\\n\\r\\n        We don't use default-slot storage.  It's also error-prone and awkward.  It's weird that it was ever\\r\\n        done that way in the first place.  But regardless, we don't.\\r\\n\\r\\n        We have no concept of \\\"Admin\\\" at this stage.  Whoever implements \\\"beforeUpgrade\\\" can decide to\\r\\n        check access if they want to.  For us, we do this in \\\"UpgradeableBase\\\".\\r\\n\\r\\n */\\r\\n\\r\\nabstract contract UUPSUpgradeable is IUUPSUpgradeable\\r\\n{\\r\\n    bytes32 private constant ImplementationSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\r\\n    address private immutable self = address(this);\\r\\n\\r\\n    function beforeUpgrade(address newImplementation) internal virtual view;\\r\\n    \\r\\n    modifier notDelegated()\\r\\n    {\\r\\n        if (address(this) != self) { revert DelegateCallForbidden(); }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyProxy()\\r\\n    {\\r\\n        if (address(this) == self) { revert ProxyDelegateCallRequired(); }\\r\\n        if (StorageSlot.getAddressSlot(ImplementationSlot).value != self) { revert ProxyNotActive(); }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function proxiableUUID()\\r\\n        public\\r\\n        virtual\\r\\n        view\\r\\n        notDelegated\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return ImplementationSlot;\\r\\n    }\\r\\n\\r\\n    function upgradeTo(address newImplementation)\\r\\n        public\\r\\n        onlyProxy\\r\\n    {\\r\\n        try IUUPSUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot)\\r\\n        {\\r\\n            if (slot != ImplementationSlot) { revert UnsupportedProxiableUUID(); }\\r\\n            beforeUpgrade(newImplementation);\\r\\n            StorageSlot.getAddressSlot(ImplementationSlot).value = newImplementation;\\r\\n            emit Upgraded(newImplementation);\\r\\n        }\\r\\n        catch\\r\\n        {\\r\\n            revert NotUUPS();\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function upgradeToAndCall(address newImplementation, bytes memory data)\\r\\n        public\\r\\n    {\\r\\n        upgradeTo(newImplementation);\\r\\n        /// @custom:oz-upgrades-unsafe-allow delegatecall\\r\\n        (bool success, bytes memory returndata) = newImplementation.delegatecall(data);\\r\\n        if (!success)\\r\\n        {\\r\\n            if (returndata.length > 0)\\r\\n            {\\r\\n                assembly\\r\\n                {                                \\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            }\\r\\n            revert UpgradeCallFailed();\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Base/UUPSUpgradeableVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./UUPSUpgradeable.sol\\\";\\r\\nimport \\\"./IUUPSUpgradeableVersion.sol\\\";\\r\\n\\r\\n/**\\r\\n    Adds contract versioning\\r\\n\\r\\n    Contract upgrades to a new contract with the same version will be rejected\\r\\n */\\r\\nabstract contract UUPSUpgradeableVersion is UUPSUpgradeable, IUUPSUpgradeableVersion\\r\\n{\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\r\\n    uint256 private immutable _contractVersion;\\r\\n\\r\\n    function contractVersion() public virtual view returns (uint256) { return _contractVersion; }\\r\\n    \\r\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n    constructor(uint256 __contractVersion)\\r\\n    {\\r\\n        _contractVersion = __contractVersion;\\r\\n    }\\r\\n\\r\\n    function beforeUpgrade(address newImplementation)\\r\\n        internal\\r\\n        override\\r\\n        view\\r\\n    {\\r\\n        if (IUUPSUpgradeableVersion(newImplementation).contractVersion() == contractVersion()) { revert UpgradeToSameVersion(); }        \\r\\n        beforeUpgradeVersion(newImplementation);\\r\\n    }\\r\\n\\r\\n    function beforeUpgradeVersion(address newImplementation) internal virtual view;\\r\\n}\"\r\n    },\r\n    \"contracts/IREStablecoins.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./Base/IERC20Full.sol\\\";\\r\\nimport \\\"./Base/IUpgradeableBase.sol\\\";\\r\\n\\r\\ninterface IREStablecoins is IUpgradeableBase\\r\\n{\\r\\n    struct StablecoinConfig\\r\\n    {\\r\\n        IERC20Full token;\\r\\n        uint8 decimals;\\r\\n        bool hasPermit;\\r\\n    }\\r\\n    struct StablecoinConfigWithName\\r\\n    {\\r\\n        StablecoinConfig config;\\r\\n        string name;\\r\\n        string symbol;\\r\\n    }\\r\\n\\r\\n    error TokenNotSupported();\\r\\n    error TokenMisconfigured();\\r\\n    error StablecoinAlreadyExists();\\r\\n    error StablecoinDoesNotExist();\\r\\n    error StablecoinBakedIn();\\r\\n\\r\\n    function isREStablecoins() external view returns (bool);\\r\\n    function supportedStablecoins() external view returns (StablecoinConfigWithName[] memory);\\r\\n    function getStablecoinConfig(address token) external view returns (StablecoinConfig memory config);\\r\\n\\r\\n    function addStablecoin(address stablecoin, bool hasPermit) external;\\r\\n    function removeStablecoin(address stablecoin) external;\\r\\n}\"\r\n    },\r\n    \"contracts/Library/CheapSafeCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n/*\\r\\n    Adapted from openzeppelin's `Address.sol`    \\r\\n*/\\r\\n\\r\\nlibrary CheapSafeCall\\r\\n{\\r\\n    /**\\r\\n        Makes a call\\r\\n        Returns true if the call succeeded, and it was to a contract address, and either nothing was returned or 'true' was returned\\r\\n        It does not revert on failures\\r\\n     */\\r\\n    function callOptionalBooleanNoThrow(address addr, bytes memory data) \\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        (bool success, bytes memory result) = addr.call(data);\\r\\n        return success && (result.length == 0 ? addr.code.length > 0 : abi.decode(result, (bool)));        \\r\\n    }\\r\\n    /**\\r\\n        Makes a call\\r\\n        Returns true if the call succeeded, and it was to a contract address, and either nothing was returned or 'true' was returned\\r\\n        Returns false if 'false' was returned\\r\\n        Returns false if the call failed and nothing was returned\\r\\n        Bubbles up the revert reason if the call reverted\\r\\n     */\\r\\n    function callOptionalBoolean(address addr, bytes memory data) \\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        (bool success, bytes memory result) = addr.call(data);\\r\\n        if (success) \\r\\n        {\\r\\n            return result.length == 0 ? addr.code.length > 0 : abi.decode(result, (bool));\\r\\n        }\\r\\n        else \\r\\n        {\\r\\n            if (result.length == 0) { return false; }\\r\\n            assembly \\r\\n            {\\r\\n                let resultSize := mload(result)\\r\\n                revert(add(32, result), resultSize)\\r\\n            }\\r\\n        }        \\r\\n    }\\r\\n    /**\\r\\n        Makes a call\\r\\n        Returns true if the call succeded, and it was to a contract address (ignores any return value)        \\r\\n        Returns false if the call succeeded and nothing was returned\\r\\n        Bubbles up the revert reason if the call reverted\\r\\n     */\\r\\n    function call(address addr, bytes memory data)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        (bool success, bytes memory result) = addr.call(data);\\r\\n        if (success)\\r\\n        {\\r\\n            return result.length > 0 || addr.code.length > 0;\\r\\n        }\\r\\n        if (result.length == 0) { return false; }\\r\\n        assembly \\r\\n        {\\r\\n            let resultSize := mload(result)\\r\\n            revert(add(32, result), resultSize)\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Library/CheapSafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./CheapSafeCall.sol\\\";\\r\\n\\r\\n/*\\r\\n    Adapted from openzeppelin's `SafeERC20.sol`\\r\\n\\r\\n    But implemented using custom errors, and with different 'safeApprove' functionality\\r\\n*/\\r\\n\\r\\nlibrary CheapSafeERC20 \\r\\n{\\r\\n    error TransferFailed();\\r\\n    error ApprovalFailed();\\r\\n\\r\\n    /**\\r\\n        Calls 'transfer' on an ERC20\\r\\n        On failure, reverts with either the ERC20's error message or 'TransferFailed'\\r\\n     */\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) \\r\\n        internal \\r\\n    {\\r\\n        if (!CheapSafeCall.callOptionalBoolean(address(token), abi.encodeWithSelector(token.transfer.selector, to, value))) { revert TransferFailed(); }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        Calls 'transferFrom' on an ERC20\\r\\n        On failure, reverts with either the ERC20's error message or 'TransferFailed'\\r\\n     */\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) \\r\\n        internal \\r\\n    {\\r\\n        if (!CheapSafeCall.callOptionalBoolean(address(token), abi.encodeWithSelector(token.transferFrom.selector, from, to, value))) { revert TransferFailed(); }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        Calls 'approve' on an ERC20\\r\\n        If it fails, it attempts to approve for 0 amount then to the requested amount\\r\\n        If that also fails, it will revert with either the ERC20's error message or 'ApprovalFailed'\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value)\\r\\n        internal\\r\\n    {\\r\\n        if (!CheapSafeCall.callOptionalBooleanNoThrow(address(token), abi.encodeWithSelector(token.approve.selector, spender, value)))\\r\\n        {\\r\\n            if (value == 0 ||\\r\\n                !CheapSafeCall.callOptionalBoolean(address(token), abi.encodeWithSelector(token.approve.selector, spender, 0)) ||\\r\\n                !CheapSafeCall.callOptionalBoolean(address(token), abi.encodeWithSelector(token.approve.selector, spender, value)))\\r\\n            {\\r\\n                revert ApprovalFailed(); \\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/REStablecoins.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: reup.cash\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./IREStablecoins.sol\\\";\\r\\nimport \\\"./Base/UpgradeableBase.sol\\\";\\r\\n\\r\\n/**\\r\\n    Supported stablecoins configuration\\r\\n\\r\\n    The \\\"baked in\\\" stablecoins are a gas optimization.  We support up to 3 of them, or could increase this (but we probably won't!)\\r\\n\\r\\n    All stablecoins MUST have 6 or 18 decimals.  If this ever changes, we need to change code in other contracts which rely on this behavior\\r\\n\\r\\n    For each stablecoin, we track the # of decimals and whether or not it supports \\\"permit\\\"\\r\\n\\r\\n    External contracts probably just call \\\"getStablecoinConfig\\\".  Everything else is front-end helpers or admin, pretty much.\\r\\n */\\r\\ncontract REStablecoins is UpgradeableBase(2), IREStablecoins\\r\\n{\\r\\n    address[] private moreStablecoinAddresses;\\r\\n    mapping (address => StablecoinConfig) private moreStablecoins;\\r\\n\\r\\n    //------------------ end of storage\\r\\n    \\r\\n    bool public constant isREStablecoins = true;\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\r\\n    uint256 private immutable stablecoin1; // Because `struct StablecoinConfig` can't be stored as immutable\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\r\\n    uint256 private immutable stablecoin2;\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\r\\n    uint256 private immutable stablecoin3;\\r\\n\\r\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n    constructor(StablecoinConfig memory _stablecoin1, StablecoinConfig memory _stablecoin2, StablecoinConfig memory _stablecoin3)\\r\\n    {\\r\\n        stablecoin1 = toUint256(_stablecoin1);\\r\\n        stablecoin2 = toUint256(_stablecoin2);\\r\\n        stablecoin3 = toUint256(_stablecoin3);\\r\\n    }\\r\\n\\r\\n    function checkUpgradeBase(address newImplementation)\\r\\n        internal\\r\\n        override\\r\\n        view\\r\\n    {\\r\\n        assert(IREStablecoins(newImplementation).isREStablecoins());\\r\\n    }\\r\\n\\r\\n    function supportedStablecoins()\\r\\n        public\\r\\n        view\\r\\n        returns (StablecoinConfigWithName[] memory stablecoins)\\r\\n    {\\r\\n        unchecked\\r\\n        {\\r\\n            uint256 builtInCount = 0;\\r\\n            if (stablecoin1 != 0) { ++builtInCount; }\\r\\n            if (stablecoin2 != 0) { ++builtInCount; }\\r\\n            if (stablecoin3 != 0) { ++builtInCount; }\\r\\n            stablecoins = new StablecoinConfigWithName[](builtInCount + moreStablecoinAddresses.length);\\r\\n            uint256 at = 0;\\r\\n            if (stablecoin1 != 0) { stablecoins[at++] = toStablecoinConfigWithName(toStablecoinConfig(stablecoin1)); }\\r\\n            if (stablecoin2 != 0) { stablecoins[at++] = toStablecoinConfigWithName(toStablecoinConfig(stablecoin2)); }\\r\\n            if (stablecoin3 != 0) { stablecoins[at++] = toStablecoinConfigWithName(toStablecoinConfig(stablecoin3)); }\\r\\n            for (uint256 x = moreStablecoinAddresses.length; x > 0;) \\r\\n            {\\r\\n                stablecoins[at++] = toStablecoinConfigWithName(moreStablecoins[moreStablecoinAddresses[--x]]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function toUint256(StablecoinConfig memory stablecoin)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {        \\r\\n        unchecked\\r\\n        {\\r\\n            if (address(stablecoin.token) == address(0)) { return 0; }\\r\\n            if (stablecoin.decimals != 6 && stablecoin.decimals != 18) { revert TokenNotSupported(); }\\r\\n            if (stablecoin.decimals != stablecoin.token.decimals()) { revert TokenMisconfigured(); }\\r\\n            if (stablecoin.hasPermit) { stablecoin.token.DOMAIN_SEPARATOR(); }\\r\\n            return uint256(uint160(address(stablecoin.token))) | (uint256(stablecoin.decimals) << 160) | (stablecoin.hasPermit ? 1 << 168 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function toStablecoinConfig(uint256 data)\\r\\n        private\\r\\n        pure\\r\\n        returns (StablecoinConfig memory config)\\r\\n    {\\r\\n        unchecked\\r\\n        {\\r\\n            config.token = IERC20Full(address(uint160(data)));\\r\\n            config.decimals = uint8(data >> 160);\\r\\n            config.hasPermit = data >> 168 != 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function toStablecoinConfigWithName(StablecoinConfig memory config)\\r\\n        private\\r\\n        view\\r\\n        returns (StablecoinConfigWithName memory configWithName)\\r\\n    {\\r\\n        return StablecoinConfigWithName({\\r\\n            config: config,\\r\\n            name: config.token.name(),\\r\\n            symbol: config.token.symbol()\\r\\n        });\\r\\n    }\\r\\n\\r\\n    function getStablecoinConfig(address token)\\r\\n        public\\r\\n        view\\r\\n        returns (StablecoinConfig memory config)\\r\\n    {\\r\\n        unchecked\\r\\n        {\\r\\n            if (token == address(0)) { revert TokenNotSupported(); }\\r\\n            if (token == address(uint160(stablecoin1))) { return toStablecoinConfig(stablecoin1); }\\r\\n            if (token == address(uint160(stablecoin2))) { return toStablecoinConfig(stablecoin2); }\\r\\n            if (token == address(uint160(stablecoin3))) { return toStablecoinConfig(stablecoin3); }\\r\\n            config = moreStablecoins[token];\\r\\n            if (address(config.token) == address(0)) { revert TokenNotSupported(); }            \\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addStablecoin(address stablecoin, bool hasPermit)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        if (stablecoin == address(uint160(stablecoin1)) ||\\r\\n            stablecoin == address(uint160(stablecoin2)) ||\\r\\n            stablecoin == address(uint160(stablecoin3)) ||\\r\\n            address(moreStablecoins[stablecoin].token) != address(0))\\r\\n        {\\r\\n            revert StablecoinAlreadyExists();\\r\\n        }\\r\\n        if (hasPermit) { IERC20Full(stablecoin).DOMAIN_SEPARATOR(); }\\r\\n        uint8 decimals = IERC20Full(stablecoin).decimals();\\r\\n        if (decimals != 6 && decimals != 18) { revert TokenNotSupported(); }\\r\\n        moreStablecoinAddresses.push(stablecoin);\\r\\n        moreStablecoins[stablecoin] = StablecoinConfig({\\r\\n            token: IERC20Full(stablecoin),\\r\\n            decimals: decimals,\\r\\n            hasPermit: hasPermit\\r\\n        });\\r\\n    }\\r\\n\\r\\n    function removeStablecoin(address stablecoin)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        if (stablecoin == address(uint160(stablecoin1)) ||\\r\\n            stablecoin == address(uint160(stablecoin2)) ||\\r\\n            stablecoin == address(uint160(stablecoin3)))\\r\\n        {\\r\\n            revert StablecoinBakedIn();\\r\\n        }\\r\\n        if (address(moreStablecoins[stablecoin].token) == address(0)) { revert StablecoinDoesNotExist(); }\\r\\n        delete moreStablecoins[stablecoin];\\r\\n        for (uint256 x = moreStablecoinAddresses.length - 1; ; --x) \\r\\n        {\\r\\n            if (moreStablecoinAddresses[x] == stablecoin) \\r\\n            {\\r\\n                moreStablecoinAddresses[x] = moreStablecoinAddresses[moreStablecoinAddresses.length - 1];\\r\\n                moreStablecoinAddresses.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20Full\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"hasPermit\",\"type\":\"bool\"}],\"internalType\":\"struct IREStablecoins.StablecoinConfig\",\"name\":\"_stablecoin1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"contract IERC20Full\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"hasPermit\",\"type\":\"bool\"}],\"internalType\":\"struct IREStablecoins.StablecoinConfig\",\"name\":\"_stablecoin2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"contract IERC20Full\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"hasPermit\",\"type\":\"bool\"}],\"internalType\":\"struct IREStablecoins.StablecoinConfig\",\"name\":\"_stablecoin3\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DelegateCallForbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotRECoverableOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotUUPS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProxyDelegateCallRequired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProxyNotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StablecoinAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StablecoinBakedIn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StablecoinDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenMisconfigured\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsupportedProxiableUUID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UpgradeCallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UpgradeToSameVersion\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stablecoin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasPermit\",\"type\":\"bool\"}],\"name\":\"addStablecoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getStablecoinConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IERC20Full\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"hasPermit\",\"type\":\"bool\"}],\"internalType\":\"struct IREStablecoins.StablecoinConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isREStablecoins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stablecoin\",\"type\":\"address\"}],\"name\":\"removeStablecoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportedStablecoins\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"contract IERC20Full\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"hasPermit\",\"type\":\"bool\"}],\"internalType\":\"struct IREStablecoins.StablecoinConfig\",\"name\":\"config\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"internalType\":\"struct IREStablecoins.StablecoinConfigWithName[]\",\"name\":\"stablecoins\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"REStablecoins","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"99999","ConstructorArguments":"000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000001000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000000000000000000000000006b175474e89094c44da98b954eedeac495271d0f00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]