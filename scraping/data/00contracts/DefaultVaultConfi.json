[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/DefaultVaultConfig.sol\": {\r\n      \"content\": \"//.██████..███████.███████.██.....██████..██████...██████.\\n//.██...██.██......██......██.....██...██.██...██.██....██\\n//.██████..█████...█████...██.....██████..██████..██....██\\n//.██...██.██......██......██.....██......██...██.██....██\\n//.██...██.███████.██......██.....██......██...██..██████.\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\nimport { Auth, Authority } from \\\"solmate/auth/Auth.sol\\\";\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\n\\nimport { IVaultConfig } from \\\"./interfaces/IVaultConfig.sol\\\";\\nimport { RPVault } from \\\"./RPVault.sol\\\";\\n\\ncontract DefaultVaultConfig is Auth, IVaultConfig {\\n    bool public _isFeeEnabled = true;\\n    uint256 public _entryFeeBps = 100;\\n    uint256 public _exitFeeBps = 100;\\n\\n    uint256 public minimumStoredValueBeforeFees = 10_000 * 1e6; // 25k USDC\\n    uint256 public minimumRefiHeld = 1_000_000 * 1e18; // 1 million REFI\\n\\n    address public refiAddress;\\n    address public vaultAddress;\\n\\n    struct UserOverride {\\n        bool shouldOverrideCanDeposit;\\n        bool canDeposit;\\n        bool hasCustomMinimum;\\n        uint256 customMinimum;\\n    }\\n    mapping(address => UserOverride) public userOverrides;\\n\\n    error VaultNotSetup();\\n\\n    modifier onlyAfterVaultSetup() {\\n        if (!isVaultSetup()) {\\n            revert VaultNotSetup();\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        address _owner,\\n        address _refiAddress,\\n        address _vaultAddress\\n    ) Auth(msg.sender, Authority(address(0))) {\\n        refiAddress = _refiAddress;\\n        setVaultAddress(_vaultAddress);\\n\\n        // transactions from https://etherscan.io/address/0x00000997e18087b2477336fe87b0c486c6a2670d\\n        setUserOverride(0xad55d623201C26Ac599A4F6898fdD519d98D1070, true);\\n        setUserOverride(0x00d16F998e1f62fB2a58995dd2042f108eB800d1, true);\\n        setUserOverride(0x7e849911b62B91eb3623811A42b9820a4a78755b, true);\\n        setUserOverride(0x82D746d7d53515B22Ad058937EE4D139bA09Ff07, true);\\n        setUserOverride(0x9F58E312F9efFF3e055e75A154Df8C624D07Cde9, true);\\n        setUserOverride(0x5189d4978504CfB245D3ed918a6C2629Cac7b0df, true);\\n        setUserOverride(0xf4d430dD8EaA0412c802fFb450250cC8B6117895, true);\\n        setUserOverride(0xb6Aa99C580A5203A6C0d7FA40b88d09cb5D65911, true);\\n        setUserOverride(0x29b7e5E20820ec9A27896AE25f768B8F3B3Bc263, true);\\n\\n        // new\\n        setUserOverride(0xf3782301916F56598dDBE5c74C91fd1Aa52B4CC3, true);\\n\\n        setOwner(_owner);\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    // IVaultConfig ///////////////////////////////////////////////////////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    function canDeposit(address _user, uint256 _assets) external view onlyAfterVaultSetup returns (bool) {\\n        if (userOverrides[_user].shouldOverrideCanDeposit) {\\n            return userOverrides[_user].canDeposit;\\n        }\\n        if (userOverrides[_user].hasCustomMinimum) {\\n            return _assets + getAlreadyStoredValue(_user) >= userOverrides[_user].customMinimum;\\n        }\\n        if (isRefiHolder(_user)) {\\n            return true;\\n        }\\n        return _assets + getAlreadyStoredValue(_user) >= minimumStoredValueBeforeFees;\\n    }\\n\\n    function isFeeEnabled(address) external view onlyAfterVaultSetup returns (bool) {\\n        return _isFeeEnabled;\\n    }\\n\\n    function entryFeeBps(address) external view onlyAfterVaultSetup returns (uint256) {\\n        if (vaultAddress != address(0)) {\\n            return RPVault(vaultAddress).entryFeeBps();\\n        }\\n        return _entryFeeBps;\\n    }\\n\\n    function exitFeeBps(address) external view onlyAfterVaultSetup returns (uint256) {\\n        if (vaultAddress != address(0)) {\\n            return RPVault(vaultAddress).exitFeeBps();\\n        }\\n        return _entryFeeBps;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    // Helpers ////////////////////////////////////////////////////////////////\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    function isRefiHolder(address _user) internal view returns (bool) {\\n        ERC20 refi = ERC20(refiAddress);\\n        return refi.balanceOf(_user) >= minimumRefiHeld;\\n    }\\n\\n    function getAlreadyStoredValue(address _user) internal view returns (uint256) {\\n        RPVault vault = RPVault(vaultAddress);\\n        return vault.getStoredValue(_user);\\n    }\\n\\n    function isVaultSetup() internal view returns (bool) {\\n        return vaultAddress != address(0);\\n    }\\n\\n    function setVaultAddress(address _vaultAddress) public requiresAuth {\\n        vaultAddress = _vaultAddress;\\n    }\\n\\n    function setMinimumRefiHeld(uint256 _minimumRefiHeld) external requiresAuth {\\n        minimumRefiHeld = _minimumRefiHeld;\\n    }\\n\\n    function setRefiAddress(address _refiAddress) external requiresAuth {\\n        refiAddress = _refiAddress;\\n    }\\n\\n    function setMinimumDeposit(uint256 _assetAmount) external requiresAuth {\\n        minimumStoredValueBeforeFees = _assetAmount;\\n    }\\n\\n    function removeUserOverride(address _user) external requiresAuth {\\n        userOverrides[_user].shouldOverrideCanDeposit = false;\\n    }\\n\\n    function setUserOverride(address _user, bool _canDeposit) public requiresAuth {\\n        userOverrides[_user].shouldOverrideCanDeposit = true;\\n        userOverrides[_user].canDeposit = _canDeposit;\\n    }\\n\\n    function setUserCustomMinimum(address _user, uint256 _minimum) external requiresAuth {\\n        userOverrides[_user].hasCustomMinimum = true;\\n        userOverrides[_user].customMinimum = _minimum;\\n    }\\n\\n    function removeUserCustomMinimum(address _user) external requiresAuth {\\n        userOverrides[_user].hasCustomMinimum = false;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() virtual {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IVaultConfig.sol\": {\r\n      \"content\": \"//.██████..███████.███████.██.....██████..██████...██████.\\n//.██...██.██......██......██.....██...██.██...██.██....██\\n//.██████..█████...█████...██.....██████..██████..██....██\\n//.██...██.██......██......██.....██......██...██.██....██\\n//.██...██.███████.██......██.....██......██...██..██████.\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\ninterface IVaultConfig {\\n    function canDeposit(address _user, uint256 _assets) external view returns (bool);\\n\\n    function isFeeEnabled(address _user) external view returns (bool);\\n\\n    function entryFeeBps(address _user) external view returns (uint256);\\n\\n    function exitFeeBps(address _user) external view returns (uint256);\\n\\n    /// @dev management fee is the same for everyone\\n    // function managementFeeBps() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/RPVault.sol\": {\r\n      \"content\": \"//.██████..███████.███████.██.....██████..██████...██████.\\n//.██...██.██......██......██.....██...██.██...██.██....██\\n//.██████..█████...█████...██.....██████..██████..██....██\\n//.██...██.██......██......██.....██......██...██.██....██\\n//.██...██.███████.██......██.....██......██...██..██████.\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport { FixedPointMathLib } from \\\"solmate/utils/FixedPointMathLib.sol\\\";\\nimport { SafeTransferLib } from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\nimport { Auth, Authority } from \\\"solmate/auth/Auth.sol\\\";\\nimport { ERC4626Accounting } from \\\"./ERC4626Accounting.sol\\\";\\nimport { IVaultConfig } from \\\"./interfaces/IVaultConfig.sol\\\";\\n\\n/// @title RPVault\\n/// @notice epoch-based fund management contract that uses ERC4626 accounting logic.\\n/// @dev in this version, the contract does not actually use ERC4626 base functions.\\n/// @dev all vault tokens are stored in-contract, owned by farmer address.\\n/// @dev all assets are sent to farmer address each epoch change;\\n/// @dev except for: stored fee, pending withdrawals, & pending deposits.\\n/// @author mathdroid (https://github.com/mathdroid)\\ncontract RPVault is ERC4626Accounting, Auth {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /// ██████████████ vault metadata ████████████████████████████████████████\\n\\n    /// @notice aum = **external** assets under management\\n    uint256 public aum = 0;\\n    /// @notice aumCap = maximum aum allowed to be stored in the contract\\n    uint256 public aumCap = 0;\\n    /// @notice epoch = period of time where aum is being managed\\n    uint256 public epoch = 0;\\n    /// @notice farmer = administrative address, responsible for managing aum\\n    /// @dev the address where funds will go from/to the contract\\n    address public immutable farmer;\\n    /// @notice managementBlocksDuration = number of blocks where farmer can make amendments to the contract\\n    /// @dev this is to prevent mistakes when progressing epoch\\n    uint256 public managementBlocksDuration = 6000; // avg block time is 15 seconds, so this is ~24 hours\\n    /// @notice vault config contract\\n    address public vaultConfigAddress;\\n\\n    /// ██████████████ fees ███████████████████████████████████████████████████\\n\\n    /// @notice isFeeEnabled = flag to enable/disable fees\\n    bool public isFeeEnabled = false;\\n    /// @notice feeDistributor = address to receive fees from the contract\\n    address public feeDistributor;\\n    /// @notice managementFeeBps = management fee in basis points per second\\n    /// @dev only charged when delta AUM is positive in an epoch\\n    /// @dev management fee = (assetsExternalEnd - assetsExternalStart) * managementFeeBps / 1e5\\n    uint256 public managementFeeBps = 2000;\\n    /// @notice entry/exit fees are charged when a user enters/exits the contract\\n    uint256 public entryFeeBps = 100;\\n    /// @notice entry/exit fees are charged when a user enters/exits the contract\\n    uint256 public exitFeeBps = 100;\\n    /// @notice storedFee = the amount of stored fee in the contract\\n    uint256 public storedFee;\\n    /// @notice helper for fee calculation\\n    uint256 private constant BASIS = 10000;\\n\\n    /// ██████████████ vault state per epoch ██████████████████████████████████\\n    struct VaultState {\\n        /// @dev starting AUM this epoch\\n        uint256 assetsExternalStart;\\n        /// @dev assets deposited by users during this epoch\\n        uint256 assetsToDeposit;\\n        /// @dev shares unlocked during this epoch\\n        uint256 sharesToRedeem;\\n        /// @dev the number of external AUM at the end of epoch (after fees)\\n        uint256 assetsExternalEnd;\\n        /// @dev management fee captured this epoch. maybe 0 if delta AUM <= 0\\n        /// @dev managementFee + assetsExternalEnd == aum input by farmer\\n        uint256 managementFee;\\n        /// @dev total vault tokens supply\\n        /// @dev no difference start/end of the epoch\\n        uint256 totalSupply;\\n        /// @dev last block number where farmer can edit the aum\\n        /// @dev only farmer can interact with contract before this blocknumber\\n        uint256 lastManagementBlock;\\n    }\\n    /// @notice vaultState = array of vault states per epoch\\n    mapping(uint256 => VaultState) public vaultStates;\\n\\n    /// ██████████████ user balances ██████████████████████████████████████████\\n    struct VaultUser {\\n        /// @dev assets currently deposited, not yet included in aum\\n        /// @dev should be zeroed after epoch change (shares minted)\\n        uint256 assetsDeposited;\\n        /// @dev last epoch where user deposited assets\\n        uint256 epochLastDeposited;\\n        /// @dev glorified `balanceOf`\\n        uint256 vaultShares;\\n        /// @dev shares to be unlocked next epoch\\n        uint256 sharesToRedeem;\\n        /// @dev the epoch where user can start withdrawing the unlocked shares\\n        /// @dev use this epoch's redemption rate (aum/totalSupply) to calculate the amount of assets to be withdrawn\\n        uint256 epochToRedeem;\\n    }\\n    /// @notice vaultUsers = array of user balances per address\\n    mapping(address => VaultUser) public vaultUsers;\\n\\n    /// ██████████████ errors █████████████████████████████████████████████████\\n\\n    /// ░░░░░░░░░░░░░░ internal ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\n    /// @notice transaction will result in zero shares given\\n    error DepositReturnsZeroShares();\\n    /// @notice transaction will result in zero assets given\\n    error RedeemReturnsZeroAssets();\\n    /// ░░░░░░░░░░░░░░ epoch ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\n    /// @notice vault is still initializing\\n    error VaultIsInitializing();\\n    /// @notice vault has been initialized\\n    error VaultAlreadyInitialized();\\n\\n    /// ░░░░░░░░░░░░░░ management phase ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\n    /// @notice farmer function called outside management phase\\n    error OnlyAtManagementPhase();\\n    /// @notice public function called during management phase\\n    error OnlyOutsideManagementPhase();\\n\\n    /// ░░░░░░░░░░░░░░ farmer ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\n    /// @notice wrong aum cap value (lower than current aum, etc)\\n    error AumCapInvalid();\\n    /// @notice wrong ending aum value (infinite growth)\\n    error AumInvalid();\\n    /// @notice farmer asset allowance insufficient\\n    error FarmerInsufficientAllowance();\\n    /// @notice farmer asset balance insufficient\\n    error FarmerInsufficientBalance();\\n\\n    /// ░░░░░░░░░░░░░░ fee ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\n    /// @notice error setting fee config\\n    error FeeSettingsInvalid();\\n    /// @notice stored fees = 0;\\n    error FeeIsZero();\\n\\n    /// ░░░░░░░░░░░░░░ deposit ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\n    /// @notice deposit > aum cap\\n    error DepositExceedsAumCap();\\n    /// @notice deposit negated by config contract\\n    error DepositRequirementsNotMet();\\n    /// @notice deposit fees larger than sent amount\\n    error DepositFeeExceedsAssets();\\n    /// @notice has a pending withdrawal\\n    error DepositBlockedByWithdrawal();\\n\\n    /// ░░░░░░░░░░░░░░ unlock ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\n    /// @notice has a pending withdrawal already\\n    error UnlockBlockedByWithdrawal();\\n    /// @notice invalid amount e.g. 0\\n    error UnlockSharesAmountInvalid();\\n    /// @notice\\n    error UnlockExceedsShareBalance();\\n\\n    /// ░░░░░░░░░░░░░░ withdraw ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\n    /// @notice not the epoch to withdraw\\n    error WithdrawNotAvailableYet();\\n\\n    /// ██████████████ events █████████████████████████████████████████████████\\n    /// @notice user events\\n    event UserDeposit(address indexed user, uint256 amount);\\n    event UserUnlock(address indexed user, uint256 amount);\\n    event UserWithdraw(address indexed user, address withdrawalAddress, uint256 amount);\\n\\n    /// @notice vault events\\n    event EpochEnd(uint256 epoch, uint256 endingAssets);\\n    event EpochUpdated(uint256 epoch, uint256 endingAssets);\\n    event AumCapUpdated(uint256 aumCap);\\n\\n    /// @notice fee events\\n    event StoredFeeSent(uint256 amount);\\n    event FeeUpdated(bool isFeeEnabled, uint256 entryFee, uint256 exitFee, uint256 managementFee);\\n    event FeeReceiverUpdated(address feeDistributor);\\n\\n    /// ██████████████ modifiers ██████████████████████████████████████████████\\n\\n    /// requiresAuth -> from solmate/Auth\\n\\n    modifier onlyEpochZero() {\\n        if (epoch != 0) revert VaultAlreadyInitialized();\\n        _;\\n    }\\n\\n    modifier exceptEpochZero() {\\n        if (epoch < 1) revert VaultIsInitializing();\\n        _;\\n    }\\n\\n    modifier onlyManagementPhase() {\\n        if (!isManagementPhase()) {\\n            revert OnlyAtManagementPhase();\\n        }\\n        _;\\n    }\\n\\n    modifier exceptManagementPhase() {\\n        if (isManagementPhase()) {\\n            revert OnlyOutsideManagementPhase();\\n        }\\n        _;\\n    }\\n\\n    modifier canDeposit(address _user, uint256 _assets) {\\n        if (userHasPendingWithdrawal(_user)) {\\n            revert DepositBlockedByWithdrawal();\\n        }\\n        // cap must be higher than current AUM + pending deposit + incoming deposit\\n        if (_assets + getEffectiveAssets() > aumCap) {\\n            revert DepositExceedsAumCap();\\n        }\\n\\n        if (vaultConfigAddress != address(0) && !IVaultConfig(vaultConfigAddress).canDeposit(_user, _assets)) {\\n            revert DepositRequirementsNotMet();\\n        }\\n        _;\\n    }\\n\\n    modifier canUnlock(address _user, uint256 _shares) {\\n        if (_shares < 1) revert UnlockSharesAmountInvalid();\\n        if (msg.sender != _user) {\\n            uint256 allowed = allowance[_user][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[_user][msg.sender] = allowed - _shares;\\n        }\\n\\n        if (userHasPendingWithdrawal(_user)) revert UnlockBlockedByWithdrawal();\\n        _;\\n    }\\n\\n    modifier canWithdraw(address _user) {\\n        if (!userHasPendingWithdrawal(_user)) {\\n            revert WithdrawNotAvailableYet();\\n        }\\n        _;\\n    }\\n\\n    modifier updatesPendingDeposit(address _user) {\\n        updatePendingDepositState(_user);\\n        _;\\n    }\\n\\n    /// ██████████████ ERC4626 ████████████████████████████████████████████████\\n    /// ░░░░░░░░░░░░░░ constructor ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\n    /// @notice create an RPVault\\n    /// @param _name token name, also used as vault name in the UI, omitting `Token` postfix\\n    /// @param _symbol token symbol, also used as vault symbol in the UI\\n    /// @param _farmer farmer address, responsible for managing aum\\n    /// @param _feeDistributor address to receive fees from the contract\\n    /// @param _underlying asset to be used as underlying asset for the vault\\n    /// @param _vaultConfig contract address to be used as vault config contract. if 0x0, default config will be used\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _farmer,\\n        address _feeDistributor,\\n        address _underlying,\\n        address _vaultConfig\\n    ) ERC4626Accounting(ERC20(_underlying), _name, _symbol) Auth(_farmer, Authority(address(0))) {\\n        farmer = _farmer;\\n        feeDistributor = _feeDistributor;\\n        vaultConfigAddress = _vaultConfig;\\n    }\\n\\n    /// @notice Get the amount of productive underlying tokens\\n    /// @dev used at self deposits/redeems at epoch change\\n    /// @return aum, total external productive assets\\n    function totalAssets() public view override returns (uint256) {\\n        return aum;\\n    }\\n\\n    /// ██████████████ farmer functions ███████████████████████████████████████\\n    /*\\n        farmer's actions:\\n            - [x] starts vault with initial settings\\n            - [x] progress epoch\\n            - [x] update aum (management phase only)\\n            - [x] end management phase (management phase only)\\n            - [x] update aum cap\\n            - [x] enable/disable fees\\n            - [x] update fees\\n            - [x] update fee distributor\\n            - [x] update vault config address\\n    */\\n\\n    /// @notice starts the vault with a custom initial aum\\n    /// @dev in most cases, initial aum = 0\\n    /// @param _initialExternalAsset initial aum, must be held by farmer\\n    /// @param _aumCap maximum asset that can be stored\\n    function startVault(uint256 _initialExternalAsset, uint256 _aumCap) external onlyEpochZero requiresAuth {\\n        if (_aumCap < _initialExternalAsset) {\\n            revert AumCapInvalid();\\n        }\\n        if (_initialExternalAsset != 0) {\\n            uint256 initialShare = _selfDeposit(_initialExternalAsset);\\n            vaultUsers[msg.sender].vaultShares = initialShare;\\n        }\\n        aumCap = _aumCap;\\n        epoch = 1;\\n        vaultStates[epoch].assetsExternalStart = aum;\\n        vaultStates[epoch].totalSupply = totalSupply;\\n        vaultStates[epoch].lastManagementBlock = block.number;\\n        emit EpochEnd(0, aum);\\n    }\\n\\n    /// @notice Increment epoch from n to (n + 1)\\n    /// @dev goes to management phase after this function is called\\n    /// @param _assetsExternalEndBeforeFees current external asset (manual counting by farmer)\\n    /// @return newAUM (external asset)\\n    function progressEpoch(uint256 _assetsExternalEndBeforeFees) public requiresAuth exceptEpochZero returns (uint256) {\\n        // end epoch n\\n        (\\n            bool shouldTransferToFarm,\\n            uint256 totalAssetsToTransfer,\\n            bool shouldDepositDelta,\\n            uint256 deltaAssets,\\n            uint256 managementFee,\\n            uint256 assetsExternalEnd\\n        ) = previewProgress(_assetsExternalEndBeforeFees, epoch);\\n\\n        storedFee += managementFee;\\n        vaultStates[epoch].managementFee = managementFee;\\n\\n        aum = assetsExternalEnd;\\n        vaultStates[epoch].assetsExternalEnd = assetsExternalEnd;\\n\\n        emit EpochEnd(epoch, aum);\\n        epoch++;\\n\\n        // start epoch n + 1\\n        // transfer assets\\n        if (totalAssetsToTransfer > 0) {\\n            if (shouldTransferToFarm) {\\n                // if there are assets to be transferred to the farm, do it\\n                transferAssetToFarmer(totalAssetsToTransfer);\\n            } else {\\n                // transfer back to contract\\n                // msg.sender is farmer address\\n                transferAssetToContract(totalAssetsToTransfer);\\n            }\\n        }\\n\\n        // self deposit/redeem delta\\n        if (deltaAssets > 0) {\\n            if (shouldDepositDelta) {\\n                // self-deposit, update aum\\n                _selfDeposit(deltaAssets);\\n            } else {\\n                // self-redeem, update aum\\n                _selfRedeem(convertToShares(deltaAssets));\\n            }\\n        }\\n\\n        // if new aum is higher than the cap, increase the cap\\n        if (aum > aumCap) {\\n            aumCap = aum;\\n            emit AumCapUpdated(aumCap);\\n        }\\n\\n        //  update vault state\\n        vaultStates[epoch].assetsExternalStart = aum;\\n        vaultStates[epoch].totalSupply = totalSupply;\\n        vaultStates[epoch].lastManagementBlock = block.number + managementBlocksDuration;\\n        return aum;\\n    }\\n\\n    /// @notice amends last epoch's aum update\\n    /// @dev callable at management phase only\\n    /// @param _assetsExternalEndBeforeFees current external asset (manual counting by farmer)\\n    /// @return newAUM (external asset)\\n    // solhint-disable-next-line code-complexity\\n    function editAUM(uint256 _assetsExternalEndBeforeFees)\\n        public\\n        onlyManagementPhase\\n        requiresAuth\\n        returns (uint256 newAUM)\\n    {\\n        uint256 lastEpoch = epoch - 1;\\n        uint256 lastAssetsExternalEnd = vaultStates[lastEpoch].assetsExternalEnd;\\n        uint256 lastManagementFee = vaultStates[lastEpoch].managementFee;\\n        uint256 lastTotalSupply = vaultStates[lastEpoch].totalSupply;\\n\\n        if (_assetsExternalEndBeforeFees == lastAssetsExternalEnd + lastManagementFee) {\\n            // no change in aum\\n            return lastAssetsExternalEnd;\\n        }\\n        (\\n            bool didTransferToFarm,\\n            uint256 totalAssetsTransferred, // bool didDepositDelta,\\n            ,\\n            ,\\n            ,\\n\\n        ) = previewProgress(lastAssetsExternalEnd + lastManagementFee, lastEpoch);\\n\\n        /// @dev rather than saving gas by combining these into 1 transfers but with overflow handling, we do it in 2\\n        /// @dev gas is paid by farmer (upkeep)\\n\\n        // revert transfers\\n        if (totalAssetsTransferred > 0) {\\n            if (didTransferToFarm) {\\n                // revert\\n                transferAssetToContract(totalAssetsTransferred);\\n            } else {\\n                transferAssetToFarmer(totalAssetsTransferred);\\n            }\\n        }\\n\\n        // // revert deposit/redeem using latest rate, update aum automatically\\n        if (totalSupply > lastTotalSupply) {\\n            _burn(address(this), totalSupply - lastTotalSupply);\\n        }\\n\\n        if (totalSupply < lastTotalSupply) {\\n            _mint(address(this), lastTotalSupply - totalSupply);\\n        }\\n\\n        // /// @dev by this point, aum should be the same as last epoch's aum\\n        storedFee -= lastManagementFee;\\n        epoch = lastEpoch;\\n        return progressEpoch(_assetsExternalEndBeforeFees);\\n    }\\n\\n    /// @notice ends management phase, allow users to deposit/unlock/withdraw\\n    function endManagementPhase() public requiresAuth onlyManagementPhase {\\n        vaultStates[epoch].lastManagementBlock = block.number;\\n    }\\n\\n    /// @notice change AUM cap\\n    /// @param _aumCap new AUM cap\\n    function updateAumCap(uint256 _aumCap) public requiresAuth {\\n        if (aumCap < getEffectiveAssets()) {\\n            revert AumCapInvalid();\\n        }\\n        aumCap = _aumCap;\\n    }\\n\\n    /// @notice toggle fees on/off\\n    /// @param _isFeeEnabled true to enable fees, false to disable fees\\n    function setIsFeeEnabled(bool _isFeeEnabled) public requiresAuth {\\n        if (isFeeEnabled == _isFeeEnabled) {\\n            revert FeeSettingsInvalid();\\n        }\\n        isFeeEnabled = _isFeeEnabled;\\n    }\\n\\n    /// @notice update fees\\n    function setFees(\\n        uint256 _managementFeeBps,\\n        uint256 _entryFeeBps,\\n        uint256 _exitFeeBps\\n    ) public requiresAuth {\\n        if (_managementFeeBps > BASIS || _entryFeeBps > BASIS || _exitFeeBps > BASIS) {\\n            revert FeeSettingsInvalid();\\n        }\\n        managementFeeBps = _managementFeeBps;\\n        entryFeeBps = _entryFeeBps;\\n        exitFeeBps = _exitFeeBps;\\n    }\\n\\n    /// @notice update fee distributor\\n    function setFeeDistributor(address _feeDistributor) public requiresAuth {\\n        if (_feeDistributor == address(0)) {\\n            revert FeeSettingsInvalid();\\n        }\\n        feeDistributor = _feeDistributor;\\n    }\\n\\n    function setVaultConfigAddress(address _vaultConfigAddress) public requiresAuth {\\n        vaultConfigAddress = _vaultConfigAddress;\\n    }\\n\\n    /// ██████████████ user functions █████████████████████████████████████████\\n    /*\\n        A user can only do:\\n            - [x] deposit (not to be confused with ERC4626 deposit)\\n                - minimum/maximum rule set in the vaultConfig contract\\n            - [x] unlock\\n            - [x] withdraw (not to be confused with ERC4626 withdraw)\\n\\n    */\\n\\n    /// ░░░░░░░░░░░░░░ deposit ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\n    /// @notice a user stores assets in the contract to enter in the next epoch\\n    /// @dev funds should be withdrawable before epoch progresses\\n    /// @dev actual share minting happens at the epoch progression\\n    /// @dev share minting uses next epoch's starting exchange rate\\n    function deposit(uint256 _assets) external exceptEpochZero exceptManagementPhase returns (uint256) {\\n        return deposit(_assets, msg.sender);\\n    }\\n\\n    function deposit(uint256 _assets, address _for)\\n        public\\n        exceptEpochZero\\n        exceptManagementPhase\\n        canDeposit(_for, _assets)\\n        updatesPendingDeposit(_for)\\n        returns (uint256)\\n    {\\n        uint256 depositFee = getDepositFee(_assets, _for);\\n        if (depositFee >= _assets) {\\n            revert DepositFeeExceedsAssets();\\n        }\\n        uint256 netAssets = _assets - depositFee;\\n\\n        storedFee += depositFee;\\n\\n        /// last deposit epoch = 0\\n        /// assetDeposited = 0\\n\\n        vaultUsers[_for].epochLastDeposited = epoch;\\n        vaultUsers[_for].assetsDeposited += netAssets;\\n\\n        // update vault state\\n        vaultStates[epoch].assetsToDeposit += netAssets;\\n\\n        // transfer asset to vault\\n        asset.safeTransferFrom(msg.sender, address(this), _assets);\\n        emit UserDeposit(_for, netAssets);\\n        return netAssets;\\n    }\\n\\n    /// ░░░░░░░░░░░░░░ unlock (withdraw 1/2) ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\n    /// @notice unlock _shares for withdrawal at next available epoch\\n    function unlock(uint256 _shares) external exceptEpochZero exceptManagementPhase returns (uint256) {\\n        return unlock(_shares, msg.sender);\\n    }\\n\\n    function unlock(uint256 _shares, address _owner)\\n        public\\n        exceptEpochZero\\n        exceptManagementPhase\\n        canUnlock(_owner, _shares)\\n        updatesPendingDeposit(_owner)\\n        returns (uint256)\\n    {\\n        // updatePendingDepositState(msg.sender);\\n\\n        if (vaultUsers[_owner].vaultShares < vaultUsers[_owner].sharesToRedeem + _shares) {\\n            revert UnlockExceedsShareBalance();\\n        }\\n\\n        vaultUsers[_owner].sharesToRedeem += _shares;\\n        vaultUsers[_owner].epochToRedeem = epoch + 1;\\n        vaultStates[epoch].sharesToRedeem += _shares;\\n\\n        emit UserUnlock(_owner, _shares);\\n        return _shares;\\n    }\\n\\n    /// ░░░░░░░░░░░░░░ finalize (withdraw 2/2) ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\\n    /// @notice withdraw all available asset for user\\n    function withdraw() external exceptEpochZero exceptManagementPhase returns (uint256) {\\n        return withdraw(msg.sender);\\n    }\\n\\n    function withdraw(address _to)\\n        public\\n        exceptEpochZero\\n        exceptManagementPhase\\n        canWithdraw(msg.sender)\\n        updatesPendingDeposit(msg.sender)\\n        returns (uint256)\\n    {\\n        (uint256 totalAssetValue, uint256 withdrawalFee) = getWithdrawalAmount(msg.sender);\\n\\n        vaultUsers[msg.sender].vaultShares -= vaultUsers[msg.sender].sharesToRedeem;\\n        vaultUsers[msg.sender].sharesToRedeem = 0;\\n        vaultUsers[msg.sender].epochToRedeem = 0;\\n        storedFee += withdrawalFee;\\n\\n        if (withdrawalFee == totalAssetValue) {\\n            // @dev for really small values, we can't afford to lose precision\\n            return 0;\\n        }\\n\\n        uint256 transferValue = totalAssetValue - withdrawalFee;\\n        asset.transfer(_to, transferValue);\\n\\n        emit UserWithdraw(msg.sender, _to, transferValue);\\n        return transferValue;\\n    }\\n\\n    /// ██████████████ public functions ███████████████████████████████████████\\n    /*\\n        public functions:\\n            - [x] preview funds flow from/to contract next epoch\\n            - [x] check if user can deposit/unlock/withdraw\\n            - [x] send stored fees to fee distributor\\n            - [x] get maximum deposit amount\\n    */\\n    /// @notice preview funds flow from/to contract next epoch\\n    /// @dev assets to transfer = deltaAssets - managementFee\\n    /// @dev sign shows direction of transfer (true = to farm, false = to contract)\\n    /// @param _assetsExternalEndBeforeFees amount of external aum before fees\\n    /// @return shouldTransferToFarm direction of funds to transfer\\n    /// @return totalAssetsToTransfer amount of assets to transfer\\n    /// @return shouldDepositDelta true if deltaAssets should be deposited, false if deltaAssets should be redeemed\\n    /// @return deltaAssets amount of assets to deposit/redeem\\n    /// @return managementFee amount of management fee for next epoch\\n    /// @return assetsExternalEnd amount of vault ending aum. assetsExternalEnd = _assetsExternalEndBeforeFees - fees\\n    function previewProgress(uint256 _assetsExternalEndBeforeFees)\\n        public\\n        view\\n        returns (\\n            bool shouldTransferToFarm,\\n            uint256 totalAssetsToTransfer,\\n            bool shouldDepositDelta,\\n            uint256 deltaAssets,\\n            uint256 managementFee,\\n            uint256 assetsExternalEnd\\n        )\\n    {\\n        return previewProgress(_assetsExternalEndBeforeFees, epoch);\\n    }\\n\\n    function previewProgress(uint256 _assetsExternalEndBeforeFees, uint256 _epoch)\\n        public\\n        view\\n        returns (\\n            bool shouldTransferToFarm,\\n            uint256 totalAssetsToTransfer,\\n            bool shouldDepositDelta,\\n            uint256 deltaAssets,\\n            uint256 managementFee,\\n            uint256 assetsExternalEnd\\n        )\\n    {\\n        uint256 epochTotalSupply = _epoch == epoch ? totalSupply : vaultStates[_epoch].totalSupply;\\n\\n        uint256 assetsExternalStart = vaultStates[_epoch].assetsExternalStart;\\n        uint256 assetsToDeposit = vaultStates[_epoch].assetsToDeposit;\\n        uint256 sharesToRedeem = vaultStates[_epoch].sharesToRedeem;\\n\\n        if (assetsExternalStart == 0 && _assetsExternalEndBeforeFees > 0) {\\n            revert AumInvalid();\\n        }\\n\\n        managementFee = getManagementFee(assetsExternalStart, _assetsExternalEndBeforeFees);\\n        assetsExternalEnd = _assetsExternalEndBeforeFees - managementFee;\\n\\n        /// @dev at 0 supply, rate is 1:1\\n        uint256 redeemAssetValue = epochTotalSupply == 0\\n            ? sharesToRedeem\\n            : sharesToRedeem.mulDivDown(assetsExternalEnd, epochTotalSupply);\\n\\n        /// @dev if true, the delta (deltaAssets) will be used in selfDeposit.\\n        /// @dev if false, the delta will be \\\"soft-used\\\" in selfRedeem(shares);\\n\\n        shouldDepositDelta = assetsToDeposit > redeemAssetValue;\\n        deltaAssets = shouldDepositDelta ? assetsToDeposit - redeemAssetValue : redeemAssetValue - assetsToDeposit;\\n\\n        if (shouldDepositDelta) {\\n            // if deposit is bigger, transfer to farm\\n            // subtract by management fee\\n            if (managementFee > deltaAssets) {\\n                // reverse if fee > delta\\n                totalAssetsToTransfer = managementFee - deltaAssets;\\n                shouldTransferToFarm = false;\\n            } else {\\n                totalAssetsToTransfer = deltaAssets - managementFee;\\n                shouldTransferToFarm = true;\\n            }\\n        } else {\\n            // if redeem value is bigger, transfer to contract\\n            // add management fee\\n            totalAssetsToTransfer = deltaAssets + managementFee;\\n            shouldTransferToFarm = false;\\n        }\\n\\n        return (\\n            shouldTransferToFarm,\\n            totalAssetsToTransfer,\\n            shouldDepositDelta,\\n            deltaAssets,\\n            managementFee,\\n            assetsExternalEnd\\n        );\\n    }\\n\\n    function isManagementPhase() public view returns (bool) {\\n        return block.number <= vaultStates[epoch].lastManagementBlock;\\n    }\\n\\n    /// @notice sends stored fee to fee distributor\\n    function sendFee() public exceptManagementPhase {\\n        if (storedFee == 0) {\\n            revert FeeIsZero();\\n        }\\n        uint256 amount = storedFee;\\n        storedFee = 0;\\n        asset.transfer(feeDistributor, amount);\\n        emit StoredFeeSent(storedFee);\\n    }\\n\\n    /// @notice get maximum deposit amount\\n    function getMaxDeposit() public view returns (uint256) {\\n        return aumCap - getEffectiveAssets();\\n    }\\n\\n    /// @notice preview deposit on epoch\\n    function previewDepositEpoch(uint256 _assets, uint256 _epoch) public view returns (uint256) {\\n        if (vaultStates[_epoch].totalSupply == 0 || vaultStates[_epoch].assetsExternalStart == 0) {\\n            return _assets;\\n        }\\n        return _assets.mulDivDown(vaultStates[_epoch].totalSupply, vaultStates[_epoch].assetsExternalStart);\\n    }\\n\\n    /// ██████████████ internals ██████████████████████████████████████████████\\n    // TODO: internalize before deploy\\n    /// @notice self-deposit, uses ERC4626 calculations, without actual transfer\\n    /// @dev updates AUM\\n    /// @param _assets number of assets to deposit\\n    /// @return shares minted\\n    function _selfDeposit(uint256 _assets) internal returns (uint256) {\\n        uint256 shares;\\n        if ((shares = previewDeposit(_assets)) == 0) revert DepositReturnsZeroShares();\\n\\n        _mint(address(this), shares);\\n        aum += _assets;\\n\\n        emit Deposit(msg.sender, address(this), _assets, shares);\\n\\n        return shares;\\n    }\\n\\n    /// @notice self-redeem, uses ERC4626 calculations, without actual transfer\\n    /// @dev updates AUM\\n    /// @param _shares number of shares to redeem\\n    /// @return assets value of burned shares\\n    function _selfRedeem(uint256 _shares) internal returns (uint256) {\\n        uint256 assets;\\n        // Check for rounding error since we round down in previewRedeem.\\n        if ((assets = previewRedeem(_shares)) == 0) revert RedeemReturnsZeroAssets();\\n\\n        _burn(address(this), _shares);\\n        aum -= assets;\\n\\n        emit Withdraw(msg.sender, address(this), address(this), assets, _shares);\\n        return assets;\\n    }\\n\\n    /// @notice calculate management fee based on aum change\\n    /// @param _assetsExternalStart assets at start of epoch\\n    /// @param _assetsExternalEndBeforeFees assets at end of epoch\\n    /// @return managementFee management fees in asset\\n    function getManagementFee(uint256 _assetsExternalStart, uint256 _assetsExternalEndBeforeFees)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        if (!isFeeEnabled) {\\n            return 0;\\n        }\\n        return\\n            (_assetsExternalEndBeforeFees > _assetsExternalStart && managementFeeBps > 0)\\n                ? managementFeeBps.mulDivUp(_assetsExternalEndBeforeFees - _assetsExternalStart, BASIS)\\n                : 0;\\n    }\\n\\n    function transferAssetToFarmer(uint256 _assets) internal returns (bool) {\\n        return asset.transfer(farmer, _assets);\\n    }\\n\\n    function transferAssetToContract(uint256 _assets) internal {\\n        if (asset.allowance(msg.sender, address(this)) < _assets) {\\n            revert FarmerInsufficientAllowance();\\n        }\\n        if (asset.balanceOf(msg.sender) < _assets) {\\n            revert FarmerInsufficientBalance();\\n        }\\n        return asset.safeTransferFrom(msg.sender, address(this), _assets);\\n    }\\n\\n    function getEffectiveAssets() internal view returns (uint256) {\\n        return aum + vaultStates[epoch].assetsToDeposit;\\n    }\\n\\n    /// @notice update VaultUser's data if they have pending deposits\\n    /// @param _user address of the VaultUser\\n    /// @dev after this, last deposit epoch = 0, assetDeposited = 0\\n    /// @dev can be manually called\\n    function updatePendingDepositState(address _user) public {\\n        // @dev check if user has already stored assets\\n        if (userHasPendingDeposit(_user)) {\\n            // @dev user should already have shares here, let's increment\\n            vaultUsers[_user].vaultShares += previewDepositEpoch(\\n                vaultUsers[_user].assetsDeposited,\\n                vaultUsers[_user].epochLastDeposited + 1\\n            );\\n\\n            vaultUsers[_user].assetsDeposited = 0;\\n            vaultUsers[_user].epochLastDeposited = 0;\\n        }\\n    }\\n\\n    /// @notice check if user has pending deposits\\n    /// @param _user address of the VaultUser\\n    /// @return true if user has pending deposits\\n    function userHasPendingDeposit(address _user) public view returns (bool) {\\n        uint256 userEpoch = vaultUsers[_user].epochLastDeposited;\\n        return userEpoch != 0 && epoch > userEpoch;\\n    }\\n\\n    /// @notice get deposit fee for user\\n    function getDepositFee(uint256 _assets, address _user) public view returns (uint256) {\\n        if (vaultConfigAddress != address(0) && IVaultConfig(vaultConfigAddress).isFeeEnabled(_user)) {\\n            return _assets.mulDivUp(IVaultConfig(vaultConfigAddress).entryFeeBps(_user), BASIS);\\n        } else {\\n            return isFeeEnabled ? _assets.mulDivUp(entryFeeBps, BASIS) : 0;\\n        }\\n    }\\n\\n    /// @notice check if a user has pending, unlocked funds to withdraw\\n    function userHasPendingWithdrawal(address _user) public view returns (bool) {\\n        return vaultUsers[_user].epochToRedeem > 0 && vaultUsers[_user].epochToRedeem <= epoch;\\n    }\\n\\n    function getStoredValue(address _user) public view returns (uint256 userAssetValue) {\\n        VaultUser memory user = vaultUsers[_user];\\n\\n        uint256 userShares = user.vaultShares;\\n\\n        if (userHasPendingDeposit(_user)) {\\n            // shares has been minted, user state not yet updated\\n            userShares += previewDepositEpoch(user.assetsDeposited, user.epochLastDeposited + 1);\\n        } else {\\n            // still currently pending (no minted shares yet)\\n            userAssetValue += user.assetsDeposited;\\n        }\\n\\n        userAssetValue += convertToAssets(userShares);\\n    }\\n\\n    function getWithdrawalFee(uint256 _assets, address _user) public view returns (uint256) {\\n        if (vaultConfigAddress != address(0) && IVaultConfig(vaultConfigAddress).isFeeEnabled(_user)) {\\n            return _assets.mulDivUp(IVaultConfig(vaultConfigAddress).exitFeeBps(_user), BASIS);\\n        } else {\\n            return isFeeEnabled ? _assets.mulDivUp(exitFeeBps, BASIS) : 0;\\n        }\\n    }\\n\\n    function getWithdrawalAmount(address _owner) public view returns (uint256, uint256) {\\n        if (!userHasPendingWithdrawal(_owner)) return (0, 0);\\n        uint256 epochToRedeem = vaultUsers[_owner].epochToRedeem;\\n        uint256 sharesToRedeem = vaultUsers[_owner].sharesToRedeem;\\n        uint256 assetsExternalStart = vaultStates[epochToRedeem].assetsExternalStart;\\n        uint256 totalSupplyAtRedeem = vaultStates[epochToRedeem].totalSupply;\\n\\n        if (assetsExternalStart == 0 || totalSupplyAtRedeem == 0) {\\n            return (0, 0);\\n        }\\n\\n        uint256 totalAssetValue = sharesToRedeem.mulDivDown(\\n            vaultStates[epochToRedeem].assetsExternalStart,\\n            vaultStates[epochToRedeem].totalSupply\\n        );\\n        uint256 fee = getWithdrawalFee(totalAssetValue, _owner);\\n\\n        return (totalAssetValue, fee);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ERC4626Accounting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\nimport { SafeTransferLib } from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport { FixedPointMathLib } from \\\"solmate/utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @dev derived from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626Accounting is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, _asset.decimals()) {\\n        asset = _asset;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /* None! Ta da! */\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_refiAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"VaultNotSetup\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_entryFeeBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_exitFeeBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isFeeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assets\",\"type\":\"uint256\"}],\"name\":\"canDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"entryFeeBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exitFeeBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumRefiHeld\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStoredValueBeforeFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refiAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeUserCustomMinimum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeUserOverride\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetAmount\",\"type\":\"uint256\"}],\"name\":\"setMinimumDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumRefiHeld\",\"type\":\"uint256\"}],\"name\":\"setMinimumRefiHeld\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_refiAddress\",\"type\":\"address\"}],\"name\":\"setRefiAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimum\",\"type\":\"uint256\"}],\"name\":\"setUserCustomMinimum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_canDeposit\",\"type\":\"bool\"}],\"name\":\"setUserOverride\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"}],\"name\":\"setVaultAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userOverrides\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"shouldOverrideCanDeposit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canDeposit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasCustomMinimum\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"customMinimum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DefaultVaultConfig","CompilerVersion":"v0.8.14+commit.80d49f37","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004457df4a5bccf796662b6374d5947c881cc83ac7000000000000000000000000a808b22ffd2c472ad1278088f16d4010e6a54d5f00000000000000000000000000000008786611c72a00909bd8d398b1be195be3","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]