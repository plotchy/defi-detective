[{"SourceCode":"pragma solidity =0.8.4;\r\npragma experimental ABIEncoderV2;\r\n// Leak alpha with https://twitter.com/mevalphaleak\r\n\r\n// All existing flash-loan providers have at least one of the following downsides\r\n// - Taking excessive fee for the service\r\n// - Hard to loan multiple assets at once\r\n// - Horribly inefficient in terms of gas:\r\n//  - Emitting pointless events\r\n//  - Creating useless additional transfers\r\n//  - No SLOAD/SSTORE optimisation past EIP-2929\r\n\r\n// ApeBank is introduced to make most gas efficient flash-loans available to everyone completely for free\r\n// Combined with native gas refunds without any additional sstore operations\r\n\r\n// ApeBank doesnt use safeMath and cuts corners everywhere, it isn't suitable for flash-mintable tokens\r\n// Contract wasnt audited by anyone and there's no benefit for depositing tokens into this contract and no APY\r\n// Anyone with half-working brain should think twice before putting anything into this contract\r\ncontract ApeBank {\r\n    string  public   constant name = \"https://twitter.com/mevalphaleak\";\r\n    address internal constant TOKEN_ETH  = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address internal constant TOKEN_WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address internal constant TOKEN_WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\r\n    address internal constant TOKEN_DAI  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    address internal constant TOKEN_USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n    address internal constant TOKEN_USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n\r\n    uint256 internal constant TOKEN_WETH_MULTIPLIER = 10 ** 14; // 0.4$ at the time of contract creation\r\n    uint256 internal constant TOKEN_WBTC_MULTIPLIER = 10 ** 3;  // 0.5$ at the time of contract creation\r\n    uint256 internal constant TOKEN_DAI_MULTIPLIER  = 10 ** 18;\r\n    uint256 internal constant TOKEN_USDC_MULTIPLIER = 10 ** 6;\r\n    uint256 internal constant TOKEN_USDT_MULTIPLIER = 10 ** 6;\r\n\r\n    uint256 internal constant FLAG_BORROW_ETH  = 0x1;\r\n    uint256 internal constant FLAG_BORROW_WETH = 0x2;\r\n    uint256 internal constant FLAG_BORROW_WBTC = 0x4;\r\n    uint256 internal constant FLAG_BORROW_DAI  = 0x8;\r\n    uint256 internal constant FLAG_BORROW_USDC = 0x10;\r\n    uint256 internal constant FLAG_BORROW_USDT = 0x20;\r\n    uint256 internal constant FLAG_COVER_WETH  = 0x40;\r\n\r\n    uint256 internal constant FLAG_BURN_NATIVE = 0x80;\r\n    uint256 internal constant FLAG_BURN_GST2   = 0x100;\r\n    uint256 internal constant FLAG_BURN_CHI    = 0x200;\r\n\r\n    uint256 internal constant FLAG_SMALL_CALLBACK = 0x400;\r\n    uint256 internal constant FLAG_LARGE_CALLBACK = 0x800;\r\n\r\n    uint256 internal constant FLAG_FREE_GAS_TOKEN               = 0x1000;\r\n    uint256 internal constant FLAG_GAS_TOKEN_BURN_AMOUNT_SHIFT  = 0x1000000000000000000000000000000000000000000000000000000000000;\r\n\r\n    Types.BankState public state;\r\n    Types.GasTokenPrices public gasTokenBurnPrices;\r\n\r\n    // Total amount of tokens deposited into ApeBank, this value can be lower than balances in 'state'\r\n    mapping (address => uint256) public totalDeposits;\r\n    mapping (address => uint256) public userEthBalances;\r\n    mapping (address => Types.BankState) public userTokenBalances;\r\n    // Our hall of fame which allows to use gas tokens for free\r\n    mapping (address => bool) public bestApeOperators;\r\n    \r\n    // Used to collect excess balances and acquire gas tokens\r\n    address public treasury;\r\n    address public pendingTresury;\r\n\r\n    event Deposit(address indexed user, address indexed token, uint256 amount);\r\n    event Withdrawal(address indexed user, address indexed token, uint256 amount);\r\n    event SkimmedBalance(address indexed treasury, address indexed token, uint256 amount);\r\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\r\n\r\n    constructor () {\r\n        treasury = msg.sender;\r\n        pendingTresury = 0x0000000000000000000000000000000000000000;\r\n        emit TreasuryUpdated(pendingTresury, treasury);\r\n    }\r\n    function nominateTreasury(address nomination) external {\r\n        require(msg.sender == treasury);\r\n        pendingTresury = nomination;\r\n    }\r\n    function acceptNomination() external {\r\n        require(msg.sender == pendingTresury);\r\n        emit TreasuryUpdated(treasury, pendingTresury);\r\n        treasury = pendingTresury;\r\n        pendingTresury = 0x0000000000000000000000000000000000000000;\r\n    }\r\n    function updateGasTokenPrices(uint80 priceGST2, uint80 priceCHI, uint80 priceNative) external {\r\n        require(msg.sender == treasury);\r\n        Types.GasTokenPrices memory cachedPrices;\r\n        cachedPrices.priceGST2 = priceGST2;\r\n        cachedPrices.priceCHI = priceCHI;\r\n        cachedPrices.priceNative = priceNative;\r\n        gasTokenBurnPrices = cachedPrices;\r\n    }\r\n    function promoteToFreeGasTokens(address apeOperator) external {\r\n        require(msg.sender == treasury);\r\n        bestApeOperators[apeOperator] = true;\r\n    }\r\n    \r\n    fallback() external payable {}\r\n\r\n    // Logic to skim excess balances into treasury to acquire more gas tokens\r\n    function skimExcessBalances(address token) external {\r\n        require(msg.sender == treasury);\r\n        uint256 minBalanceToKeep = totalDeposits[token] + 1;\r\n\r\n        Types.BankState memory cachedBankState = state;\r\n        uint256 availableBalance;\r\n        if (token == TOKEN_ETH) {\r\n            availableBalance = address(this).balance;\r\n            require(availableBalance > minBalanceToKeep);\r\n            TransferHelper.safeTransferETH(\r\n                msg.sender,\r\n                availableBalance - minBalanceToKeep\r\n            );\r\n            // ETH balances aren't saved in state\r\n        } else {\r\n            availableBalance = IERC20Token(token).balanceOf(address(this));\r\n            require(availableBalance > minBalanceToKeep);\r\n            TransferHelper.safeTransfer(\r\n                token,\r\n                msg.sender,\r\n                availableBalance - minBalanceToKeep\r\n            );\r\n\r\n            if (token == TOKEN_WETH) {\r\n                cachedBankState.wethBalance = uint32(minBalanceToKeep / TOKEN_WETH_MULTIPLIER);\r\n            } else if (token == TOKEN_WBTC) {\r\n                cachedBankState.wbtcBalance = uint32(minBalanceToKeep / TOKEN_WBTC_MULTIPLIER);\r\n            } else if (token == TOKEN_DAI) {\r\n                cachedBankState.daiBalance  = uint32(minBalanceToKeep / TOKEN_DAI_MULTIPLIER );\r\n            } else if (token == TOKEN_USDC) {\r\n                cachedBankState.usdcBalance = uint32(minBalanceToKeep / TOKEN_USDC_MULTIPLIER);\r\n            } else if (token == TOKEN_USDT) {\r\n                cachedBankState.usdtBalance = uint32(minBalanceToKeep / TOKEN_USDT_MULTIPLIER);\r\n            }\r\n        }\r\n\r\n        require(cachedBankState.numCalls == state.numCalls);\r\n        cachedBankState.numCalls += 1;\r\n        state = cachedBankState;\r\n        emit SkimmedBalance(msg.sender, token, availableBalance - minBalanceToKeep);\r\n    }\r\n\r\n    function deposit(address token, uint256 amount) external payable {\r\n        Types.BankState memory cachedBankState = state;\r\n        if (msg.value > 0) {\r\n            require(token == TOKEN_ETH && msg.value == amount, \"Incorrect deposit amount\");\r\n            userEthBalances[msg.sender] += msg.value;\r\n        } else {\r\n            TransferHelper.safeTransferFrom(\r\n                token,\r\n                msg.sender,\r\n                address(this),\r\n                amount\r\n            );            \r\n            if (token == TOKEN_WETH) {\r\n                require(amount % TOKEN_WETH_MULTIPLIER == 0, \"Incorrect deposit amount\");\r\n                uint256 newBalance = cachedBankState.wethBalance + (amount / TOKEN_WETH_MULTIPLIER);\r\n                require(newBalance < (2 ** 32), \"Bank size is excessive\");\r\n                cachedBankState.wethBalance = uint32(newBalance);\r\n                userTokenBalances[msg.sender].wethBalance += uint32(amount / TOKEN_WETH_MULTIPLIER);\r\n            } else if (token == TOKEN_WBTC) {\r\n                require(amount % TOKEN_WBTC_MULTIPLIER == 0, \"Incorrect deposit amount\");\r\n                uint256 newBalance = cachedBankState.wbtcBalance + (amount / TOKEN_WBTC_MULTIPLIER);\r\n                require(newBalance < (2 ** 32), \"Bank size is excessive\");\r\n                cachedBankState.wbtcBalance = uint32(newBalance);\r\n                userTokenBalances[msg.sender].wbtcBalance += uint32(amount / TOKEN_WBTC_MULTIPLIER);\r\n            } else if (token == TOKEN_DAI) {\r\n                require(amount % TOKEN_DAI_MULTIPLIER == 0, \"Incorrect deposit amount\");\r\n                uint256 newBalance = cachedBankState.daiBalance + (amount / TOKEN_DAI_MULTIPLIER);\r\n                require(newBalance < (2 ** 32), \"Bank size is excessive\");\r\n                cachedBankState.daiBalance = uint32(newBalance);\r\n                userTokenBalances[msg.sender].daiBalance += uint32(amount / TOKEN_DAI_MULTIPLIER);\r\n            } else if (token == TOKEN_USDC) {\r\n                require(amount % TOKEN_USDC_MULTIPLIER == 0, \"Incorrect deposit amount\");\r\n                uint256 newBalance = cachedBankState.usdcBalance + (amount / TOKEN_USDC_MULTIPLIER);\r\n                require(newBalance < (2 ** 32), \"Bank size is excessive\");\r\n                cachedBankState.usdcBalance = uint32(newBalance);\r\n                userTokenBalances[msg.sender].usdcBalance += uint32(amount / TOKEN_USDC_MULTIPLIER);\r\n            } else {\r\n                require(token == TOKEN_USDT, \"Token not supported\");\r\n                require(amount % TOKEN_USDT_MULTIPLIER == 0, \"Incorrect deposit amount\");\r\n                uint256 newBalance = cachedBankState.usdtBalance + (amount / TOKEN_USDT_MULTIPLIER);\r\n                require(newBalance < (2 ** 32), \"Bank size is excessive\");\r\n                cachedBankState.usdtBalance = uint32(newBalance);\r\n                userTokenBalances[msg.sender].usdtBalance += uint32(amount / TOKEN_USDT_MULTIPLIER);\r\n            }\r\n        }\r\n        totalDeposits[token] += amount;\r\n        \r\n        require(cachedBankState.numCalls == state.numCalls);\r\n        cachedBankState.numCalls += 1;\r\n        state = cachedBankState;\r\n        emit Deposit(msg.sender, token, amount);\r\n    }\r\n\r\n    function withdraw(address token, uint256 amount) external {\r\n        Types.BankState memory cachedBankState = state;\r\n        \r\n        totalDeposits[token] -= amount;\r\n        if (token == TOKEN_ETH) {\r\n            require(userEthBalances[msg.sender] >= amount);\r\n            userEthBalances[msg.sender] -= amount;\r\n            // ETH balances aren't saved into state\r\n            TransferHelper.safeTransferETH(\r\n                msg.sender,\r\n                amount\r\n            );\r\n        } else {\r\n            if (token == TOKEN_WETH) {\r\n                require(amount % TOKEN_WETH_MULTIPLIER == 0, \"Incorrect withdraw amount\");\r\n                uint256 amountDelta = amount / TOKEN_WETH_MULTIPLIER;\r\n                require(uint256(userTokenBalances[msg.sender].wethBalance) >= amountDelta);\r\n                userTokenBalances[msg.sender].wethBalance -= uint32(amountDelta);\r\n                cachedBankState.wethBalance -= uint32(amountDelta);\r\n            } else if (token == TOKEN_WBTC) {\r\n                require(amount % TOKEN_WBTC_MULTIPLIER == 0, \"Incorrect withdraw amount\");\r\n                uint256 amountDelta = amount / TOKEN_WBTC_MULTIPLIER;\r\n                require(uint256(userTokenBalances[msg.sender].wbtcBalance) >= amountDelta);\r\n                userTokenBalances[msg.sender].wbtcBalance -= uint32(amountDelta);\r\n                cachedBankState.wbtcBalance -= uint32(amountDelta);\r\n            } else if (token == TOKEN_DAI) {\r\n                require(amount % TOKEN_DAI_MULTIPLIER == 0, \"Incorrect withdraw amount\");\r\n                uint256 amountDelta = amount / TOKEN_DAI_MULTIPLIER;\r\n                require(uint256(userTokenBalances[msg.sender].daiBalance) >= amountDelta);\r\n                userTokenBalances[msg.sender].daiBalance -= uint32(amountDelta);\r\n                cachedBankState.daiBalance -= uint32(amountDelta);\r\n            } else if (token == TOKEN_USDC) {\r\n                require(amount % TOKEN_USDC_MULTIPLIER == 0, \"Incorrect withdraw amount\");\r\n                uint256 amountDelta = amount / TOKEN_USDC_MULTIPLIER;\r\n                require(uint256(userTokenBalances[msg.sender].usdcBalance) >= amountDelta);\r\n                userTokenBalances[msg.sender].usdcBalance -= uint32(amountDelta);\r\n                cachedBankState.usdcBalance -= uint32(amountDelta);\r\n            } else {\r\n                require(token == TOKEN_USDT, \"Token not supported\");\r\n                require(amount % TOKEN_USDT_MULTIPLIER == 0, \"Incorrect withdraw amount\");\r\n                uint256 amountDelta = amount / TOKEN_USDT_MULTIPLIER;\r\n                require(uint256(userTokenBalances[msg.sender].usdtBalance) >= amountDelta);\r\n                userTokenBalances[msg.sender].usdtBalance -= uint32(amountDelta);\r\n                cachedBankState.usdtBalance -= uint32(amountDelta);\r\n            }\r\n            TransferHelper.safeTransfer(\r\n                token,\r\n                msg.sender,\r\n                amount\r\n            );        \r\n        }\r\n        \r\n        require(cachedBankState.numCalls == state.numCalls);\r\n        cachedBankState.numCalls += 1;\r\n        state = cachedBankState;\r\n        emit Withdrawal(msg.sender, token, amount);\r\n    }\r\n    \r\n    function flashApe(address payable callTo, uint256 flags, bytes calldata params) external payable {\r\n        Types.BankState memory cachedBankState = state;\r\n\r\n        if ((flags & FLAG_BORROW_WETH) > 0) {\r\n            TransferHelper.safeTransfer(\r\n                TOKEN_WETH,\r\n                callTo,\r\n                uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER\r\n            );\r\n        }\r\n        if ((flags & (FLAG_BORROW_WBTC | FLAG_BORROW_DAI | FLAG_BORROW_USDC | FLAG_BORROW_USDT)) > 0) {\r\n            if ((flags & FLAG_BORROW_WBTC) > 0) {\r\n                TransferHelper.safeTransfer(\r\n                    TOKEN_WBTC,\r\n                    callTo,\r\n                    uint256(cachedBankState.wbtcBalance) * TOKEN_WBTC_MULTIPLIER\r\n                );\r\n            }\r\n            if ((flags & FLAG_BORROW_DAI) > 0) {\r\n                TransferHelper.safeTransfer(\r\n                    TOKEN_DAI,\r\n                    callTo,\r\n                    uint256(cachedBankState.daiBalance) * TOKEN_DAI_MULTIPLIER\r\n                );\r\n            }\r\n            if ((flags & FLAG_BORROW_USDC) > 0) {\r\n                TransferHelper.safeTransfer(\r\n                    TOKEN_USDC,\r\n                    callTo,\r\n                    uint256(cachedBankState.usdcBalance) * TOKEN_USDC_MULTIPLIER\r\n                );\r\n            }\r\n            if ((flags & FLAG_BORROW_USDT) > 0) {\r\n                TransferHelper.safeTransfer(\r\n                    TOKEN_USDT,\r\n                    callTo,\r\n                    uint256(cachedBankState.usdtBalance) * TOKEN_USDT_MULTIPLIER\r\n                );\r\n            }\r\n        }\r\n        uint256 oldSelfBalance = address(this).balance;\r\n\r\n        // For \"ease\" of integration allowing several different callback options\r\n        if ((flags & (FLAG_SMALL_CALLBACK | FLAG_LARGE_CALLBACK)) > 0) {\r\n            // Native payable callbacks\r\n            if ((flags & FLAG_SMALL_CALLBACK) > 0) {\r\n                IApeBot(callTo).smallApeCallback{value: ((flags & FLAG_BORROW_ETH) > 0) ? oldSelfBalance - 1 : 0}(\r\n                    params\r\n                );\r\n            } else {\r\n                IApeBot(callTo).largeApeCallback{value: ((flags & FLAG_BORROW_ETH) > 0) ? oldSelfBalance - 1 : 0}(\r\n                    msg.sender,\r\n                    (((flags & FLAG_BORROW_WETH) > 0) ? uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER : 0),\r\n                    (((flags & FLAG_BORROW_WBTC) > 0) ? uint256(cachedBankState.wbtcBalance) * TOKEN_WBTC_MULTIPLIER : 0),\r\n                    (((flags & FLAG_BORROW_DAI ) > 0) ? uint256(cachedBankState.daiBalance ) * TOKEN_DAI_MULTIPLIER  : 0),\r\n                    (((flags & FLAG_BORROW_USDC) > 0) ? uint256(cachedBankState.usdcBalance) * TOKEN_USDC_MULTIPLIER : 0),\r\n                    (((flags & FLAG_BORROW_USDT) > 0) ? uint256(cachedBankState.usdtBalance) * TOKEN_USDT_MULTIPLIER : 0),\r\n                    params\r\n                );\r\n            }\r\n        } else {\r\n            // Immitating popular non-payable callback\r\n            if ((flags & FLAG_BORROW_ETH) > 0) {\r\n                TransferHelper.safeTransferETH(\r\n                    callTo,\r\n                    oldSelfBalance - 1\r\n                );\r\n            }\r\n            IApeBot(callTo).callFunction(\r\n                msg.sender,\r\n                Types.AccountInfo({\r\n                    owner: address(msg.sender),\r\n                    number: 1\r\n                }),\r\n                params\r\n            );\r\n        }\r\n\r\n        // Verifying that all funds were returned\r\n        // If Ether was sent into this function it shouldn't be counted against original balance\r\n        oldSelfBalance -= msg.value;\r\n        uint256 newSelfBalance = address(this).balance;\r\n        // Performing gas refunds\r\n        if ((flags & (FLAG_BURN_NATIVE | FLAG_BURN_GST2 | FLAG_BURN_CHI)) > 0) {\r\n            // No point in burning more than 256 tokens\r\n            uint32 tokensToBurn = uint32((flags / FLAG_GAS_TOKEN_BURN_AMOUNT_SHIFT) & 0xff);\r\n\r\n            Types.GasTokenPrices memory cachedBurnPrices;\r\n            if ((flags & FLAG_FREE_GAS_TOKEN) > 0) {\r\n                // Bot can enter hall of fame and get free gas tokens for life\r\n                require(bestApeOperators[msg.sender]);\r\n            } else {\r\n                // Otherwise price of these gas tokens would have to be deducted\r\n                cachedBurnPrices = gasTokenBurnPrices;\r\n            }\r\n\r\n            if (((flags & FLAG_BURN_NATIVE) > 0) && (cachedBankState.totalContractsCreated > cachedBankState.firstContractToDestroy + tokensToBurn)) {\r\n                _destroyContracts(cachedBankState.firstContractToDestroy, cachedBankState.firstContractToDestroy + tokensToBurn);\r\n                cachedBankState.firstContractToDestroy += tokensToBurn;\r\n                require(newSelfBalance > tokensToBurn * cachedBurnPrices.priceNative);\r\n                newSelfBalance -= tokensToBurn * cachedBurnPrices.priceNative;\r\n            } else if ((flags & FLAG_BURN_GST2) > 0) {\r\n                IGasToken(0x0000000000b3F879cb30FE243b4Dfee438691c04).free(tokensToBurn);\r\n                require(newSelfBalance > tokensToBurn * cachedBurnPrices.priceGST2);\r\n                newSelfBalance -= tokensToBurn * cachedBurnPrices.priceGST2;\r\n            } else if ((flags & FLAG_BURN_CHI) > 0) {\r\n                IGasToken(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c).free(tokensToBurn);\r\n                require(newSelfBalance > tokensToBurn * cachedBurnPrices.priceCHI);\r\n                newSelfBalance -= tokensToBurn * cachedBurnPrices.priceCHI;\r\n            }\r\n        }\r\n\r\n        if ((flags & (FLAG_BORROW_WETH | FLAG_COVER_WETH)) > 0) {\r\n            // We can combine ETH and WETH balances in this case\r\n            uint256 wethBalance = IERC20Token(TOKEN_WETH).balanceOf(address(this));\r\n            require(wethBalance < (2 ** 32) * TOKEN_WETH_MULTIPLIER && (newSelfBalance + wethBalance > oldSelfBalance + uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER));\r\n\r\n            if (wethBalance <= uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER) {\r\n                // User didn't return enough WETH covering via excess ETH\r\n                uint256 deltaToCover = uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER + 1 - wethBalance;\r\n                require(newSelfBalance >= oldSelfBalance + deltaToCover);\r\n\r\n                WETH9(TOKEN_WETH).deposit{value: deltaToCover}();\r\n                // newSelfBalance won't be used anywhere below\r\n                // WETH balance stays the same in the newState\r\n            } else if (newSelfBalance < oldSelfBalance) {\r\n                // User didn't return enough ETH covering via excess WETH\r\n                require(wethBalance > uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER + (oldSelfBalance - newSelfBalance));\r\n\r\n                WETH9(TOKEN_WETH).withdraw(oldSelfBalance - newSelfBalance);\r\n                // newSelfBalance won't be used anywhere below\r\n                cachedBankState.wethBalance = uint32((wethBalance - (oldSelfBalance - newSelfBalance)) / TOKEN_WETH_MULTIPLIER);\r\n            } else {\r\n                cachedBankState.wethBalance = uint32(wethBalance / TOKEN_WETH_MULTIPLIER);\r\n            }\r\n        } else {\r\n            require(newSelfBalance >= oldSelfBalance);\r\n        }\r\n\r\n        if ((flags & (FLAG_BORROW_WBTC | FLAG_BORROW_DAI | FLAG_BORROW_USDC | FLAG_BORROW_USDT)) > 0) {\r\n            if ((flags & FLAG_BORROW_WBTC) > 0) {\r\n                uint256 wbtcBalance = IERC20Token(TOKEN_WBTC).balanceOf(address(this));\r\n                // We use strict comparison here to make sure that token transfers always cost 5k gas and not (20k - 15k)\r\n                require(wbtcBalance < (2 ** 32) * TOKEN_WBTC_MULTIPLIER && wbtcBalance > uint256(cachedBankState.wbtcBalance) * TOKEN_WBTC_MULTIPLIER);\r\n                cachedBankState.wbtcBalance = uint32(wbtcBalance / TOKEN_WBTC_MULTIPLIER);\r\n            }\r\n            if ((flags & FLAG_BORROW_DAI) > 0) {\r\n                uint256 daiBalance = IERC20Token(TOKEN_DAI).balanceOf(address(this));\r\n                // We use strict comparison here to make sure that token transfers always cost 5k gas and not (20k - 15k)\r\n                require(daiBalance < (2 ** 32) * TOKEN_DAI_MULTIPLIER && daiBalance > uint256(cachedBankState.daiBalance) * TOKEN_DAI_MULTIPLIER);\r\n                cachedBankState.daiBalance = uint32(daiBalance / TOKEN_DAI_MULTIPLIER);\r\n            }\r\n            if ((flags & FLAG_BORROW_USDC) > 0) {\r\n                uint256 usdcBalance = IERC20Token(TOKEN_USDC).balanceOf(address(this));\r\n                // We use strict comparison here to make sure that token transfers always cost 5k gas and not (20k - 15k)\r\n                require(usdcBalance < (2 ** 32) * TOKEN_USDC_MULTIPLIER && usdcBalance > uint256(cachedBankState.usdcBalance) * TOKEN_USDC_MULTIPLIER);\r\n                cachedBankState.usdcBalance = uint32(usdcBalance / TOKEN_USDC_MULTIPLIER);\r\n            }\r\n            if ((flags & FLAG_BORROW_USDT) > 0) {\r\n                uint256 usdtBalance = IERC20Token(TOKEN_USDT).balanceOf(address(this));\r\n                // We use strict comparison here to make sure that token transfers always cost 5k gas and not (20k - 15k)\r\n                require(usdtBalance < (2 ** 32) * TOKEN_USDT_MULTIPLIER && usdtBalance > uint256(cachedBankState.usdtBalance) * TOKEN_USDT_MULTIPLIER);\r\n                cachedBankState.usdtBalance = uint32(usdtBalance / TOKEN_USDT_MULTIPLIER);\r\n            }\r\n        }\r\n\r\n        require(cachedBankState.numCalls == state.numCalls);\r\n        cachedBankState.numCalls += 1;\r\n        state = cachedBankState;\r\n    }\r\n\r\n    // Logic related to native gas refunds, it's very short but brainfuck level ugly\r\n    function generateContracts(uint256 amount) external {\r\n        Types.BankState memory cachedState = state;\r\n        uint256 offset = cachedState.totalContractsCreated;\r\n        assembly {\r\n            mstore(callvalue(), 0x766f454a11ca3a574738c0aab442b62d5d453318585733FF60005260176009f3)\r\n            for {let i := div(amount, 32)} i {i := sub(i, 1)} {\r\n                pop(create2(callvalue(), callvalue(), 32, offset))          pop(create2(callvalue(), callvalue(), 32, add(offset, 1)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 2)))  pop(create2(callvalue(), callvalue(), 32, add(offset, 3)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 4)))  pop(create2(callvalue(), callvalue(), 32, add(offset, 5)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 6)))  pop(create2(callvalue(), callvalue(), 32, add(offset, 7)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 8)))  pop(create2(callvalue(), callvalue(), 32, add(offset, 9)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 10))) pop(create2(callvalue(), callvalue(), 32, add(offset, 11)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 12))) pop(create2(callvalue(), callvalue(), 32, add(offset, 13)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 14))) pop(create2(callvalue(), callvalue(), 32, add(offset, 15)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 16))) pop(create2(callvalue(), callvalue(), 32, add(offset, 17)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 18))) pop(create2(callvalue(), callvalue(), 32, add(offset, 19)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 20))) pop(create2(callvalue(), callvalue(), 32, add(offset, 21)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 22))) pop(create2(callvalue(), callvalue(), 32, add(offset, 23)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 24))) pop(create2(callvalue(), callvalue(), 32, add(offset, 25)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 26))) pop(create2(callvalue(), callvalue(), 32, add(offset, 27)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 28))) pop(create2(callvalue(), callvalue(), 32, add(offset, 29)))\r\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 30))) pop(create2(callvalue(), callvalue(), 32, add(offset, 31)))\r\n                offset := add(offset, 32)\r\n            }\r\n\r\n            for {let i := and(amount, 0x1F)} i {i := sub(i, 1)} {\r\n                pop(create2(callvalue(), callvalue(), 32, offset))\r\n                offset := add(offset, 1)\r\n            }\r\n        }\r\n\r\n        require(cachedState.numCalls == state.numCalls && offset < 2 ** 32);\r\n        cachedState.totalContractsCreated = uint32(offset);\r\n        cachedState.numCalls += 1;\r\n        state = cachedState;\r\n    }\r\n    function _destroyContracts(uint256 firstSlot, uint256 lastSlot) internal {\r\n        assembly {\r\n            let i := firstSlot\r\n\r\n            let data := mload(0x40)\r\n            mstore(data, 0xff00000000454a11ca3a574738c0aab442b62d5d450000000000000000000000)\r\n            mstore(add(data, 53), 0x51b94132314e7e963fa256338c05c5dd9c15d277c686d6750c3bc97835a1ed27)\r\n            let ptr := add(data, 21)\r\n            for { } lt(i, lastSlot) { i := add(i, 1) } {\r\n                mstore(ptr, i)\r\n                pop(call(gas(), keccak256(data, 85), 0, 0, 0, 0, 0))\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IApeBot {\r\n    function smallApeCallback(bytes calldata data) external payable;\r\n    function largeApeCallback(\r\n        address sender,\r\n        uint wethToReturn,\r\n        uint wbtcToReturn,\r\n        uint daiToReturn,\r\n        uint usdcToReturn,\r\n        uint usdtToReturn,\r\n        bytes calldata data\r\n    ) external payable;\r\n    function callFunction(address sender, Types.AccountInfo memory accountInfo, bytes memory data) external;\r\n}\r\n\r\nlibrary Types {\r\n    struct BankState {\r\n        uint32 wethBalance;\r\n        uint32 wbtcBalance;\r\n        uint32 daiBalance;\r\n        uint32 usdcBalance;\r\n        uint32 usdtBalance;\r\n        uint32 firstContractToDestroy;\r\n        uint32 totalContractsCreated;\r\n        uint32 numCalls;\r\n    }\r\n    struct GasTokenPrices {\r\n        uint80 priceGST2;\r\n        uint80 priceCHI;\r\n        uint80 priceNative;\r\n    }\r\n    struct AccountInfo {\r\n        address owner;\r\n        uint256 number;\r\n    }\r\n}\r\n\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n// Only relevant calls in interfaces below\r\ninterface IERC20Token {\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n}\r\ninterface WETH9 {\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\ninterface IGasToken {\r\n    function free(uint256 value) external returns (uint256);\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SkimmedBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldTreasury\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"TreasuryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptNomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bestApeOperators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"callTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"flashApe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasTokenBurnPrices\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"priceGST2\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"priceCHI\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"priceNative\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"generateContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nomination\",\"type\":\"address\"}],\"name\":\"nominateTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingTresury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"apeOperator\",\"type\":\"address\"}],\"name\":\"promoteToFreeGasTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"skimExcessBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"wethBalance\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"wbtcBalance\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"daiBalance\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"usdcBalance\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"usdtBalance\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"firstContractToDestroy\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"totalContractsCreated\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numCalls\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"priceGST2\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"priceCHI\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"priceNative\",\"type\":\"uint80\"}],\"name\":\"updateGasTokenPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userEthBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTokenBalances\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"wethBalance\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"wbtcBalance\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"daiBalance\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"usdcBalance\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"usdtBalance\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"firstContractToDestroy\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"totalContractsCreated\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numCalls\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ApeBank","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e82c5c5b6cda6218d1b35614fbd2f42658c9d35663e294d2aeddd1d834940751"}]