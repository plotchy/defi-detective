[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CryptoCocksWhitelistingLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\ninterface Token {\\n    function balanceOf(address owner) external view returns (uint balance);\\n}\\n\\ninterface Token1155 {\\n    function balanceOf(address owner, uint256 id) external view returns (uint balance);\\n}\\n\\nlibrary CryptoCocksWhitelistingLib {\\n    uint8 private constant MAX_PERC_ROYALTIES = 20;\\n\\n    /**\\n     * Whitelisted community contract\\n     */\\n    struct ListContract {\\n        bool erc1155; // true if contract implements IERC11555 otherwise IERC20/IERC721\\n        uint8 id; // unique identifier of a ListContract instance\\n        uint8 percRoyal; // percentage royal fee for each contract\\n        uint16 maxSupply; // max NFTs for whitelisted owners\\n        uint16 minBalance; // min balance needed on whitelisted contracts\\n        uint16 tracker; // tracking number of minted NFTs per whitelisted contract\\n        uint128 balance;  // tracking accumulated royalty fee\\n        uint256 erc1155Id; // erc1155 token type id\\n        address cc; // community contract addresses\\n        address wallet; // community wallet addresses\\n    }\\n\\n    struct Set {\\n        // storage of ListContract instances\\n        ListContract[] _values;\\n\\n        // position of a ListContract in the `values` array, plus 1 because index 0\\n        // means a ListContract is not in the set.\\n        mapping(uint8 => uint8) _indexes;\\n    }\\n\\n    struct Whitelist {\\n        uint8 usedRoyal; // available royal for community wallets (in percentage points)\\n        Set lists;\\n    }\\n\\n    /**\\n     * @dev Add a ListContract to the set. O(1).\\n     *\\n     * Returns true if the ListContract was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Whitelist storage self, ListContract memory lc) private returns (bool) {\\n        if (!contains(self, lc.id)) {\\n            self.lists._values.push(lc);\\n            self.lists._indexes[lc.id] = SafeCast.toUint8(self.lists._values.length);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a ListContract by id. O(1).\\n     *\\n     * Returns true if the ListContract was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Whitelist storage self, uint8 lcId) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint8 listContractIndex = self.lists._indexes[lcId];\\n\\n        if (listContractIndex != 0) {\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array.\\n\\n            uint8 toDeleteIndex = listContractIndex - 1;\\n            uint8 lastIndex = SafeCast.toUint8(self.lists._values.length - 1);\\n\\n            if (lastIndex != toDeleteIndex) {\\n                ListContract storage lastListContract = self.lists._values[lastIndex];\\n\\n                // Move the last ListContract to the index where the value to delete is\\n                self.lists._values[toDeleteIndex] = lastListContract;\\n                // Update the index for the moved ListContract\\n                self.lists._indexes[lastListContract.id] = listContractIndex; // Replace lastListContract's index to listContractIndex\\n            }\\n\\n            // Delete the slot where the moved ListContract was stored\\n            self.lists._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete self.lists._indexes[lcId];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the ListContract with an identifier is already in the set. O(1).\\n     */\\n    function contains(Whitelist storage self, uint8 id) private view returns (bool) {\\n        return self.lists._indexes[id] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of ListContract instances on the set. O(1).\\n     */\\n    function length(Whitelist storage self) private view returns (uint8) {\\n        return SafeCast.toUint8(self.lists._values.length);\\n    }\\n\\n    /**\\n     * @dev Returns the ListContract stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of instances inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Whitelist storage self, uint8 index) private view returns (ListContract storage) {\\n        return self.lists._values[index];\\n    }\\n\\n    /**\\n     * Check token balance of address on an ERC721, ERC20 or ERC1155 contract\\n     */\\n    function queryBalance(Whitelist storage self, uint8 listIndex, address addressToQuery) public view returns (uint) {\\n        ListContract storage lc = at(self, listIndex);\\n        // slither-disable-next-line calls-loop\\n        return lc.erc1155 ? Token1155(lc.cc).balanceOf(addressToQuery, lc.erc1155Id) : Token(lc.cc).balanceOf(addressToQuery);\\n    }\\n\\n    function increaseSupply(Whitelist storage self, uint8 idx) external {\\n        ListContract storage lc = at(self, idx);\\n        lc.tracker += 1;\\n    }\\n\\n    function depositRoyalties(Whitelist storage self, uint128 value) external {\\n        for (uint8 idx = 0; (idx < length(self)); idx++) {\\n            ListContract storage lc = at(self, idx);\\n            lc.balance += uint128((value * lc.percRoyal) / 100);\\n        }\\n    }\\n\\n    function checkListed(Whitelist storage self, address account) external view returns (bool, uint8) {\\n        for (uint8 i = 0; (i < length(self)); i++) {\\n            ListContract storage lc = at(self, i);\\n            if ((queryBalance(self, i, account) >= lc.minBalance) && (lc.maxSupply > lc.tracker)) {\\n                return (true, i);\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    /**\\n     * Add contract address to whitelisting with maxSupply\\n     * Allows token holders to mint NFTs before the Public Sale start\\n     */\\n    function addContract(\\n        Whitelist storage self,\\n        uint8 id,\\n        bool erc1155,\\n        address cc,\\n        address payable wallet,\\n        uint16 maxSupply,\\n        uint16 minBalance,\\n        uint8 percRoyal,\\n        uint erc1155Id\\n    ) public {\\n        require((MAX_PERC_ROYALTIES - self.usedRoyal) >= percRoyal, \\\"FEE_TOO_HIGH\\\");\\n        add(self, ListContract(erc1155, id, percRoyal, maxSupply, minBalance, 0, 0, erc1155Id, cc, wallet));\\n        self.usedRoyal += percRoyal;\\n    }\\n\\n    function getListContract(Whitelist storage self, uint8 lcId) public view returns (ListContract storage lc) {\\n        if (contains(self, lcId)) {\\n            uint8 idx = self.lists._indexes[lcId] - 1;\\n            return at(self, idx);\\n        }\\n        revert(\\\"LC_NOT_FOUND\\\");\\n    }\\n\\n    function removeContract(Whitelist storage self, uint8 lcId) public {\\n        ListContract storage lc = getListContract(self, lcId);\\n        self.usedRoyal -= lc.percRoyal;\\n        remove(self, lcId);\\n    }\\n\\n    function popRoyalties(Whitelist storage self, address wallet) external returns(uint128 balance) {\\n        for (uint8 i = 0; (i < length(self)); i++) {\\n            ListContract storage lc = at(self, i);\\n            if (lc.wallet == wallet) {\\n                uint128 lcBalance = lc.balance;\\n                lc.balance = 0;\\n                return lcBalance;\\n            }\\n        }\\n        revert(\\\"NO_COMMUNITY_WALLET\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[]","ContractName":"CryptoCocksWhitelistingLib","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]