[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/ConduitInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\n/**\\n * @title ConduitInterface\\n * @author 0age\\n * @notice ConduitInterface contains all external function interfaces, events,\\n *         and errors for conduit contracts.\\n */\\ninterface ConduitInterface {\\n    /**\\n     * @dev Revert with an error when attempting to execute transfers using a\\n     *      caller that does not have an open channel.\\n     */\\n    error ChannelClosed();\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute a transfer for an\\n     *      item that does not have an ERC20/721/1155 item type.\\n     */\\n    error InvalidItemType();\\n\\n    /**\\n     * @dev Revert with an error when attempting to update the status of a\\n     *      channel from a caller that is not the conduit controller.\\n     */\\n    error InvalidController();\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute an 1155 batch\\n     *      transfer using calldata not produced by default ABI encoding or with\\n     *      different lengths for ids and amounts arrays.\\n     */\\n    error Invalid1155BatchTransferEncoding();\\n\\n    /**\\n     * @dev Emit an event whenever a channel is opened or closed.\\n     *\\n     * @param channel The channel that has been updated.\\n     * @param open    A boolean indicating whether the conduit is open or not.\\n     */\\n    event ChannelUpdated(address channel, bool open);\\n\\n    /**\\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\\n     *         with an open channel can call this function.\\n     *\\n     * @param transfers The ERC20/721/1155 transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function execute(ConduitTransfer[] calldata transfers)\\n        external\\n        returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\\n     *         open channel can call this function.\\n     *\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\\n     *         a caller with an open channel can call this function.\\n     *\\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata standardTransfers,\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Open or close a given channel. Only callable by the controller.\\n     *\\n     * @param channel The channel to open or close.\\n     * @param isOpen  The status of the channel (either open or closed).\\n     */\\n    function updateChannel(address channel, bool isOpen) external;\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { ConduitItemType } from \\\"./ConduitEnums.sol\\\";\\n\\nstruct ConduitTransfer {\\n    ConduitItemType itemType;\\n    address token;\\n    address from;\\n    address to;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\nstruct ConduitBatch1155Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256[] ids;\\n    uint256[] amounts;\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nenum ConduitItemType {\\n    NATIVE, // unused\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Executor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport {\\n    ERC20Interface,\\n    ERC721Interface,\\n    ERC1155Interface\\n} from \\\"../interfaces/AbridgedTokenInterfaces.sol\\\";\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport { ItemType } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport { ReceivedItem } from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { Verifiers } from \\\"./Verifiers.sol\\\";\\n\\nimport { TokenTransferrer } from \\\"./TokenTransferrer.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title Executor\\n * @author 0age\\n * @notice Executor contains functions related to processing executions (i.e.\\n *         transferring items, either directly or via conduits).\\n */\\ncontract Executor is Verifiers, TokenTransferrer {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) Verifiers(conduitController) {}\\n\\n    /**\\n     * @dev Internal function to transfer a given item, either directly or via\\n     *      a corresponding conduit.\\n     *\\n     * @param item        The item to transfer, including an amount and a\\n     *                    recipient.\\n     * @param from        The account supplying the item.\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _transfer(\\n        ReceivedItem memory item,\\n        address from,\\n        bytes32 conduitKey,\\n        bytes memory accumulator\\n    ) internal {\\n        // If the item type indicates Ether or a native token...\\n        if (item.itemType == ItemType.NATIVE) {\\n            // transfer the native tokens to the recipient.\\n            _transferEth(item.recipient, item.amount);\\n        } else if (item.itemType == ItemType.ERC20) {\\n            // Transfer ERC20 tokens from the source to the recipient.\\n            _transferERC20(\\n                item.token,\\n                from,\\n                item.recipient,\\n                item.amount,\\n                conduitKey,\\n                accumulator\\n            );\\n        } else if (item.itemType == ItemType.ERC721) {\\n            // Transfer ERC721 token from the source to the recipient.\\n            _transferERC721(\\n                item.token,\\n                from,\\n                item.recipient,\\n                item.identifier,\\n                item.amount,\\n                conduitKey,\\n                accumulator\\n            );\\n        } else {\\n            // Transfer ERC1155 token from the source to the recipient.\\n            _transferERC1155(\\n                item.token,\\n                from,\\n                item.recipient,\\n                item.identifier,\\n                item.amount,\\n                conduitKey,\\n                accumulator\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer an individual ERC721 or ERC1155 item\\n     *      from a given originator to a given recipient. The accumulator will\\n     *      be bypassed, meaning that this function should be utilized in cases\\n     *      where multiple item transfers can be accumulated into a single\\n     *      conduit call. Sufficient approvals must be set, either on the\\n     *      respective conduit or on this contract itself.\\n     *\\n     * @param itemType   The type of item to transfer, either ERC721 or ERC1155.\\n     * @param token      The token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The tokenId to transfer.\\n     * @param amount     The amount to transfer.\\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\\n     *                   if any, to source token approvals from. The zero hash\\n     *                   signifies that no conduit should be used, with direct\\n     *                   approvals set on this contract.\\n     */\\n    function _transferIndividual721Or1155Item(\\n        ItemType itemType,\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount,\\n        bytes32 conduitKey\\n    ) internal {\\n        // Determine if the transfer is to be performed via a conduit.\\n        if (conduitKey != bytes32(0)) {\\n            // Use free memory pointer as calldata offset for the conduit call.\\n            uint256 callDataOffset;\\n\\n            // Utilize assembly to place each argument in free memory.\\n            assembly {\\n                // Retrieve the free memory pointer and use it as the offset.\\n                callDataOffset := mload(FreeMemoryPointerSlot)\\n\\n                // Write ConduitInterface.execute.selector to memory.\\n                mstore(callDataOffset, Conduit_execute_signature)\\n\\n                // Write the offset to the ConduitTransfer array in memory.\\n                mstore(\\n                    add(\\n                        callDataOffset,\\n                        Conduit_execute_ConduitTransfer_offset_ptr\\n                    ),\\n                    Conduit_execute_ConduitTransfer_ptr\\n                )\\n\\n                // Write the length of the ConduitTransfer array to memory.\\n                mstore(\\n                    add(\\n                        callDataOffset,\\n                        Conduit_execute_ConduitTransfer_length_ptr\\n                    ),\\n                    Conduit_execute_ConduitTransfer_length\\n                )\\n\\n                // Write the item type to memory.\\n                mstore(\\n                    add(callDataOffset, Conduit_execute_transferItemType_ptr),\\n                    itemType\\n                )\\n\\n                // Write the token to memory.\\n                mstore(\\n                    add(callDataOffset, Conduit_execute_transferToken_ptr),\\n                    token\\n                )\\n\\n                // Write the transfer source to memory.\\n                mstore(\\n                    add(callDataOffset, Conduit_execute_transferFrom_ptr),\\n                    from\\n                )\\n\\n                // Write the transfer recipient to memory.\\n                mstore(add(callDataOffset, Conduit_execute_transferTo_ptr), to)\\n\\n                // Write the token identifier to memory.\\n                mstore(\\n                    add(callDataOffset, Conduit_execute_transferIdentifier_ptr),\\n                    identifier\\n                )\\n\\n                // Write the transfer amount to memory.\\n                mstore(\\n                    add(callDataOffset, Conduit_execute_transferAmount_ptr),\\n                    amount\\n                )\\n            }\\n\\n            // Perform the call to the conduit.\\n            _callConduitUsingOffsets(\\n                conduitKey,\\n                callDataOffset,\\n                OneConduitExecute_size\\n            );\\n        } else {\\n            // Otherwise, determine whether it is an ERC721 or ERC1155 item.\\n            if (itemType == ItemType.ERC721) {\\n                // Ensure that exactly one 721 item is being transferred.\\n                if (amount != 1) {\\n                    revert InvalidERC721TransferAmount();\\n                }\\n\\n                // Perform transfer via the token contract directly.\\n                _performERC721Transfer(token, from, to, identifier);\\n            } else {\\n                // Perform transfer via the token contract directly.\\n                _performERC1155Transfer(token, from, to, identifier, amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer Ether or other native tokens to a\\n     *      given recipient.\\n     *\\n     * @param to     The recipient of the transfer.\\n     * @param amount The amount to transfer.\\n     */\\n    function _transferEth(address payable to, uint256 amount) internal {\\n        // Ensure that the supplied amount is non-zero.\\n        _assertNonZeroAmount(amount);\\n\\n        // Declare a variable indicating whether the call was successful or not.\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        // If the call fails...\\n        if (!success) {\\n            // Revert and pass the revert reason along if one was returned.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // Otherwise, revert with a generic error message.\\n            revert EtherTransferGenericFailure(to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens from a given originator\\n     *      to a given recipient using a given conduit if applicable. Sufficient\\n     *      approvals must be set on this contract or on a respective conduit.\\n     *\\n     * @param token       The ERC20 token to transfer.\\n     * @param from        The originator of the transfer.\\n     * @param to          The recipient of the transfer.\\n     * @param amount      The amount to transfer.\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _transferERC20(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes32 conduitKey,\\n        bytes memory accumulator\\n    ) internal {\\n        // Ensure that the supplied amount is non-zero.\\n        _assertNonZeroAmount(amount);\\n\\n        // Trigger accumulated transfers if the conduits differ.\\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\\n\\n        // If no conduit has been specified...\\n        if (conduitKey == bytes32(0)) {\\n            // Perform the token transfer directly.\\n            _performERC20Transfer(token, from, to, amount);\\n        } else {\\n            // Insert the call to the conduit into the accumulator.\\n            _insert(\\n                conduitKey,\\n                accumulator,\\n                uint256(1),\\n                token,\\n                from,\\n                to,\\n                uint256(0),\\n                amount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer a single ERC721 token from a given\\n     *      originator to a given recipient. Sufficient approvals must be set,\\n     *      either on the respective conduit or on this contract itself.\\n     *\\n     * @param token       The ERC721 token to transfer.\\n     * @param from        The originator of the transfer.\\n     * @param to          The recipient of the transfer.\\n     * @param identifier  The tokenId to transfer (must be 1 for ERC721).\\n     * @param amount      The amount to transfer.\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _transferERC721(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount,\\n        bytes32 conduitKey,\\n        bytes memory accumulator\\n    ) internal {\\n        // Trigger accumulated transfers if the conduits differ.\\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\\n\\n        // If no conduit has been specified...\\n        if (conduitKey == bytes32(0)) {\\n            // Ensure that exactly one 721 item is being transferred.\\n            if (amount != 1) {\\n                revert InvalidERC721TransferAmount();\\n            }\\n\\n            // Perform transfer via the token contract directly.\\n            _performERC721Transfer(token, from, to, identifier);\\n        } else {\\n            // Insert the call to the conduit into the accumulator.\\n            _insert(\\n                conduitKey,\\n                accumulator,\\n                uint256(2),\\n                token,\\n                from,\\n                to,\\n                identifier,\\n                amount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given originator\\n     *      to a given recipient. Sufficient approvals must be set, either on\\n     *      the respective conduit or on this contract itself.\\n     *\\n     * @param token       The ERC1155 token to transfer.\\n     * @param from        The originator of the transfer.\\n     * @param to          The recipient of the transfer.\\n     * @param identifier  The id to transfer.\\n     * @param amount      The amount to transfer.\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _transferERC1155(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount,\\n        bytes32 conduitKey,\\n        bytes memory accumulator\\n    ) internal {\\n        // Ensure that the supplied amount is non-zero.\\n        _assertNonZeroAmount(amount);\\n\\n        // Trigger accumulated transfers if the conduits differ.\\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\\n\\n        // If no conduit has been specified...\\n        if (conduitKey == bytes32(0)) {\\n            // Perform transfer via the token contract directly.\\n            _performERC1155Transfer(token, from, to, identifier, amount);\\n        } else {\\n            // Insert the call to the conduit into the accumulator.\\n            _insert(\\n                conduitKey,\\n                accumulator,\\n                uint256(3),\\n                token,\\n                from,\\n                to,\\n                identifier,\\n                amount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to trigger a call to the conduit currently held by\\n     *      the accumulator if the accumulator contains item transfers (i.e. it\\n     *      is \\\"armed\\\") and the supplied conduit key does not match the key held\\n     *      by the accumulator.\\n     *\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     */\\n    function _triggerIfArmedAndNotAccumulatable(\\n        bytes memory accumulator,\\n        bytes32 conduitKey\\n    ) internal {\\n        // Retrieve the current conduit key from the accumulator.\\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\\n\\n        // Perform conduit call if the set key does not match the supplied key.\\n        if (accumulatorConduitKey != conduitKey) {\\n            _triggerIfArmed(accumulator);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to trigger a call to the conduit currently held by\\n     *      the accumulator if the accumulator contains item transfers (i.e. it\\n     *      is \\\"armed\\\").\\n     *\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _triggerIfArmed(bytes memory accumulator) internal {\\n        // Exit if the accumulator is not \\\"armed\\\".\\n        if (accumulator.length != 64) {\\n            return;\\n        }\\n\\n        // Retrieve the current conduit key from the accumulator.\\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\\n\\n        // Perform conduit call.\\n        _trigger(accumulatorConduitKey, accumulator);\\n    }\\n\\n    /**\\n     * @dev Internal function to trigger a call to the conduit corresponding to\\n     *      a given conduit key, supplying all accumulated item transfers. The\\n     *      accumulator will be \\\"disarmed\\\" and reset in the process.\\n     *\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _trigger(bytes32 conduitKey, bytes memory accumulator) internal {\\n        // Declare variables for offset in memory & size of calldata to conduit.\\n        uint256 callDataOffset;\\n        uint256 callDataSize;\\n\\n        // Call the conduit with all the accumulated transfers.\\n        assembly {\\n            // Call begins at third word; the first is length or \\\"armed\\\" status,\\n            // and the second is the current conduit key.\\n            callDataOffset := add(accumulator, TwoWords)\\n\\n            // 68 + items * 192\\n            callDataSize := add(\\n                Accumulator_array_offset_ptr,\\n                mul(\\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\\n                    Conduit_transferItem_size\\n                )\\n            )\\n        }\\n\\n        // Call conduit derived from conduit key & supply accumulated transfers.\\n        _callConduitUsingOffsets(conduitKey, callDataOffset, callDataSize);\\n\\n        // Reset accumulator length to signal that it is now \\\"disarmed\\\".\\n        assembly {\\n            mstore(accumulator, AccumulatorDisarmed)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to perform a call to the conduit corresponding to\\n     *      a given conduit key based on the offset and size of the calldata in\\n     *      question in memory.\\n     *\\n     * @param conduitKey     A bytes32 value indicating what corresponding\\n     *                       conduit, if any, to source token approvals from.\\n     *                       The zero hash signifies that no conduit should be\\n     *                       used, with direct approvals set on this contract.\\n     * @param callDataOffset The memory pointer where calldata is contained.\\n     * @param callDataSize   The size of calldata in memory.\\n     */\\n    function _callConduitUsingOffsets(\\n        bytes32 conduitKey,\\n        uint256 callDataOffset,\\n        uint256 callDataSize\\n    ) internal {\\n        // Derive the address of the conduit using the conduit key.\\n        address conduit = _deriveConduit(conduitKey);\\n\\n        bool success;\\n\\n        // call the conduit.\\n        assembly {\\n            // Ensure first word of scratch space is empty.\\n            mstore(0, 0)\\n\\n            // Perform call, placing first word of return data in scratch space.\\n            success := call(\\n                gas(),\\n                conduit,\\n                0,\\n                callDataOffset,\\n                callDataSize,\\n                0,\\n                OneWord\\n            )\\n        }\\n\\n        // If the call failed...\\n        if (!success) {\\n            // Pass along whatever revert reason was given by the conduit.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // Otherwise, revert with a generic error.\\n            revert InvalidCallToConduit(conduit);\\n        }\\n\\n        // Ensure that the conduit returned the correct magic value.\\n        bytes4 result;\\n        assembly {\\n            // Take value from scratch space and place it on the stack.\\n            result := mload(0)\\n        }\\n\\n        // Ensure result was extracted and matches EIP-1271 magic value.\\n        if (result != ConduitInterface.execute.selector) {\\n            revert InvalidConduit(conduitKey, conduit);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to retrieve the current conduit key set for\\n     *      the accumulator.\\n     *\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     *\\n     * @return accumulatorConduitKey The conduit key currently set for the\\n     *                               accumulator.\\n     */\\n    function _getAccumulatorConduitKey(bytes memory accumulator)\\n        internal\\n        pure\\n        returns (bytes32 accumulatorConduitKey)\\n    {\\n        // Retrieve the current conduit key from the accumulator.\\n        assembly {\\n            accumulatorConduitKey := mload(\\n                add(accumulator, Accumulator_conduitKey_ptr)\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to place an item transfer into an accumulator\\n     *      that collects a series of transfers to execute against a given\\n     *      conduit in a single call.\\n     *\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     * @param itemType    The type of the item to transfer.\\n     * @param token       The token to transfer.\\n     * @param from        The originator of the transfer.\\n     * @param to          The recipient of the transfer.\\n     * @param identifier  The tokenId to transfer.\\n     * @param amount      The amount to transfer.\\n     */\\n    function _insert(\\n        bytes32 conduitKey,\\n        bytes memory accumulator,\\n        uint256 itemType,\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    ) internal pure {\\n        uint256 elements;\\n        // \\\"Arm\\\" and prime accumulator if it's not already armed. The sentinel\\n        // value is held in the length of the accumulator array.\\n        if (accumulator.length == AccumulatorDisarmed) {\\n            elements = 1;\\n            bytes4 selector = ConduitInterface.execute.selector;\\n            assembly {\\n                mstore(accumulator, AccumulatorArmed) // \\\"arm\\\" the accumulator.\\n                mstore(add(accumulator, Accumulator_conduitKey_ptr), conduitKey)\\n                mstore(add(accumulator, Accumulator_selector_ptr), selector)\\n                mstore(\\n                    add(accumulator, Accumulator_array_offset_ptr),\\n                    Accumulator_array_offset\\n                )\\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\\n            }\\n        } else {\\n            // Otherwise, increase the number of elements by one.\\n            assembly {\\n                elements := add(\\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\\n                    1\\n                )\\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\\n            }\\n        }\\n\\n        // Insert the item.\\n        assembly {\\n            let itemPointer := sub(\\n                add(accumulator, mul(elements, Conduit_transferItem_size)),\\n                Accumulator_itemSizeOffsetDifference\\n            )\\n            mstore(itemPointer, itemType)\\n            mstore(add(itemPointer, Conduit_transferItem_token_ptr), token)\\n            mstore(add(itemPointer, Conduit_transferItem_from_ptr), from)\\n            mstore(add(itemPointer, Conduit_transferItem_to_ptr), to)\\n            mstore(\\n                add(itemPointer, Conduit_transferItem_identifier_ptr),\\n                identifier\\n            )\\n            mstore(add(itemPointer, Conduit_transferItem_amount_ptr), amount)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/AbridgedTokenInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface ERC20Interface {\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n}\\n\\ninterface ERC721Interface {\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\\ninterface ERC1155Interface {\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ConsiderationEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nenum OrderType {\\n    // 0: no partial fills, anyone can execute\\n    FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    PARTIAL_RESTRICTED\\n}\\n\\nenum BasicOrderType {\\n    // 0: no partial fills, anyone can execute\\n    ETH_TO_ERC721_FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    ETH_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 4: no partial fills, anyone can execute\\n    ETH_TO_ERC1155_FULL_OPEN,\\n\\n    // 5: partial fills supported, anyone can execute\\n    ETH_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 6: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 7: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 8: no partial fills, anyone can execute\\n    ERC20_TO_ERC721_FULL_OPEN,\\n\\n    // 9: partial fills supported, anyone can execute\\n    ERC20_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 10: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 11: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 12: no partial fills, anyone can execute\\n    ERC20_TO_ERC1155_FULL_OPEN,\\n\\n    // 13: partial fills supported, anyone can execute\\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 14: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 15: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 16: no partial fills, anyone can execute\\n    ERC721_TO_ERC20_FULL_OPEN,\\n\\n    // 17: partial fills supported, anyone can execute\\n    ERC721_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 18: no partial fills, only offerer or zone can execute\\n    ERC721_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 19: partial fills supported, only offerer or zone can execute\\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\\n\\n    // 20: no partial fills, anyone can execute\\n    ERC1155_TO_ERC20_FULL_OPEN,\\n\\n    // 21: partial fills supported, anyone can execute\\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 22: no partial fills, only offerer or zone can execute\\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 23: partial fills supported, only offerer or zone can execute\\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\\n}\\n\\nenum BasicOrderRouteType {\\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\\n    ETH_TO_ERC721,\\n\\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\\n    ETH_TO_ERC1155,\\n\\n    // 2: provide ERC20 item to receive offered ERC721 item.\\n    ERC20_TO_ERC721,\\n\\n    // 3: provide ERC20 item to receive offered ERC1155 item.\\n    ERC20_TO_ERC1155,\\n\\n    // 4: provide ERC721 item to receive offered ERC20 item.\\n    ERC721_TO_ERC20,\\n\\n    // 5: provide ERC1155 item to receive offered ERC20 item.\\n    ERC1155_TO_ERC20\\n}\\n\\nenum ItemType {\\n    // 0: ETH on mainnet, MATIC on polygon, etc.\\n    NATIVE,\\n\\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\\n    ERC20,\\n\\n    // 2: ERC721 items\\n    ERC721,\\n\\n    // 3: ERC1155 items\\n    ERC1155,\\n\\n    // 4: ERC721 items where a number of tokenIds are supported\\n    ERC721_WITH_CRITERIA,\\n\\n    // 5: ERC1155 items where a number of ids are supported\\n    ERC1155_WITH_CRITERIA\\n}\\n\\nenum Side {\\n    // 0: Items that can be spent\\n    OFFER,\\n\\n    // 1: Items that must be received\\n    CONSIDERATION\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ConsiderationStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport {\\n    OrderType,\\n    BasicOrderType,\\n    ItemType,\\n    Side\\n} from \\\"./ConsiderationEnums.sol\\\";\\n\\n/**\\n * @dev An order contains eleven components: an offerer, a zone (or account that\\n *      can cancel the order or restrict who can fulfill the order depending on\\n *      the type), the order type (specifying partial fill support as well as\\n *      restricted order status), the start and end time, a hash that will be\\n *      provided to the zone when validating restricted orders, a salt, a key\\n *      corresponding to a given conduit, a nonce, and an arbitrary number of\\n *      offer items that can be spent along with consideration items that must\\n *      be received by their respective recipient.\\n */\\nstruct OrderComponents {\\n    address offerer;\\n    address zone;\\n    OfferItem[] offer;\\n    ConsiderationItem[] consideration;\\n    OrderType orderType;\\n    uint256 startTime;\\n    uint256 endTime;\\n    bytes32 zoneHash;\\n    uint256 salt;\\n    bytes32 conduitKey;\\n    uint256 nonce;\\n}\\n\\n/**\\n * @dev An offer item has five components: an item type (ETH or other native\\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\\n *      ERC1155), a token address, a dual-purpose \\\"identifierOrCriteria\\\"\\n *      component that will either represent a tokenId or a merkle root\\n *      depending on the item type, and a start and end amount that support\\n *      increasing or decreasing amounts over the duration of the respective\\n *      order.\\n */\\nstruct OfferItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n}\\n\\n/**\\n * @dev A consideration item has the same five components as an offer item and\\n *      an additional sixth component designating the required recipient of the\\n *      item.\\n */\\nstruct ConsiderationItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev A spent item is translated from a utilized offer item an has four\\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\\n *      ERC1155), a token address, a tokenId, and an amount.\\n */\\nstruct SpentItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev A received item is translated from a utilized consideration item and has\\n *      the same four components as a spent item, as well as an additional fifth\\n *      component designating the required recipient of the item.\\n */\\nstruct ReceivedItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\\n *      matching, a group of six functions may be called that only requires a\\n *      subset of the usual order arguments. Note the use of a \\\"basicOrderType\\\"\\n *      enum; this represents both the usual order type as well as the \\\"route\\\"\\n *      of the basic order (a simple derivation function for the basic order\\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\\n */\\nstruct BasicOrderParameters {\\n    // calldata offset\\n    address considerationToken; // 0x24\\n    uint256 considerationIdentifier; // 0x44\\n    uint256 considerationAmount; // 0x64\\n    address payable offerer; // 0x84\\n    address zone; // 0xa4\\n    address offerToken; // 0xc4\\n    uint256 offerIdentifier; // 0xe4\\n    uint256 offerAmount; // 0x104\\n    BasicOrderType basicOrderType; // 0x124\\n    uint256 startTime; // 0x144\\n    uint256 endTime; // 0x164\\n    bytes32 zoneHash; // 0x184\\n    uint256 salt; // 0x1a4\\n    bytes32 offererConduitKey; // 0x1c4\\n    bytes32 fulfillerConduitKey; // 0x1e4\\n    uint256 totalOriginalAdditionalRecipients; // 0x204\\n    AdditionalRecipient[] additionalRecipients; // 0x224\\n    bytes signature; // 0x244\\n    // Total length, excluding dynamic array data: 0x264 (580)\\n}\\n\\n/**\\n * @dev Basic orders can supply any number of additional recipients, with the\\n *      implied assumption that they are supplied from the offered ETH (or other\\n *      native token) or ERC20 token for the order.\\n */\\nstruct AdditionalRecipient {\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev The full set of order components, with the exception of the nonce, must\\n *      be supplied when fulfilling more sophisticated orders or groups of\\n *      orders. The total number of original consideration items must also be\\n *      supplied, as the caller may specify additional consideration items.\\n */\\nstruct OrderParameters {\\n    address offerer; // 0x00\\n    address zone; // 0x20\\n    OfferItem[] offer; // 0x40\\n    ConsiderationItem[] consideration; // 0x60\\n    OrderType orderType; // 0x80\\n    uint256 startTime; // 0xa0\\n    uint256 endTime; // 0xc0\\n    bytes32 zoneHash; // 0xe0\\n    uint256 salt; // 0x100\\n    bytes32 conduitKey; // 0x120\\n    uint256 totalOriginalConsiderationItems; // 0x140\\n    // offer.length                          // 0x160\\n}\\n\\n/**\\n * @dev Orders require a signature in addition to the other order parameters.\\n */\\nstruct Order {\\n    OrderParameters parameters;\\n    bytes signature;\\n}\\n\\n/**\\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\\n *      and a denominator (the total size of the order) in addition to the\\n *      signature and other order parameters. It also supports an optional field\\n *      for supplying extra data; this data will be included in a staticcall to\\n *      `isValidOrderIncludingExtraData` on the zone for the order if the order\\n *      type is restricted and the offerer or zone are not the caller.\\n */\\nstruct AdvancedOrder {\\n    OrderParameters parameters;\\n    uint120 numerator;\\n    uint120 denominator;\\n    bytes signature;\\n    bytes extraData;\\n}\\n\\n/**\\n * @dev Orders can be validated (either explicitly via `validate`, or as a\\n *      consequence of a full or partial fill), specifically cancelled (they can\\n *      also be cancelled in bulk via incrementing a per-zone nonce), and\\n *      partially or fully filled (with the fraction filled represented by a\\n *      numerator and denominator).\\n */\\nstruct OrderStatus {\\n    bool isValidated;\\n    bool isCancelled;\\n    uint120 numerator;\\n    uint120 denominator;\\n}\\n\\n/**\\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\\n *      alongside a merkle proof demonstrating the identifier meets the required\\n *      criteria.\\n */\\nstruct CriteriaResolver {\\n    uint256 orderIndex;\\n    Side side;\\n    uint256 index;\\n    uint256 identifier;\\n    bytes32[] criteriaProof;\\n}\\n\\n/**\\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\\n *      offer and consideration items, then generates a single execution\\n *      element. A given fulfillment can be applied to as many offer and\\n *      consideration items as desired, but must contain at least one offer and\\n *      at least one consideration that match. The fulfillment must also remain\\n *      consistent on all key parameters across all offer items (same offerer,\\n *      token, type, tokenId, and conduit preference) as well as across all\\n *      consideration items (token, type, tokenId, and recipient).\\n */\\nstruct Fulfillment {\\n    FulfillmentComponent[] offerComponents;\\n    FulfillmentComponent[] considerationComponents;\\n}\\n\\n/**\\n * @dev Each fulfillment component contains one index referencing a specific\\n *      order and another referencing a specific offer or consideration item.\\n */\\nstruct FulfillmentComponent {\\n    uint256 orderIndex;\\n    uint256 itemIndex;\\n}\\n\\n/**\\n * @dev An execution is triggered once all consideration items have been zeroed\\n *      out. It sends the item in question from the offerer to the item's\\n *      recipient, optionally sourcing approvals from either this contract\\n *      directly or from the offerer's chosen conduit if one is specified. An\\n *      execution is not provided as an argument, but rather is derived via\\n *      orders, criteria resolvers, and fulfillments (where the total number of\\n *      executions will be less than or equal to the total number of indicated\\n *      fulfillments) and returned as part of `matchOrders`.\\n */\\nstruct Execution {\\n    ReceivedItem item;\\n    address offerer;\\n    bytes32 conduitKey;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Verifiers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { OrderStatus } from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { Assertions } from \\\"./Assertions.sol\\\";\\n\\nimport { SignatureVerification } from \\\"./SignatureVerification.sol\\\";\\n\\n/**\\n * @title Verifiers\\n * @author 0age\\n * @notice Verifiers contains functions for performing verifications.\\n */\\ncontract Verifiers is Assertions, SignatureVerification {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) Assertions(conduitController) {}\\n\\n    /**\\n     * @dev Internal view function to ensure that the current time falls within\\n     *      an order's valid timespan.\\n     *\\n     * @param startTime       The time at which the order becomes active.\\n     * @param endTime         The time at which the order becomes inactive.\\n     * @param revertOnInvalid A boolean indicating whether to revert if the\\n     *                        order is not active.\\n     *\\n     * @return valid A boolean indicating whether the order is active.\\n     */\\n    function _verifyTime(\\n        uint256 startTime,\\n        uint256 endTime,\\n        bool revertOnInvalid\\n    ) internal view returns (bool valid) {\\n        // Revert if order's timespan hasn't started yet or has already ended.\\n        if (startTime > block.timestamp || endTime <= block.timestamp) {\\n            // Only revert if revertOnInvalid has been supplied as true.\\n            if (revertOnInvalid) {\\n                revert InvalidTime();\\n            }\\n\\n            // Return false as the order is invalid.\\n            return false;\\n        }\\n\\n        // Return true as the order time is valid.\\n        valid = true;\\n    }\\n\\n    /**\\n     * @dev Internal view function to verify the signature of an order. An\\n     *      ERC-1271 fallback will be attempted if either the signature length\\n     *      is not 32 or 33 bytes or if the recovered signer does not match the\\n     *      supplied offerer. Note that in cases where a 32 or 33 byte signature\\n     *      is supplied, only standard ECDSA signatures that recover to a\\n     *      non-zero address are supported.\\n     *\\n     * @param offerer   The offerer for the order.\\n     * @param orderHash The order hash.\\n     * @param signature A signature from the offerer indicating that the order\\n     *                  has been approved.\\n     */\\n    function _verifySignature(\\n        address offerer,\\n        bytes32 orderHash,\\n        bytes memory signature\\n    ) internal view {\\n        // Skip signature verification if the offerer is the caller.\\n        if (offerer == msg.sender) {\\n            return;\\n        }\\n\\n        // Derive EIP-712 digest using the domain separator and the order hash.\\n        bytes32 digest = _deriveEIP712Digest(_domainSeparator(), orderHash);\\n\\n        // Ensure that the signature for the digest is valid for the offerer.\\n        _assertValidSignature(offerer, digest, signature);\\n    }\\n\\n    /**\\n     * @dev Internal pure function to validate that a given order is fillable\\n     *      and not cancelled based on the order status.\\n     *\\n     * @param orderHash       The order hash.\\n     * @param orderStatus     The status of the order, including whether it has\\n     *                        been cancelled and the fraction filled.\\n     * @param onlyAllowUnused A boolean flag indicating whether partial fills\\n     *                        are supported by the calling function.\\n     * @param revertOnInvalid A boolean indicating whether to revert if the\\n     *                        order has been cancelled or filled beyond the\\n     *                        allowable amount.\\n     *\\n     * @return valid A boolean indicating whether the order is valid.\\n     */\\n    function _verifyOrderStatus(\\n        bytes32 orderHash,\\n        OrderStatus memory orderStatus,\\n        bool onlyAllowUnused,\\n        bool revertOnInvalid\\n    ) internal pure returns (bool valid) {\\n        // Ensure that the order has not been cancelled.\\n        if (orderStatus.isCancelled) {\\n            // Only revert if revertOnInvalid has been supplied as true.\\n            if (revertOnInvalid) {\\n                revert OrderIsCancelled(orderHash);\\n            }\\n\\n            // Return false as the order status is invalid.\\n            return false;\\n        }\\n\\n        // If the order is not entirely unused...\\n        if (orderStatus.numerator != 0) {\\n            // ensure the order has not been partially filled when not allowed.\\n            if (onlyAllowUnused) {\\n                // Always revert on partial fills when onlyAllowUnused is true.\\n                revert OrderPartiallyFilled(orderHash);\\n                // Otherwise, ensure that order has not been entirely filled.\\n            } else if (orderStatus.numerator >= orderStatus.denominator) {\\n                // Only revert if revertOnInvalid has been supplied as true.\\n                if (revertOnInvalid) {\\n                    revert OrderAlreadyFilled(orderHash);\\n                }\\n\\n                // Return false as the order status is invalid.\\n                return false;\\n            }\\n        }\\n\\n        // Return true as the order status is valid.\\n        valid = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/TokenTransferrer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./TokenTransferrerConstants.sol\\\";\\n\\nimport {\\n    TokenTransferrerErrors\\n} from \\\"../interfaces/TokenTransferrerErrors.sol\\\";\\n\\nimport { ConduitBatch1155Transfer } from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\ncontract TokenTransferrer is TokenTransferrerErrors {\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens from a given originator\\n     *      to a given recipient. Sufficient approvals must be set on the\\n     *      contract performing the transfer.\\n     *\\n     * @param token      The ERC20 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performERC20Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC20 token transfer.\\n        assembly {\\n            // Write calldata to the free memory pointer, but restore it later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write calldata into memory, starting with function selector.\\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\\n            mstore(ERC20_transferFrom_from_ptr, from)\\n            mstore(ERC20_transferFrom_to_ptr, to)\\n            mstore(ERC20_transferFrom_amount_ptr, amount)\\n\\n            // Make call & copy up to 32 bytes of return data to scratch space.\\n            let callStatus := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC20_transferFrom_sig_ptr,\\n                ERC20_transferFrom_length,\\n                0,\\n                OneWord\\n            )\\n\\n            // Determine whether transfer was successful using status & result.\\n            let success := and(\\n                // Set success to whether the call reverted, if not check it\\n                // either returned exactly 1 (can't just be non-zero data), or\\n                // had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                callStatus\\n            )\\n\\n            // If the transfer failed or it returned nothing:\\n            // Group these because they should be uncommon.\\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\\n            // but after it's inverted for JUMPI this expression is cheaper.\\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\\n                // If the token has no code or the transfer failed:\\n                // Equivalent to `or(iszero(success), iszero(extcodesize(token)))`\\n                // but after it's inverted for JUMPI this expression is cheaper.\\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\\n                    // If the transfer failed:\\n                    if iszero(success) {\\n                        // If it was due to a revert:\\n                        if iszero(callStatus) {\\n                            // If it returned a message, bubble it up as long as\\n                            // sufficient gas remains to do so:\\n                            if returndatasize() {\\n                                // Ensure that sufficient gas is available to\\n                                // copy returndata while expanding memory where\\n                                // necessary. Start by computing the word size\\n                                // of returndata and allocated memory.\\n                                let returnDataWords := div(\\n                                    returndatasize(),\\n                                    OneWord\\n                                )\\n\\n                                // Note: use the free memory pointer in place of\\n                                // msize() to work around a Yul warning that\\n                                // prevents accessing msize directly when the IR\\n                                // pipeline is activated.\\n                                let msizeWords := div(memPointer, OneWord)\\n\\n                                // Next, compute the cost of the returndatacopy.\\n                                let cost := mul(CostPerWord, returnDataWords)\\n\\n                                // Then, compute cost of new memory allocation.\\n                                if gt(returnDataWords, msizeWords) {\\n                                    cost := add(\\n                                        cost,\\n                                        add(\\n                                            mul(\\n                                                sub(\\n                                                    returnDataWords,\\n                                                    msizeWords\\n                                                ),\\n                                                CostPerWord\\n                                            ),\\n                                            div(\\n                                                sub(\\n                                                    mul(\\n                                                        returnDataWords,\\n                                                        returnDataWords\\n                                                    ),\\n                                                    mul(msizeWords, msizeWords)\\n                                                ),\\n                                                MemoryExpansionCoefficient\\n                                            )\\n                                        )\\n                                    )\\n                                }\\n\\n                                // Finally, add a small constant and compare to\\n                                // gas remaining; bubble up the revert data if\\n                                // enough gas is still available.\\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\\n                                    // Copy returndata to memory; overwrite\\n                                    // existing memory.\\n                                    returndatacopy(0, 0, returndatasize())\\n\\n                                    // Revert, specifying memory region with\\n                                    // copied returndata.\\n                                    revert(0, returndatasize())\\n                                }\\n                            }\\n\\n                            // Otherwise revert with a generic error message.\\n                            mstore(\\n                                TokenTransferGenericFailure_error_sig_ptr,\\n                                TokenTransferGenericFailure_error_signature\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_token_ptr,\\n                                token\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_from_ptr,\\n                                from\\n                            )\\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                            mstore(TokenTransferGenericFailure_error_id_ptr, 0)\\n                            mstore(\\n                                TokenTransferGenericFailure_error_amount_ptr,\\n                                amount\\n                            )\\n                            revert(\\n                                TokenTransferGenericFailure_error_sig_ptr,\\n                                TokenTransferGenericFailure_error_length\\n                            )\\n                        }\\n\\n                        // Otherwise revert with a message about the token\\n                        // returning false.\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\n                            BadReturnValueFromERC20OnTransfer_error_signature\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\\n                            token\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\\n                            from\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\\n                            to\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\\n                            amount\\n                        )\\n                        revert(\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\n                            BadReturnValueFromERC20OnTransfer_error_length\\n                        )\\n                    }\\n\\n                    // Otherwise revert with error about token not having code:\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Otherwise the token just returned nothing but otherwise\\n                // succeeded; no need to optimize for this as it's not\\n                // technically ERC20 compliant.\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer an ERC721 token from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer.\\n     *\\n     * @param token      The ERC721 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The tokenId to transfer.\\n     */\\n    function _performERC721Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC721 token transfer.\\n        assembly {\\n            // If the token has no code, revert.\\n            if iszero(extcodesize(token)) {\\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                mstore(NoContract_error_token_ptr, token)\\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\\n            }\\n\\n            // Write calldata to free memory pointer (restore it later).\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write calldata to memory starting with function selector.\\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\\n            mstore(ERC721_transferFrom_from_ptr, from)\\n            mstore(ERC721_transferFrom_to_ptr, to)\\n            mstore(ERC721_transferFrom_id_ptr, identifier)\\n\\n            // Perform the call, ignoring return data.\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC721_transferFrom_sig_ptr,\\n                ERC721_transferFrom_length,\\n                0,\\n                0\\n            )\\n\\n            // If the transfer reverted:\\n            if iszero(success) {\\n                // If it returned a message, bubble it up as long as sufficient\\n                // gas remains to do so:\\n                if returndatasize() {\\n                    // Ensure that sufficient gas is available to copy\\n                    // returndata while expanding memory where necessary. Start\\n                    // by computing word size of returndata & allocated memory.\\n                    let returnDataWords := div(returndatasize(), OneWord)\\n\\n                    // Note: use the free memory pointer in place of msize() to\\n                    // work around a Yul warning that prevents accessing msize\\n                    // directly when the IR pipeline is activated.\\n                    let msizeWords := div(memPointer, OneWord)\\n\\n                    // Next, compute the cost of the returndatacopy.\\n                    let cost := mul(CostPerWord, returnDataWords)\\n\\n                    // Then, compute cost of new memory allocation.\\n                    if gt(returnDataWords, msizeWords) {\\n                        cost := add(\\n                            cost,\\n                            add(\\n                                mul(\\n                                    sub(returnDataWords, msizeWords),\\n                                    CostPerWord\\n                                ),\\n                                div(\\n                                    sub(\\n                                        mul(returnDataWords, returnDataWords),\\n                                        mul(msizeWords, msizeWords)\\n                                    ),\\n                                    MemoryExpansionCoefficient\\n                                )\\n                            )\\n                        )\\n                    }\\n\\n                    // Finally, add a small constant and compare to gas\\n                    // remaining; bubble up the revert data if enough gas is\\n                    // still available.\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, giving memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Otherwise revert with a generic error message.\\n                mstore(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_signature\\n                )\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\\n                revert(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_length\\n                )\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer and contract recipients must\\n     *      implement onReceived to indicate that they are willing to accept the\\n     *      transfer.\\n     *\\n     * @param token      The ERC1155 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The id to transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performERC1155Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\\n        assembly {\\n            // If the token has no code, revert.\\n            if iszero(extcodesize(token)) {\\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                mstore(NoContract_error_token_ptr, token)\\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\\n            }\\n\\n            // Write calldata to these slots below, but restore them later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n            let slot0x80 := mload(Slot0x80)\\n            let slot0xA0 := mload(Slot0xA0)\\n            let slot0xC0 := mload(Slot0xC0)\\n\\n            // Write calldata into memory, beginning with function selector.\\n            mstore(\\n                ERC1155_safeTransferFrom_sig_ptr,\\n                ERC1155_safeTransferFrom_signature\\n            )\\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\\n            mstore(\\n                ERC1155_safeTransferFrom_data_offset_ptr,\\n                ERC1155_safeTransferFrom_data_length_offset\\n            )\\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\\n\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC1155_safeTransferFrom_sig_ptr,\\n                ERC1155_safeTransferFrom_length,\\n                0,\\n                0\\n            )\\n\\n            // If the transfer reverted:\\n            if iszero(success) {\\n                // If it returned a message, bubble it up as long as sufficient\\n                // gas remains to do so:\\n                if returndatasize() {\\n                    // Ensure that sufficient gas is available to copy\\n                    // returndata while expanding memory where necessary. Start\\n                    // by computing word size of returndata & allocated memory.\\n                    let returnDataWords := div(returndatasize(), OneWord)\\n\\n                    // Note: use the free memory pointer in place of msize() to\\n                    // work around a Yul warning that prevents accessing msize\\n                    // directly when the IR pipeline is activated.\\n                    let msizeWords := div(memPointer, OneWord)\\n\\n                    // Next, compute the cost of the returndatacopy.\\n                    let cost := mul(CostPerWord, returnDataWords)\\n\\n                    // Then, compute cost of new memory allocation.\\n                    if gt(returnDataWords, msizeWords) {\\n                        cost := add(\\n                            cost,\\n                            add(\\n                                mul(\\n                                    sub(returnDataWords, msizeWords),\\n                                    CostPerWord\\n                                ),\\n                                div(\\n                                    sub(\\n                                        mul(returnDataWords, returnDataWords),\\n                                        mul(msizeWords, msizeWords)\\n                                    ),\\n                                    MemoryExpansionCoefficient\\n                                )\\n                            )\\n                        )\\n                    }\\n\\n                    // Finally, add a small constant and compare to gas\\n                    // remaining; bubble up the revert data if enough gas is\\n                    // still available.\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, giving memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Otherwise revert with a generic error message.\\n                mstore(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_signature\\n                )\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\\n                revert(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_length\\n                )\\n            }\\n\\n            mstore(Slot0x80, slot0x80) // Restore slot 0x80.\\n            mstore(Slot0xA0, slot0xA0) // Restore slot 0xA0.\\n            mstore(Slot0xC0, slot0xC0) // Restore slot 0xC0.\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer and contract recipients must\\n     *      implement onReceived to indicate that they are willing to accept the\\n     *      transfer.\\n     *\\n     * @param batchTransfers The group of 1155 batch transfers to perform.\\n     */\\n    function _performERC1155BatchTransfers(\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) internal {\\n        // Utilize assembly to perform optimized batch 1155 transfers.\\n        assembly {\\n            let len := batchTransfers.length\\n            // Pointer to first head in the array, which is offset to the struct\\n            // at each index. This gets incremented after each loop to avoid\\n            // multiplying by 32 to get the offset for each element.\\n            let nextElementHeadPtr := batchTransfers.offset\\n\\n            // Pointer to beginning of the head of the array. This is the\\n            // reference position each offset references. It's held static to\\n            // let each loop calculate the data position for an element.\\n            let arrayHeadPtr := nextElementHeadPtr\\n\\n            // Write the function selector, which will be reused for each call:\\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\n            mstore(\\n                ConduitBatch1155Transfer_from_offset,\\n                ERC1155_safeBatchTransferFrom_signature\\n            )\\n\\n            // Iterate over each batch transfer.\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n                i := add(i, 1)\\n            } {\\n                // Read the offset to the beginning of the element and add\\n                // it to pointer to the beginning of the array head to get\\n                // the absolute position of the element in calldata.\\n                let elementPtr := add(\\n                    arrayHeadPtr,\\n                    calldataload(nextElementHeadPtr)\\n                )\\n\\n                // Update the offset position for the next loop\\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\\n\\n                // Copy the first section of calldata (before dynamic values).\\n                calldatacopy(\\n                    BatchTransfer1155Params_ptr,\\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\\n                    ConduitBatch1155Transfer_usable_head_size\\n                )\\n\\n                // Get the total number of supplied ids.\\n                let idsLength := calldataload(\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\\n                )\\n\\n                // Determine size of calldata required for ids and amounts. Note\\n                // that the size includes both lengths as well as the data.\\n                let idsAndAmountsSize := add(TwoWords, mul(idsLength, TwoWords))\\n\\n                // Update the offset for the data array in memory.\\n                mstore(\\n                    BatchTransfer1155Params_data_head_ptr,\\n                    add(\\n                        BatchTransfer1155Params_ids_length_offset,\\n                        idsAndAmountsSize\\n                    )\\n                )\\n\\n                // Set the length of the data array in memory to zero.\\n                mstore(\\n                    add(\\n                        BatchTransfer1155Params_data_length_basePtr,\\n                        idsAndAmountsSize\\n                    ),\\n                    0\\n                )\\n\\n                // Determine the total calldata size for the call to transfer.\\n                let transferDataSize := add(\\n                    BatchTransfer1155Params_data_length_basePtr,\\n                    mul(idsLength, TwoWords)\\n                )\\n\\n                // Copy second section of calldata (including dynamic values).\\n                calldatacopy(\\n                    BatchTransfer1155Params_ids_length_ptr,\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\\n                    idsAndAmountsSize\\n                )\\n\\n                // Determine the expected offset for the amounts array.\\n                let expectedAmountsOffset := add(\\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\\n                    mul(idsLength, OneWord)\\n                )\\n\\n                // Validate struct encoding.\\n                let invalidEncoding := iszero(\\n                    and(\\n                        // ids.length == amounts.length\\n                        eq(\\n                            idsLength,\\n                            calldataload(add(elementPtr, expectedAmountsOffset))\\n                        ),\\n                        and(\\n                            // ids_offset == 0xa0\\n                            eq(\\n                                calldataload(\\n                                    add(\\n                                        elementPtr,\\n                                        ConduitBatch1155Transfer_ids_head_offset\\n                                    )\\n                                ),\\n                                ConduitBatch1155Transfer_ids_length_offset\\n                            ),\\n                            // amounts_offset == 0xc0 + ids.length*32\\n                            eq(\\n                                calldataload(\\n                                    add(\\n                                        elementPtr,\\n                                        ConduitBatch1155Transfer_amounts_head_offset\\n                                    )\\n                                ),\\n                                expectedAmountsOffset\\n                            )\\n                        )\\n                    )\\n                )\\n\\n                // Revert with an error if the encoding is not valid.\\n                if invalidEncoding {\\n                    mstore(\\n                        Invalid1155BatchTransferEncoding_ptr,\\n                        Invalid1155BatchTransferEncoding_selector\\n                    )\\n                    revert(\\n                        Invalid1155BatchTransferEncoding_ptr,\\n                        Invalid1155BatchTransferEncoding_length\\n                    )\\n                }\\n\\n                // Retrieve the token from calldata.\\n                let token := calldataload(elementPtr)\\n\\n                // If the token has no code, revert.\\n                if iszero(extcodesize(token)) {\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Perform the call to transfer 1155 tokens.\\n                let success := call(\\n                    gas(),\\n                    token,\\n                    0,\\n                    ConduitBatch1155Transfer_from_offset, // Data portion start.\\n                    transferDataSize, // Location of the length of callData.\\n                    0,\\n                    0\\n                )\\n\\n                // If the transfer reverted:\\n                if iszero(success) {\\n                    // If it returned a message, bubble it up as long as\\n                    // sufficient gas remains to do so:\\n                    if returndatasize() {\\n                        // Ensure that sufficient gas is available to copy\\n                        // returndata while expanding memory where necessary.\\n                        // Start by computing word size of returndata and\\n                        // allocated memory.\\n                        let returnDataWords := div(returndatasize(), OneWord)\\n\\n                        // Note: use transferDataSize in place of msize() to\\n                        // work around a Yul warning that prevents accessing\\n                        // msize directly when the IR pipeline is activated.\\n                        // The free memory pointer is not used here because\\n                        // this function does almost all memory management\\n                        // manually and does not update it, and transferDataSize\\n                        // should be the largest memory value used (unless a\\n                        // previous batch was larger).\\n                        let msizeWords := div(transferDataSize, OneWord)\\n\\n                        // Next, compute the cost of the returndatacopy.\\n                        let cost := mul(CostPerWord, returnDataWords)\\n\\n                        // Then, compute cost of new memory allocation.\\n                        if gt(returnDataWords, msizeWords) {\\n                            cost := add(\\n                                cost,\\n                                add(\\n                                    mul(\\n                                        sub(returnDataWords, msizeWords),\\n                                        CostPerWord\\n                                    ),\\n                                    div(\\n                                        sub(\\n                                            mul(\\n                                                returnDataWords,\\n                                                returnDataWords\\n                                            ),\\n                                            mul(msizeWords, msizeWords)\\n                                        ),\\n                                        MemoryExpansionCoefficient\\n                                    )\\n                                )\\n                            )\\n                        }\\n\\n                        // Finally, add a small constant and compare to gas\\n                        // remaining; bubble up the revert data if enough gas is\\n                        // still available.\\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\\n                            // Copy returndata to memory; overwrite existing.\\n                            returndatacopy(0, 0, returndatasize())\\n\\n                            // Revert with memory region containing returndata.\\n                            revert(0, returndatasize())\\n                        }\\n                    }\\n\\n                    // Set the error signature.\\n                    mstore(\\n                        0,\\n                        ERC1155BatchTransferGenericFailure_error_signature\\n                    )\\n\\n                    // Write the token.\\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\\n\\n                    // Move the ids and amounts offsets forward a word.\\n                    mstore(\\n                        BatchTransfer1155Params_ids_head_ptr,\\n                        ConduitBatch1155Transfer_amounts_head_offset\\n                    )\\n                    mstore(\\n                        BatchTransfer1155Params_amounts_head_ptr,\\n                        add(\\n                            OneWord,\\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\\n                        )\\n                    )\\n\\n                    // Return modified region with one fewer word at the end.\\n                    revert(\\n                        0,\\n                        add(transferDataSize, BatchTransfer1155Params_ptr)\\n                    )\\n                }\\n            }\\n\\n            // Reset the free memory pointer to the default value; memory must\\n            // be assumed to be dirtied and not reused from this point forward.\\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ConsiderationConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/*\\n * -------------------------- Disambiguation & Other Notes ---------------------\\n *    - The term \\\"head\\\" is used as it is in the documentation for ABI encoding,\\n *      but only in reference to dynamic types, i.e. it always refers to the\\n *      offset or pointer to the body of a dynamic type. In calldata, the head\\n *      is always an offset (relative to the parent object), while in memory,\\n *      the head is always the pointer to the body. More information found here:\\n *      https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#argument-encoding\\n *        - Note that the length of an array is separate from and precedes the\\n *          head of the array.\\n *\\n *    - The term \\\"body\\\" is used in place of the term \\\"head\\\" used in the ABI\\n *      documentation. It refers to the start of the data for a dynamic type,\\n *      e.g. the first word of a struct or the first word of the first element\\n *      in an array.\\n *\\n *    - The term \\\"pointer\\\" is used to describe the absolute position of a value\\n *      and never an offset relative to another value.\\n *        - The suffix \\\"_ptr\\\" refers to a memory pointer.\\n *        - The suffix \\\"_cdPtr\\\" refers to a calldata pointer.\\n *\\n *    - The term \\\"offset\\\" is used to describe the position of a value relative\\n *      to some parent value. For example, OrderParameters_conduit_offset is the\\n *      offset to the \\\"conduit\\\" value in the OrderParameters struct relative to\\n *      the start of the body.\\n *        - Note: Offsets are used to derive pointers.\\n *\\n *    - Some structs have pointers defined for all of their fields in this file.\\n *      Lines which are commented out are fields that are not used in the\\n *      codebase but have been left in for readability.\\n */\\n\\n// Declare constants for name, version, and reentrancy sentinel values.\\n\\n// Name is right padded, so it touches the length which is left padded.\\n// This lets us write both values at once.\\n// Length goes at byte 63, and name fills bytes 64-77, so we write\\n// both values left-padded to 45.\\nuint256 constant NameLengthPtr = 45;\\nuint256 constant NameWithLength = 0x0d436F6E73696465726174696F6E;\\n\\nuint256 constant Version = 0x31;\\nuint256 constant Version_length = 1;\\n\\nuint256 constant _NOT_ENTERED = 1;\\nuint256 constant _ENTERED = 2;\\n\\n// Common Offsets\\n// Offsets for identically positioned fields shared by:\\n// OfferItem, ConsiderationItem, SpentItem, ReceivedItem\\n\\nuint256 constant Common_token_offset = 0x20;\\nuint256 constant Common_identifier_offset = 0x40;\\nuint256 constant Common_amount_offset = 0x60;\\n\\nuint256 constant ReceivedItem_size = 0xa0;\\nuint256 constant ReceivedItem_amount_offset = 0x60;\\nuint256 constant ReceivedItem_recipient_offset = 0x80;\\n\\nuint256 constant ReceivedItem_CommonParams_size = 0x60;\\n\\nuint256 constant ConsiderationItem_recipient_offset = 0xa0;\\n// Store the same constant in an abbreviated format for a line length fix.\\nuint256 constant ConsiderItem_recipient_offset = 0xa0;\\n\\nuint256 constant Execution_offerer_offset = 0x20;\\nuint256 constant Execution_conduit_offset = 0x40;\\n\\nuint256 constant InvalidFulfillmentComponentData_error_signature = (\\n    0x7fda727900000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant InvalidFulfillmentComponentData_error_len = 0x20;\\n\\nuint256 constant Panic_error_signature = (\\n    0x4e487b7100000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant Panic_error_offset = 0x04;\\nuint256 constant Panic_error_length = 0x24;\\nuint256 constant Panic_arithmetic = 0x11;\\n\\nuint256 constant MissingItemAmount_error_signature = (\\n    0x91b3e51400000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant MissingItemAmount_error_len = 0x20;\\n\\nuint256 constant OrderParameters_offer_head_offset = 0x40;\\nuint256 constant OrderParameters_consideration_head_offset = 0x60;\\nuint256 constant OrderParameters_conduit_offset = 0x120;\\nuint256 constant OrderParameters_nonce_offset = 0x140;\\n\\nuint256 constant Fulfillment_itemIndex_offset = 0x20;\\n\\nuint256 constant AdvancedOrder_numerator_offset = 0x20;\\n\\nuint256 constant OneWord = 0x20;\\nuint256 constant TwoWords = 0x40;\\nuint256 constant ThreeWords = 0x60;\\nuint256 constant FourWords = 0x80;\\nuint256 constant FiveWords = 0xa0;\\n\\nuint256 constant FreeMemoryPointerSlot = 0x40;\\nuint256 constant ZeroSlot = 0x60;\\nuint256 constant DefaultFreeMemoryPointer = 0x80;\\n\\nuint256 constant Slot0x80 = 0x80;\\nuint256 constant Slot0xA0 = 0xa0;\\n\\nuint256 constant BasicOrder_endAmount_cdPtr = 0x104;\\n\\nuint256 constant BasicOrder_considerationHashesArray_ptr = 0x160;\\n\\nuint256 constant EIP712_Order_size = 0x180;\\nuint256 constant EIP712_OfferItem_size = 0xc0;\\nuint256 constant EIP712_ConsiderationItem_size = 0xe0;\\nuint256 constant AdditionalRecipients_size = 0x40;\\n\\nuint256 constant EIP712_DomainSeparator_offset = 0x02;\\nuint256 constant EIP712_OrderHash_offset = 0x22;\\nuint256 constant EIP712_DigestPayload_size = 0x42;\\n\\nuint256 constant receivedItemsHash_ptr = 0x60;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  data for OrderFulfilled\\n *\\n *   event OrderFulfilled(\\n *     bytes32 orderHash,\\n *     address indexed offerer,\\n *     address indexed zone,\\n *     address fulfiller,\\n *     SpentItem[] offer,\\n *       > (itemType, token, id, amount)\\n *     ReceivedItem[] consideration\\n *       > (itemType, token, id, amount, recipient)\\n *   )\\n *\\n *  - 0x00: orderHash\\n *  - 0x20: fulfiller\\n *  - 0x40: offer offset (0x80)\\n *  - 0x60: consideration offset (0x120)\\n *  - 0x80: offer.length (1)\\n *  - 0xa0: offerItemType\\n *  - 0xc0: offerToken\\n *  - 0xe0: offerIdentifier\\n *  - 0x100: offerAmount\\n *  - 0x120: consideration.length (1 + additionalRecipients.length)\\n *  - 0x140: considerationItemType\\n *  - 0x160: considerationToken\\n *  - 0x180: considerationIdentifier\\n *  - 0x1a0: considerationAmount\\n *  - 0x1c0: considerationRecipient\\n *  - ...\\n */\\n\\n// Minimum length of the OrderFulfilled event data.\\n// Must be added to the size of the ReceivedItem array for additionalRecipients\\n// (0xa0 * additionalRecipients.length) to calculate full size of the buffer.\\nuint256 constant OrderFulfilled_baseSize = 0x1e0;\\nuint256 constant OrderFulfilled_selector = (\\n    0x9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31\\n);\\n\\n// Minimum offset in memory to OrderFulfilled event data.\\n// Must be added to the size of the EIP712 hash array for additionalRecipients\\n// (32 * additionalRecipients.length) to calculate the pointer to event data.\\nuint256 constant OrderFulfilled_baseOffset = 0x180;\\nuint256 constant OrderFulfilled_consideration_length_baseOffset = 0x2a0;\\nuint256 constant OrderFulfilled_offer_length_baseOffset = 0x200;\\n\\n// uint256 constant OrderFulfilled_orderHash_offset = 0x00;\\nuint256 constant OrderFulfilled_fulfiller_offset = 0x20;\\nuint256 constant OrderFulfilled_offer_head_offset = 0x40;\\nuint256 constant OrderFulfilled_offer_body_offset = 0x80;\\nuint256 constant OrderFulfilled_consideration_head_offset = 0x60;\\nuint256 constant OrderFulfilled_consideration_body_offset = 0x120;\\n\\n// BasicOrderParameters\\nuint256 constant BasicOrder_parameters_cdPtr = 0x04;\\nuint256 constant BasicOrder_considerationToken_cdPtr = 0x24;\\n// uint256 constant BasicOrder_considerationIdentifier_cdPtr = 0x44;\\nuint256 constant BasicOrder_considerationAmount_cdPtr = 0x64;\\nuint256 constant BasicOrder_offerer_cdPtr = 0x84;\\nuint256 constant BasicOrder_zone_cdPtr = 0xa4;\\nuint256 constant BasicOrder_offerToken_cdPtr = 0xc4;\\n// uint256 constant BasicOrder_offerIdentifier_cdPtr = 0xe4;\\nuint256 constant BasicOrder_offerAmount_cdPtr = 0x104;\\nuint256 constant BasicOrder_basicOrderType_cdPtr = 0x124;\\nuint256 constant BasicOrder_startTime_cdPtr = 0x144;\\n// uint256 constant BasicOrder_endTime_cdPtr = 0x164;\\n// uint256 constant BasicOrder_zoneHash_cdPtr = 0x184;\\n// uint256 constant BasicOrder_salt_cdPtr = 0x1a4;\\nuint256 constant BasicOrder_offererConduit_cdPtr = 0x1c4;\\nuint256 constant BasicOrder_fulfillerConduit_cdPtr = 0x1e4;\\nuint256 constant BasicOrder_totalOriginalAdditionalRecipients_cdPtr = 0x204;\\nuint256 constant BasicOrder_additionalRecipients_head_cdPtr = 0x224;\\nuint256 constant BasicOrder_signature_cdPtr = 0x244;\\nuint256 constant BasicOrder_additionalRecipients_length_cdPtr = 0x264;\\nuint256 constant BasicOrder_additionalRecipients_data_cdPtr = 0x284;\\n\\nuint256 constant BasicOrder_parameters_ptr = 0x20;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  EIP712 data for ConsiderationItem\\n *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\\n *   - 0xa0: itemType\\n *   - 0xc0: token\\n *   - 0xe0: identifier\\n *   - 0x100: startAmount\\n *   - 0x120: endAmount\\n *   - 0x140: recipient\\n */\\nuint256 constant BasicOrder_considerationItem_typeHash_ptr = 0x80; // memoryPtr\\nuint256 constant BasicOrder_considerationItem_itemType_ptr = 0xa0;\\nuint256 constant BasicOrder_considerationItem_token_ptr = 0xc0;\\nuint256 constant BasicOrder_considerationItem_identifier_ptr = 0xe0;\\nuint256 constant BasicOrder_considerationItem_startAmount_ptr = 0x100;\\nuint256 constant BasicOrder_considerationItem_endAmount_ptr = 0x120;\\n// uint256 constant BasicOrder_considerationItem_recipient_ptr = 0x140;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  EIP712 data for OfferItem\\n *   - 0x80:  OfferItem EIP-712 typehash (constant)\\n *   - 0xa0:  itemType\\n *   - 0xc0:  token\\n *   - 0xe0:  identifier (reused for offeredItemsHash)\\n *   - 0x100: startAmount\\n *   - 0x120: endAmount\\n */\\nuint256 constant BasicOrder_offerItem_typeHash_ptr = DefaultFreeMemoryPointer;\\nuint256 constant BasicOrder_offerItem_itemType_ptr = 0xa0;\\nuint256 constant BasicOrder_offerItem_token_ptr = 0xc0;\\n// uint256 constant BasicOrder_offerItem_identifier_ptr = 0xe0;\\n// uint256 constant BasicOrder_offerItem_startAmount_ptr = 0x100;\\nuint256 constant BasicOrder_offerItem_endAmount_ptr = 0x120;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  EIP712 data for Order\\n *   - 0x80:   Order EIP-712 typehash (constant)\\n *   - 0xa0:   orderParameters.offerer\\n *   - 0xc0:   orderParameters.zone\\n *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\\n *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\\n *   - 0x120:  orderType\\n *   - 0x140:  startTime\\n *   - 0x160:  endTime\\n *   - 0x180:  zoneHash\\n *   - 0x1a0:  salt\\n *   - 0x1c0:  conduit\\n *   - 0x1e0:  _nonces[orderParameters.offerer] (from storage)\\n */\\nuint256 constant BasicOrder_order_typeHash_ptr = 0x80;\\nuint256 constant BasicOrder_order_offerer_ptr = 0xa0;\\n// uint256 constant BasicOrder_order_zone_ptr = 0xc0;\\nuint256 constant BasicOrder_order_offerHashes_ptr = 0xe0;\\nuint256 constant BasicOrder_order_considerationHashes_ptr = 0x100;\\nuint256 constant BasicOrder_order_orderType_ptr = 0x120;\\nuint256 constant BasicOrder_order_startTime_ptr = 0x140;\\n// uint256 constant BasicOrder_order_endTime_ptr = 0x160;\\n// uint256 constant BasicOrder_order_zoneHash_ptr = 0x180;\\n// uint256 constant BasicOrder_order_salt_ptr = 0x1a0;\\n// uint256 constant BasicOrder_order_conduitKey_ptr = 0x1c0;\\nuint256 constant BasicOrder_order_nonce_ptr = 0x1e0;\\nuint256 constant BasicOrder_additionalRecipients_head_ptr = 0x240;\\nuint256 constant BasicOrder_signature_ptr = 0x260;\\n\\n// Signature-related\\nbytes32 constant EIP2098_allButHighestBitMask = (\\n    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n);\\n\\n// abi.encodeWithSignature(\\\"NoContract(address)\\\")\\nuint256 constant NoContract_error_signature = (\\n    0x5f15d67200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant NoContract_error_sig_ptr = 0x0;\\nuint256 constant NoContract_error_token_ptr = 0x4;\\nuint256 constant NoContract_error_length = 0x24; // 4 + 32 == 36\\n\\nuint256 constant EIP_712_PREFIX = (\\n    0x1901000000000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant ExtraGasBuffer = 0x20;\\nuint256 constant CostPerWord = 3;\\nuint256 constant MemoryExpansionCoefficient = 0x200;\\n\\nuint256 constant Create2AddressDerivation_ptr = 0x0b;\\nuint256 constant Create2AddressDerivation_length = 0x55;\\n\\nuint256 constant MaskOverByteTwelve = (\\n    0x0000000000000000000000ff0000000000000000000000000000000000000000\\n);\\n\\nuint256 constant MaskOverLastTwentyBytes = (\\n    0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\\n);\\n\\nuint256 constant MaskOverFirstFourBytes = (\\n    0xffffffff00000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant Conduit_execute_signature = (\\n    0x4ce34aa200000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant Conduit_execute_ConduitTransfer_ptr = 0x20;\\nuint256 constant Conduit_execute_ConduitTransfer_length = 0x01;\\n\\nuint256 constant Conduit_execute_ConduitTransfer_offset_ptr = 0x04;\\nuint256 constant Conduit_execute_ConduitTransfer_length_ptr = 0x24;\\nuint256 constant Conduit_execute_transferItemType_ptr = 0x44;\\nuint256 constant Conduit_execute_transferToken_ptr = 0x64;\\nuint256 constant Conduit_execute_transferFrom_ptr = 0x84;\\nuint256 constant Conduit_execute_transferTo_ptr = 0xa4;\\nuint256 constant Conduit_execute_transferIdentifier_ptr = 0xc4;\\nuint256 constant Conduit_execute_transferAmount_ptr = 0xe4;\\n\\nuint256 constant OneConduitExecute_size = 0x104;\\n\\n// Sentinel value to indicate that the conduit accumulator is not armed.\\nuint256 constant AccumulatorDisarmed = 0x20;\\nuint256 constant AccumulatorArmed = 0x40;\\nuint256 constant Accumulator_conduitKey_ptr = 0x20;\\nuint256 constant Accumulator_selector_ptr = 0x40;\\nuint256 constant Accumulator_array_offset_ptr = 0x44;\\nuint256 constant Accumulator_array_length_ptr = 0x64;\\n\\nuint256 constant Accumulator_itemSizeOffsetDifference = 0x3c;\\n\\nuint256 constant Accumulator_array_offset = 0x20;\\nuint256 constant Conduit_transferItem_size = 0xc0;\\nuint256 constant Conduit_transferItem_token_ptr = 0x20;\\nuint256 constant Conduit_transferItem_from_ptr = 0x40;\\nuint256 constant Conduit_transferItem_to_ptr = 0x60;\\nuint256 constant Conduit_transferItem_identifier_ptr = 0x80;\\nuint256 constant Conduit_transferItem_amount_ptr = 0xa0;\\n\"\r\n    },\r\n    \"contracts/lib/Assertions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { OrderParameters } from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { GettersAndDerivers } from \\\"./GettersAndDerivers.sol\\\";\\n\\nimport { TokenTransferrerErrors } from \\\"../interfaces/TokenTransferrerErrors.sol\\\";\\n\\nimport { NonceManager } from \\\"./NonceManager.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title Assertions\\n * @author 0age\\n * @notice Assertions contains logic for making various assertions that do not\\n *         fit neatly within a dedicated semantic scope.\\n */\\ncontract Assertions is\\n    GettersAndDerivers,\\n    NonceManager,\\n    TokenTransferrerErrors\\n{\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController)\\n        GettersAndDerivers(conduitController)\\n    {}\\n\\n    /**\\n     * @dev Internal view function to to ensure that the supplied consideration\\n     *      array length on a given set of order parameters is not less than the\\n     *      original consideration array length for that order and to retrieve\\n     *      the current nonce for a given order's offerer and zone and use it to\\n     *      derive the order hash.\\n     *\\n     * @param orderParameters The parameters of the order to hash.\\n     *\\n     * @return The hash.\\n     */\\n    function _assertConsiderationLengthAndGetNoncedOrderHash(\\n        OrderParameters memory orderParameters\\n    ) internal view returns (bytes32) {\\n        // Ensure supplied consideration array length is not less than original.\\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\\n            orderParameters.consideration.length,\\n            orderParameters.totalOriginalConsiderationItems\\n        );\\n\\n        // Derive and return order hash using current nonce for the offerer.\\n        return\\n            _deriveOrderHash(\\n                orderParameters,\\n                _getNonce(orderParameters.offerer)\\n            );\\n    }\\n\\n    /**\\n     * @dev Internal pure function to ensure that the supplied consideration\\n     *      array length for an order to be fulfilled is not less than the\\n     *      original consideration array length for that order.\\n     *\\n     * @param suppliedConsiderationItemTotal The number of consideration items\\n     *                                       supplied when fulfilling the order.\\n     * @param originalConsiderationItemTotal The number of consideration items\\n     *                                       supplied on initial order creation.\\n     */\\n    function _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\\n        uint256 suppliedConsiderationItemTotal,\\n        uint256 originalConsiderationItemTotal\\n    ) internal pure {\\n        // Ensure supplied consideration array length is not less than original.\\n        if (suppliedConsiderationItemTotal < originalConsiderationItemTotal) {\\n            revert MissingOriginalConsiderationItems();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to ensure that a given item amount is not\\n     *      zero.\\n     *\\n     * @param amount The amount to check.\\n     */\\n    function _assertNonZeroAmount(uint256 amount) internal pure {\\n        // Revert if the supplied amont is equal to zero.\\n        if (amount == 0) {\\n            revert MissingItemAmount();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to validate calldata offsets for dynamic\\n     *      types in BasicOrderParameters. This ensures that functions using the\\n     *      calldata object normally will be using the same data as the assembly\\n     *      functions. Note that no parameters are supplied as all basic order\\n     *      functions use the same calldata encoding.\\n     */\\n    function _assertValidBasicOrderParameterOffsets() internal pure {\\n        // Declare a boolean designating basic order parameter offset validity.\\n        bool validOffsets;\\n\\n        // Utilize assembly in order to read offset data directly from calldata.\\n        assembly {\\n            /*\\n             * Checks:\\n             * 1. Order parameters struct offset == 0x20\\n             * 2. Additional recipients arr offset == 0x240\\n             * 3. Signature offset == 0x260 + (recipients.length * 0x40)\\n             */\\n            validOffsets := and(\\n                // Order parameters at calldata 0x04 must have offset of 0x20.\\n                eq(\\n                    calldataload(BasicOrder_parameters_cdPtr),\\n                    BasicOrder_parameters_ptr\\n                ),\\n                // Additional recipients at cd 0x224 must have offset of 0x240.\\n                eq(\\n                    calldataload(BasicOrder_additionalRecipients_head_cdPtr),\\n                    BasicOrder_additionalRecipients_head_ptr\\n                )\\n            )\\n            validOffsets := and(\\n                validOffsets,\\n                eq(\\n                    // Load signature offset from calldata 0x244.\\n                    calldataload(BasicOrder_signature_cdPtr),\\n                    // Derive expected offset as start of recipients + len * 64.\\n                    add(\\n                        BasicOrder_signature_ptr,\\n                        mul(\\n                            // Additional recipients length at calldata 0x264.\\n                            calldataload(\\n                                BasicOrder_additionalRecipients_length_cdPtr\\n                            ),\\n                            // Each additional recipient has a length of 0x40.\\n                            AdditionalRecipients_size\\n                        )\\n                    )\\n                )\\n            )\\n        }\\n\\n        // Revert with an error if basic order parameter offsets are invalid.\\n        if (!validOffsets) {\\n            revert InvalidBasicOrderParameterEncoding();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SignatureVerification.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { EIP1271Interface } from \\\"../interfaces/EIP1271Interface.sol\\\";\\n\\nimport {\\n    SignatureVerificationErrors\\n} from \\\"../interfaces/SignatureVerificationErrors.sol\\\";\\n\\nimport { LowLevelHelpers } from \\\"./LowLevelHelpers.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title SignatureVerification\\n * @author 0age\\n * @notice SignatureVerification contains logic for verifying signatures.\\n */\\ncontract SignatureVerification is SignatureVerificationErrors, LowLevelHelpers {\\n    /**\\n     * @dev Internal view function to verify the signature of an order. An\\n     *      ERC-1271 fallback will be attempted if either the signature length\\n     *      is not 32 or 33 bytes or if the recovered signer does not match the\\n     *      supplied signer. Note that in cases where a 32 or 33 byte signature\\n     *      is supplied, only standard ECDSA signatures that recover to a\\n     *      non-zero address are supported.\\n     *\\n     * @param signer    The signer for the order.\\n     * @param digest    The digest to verify the signature against.\\n     * @param signature A signature from the signer indicating that the order\\n     *                  has been approved.\\n     */\\n    function _assertValidSignature(\\n        address signer,\\n        bytes32 digest,\\n        bytes memory signature\\n    ) internal view {\\n        // Declare r, s, and v signature parameters.\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // If signature contains 64 bytes, parse as EIP-2098 signature (r+s&v).\\n        if (signature.length == 64) {\\n            // Declare temporary vs that will be decomposed into s and v.\\n            bytes32 vs;\\n\\n            // Read each parameter directly from the signature's memory region.\\n            assembly {\\n                // Put the first word from the signature onto the stack as r.\\n                r := mload(add(signature, OneWord))\\n\\n                // Put the second word from the signature onto the stack as vs.\\n                vs := mload(add(signature, TwoWords))\\n\\n                // Extract canonical s from vs (all but the highest bit).\\n                s := and(vs, EIP2098_allButHighestBitMask)\\n\\n                // Extract yParity from highest bit of vs and add 27 to get v.\\n                v := add(shr(255, vs), 27)\\n            }\\n        } else if (signature.length == 65) {\\n            // If signature is 65 bytes, parse as a standard signature (r+s+v).\\n            // Read each parameter directly from the signature's memory region.\\n            assembly {\\n                // Place first word on the stack at r.\\n                r := mload(add(signature, OneWord))\\n\\n                // Place second word on the stack at s.\\n                s := mload(add(signature, TwoWords))\\n\\n                // Place final byte on the stack at v.\\n                v := byte(0, mload(add(signature, ThreeWords)))\\n            }\\n\\n            // Ensure v value is properly formatted.\\n            if (v != 27 && v != 28) {\\n                revert BadSignatureV(v);\\n            }\\n        } else {\\n            // For all other signature lengths, try verification via EIP-1271.\\n            // Attempt EIP-1271 static call to signer in case it's a contract.\\n            _assertValidEIP1271Signature(signer, digest, signature);\\n\\n            // Return early if the ERC-1271 signature check succeeded.\\n            return;\\n        }\\n\\n        // Attempt to recover signer using the digest and signature parameters.\\n        address recoveredSigner = ecrecover(digest, v, r, s);\\n\\n        // Disallow invalid signers.\\n        if (recoveredSigner == address(0)) {\\n            revert InvalidSignature();\\n            // Should a signer be recovered, but it doesn't match the signer...\\n        } else if (recoveredSigner != signer) {\\n            // Attempt EIP-1271 static call to signer in case it's a contract.\\n            _assertValidEIP1271Signature(signer, digest, signature);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to verify the signature of an order using\\n     *      ERC-1271 (i.e. contract signatures via `isValidSignature`). Note\\n     *      that, in contrast to standard ECDSA signatures, 1271 signatures may\\n     *      be valid in certain contexts and invalid in others, or vice versa;\\n     *      orders that validate signatures ahead of time must explicitly cancel\\n     *      those orders to invalidate them.\\n     *\\n     * @param signer    The signer for the order.\\n     * @param digest    The signature digest, derived from the domain separator\\n     *                  and the order hash.\\n     * @param signature A signature (or other data) used to validate the digest.\\n     */\\n    function _assertValidEIP1271Signature(\\n        address signer,\\n        bytes32 digest,\\n        bytes memory signature\\n    ) internal view {\\n        // Attempt an EIP-1271 staticcall to the signer.\\n        bool success = _staticcall(\\n            signer,\\n            abi.encodeWithSelector(\\n                EIP1271Interface.isValidSignature.selector,\\n                digest,\\n                signature\\n            )\\n        );\\n\\n        // If the call fails...\\n        if (!success) {\\n            // Revert and pass reason along if one was returned.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // Otherwise, revert with a generic error message.\\n            revert BadContractSignature();\\n        }\\n\\n        // Ensure result was extracted and matches EIP-1271 magic value.\\n        if (_doesNotMatchMagic(EIP1271Interface.isValidSignature.selector)) {\\n            revert InvalidSigner();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/GettersAndDerivers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { OrderParameters } from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { ConsiderationBase } from \\\"./ConsiderationBase.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title GettersAndDerivers\\n * @author 0age\\n * @notice ConsiderationInternal contains pure and internal view functions\\n *         related to getting or deriving various values.\\n */\\ncontract GettersAndDerivers is ConsiderationBase {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController)\\n        ConsiderationBase(conduitController)\\n    {}\\n\\n    /**\\n     * @dev Internal view function to derive the order hash for a given order.\\n     *      Note that only the original consideration items are included in the\\n     *      order hash, as additional consideration items may be supplied by the\\n     *      caller.\\n     *\\n     * @param orderParameters The parameters of the order to hash.\\n     * @param nonce           The nonce of the order to hash.\\n     *\\n     * @return orderHash The hash.\\n     */\\n    function _deriveOrderHash(\\n        OrderParameters memory orderParameters,\\n        uint256 nonce\\n    ) internal view returns (bytes32 orderHash) {\\n        // Get length of original consideration array and place it on the stack.\\n        uint256 originalConsiderationLength = (\\n            orderParameters.totalOriginalConsiderationItems\\n        );\\n\\n        /*\\n         * Memory layout for an array of structs (dynamic or not) is similar\\n         * to ABI encoding of dynamic types, with a head segment followed by\\n         * a data segment. The main difference is that the head of an element\\n         * is a memory pointer rather than an offset.\\n         */\\n\\n        // Declare a variable for the derived hash of the offer array.\\n        bytes32 offerHash;\\n\\n        // Read offer item EIP-712 typehash from runtime code & place on stack.\\n        bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\\n\\n        // Utilize assembly so that memory regions can be reused across hashes.\\n        assembly {\\n            // Retrieve the free memory pointer and place on the stack.\\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\\n\\n            // Get the pointer to the offers array.\\n            let offerArrPtr := mload(add(orderParameters, TwoWords))\\n\\n            // Load the length.\\n            let offerLength := mload(offerArrPtr)\\n\\n            // Set the pointer to the first offer's head.\\n            offerArrPtr := add(offerArrPtr, OneWord)\\n\\n            // Iterate over the offer items.\\n            for { let i := 0 } lt(i, offerLength) {\\n                i := add(i, 1)\\n            } {\\n                // Read the pointer to the offer data and subtract one word\\n                // to get typeHash pointer.\\n                let ptr := sub(mload(offerArrPtr), OneWord)\\n\\n                // Read the current value before the offer data.\\n                let value := mload(ptr)\\n\\n                // Write the type hash to the previous word.\\n                mstore(ptr, typeHash)\\n\\n                // Take the EIP712 hash and store it in the hash array.\\n                mstore(hashArrPtr, keccak256(ptr, EIP712_OfferItem_size))\\n\\n                // Restore the previous word.\\n                mstore(ptr, value)\\n\\n                // Increment the array pointers by one word.\\n                offerArrPtr := add(offerArrPtr, OneWord)\\n                hashArrPtr := add(hashArrPtr, OneWord)\\n            }\\n\\n            // Derive the offer hash using the hashes of each item.\\n            offerHash := keccak256(\\n                mload(FreeMemoryPointerSlot),\\n                mul(offerLength, OneWord)\\n            )\\n        }\\n\\n        // Declare a variable for the derived hash of the consideration array.\\n        bytes32 considerationHash;\\n\\n        // Read consideration item typehash from runtime code & place on stack.\\n        typeHash = _CONSIDERATION_ITEM_TYPEHASH;\\n\\n        // Utilize assembly so that memory regions can be reused across hashes.\\n        assembly {\\n            // Retrieve the free memory pointer and place on the stack.\\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\\n\\n            // Get the pointer to the consideration array.\\n            let considerationArrPtr := add(\\n                mload(\\n                    add(\\n                        orderParameters,\\n                        OrderParameters_consideration_head_offset\\n                    )\\n                ),\\n                OneWord\\n            )\\n\\n            // Iterate over the offer items (not including tips).\\n            for { let i := 0 } lt(i, originalConsiderationLength) {\\n                i := add(i, 1)\\n            } {\\n                // Read the pointer to the consideration data and subtract one\\n                // word to get typeHash pointer.\\n                let ptr := sub(mload(considerationArrPtr), OneWord)\\n\\n                // Read the current value before the consideration data.\\n                let value := mload(ptr)\\n\\n                // Write the type hash to the previous word.\\n                mstore(ptr, typeHash)\\n\\n                // Take the EIP712 hash and store it in the hash array.\\n                mstore(hashArrPtr, keccak256(ptr, EIP712_ConsiderationItem_size))\\n\\n                // Restore the previous word.\\n                mstore(ptr, value)\\n\\n                // Increment the array pointers by one word.\\n                considerationArrPtr := add(considerationArrPtr, OneWord)\\n                hashArrPtr := add(hashArrPtr, OneWord)\\n            }\\n\\n            // Derive the consideration hash using the hashes of each item.\\n            considerationHash := keccak256(\\n                mload(FreeMemoryPointerSlot),\\n                mul(originalConsiderationLength, OneWord)\\n            )\\n        }\\n\\n        // Read order item EIP-712 typehash from runtime code & place on stack.\\n        typeHash = _ORDER_TYPEHASH;\\n\\n        // Utilize assembly to access derived hashes & other arguments directly.\\n        assembly {\\n            // Retrieve pointer to the region located just behind parameters.\\n            let typeHashPtr := sub(orderParameters, OneWord)\\n\\n            // Store the value at that pointer location to restore later.\\n            let previousValue := mload(typeHashPtr)\\n\\n            // Store the order item EIP-712 typehash at the typehash location.\\n            mstore(typeHashPtr, typeHash)\\n\\n            // Retrieve the pointer for the offer array head.\\n            let offerHeadPtr := add(\\n                orderParameters,\\n                OrderParameters_offer_head_offset\\n            )\\n\\n            // Retrieve the data pointer referenced by the offer head.\\n            let offerDataPtr := mload(offerHeadPtr)\\n\\n            // Store the offer hash at the retrieved memory location.\\n            mstore(offerHeadPtr, offerHash)\\n\\n            // Retrieve the pointer for the consideration array head.\\n            let considerationHeadPtr := add(\\n                orderParameters,\\n                OrderParameters_consideration_head_offset\\n            )\\n\\n            // Retrieve the data pointer referenced by the consideration head.\\n            let considerationDataPtr := mload(considerationHeadPtr)\\n\\n            // Store the consideration hash at the retrieved memory location.\\n            mstore(considerationHeadPtr, considerationHash)\\n\\n            // Retrieve the pointer for the nonce.\\n            let noncePtr := add(orderParameters, OrderParameters_nonce_offset)\\n\\n            // Store the nonce at the retrieved memory location.\\n            mstore(noncePtr, nonce)\\n\\n            // Derive the order hash using the full range of order parameters.\\n            orderHash := keccak256(typeHashPtr, EIP712_Order_size)\\n\\n            // Restore the value previously held at typehash pointer location.\\n            mstore(typeHashPtr, previousValue)\\n\\n            // Restore offer data pointer at the offer head pointer location.\\n            mstore(offerHeadPtr, offerDataPtr)\\n\\n            // Restore consideration data pointer at the consideration head ptr.\\n            mstore(considerationHeadPtr, considerationDataPtr)\\n\\n            // Restore original consideration item length at the nonce pointer.\\n            mstore(noncePtr, originalConsiderationLength)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to derive the address of a given conduit\\n     *      using a corresponding conduit key.\\n     *\\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\\n     *                   if any, to source token approvals from. This value is\\n     *                   the \\\"salt\\\" parameter supplied by the deployer (i.e. the\\n     *                   conduit controller) when deploying the given conduit.\\n     *\\n     * @return conduit The address of the conduit associated with the given\\n     *                 conduit key.\\n     */\\n    function _deriveConduit(bytes32 conduitKey)\\n        internal\\n        view\\n        returns (address conduit)\\n    {\\n        // Read conduit controller address from runtime and place on the stack.\\n        address conduitController = address(_CONDUIT_CONTROLLER);\\n\\n        // Read conduit creation code hash from runtime and place on the stack.\\n        bytes32 conduitCreationCodeHash = _CONDUIT_CREATION_CODE_HASH;\\n\\n        // Leverage scratch space to perform an efficient hash.\\n        assembly {\\n            // Retrieve the free memory pointer; it will be replaced afterwards.\\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Place the control character and the conduit controller in scratch\\n            // space; note that eleven bytes at the beginning are left unused.\\n            mstore(0, or(MaskOverByteTwelve, conduitController))\\n\\n            // Place the conduit key in the next region of scratch space.\\n            mstore(OneWord, conduitKey)\\n\\n            // Place conduit creation code hash in free memory pointer location.\\n            mstore(TwoWords, conduitCreationCodeHash)\\n\\n            // Derive conduit by hashing and applying a mask over last 20 bytes.\\n            conduit := and(\\n                // Hash the relevant region.\\n                keccak256(\\n                    // The region starts at memory pointer 11.\\n                    Create2AddressDerivation_ptr,\\n                    // The region is 85 bytes long (1 + 20 + 32 + 32).\\n                    Create2AddressDerivation_length\\n                ),\\n                // The address equals the last twenty bytes of the hash.\\n                MaskOverLastTwentyBytes\\n            )\\n\\n            // Restore the free memory pointer.\\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to get the EIP-712 domain separator. If the\\n     *      chainId matches the chainId set on deployment, the cached domain\\n     *      separator will be returned; otherwise, it will be derived from\\n     *      scratch.\\n     */\\n    function _domainSeparator() internal view returns (bytes32) {\\n        return block.chainid == _CHAIN_ID\\n            ? _DOMAIN_SEPARATOR\\n            : _deriveDomainSeparator();\\n    }\\n\\n    /**\\n     * @dev Internal view function to retrieve configuration information for\\n     *      this contract.\\n     *\\n     * @return version           The contract version.\\n     * @return domainSeparator   The domain separator for this contract.\\n     * @return conduitController The conduit Controller set for this contract.\\n     */\\n    function _information()\\n        internal\\n        view\\n        returns (\\n            string memory version,\\n            bytes32 domainSeparator,\\n            address conduitController\\n        )\\n    {\\n        // Derive the domain separator.\\n        domainSeparator = _domainSeparator();\\n\\n        // Declare variable as immutables cannot be accessed within assembly.\\n        conduitController = address(_CONDUIT_CONTROLLER);\\n\\n        // Allocate a string with the intended length.\\n        version = new string(Version_length);\\n\\n        // Set the version as data on the newly allocated string.\\n        assembly {\\n            mstore(add(version, OneWord), shl(0xf8, Version))\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to efficiently derive an digest to sign for\\n     *      an order in accordance with EIP-712.\\n     *\\n     * @param domainSeparator The domain separator.\\n     * @param orderHash       The order hash.\\n     *\\n     * @return value The hash.\\n     */\\n    function _deriveEIP712Digest(bytes32 domainSeparator, bytes32 orderHash)\\n        internal\\n        pure\\n        returns (bytes32 value)\\n    {\\n        // Leverage scratch space to perform an efficient hash.\\n        assembly {\\n            // Place the EIP-712 prefix at the start of scratch space.\\n            mstore(0, EIP_712_PREFIX)\\n\\n            // Place the domain separator in the next region of scratch space.\\n            mstore(EIP712_DomainSeparator_offset, domainSeparator)\\n\\n            // Place the order hash in scratch space, spilling into the first\\n            // two bytes of the free memory pointer — this should never be set\\n            // as memory cannot be expanded to that size, and will be zeroed out\\n            // after the hash is performed.\\n            mstore(EIP712_OrderHash_offset, orderHash)\\n\\n            // Hash the relevant region (65 bytes).\\n            value := keccak256(0, EIP712_DigestPayload_size)\\n\\n            // Clear out the dirtied bits in the memory pointer.\\n            mstore(EIP712_OrderHash_offset, 0)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TokenTransferrerErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/**\\n * @title TokenTransferrerErrors\\n */\\ninterface TokenTransferrerErrors {\\n    /**\\n     * @dev Revert with an error when an ERC721 transfer with amount other than\\n     *      one is attempted.\\n     */\\n    error InvalidERC721TransferAmount();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order where an\\n     *      item has an amount of zero.\\n     */\\n    error MissingItemAmount();\\n\\n    /**\\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\\n     *      transfer reverts.\\n     *\\n     * @param token      The token for which the transfer was attempted.\\n     * @param from       The source of the attempted transfer.\\n     * @param to         The recipient of the attempted transfer.\\n     * @param identifier The identifier for the attempted transfer.\\n     * @param amount     The amount for the attempted transfer.\\n     */\\n    error TokenTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\\n     *\\n     * @param token       The token for which the transfer was attempted.\\n     * @param from        The source of the attempted transfer.\\n     * @param to          The recipient of the attempted transfer.\\n     * @param identifiers The identifiers for the attempted transfer.\\n     * @param amounts     The amounts for the attempted transfer.\\n     */\\n    error ERC1155BatchTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256[] identifiers,\\n        uint256[] amounts\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\\n     *      value.\\n     *\\n     * @param token      The token for which the ERC20 transfer was attempted.\\n     * @param from       The source of the attempted ERC20 transfer.\\n     * @param to         The recipient of the attempted ERC20 transfer.\\n     * @param amount     The amount for the attempted ERC20 transfer.\\n     */\\n    error BadReturnValueFromERC20OnTransfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an account being called as an assumed\\n     *      contract does not have code and returns no data.\\n     *\\n     * @param account The account that should contain code.\\n     */\\n    error NoContract(address account);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/NonceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport {\\n    ConsiderationEventsAndErrors\\n} from \\\"../interfaces/ConsiderationEventsAndErrors.sol\\\";\\n\\nimport { ReentrancyGuard } from \\\"./ReentrancyGuard.sol\\\";\\n\\n/**\\n * @title NonceManager\\n * @author 0age\\n * @notice NonceManager contains a storage mapping and related functionality\\n *         for retrieving and incrementing a per-offerer nonce.\\n */\\ncontract NonceManager is ConsiderationEventsAndErrors, ReentrancyGuard {\\n    // Only orders signed using an offerer's current nonce are fulfillable.\\n    mapping(address => uint256) private _nonces;\\n\\n    /**\\n     * @dev Internal function to cancel all orders from a given offerer with a\\n     *      given zone in bulk by incrementing a nonce. Note that only the\\n     *      offerer may increment the nonce.\\n     *\\n     * @return newNonce The new nonce.\\n     */\\n    function _incrementNonce() internal returns (uint256 newNonce) {\\n        // Ensure that the reentrancy guard is not currently set.\\n        _assertNonReentrant();\\n\\n        // No need to check for overflow; nonce cannot be incremented that far.\\n        unchecked {\\n            // Increment current nonce for the supplied offerer.\\n            newNonce = ++_nonces[msg.sender];\\n        }\\n\\n        // Emit an event containing the new nonce.\\n        emit NonceIncremented(newNonce, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Internal view function to retrieve the current nonce for a given\\n     *      offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return currentNonce The current nonce.\\n     */\\n    function _getNonce(address offerer)\\n        internal\\n        view\\n        returns (uint256 currentNonce)\\n    {\\n        // Return the nonce for the supplied offerer.\\n        currentNonce = _nonces[offerer];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ConsiderationBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport {\\n    ConduitControllerInterface\\n} from \\\"../interfaces/ConduitControllerInterface.sol\\\";\\n\\nimport {\\n    ConsiderationEventsAndErrors\\n} from \\\"../interfaces/ConsiderationEventsAndErrors.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title ConsiderationBase\\n * @author 0age\\n * @notice ConsiderationBase contains immutable constants and constructor logic.\\n */\\ncontract ConsiderationBase is ConsiderationEventsAndErrors {\\n    // Precompute hashes, original chainId, and domain separator on deployment.\\n    bytes32 internal immutable _NAME_HASH;\\n    bytes32 internal immutable _VERSION_HASH;\\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\\n    bytes32 internal immutable _OFFER_ITEM_TYPEHASH;\\n    bytes32 internal immutable _CONSIDERATION_ITEM_TYPEHASH;\\n    bytes32 internal immutable _ORDER_TYPEHASH;\\n    uint256 internal immutable _CHAIN_ID;\\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\\n\\n    // Allow for interaction with the conduit controller.\\n    ConduitControllerInterface internal immutable _CONDUIT_CONTROLLER;\\n\\n    // Cache the conduit creation code hash used by the conduit controller.\\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\\n\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) {\\n        // Derive name and version hashes alongside required EIP-712 typehashes.\\n        (\\n            _NAME_HASH,\\n            _VERSION_HASH,\\n            _EIP_712_DOMAIN_TYPEHASH,\\n            _OFFER_ITEM_TYPEHASH,\\n            _CONSIDERATION_ITEM_TYPEHASH,\\n            _ORDER_TYPEHASH\\n        ) = _deriveTypehashes();\\n\\n        // Store the current chainId and derive the current domain separator.\\n        _CHAIN_ID = block.chainid;\\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\\n\\n        // Set the supplied conduit controller.\\n        _CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\\n\\n        // Retrieve the conduit creation code hash from the supplied controller.\\n        (_CONDUIT_CREATION_CODE_HASH, ) = (\\n            _CONDUIT_CONTROLLER.getConduitCodeHashes()\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal view function to derive the EIP-712 domain separator.\\n     *\\n     * @return The derived domain separator.\\n     */\\n    function _deriveDomainSeparator() internal view returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                _EIP_712_DOMAIN_TYPEHASH,\\n                _NAME_HASH,\\n                _VERSION_HASH,\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal pure function to retrieve the default name of this\\n     *      contract and return.\\n     *\\n     * @return The name of this contract.\\n     */\\n    function _name() internal pure virtual returns (string memory) {\\n        // Return the name of the contract.\\n        assembly {\\n            mstore(0, OneWord) // First element is the offset.\\n            // Name is right padded, so it touches the length which is left\\n            // padded. This enables writing both values at once.\\n            mstore(NameLengthPtr, NameWithLength)\\n            return(0, ThreeWords) // Return all three words.\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to retrieve the default name of this contract\\n     *      as a string that can be used internally.\\n     *\\n     * @return The name of this contract.\\n     */\\n    function _nameString() internal pure virtual returns (string memory) {\\n        // Return the name of the contract.\\n        return \\\"Consideration\\\";\\n    }\\n\\n    /**\\n     * @dev Internal pure function to derive required EIP-712 typehashes and\\n     *      other hashes during contract creation.\\n     *\\n     * @return nameHash                  The hash of the name of the contract.\\n     * @return versionHash               The hash of the version string of the\\n     *                                   contract.\\n     * @return eip712DomainTypehash      The primary EIP-712 domain typehash.\\n     * @return offerItemTypehash         The EIP-712 typehash for OfferItem\\n     *                                   types.\\n     * @return considerationItemTypehash The EIP-712 typehash for\\n     *                                   ConsiderationItem types.\\n     * @return orderTypehash             The EIP-712 typehash for Order types.\\n     */\\n    function _deriveTypehashes()\\n        internal\\n        pure\\n        returns (\\n            bytes32 nameHash,\\n            bytes32 versionHash,\\n            bytes32 eip712DomainTypehash,\\n            bytes32 offerItemTypehash,\\n            bytes32 considerationItemTypehash,\\n            bytes32 orderTypehash\\n        )\\n    {\\n        // Derive hash of the name of the contract.\\n        nameHash = keccak256(bytes(_nameString()));\\n\\n        // Derive hash of the version string of the contract.\\n        versionHash = keccak256(bytes(\\\"1\\\"));\\n\\n        // Construct the OfferItem type string.\\n        bytes memory offerItemTypeString = abi.encodePacked(\\n            \\\"OfferItem(\\\",\\n                \\\"uint8 itemType,\\\",\\n                \\\"address token,\\\",\\n                \\\"uint256 identifierOrCriteria,\\\",\\n                \\\"uint256 startAmount,\\\",\\n                \\\"uint256 endAmount\\\",\\n            \\\")\\\"\\n        );\\n\\n        // Construct the ConsiderationItem type string.\\n        bytes memory considerationItemTypeString = abi.encodePacked(\\n            \\\"ConsiderationItem(\\\",\\n                \\\"uint8 itemType,\\\",\\n                \\\"address token,\\\",\\n                \\\"uint256 identifierOrCriteria,\\\",\\n                \\\"uint256 startAmount,\\\",\\n                \\\"uint256 endAmount,\\\",\\n                \\\"address recipient\\\",\\n            \\\")\\\"\\n        );\\n\\n        // Construct the OrderComponents type string, not including the above.\\n        bytes memory orderComponentsPartialTypeString = abi.encodePacked(\\n            \\\"OrderComponents(\\\",\\n                \\\"address offerer,\\\",\\n                \\\"address zone,\\\",\\n                \\\"OfferItem[] offer,\\\",\\n                \\\"ConsiderationItem[] consideration,\\\",\\n                \\\"uint8 orderType,\\\",\\n                \\\"uint256 startTime,\\\",\\n                \\\"uint256 endTime,\\\",\\n                \\\"bytes32 zoneHash,\\\",\\n                \\\"uint256 salt,\\\",\\n                \\\"bytes32 conduitKey,\\\",\\n                \\\"uint256 nonce\\\",\\n            \\\")\\\"\\n        );\\n\\n        // Construct the primary EIP-712 domain type string.\\n        eip712DomainTypehash = keccak256(\\n            abi.encodePacked(\\n                \\\"EIP712Domain(\\\",\\n                    \\\"string name,\\\",\\n                    \\\"string version,\\\",\\n                    \\\"uint256 chainId,\\\",\\n                    \\\"address verifyingContract\\\",\\n                \\\")\\\"\\n            )\\n        );\\n\\n        // Derive the OfferItem type hash using the corresponding type string.\\n        offerItemTypehash = keccak256(offerItemTypeString);\\n\\n        // Derive ConsiderationItem type hash using corresponding type string.\\n        considerationItemTypehash = keccak256(considerationItemTypeString);\\n\\n        // Derive OrderItem type hash via combination of relevant type strings.\\n        orderTypehash = keccak256(\\n            abi.encodePacked(\\n                orderComponentsPartialTypeString,\\n                considerationItemTypeString,\\n                offerItemTypeString\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ConduitControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/**\\n * @title ConduitControllerInterface\\n * @author 0age\\n * @notice ConduitControllerInterface contains all external function interfaces,\\n *         structs, events, and errors for the conduit controller.\\n */\\ninterface ConduitControllerInterface {\\n    /**\\n     * @dev Track the conduit key, current owner, new potential owner, and open\\n     *      channels for each deployed conduit.\\n     */\\n    struct ConduitProperties {\\n        bytes32 key;\\n        address owner;\\n        address potentialOwner;\\n        address[] channels;\\n        mapping(address => uint256) channelIndexesPlusOne;\\n    }\\n\\n    /**\\n     * @dev Emit an event whenever a new conduit is created.\\n     *\\n     * @param conduit    The newly created conduit.\\n     * @param conduitKey The conduit key used to create the new conduit.\\n     */\\n    event NewConduit(address conduit, bytes32 conduitKey);\\n\\n    /**\\n     * @dev Emit an event whenever conduit ownership is transferred.\\n     *\\n     * @param conduit       The conduit for which ownership has been\\n     *                      transferred.\\n     * @param previousOwner The previous owner of the conduit.\\n     * @param newOwner      The new owner of the conduit.\\n     */\\n    event OwnershipTransferred(\\n        address indexed conduit,\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever a conduit owner registers a new potential\\n     *      owner for that conduit.\\n     *\\n     * @param conduit           The conduit for which ownership may now be\\n     *                          transferred.\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    event PotentialOwnerUpdated(\\n        address indexed conduit,\\n        address indexed newPotentialOwner\\n    );\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit using a\\n     *      conduit key where the last twenty bytes of the key do not match the\\n     *      address of the caller.\\n     */\\n    error InvalidCreator();\\n\\n    /**\\n     * @dev Revert with an error when attempting to interact with a conduit that\\n     *      does not yet exist.\\n     */\\n    error NoConduit();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a conduit that\\n     *      already exists.\\n     */\\n    error ConduitAlreadyExists(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update channels or transfer\\n     *      ownership of a conduit when the caller is not the owner of the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to register a new potential\\n     *      owner and supplying the null address.\\n     */\\n    error NewPotentialOwnerIsZeroAddress(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to claim ownership of a conduit\\n     *      with a caller that is not the current potential owner for the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotNewPotentialOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to retrieve a channel using an\\n     *      index that is out of range.\\n     */\\n    error ChannelOutOfRange(address conduit);\\n\\n    /**\\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\\n     *         an initial owner for the deployed conduit. Note that the last\\n     *         twenty bytes of the supplied conduit key must match the caller\\n     *         and that a new conduit cannot be created if one has already been\\n     *         deployed using the same conduit key.\\n     *\\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\\n     *                     the last twenty bytes of the conduit key must match\\n     *                     the caller of this contract.\\n     * @param initialOwner The initial owner to set for the new conduit.\\n     *\\n     * @return conduit The address of the newly deployed conduit.\\n     */\\n    function createConduit(bytes32 conduitKey, address initialOwner)\\n        external\\n        returns (address conduit);\\n\\n    /**\\n     * @notice Open or close a channel on a given conduit, thereby allowing the\\n     *         specified account to execute transfers against that conduit.\\n     *         Extreme care must be taken when updating channels, as malicious\\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\\n     *         tokens where the token holder has granted the conduit approval.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to open or close the channel.\\n     * @param channel The channel to open or close on the conduit.\\n     * @param isOpen  A boolean indicating whether to open or close the channel.\\n     */\\n    function updateChannel(\\n        address conduit,\\n        address channel,\\n        bool isOpen\\n    ) external;\\n\\n    /**\\n     * @notice Initiate conduit ownership transfer by assigning a new potential\\n     *         owner for the given conduit. Once set, the new potential owner\\n     *         may call `acceptOwnership` to claim ownership of the conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to initiate ownership transfer.\\n     */\\n    function transferOwnership(address conduit, address newPotentialOwner)\\n        external;\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any, from a conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to cancel ownership transfer.\\n     */\\n    function cancelOwnershipTransfer(address conduit) external;\\n\\n    /**\\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     *\\n     * @param conduit The conduit for which to accept ownership.\\n     */\\n    function acceptOwnership(address conduit) external;\\n\\n    /**\\n     * @notice Retrieve the current owner of a deployed conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated owner.\\n     *\\n     * @return owner The owner of the supplied conduit.\\n     */\\n    function ownerOf(address conduit) external view returns (address owner);\\n\\n    /**\\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\\n     *         lookup.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated conduit\\n     *                key.\\n     *\\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\\n     */\\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\\n\\n    /**\\n     * @notice Derive the conduit associated with a given conduit key and\\n     *         determine whether that conduit exists (i.e. whether it has been\\n     *         deployed).\\n     *\\n     * @param conduitKey The conduit key used to derive the conduit.\\n     *\\n     * @return conduit The derived address of the conduit.\\n     * @return exists  A boolean indicating whether the derived conduit has been\\n     *                 deployed or not.\\n     */\\n    function getConduit(bytes32 conduitKey)\\n        external\\n        view\\n        returns (address conduit, bool exists);\\n\\n    /**\\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\\n     *         current owner may set a new potential owner via\\n     *         `transferOwnership` and that owner may then accept ownership of\\n     *         the conduit in question via `acceptOwnership`.\\n     *\\n     * @param conduit The conduit for which to retrieve the potential owner.\\n     *\\n     * @return potentialOwner The potential owner, if any, for the conduit.\\n     */\\n    function getPotentialOwner(address conduit)\\n        external\\n        view\\n        returns (address potentialOwner);\\n\\n    /**\\n     * @notice Retrieve the status (either open or closed) of a given channel on\\n     *         a conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the channel status.\\n     * @param channel The channel for which to retrieve the status.\\n     *\\n     * @return isOpen The status of the channel on the given conduit.\\n     */\\n    function getChannelStatus(address conduit, address channel)\\n        external\\n        view\\n        returns (bool isOpen);\\n\\n    /**\\n     * @notice Retrieve the total number of open channels for a given conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the total channel count.\\n     *\\n     * @return totalChannels The total number of open channels for the conduit.\\n     */\\n    function getTotalChannels(address conduit)\\n        external\\n        view\\n        returns (uint256 totalChannels);\\n\\n    /**\\n     * @notice Retrieve an open channel at a specific index for a given conduit.\\n     *         Note that the index of a channel can change as a result of other\\n     *         channels being closed on the conduit.\\n     *\\n     * @param conduit      The conduit for which to retrieve the open channel.\\n     * @param channelIndex The index of the channel in question.\\n     *\\n     * @return channel The open channel, if any, at the specified channel index.\\n     */\\n    function getChannel(address conduit, uint256 channelIndex)\\n        external\\n        view\\n        returns (address channel);\\n\\n    /**\\n     * @notice Retrieve all open channels for a given conduit. Note that calling\\n     *         this function for a conduit with many channels will revert with\\n     *         an out-of-gas error.\\n     *\\n     * @param conduit The conduit for which to retrieve open channels.\\n     *\\n     * @return channels An array of open channels on the given conduit.\\n     */\\n    function getChannels(address conduit)\\n        external\\n        view\\n        returns (address[] memory channels);\\n\\n    /**\\n     * @dev Retrieve the conduit creation code and runtime code hashes.\\n     */\\n    function getConduitCodeHashes()\\n        external\\n        view\\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ConsiderationEventsAndErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { SpentItem, ReceivedItem } from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title ConsiderationEventsAndErrors\\n * @author 0age\\n * @notice ConsiderationEventsAndErrors contains all events and errors.\\n */\\ninterface ConsiderationEventsAndErrors {\\n    /**\\n     * @dev Emit an event whenever an order is successfully fulfilled.\\n     *\\n     * @param orderHash     The hash of the fulfilled order.\\n     * @param offerer       The offerer of the fulfilled order.\\n     * @param zone          The zone of the fulfilled order.\\n     * @param fulfiller     The fulfiller of the order, or the null address if\\n     *                      there is no specific fulfiller (i.e. the order is\\n     *                      part of a group of orders).\\n     * @param offer         The offer items spent as part of the order.\\n     * @param consideration The consideration items received as part of the\\n     *                      order along with the recipients of each item.\\n     */\\n    event OrderFulfilled(\\n        bytes32 orderHash,\\n        address indexed offerer,\\n        address indexed zone,\\n        address fulfiller,\\n        SpentItem[] offer,\\n        ReceivedItem[] consideration\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever an order is successfully cancelled.\\n     *\\n     * @param orderHash The hash of the cancelled order.\\n     * @param offerer   The offerer of the cancelled order.\\n     * @param zone      The zone of the cancelled order.\\n     */\\n    event OrderCancelled(\\n        bytes32 orderHash,\\n        address indexed offerer,\\n        address indexed zone\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever an order is explicitly validated. Note that\\n     *      this event will not be emitted on partial fills even though they do\\n     *      validate the order as part of partial fulfillment.\\n     *\\n     * @param orderHash The hash of the validated order.\\n     * @param offerer   The offerer of the validated order.\\n     * @param zone      The zone of the validated order.\\n     */\\n    event OrderValidated(\\n        bytes32 orderHash,\\n        address indexed offerer,\\n        address indexed zone\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever a nonce for a given offerer is incremented.\\n     *\\n     * @param newNonce The new nonce for the offerer.\\n     * @param offerer  The offerer in question.\\n     */\\n    event NonceIncremented(uint256 newNonce, address indexed offerer);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order that has\\n     *      already been fully filled.\\n     *\\n     * @param orderHash The order hash on which a fill was attempted.\\n     */\\n    error OrderAlreadyFilled(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order outside the\\n     *      specified start time and end time.\\n     */\\n    error InvalidTime();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order referencing an\\n     *      invalid conduit (i.e. one that has not been deployed).\\n     */\\n    error InvalidConduit(bytes32 conduitKey, address conduit);\\n\\n    /**\\n     * @dev Revert with an error when an order is supplied for fulfillment with\\n     *      a consideration array that is shorter than the original array.\\n     */\\n    error MissingOriginalConsiderationItems();\\n\\n    /**\\n     * @dev Revert with an error when a call to a conduit fails with revert data\\n     *      that is too expensive to return.\\n     */\\n    error InvalidCallToConduit(address conduit);\\n\\n    /**\\n     * @dev Revert with an error if a consideration amount has not been fully\\n     *      zeroed out after applying all fulfillments.\\n     *\\n     * @param orderIndex         The index of the order with the consideration\\n     *                           item with a shortfall.\\n     * @param considerationIndex The index of the consideration item on the\\n     *                           order.\\n     * @param shortfallAmount    The unfulfilled consideration amount.\\n     */\\n    error ConsiderationNotMet(\\n        uint256 orderIndex,\\n        uint256 considerationIndex,\\n        uint256 shortfallAmount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when insufficient ether is supplied as part of\\n     *      msg.value when fulfilling orders.\\n     */\\n    error InsufficientEtherSupplied();\\n\\n    /**\\n     * @dev Revert with an error when an ether transfer reverts.\\n     */\\n    error EtherTransferGenericFailure(address account, uint256 amount);\\n\\n    /**\\n     * @dev Revert with an error when a partial fill is attempted on an order\\n     *      that does not specify partial fill support in its order type.\\n     */\\n    error PartialFillsNotEnabledForOrder();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order that has been\\n     *      cancelled.\\n     *\\n     * @param orderHash The hash of the cancelled order.\\n     */\\n    error OrderIsCancelled(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill a basic order that has\\n     *      been partially filled.\\n     *\\n     * @param orderHash The hash of the partially used order.\\n     */\\n    error OrderPartiallyFilled(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when attempting to cancel an order as a caller\\n     *      other than the indicated offerer or zone.\\n     */\\n    error InvalidCanceller();\\n\\n    /**\\n     * @dev Revert with an error when supplying a fraction with a value of zero\\n     *      for the numerator or denominator, or one where the numerator exceeds\\n     *      the denominator.\\n     */\\n    error BadFraction();\\n\\n    /**\\n     * @dev Revert with an error when a caller attempts to supply callvalue to a\\n     *      non-payable basic order route or does not supply any callvalue to a\\n     *      payable basic order route.\\n     */\\n    error InvalidMsgValue(uint256 value);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill a basic order using\\n     *      calldata not produced by default ABI encoding.\\n     */\\n    error InvalidBasicOrderParameterEncoding();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill any number of\\n     *      available orders when none are fulfillable.\\n     */\\n    error NoSpecifiedOrdersAvailable();\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { ReentrancyErrors } from \\\"../interfaces/ReentrancyErrors.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title ReentrancyGuard\\n * @author 0age\\n * @notice ReentrancyGuard contains a storage variable and related functionality\\n *         for protecting against reentrancy.\\n */\\ncontract ReentrancyGuard is ReentrancyErrors {\\n    // Prevent reentrant calls on protected functions.\\n    uint256 private _reentrancyGuard;\\n\\n    /**\\n     * @dev Initialize the reentrancy guard during deployment.\\n     */\\n    constructor() {\\n        // Initialize the reentrancy guard in a cleared state.\\n        _reentrancyGuard = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Internal function to ensure that the sentinel value for the\\n     *      reentrancy guard is not currently set and, if not, to set the\\n     *      sentinel value for the reentrancy guard.\\n     */\\n    function _setReentrancyGuard() internal {\\n        // Ensure that the reentrancy guard is not already set.\\n        _assertNonReentrant();\\n\\n        // Set the reentrancy guard.\\n        _reentrancyGuard = _ENTERED;\\n    }\\n\\n    /**\\n     * @dev Internal function to unset the reentrancy guard sentinel value.\\n     */\\n    function _clearReentrancyGuard() internal {\\n        // Clear the reentrancy guard.\\n        _reentrancyGuard = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Internal view function to ensure that the sentinel value for the\\n            reentrancy guard is not currently set.\\n     */\\n    function _assertNonReentrant() internal view {\\n        // Ensure that the reentrancy guard is not currently set.\\n        if (_reentrancyGuard != _NOT_ENTERED) {\\n            revert NoReentrantCalls();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ReentrancyErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/**\\n * @title ReentrancyErrors\\n * @author 0age\\n * @notice ReentrancyErrors contains errors related to reentrancy.\\n */\\ninterface ReentrancyErrors {\\n    /**\\n     * @dev Revert with an error when a caller attempts to reenter a protected\\n     *      function.\\n     */\\n    error NoReentrantCalls();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/EIP1271Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface EIP1271Interface {\\n    function isValidSignature(bytes32 digest, bytes calldata signature)\\n        external\\n        view\\n        returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/SignatureVerificationErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/**\\n * @title SignatureVerificationErrors\\n * @author 0age\\n * @notice SignatureVerificationErrors contains all errors related to signature\\n *         verification.\\n */\\ninterface SignatureVerificationErrors {\\n    /**\\n     * @dev Revert with an error when a signature that does not contain a v\\n     *      value of 27 or 28 has been supplied.\\n     *\\n     * @param v The invalid v value.\\n     */\\n    error BadSignatureV(uint8 v);\\n\\n    /**\\n     * @dev Revert with an error when the signer recovered by the supplied\\n     *      signature does not match the offerer or an allowed EIP-1271 signer\\n     *      as specified by the offerer in the event they are a contract.\\n     */\\n    error InvalidSigner();\\n\\n    /**\\n     * @dev Revert with an error when a signer cannot be recovered from the\\n     *      supplied signature.\\n     */\\n    error InvalidSignature();\\n\\n    /**\\n     * @dev Revert with an error when an EIP-1271 call to an account fails.\\n     */\\n    error BadContractSignature();\\n}\\n\"\r\n    },\r\n    \"contracts/lib/LowLevelHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title LowLevelHelpers\\n * @author 0age\\n * @notice LowLevelHelpers contains logic for performing various low-level\\n *         operations.\\n */\\ncontract LowLevelHelpers {\\n    /**\\n     * @dev Internal view function to staticcall an arbitrary target with given\\n     *      calldata. Note that no data is written to memory and no contract\\n     *      size check is performed.\\n     *\\n     * @param target   The account to staticcall.\\n     * @param callData The calldata to supply when staticcalling the target.\\n     *\\n     * @return success The status of the staticcall to the target.\\n     */\\n    function _staticcall(address target, bytes memory callData)\\n        internal\\n        view\\n        returns (bool success)\\n    {\\n        assembly {\\n            // Perform the staticcall.\\n            success := staticcall(\\n                gas(),\\n                target,\\n                add(callData, OneWord),\\n                mload(callData),\\n                0,\\n                0\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to revert and pass along the revert reason if\\n     *      data was returned by the last call and that the size of that data\\n     *      does not exceed the currently allocated memory size.\\n     */\\n    function _revertWithReasonIfOneIsReturned() internal view {\\n        assembly {\\n            // If it returned a message, bubble it up as long as sufficient gas\\n            // remains to do so:\\n            if returndatasize() {\\n                // Ensure that sufficient gas is available to copy returndata\\n                // while expanding memory where necessary. Start by computing\\n                // the word size of returndata and allocated memory.\\n                let returnDataWords := div(returndatasize(), OneWord)\\n\\n                // Note: use the free memory pointer in place of msize() to work\\n                // around a Yul warning that prevents accessing msize directly\\n                // when the IR pipeline is activated.\\n                let msizeWords := div(mload(FreeMemoryPointerSlot), OneWord)\\n\\n                // Next, compute the cost of the returndatacopy.\\n                let cost := mul(CostPerWord, returnDataWords)\\n\\n                // Then, compute cost of new memory allocation.\\n                if gt(returnDataWords, msizeWords) {\\n                    cost := add(\\n                        cost,\\n                        add(\\n                            mul(sub(returnDataWords, msizeWords), CostPerWord),\\n                            div(\\n                                sub(\\n                                    mul(returnDataWords, returnDataWords),\\n                                    mul(msizeWords, msizeWords)\\n                                ),\\n                                MemoryExpansionCoefficient\\n                            )\\n                        )\\n                    )\\n                }\\n\\n                // Finally, add a small constant and compare to gas remaining;\\n                // bubble up the revert data if enough gas is still available.\\n                if lt(add(cost, ExtraGasBuffer), gas()) {\\n                    // Copy returndata to memory; overwrite existing memory.\\n                    returndatacopy(0, 0, returndatasize())\\n\\n                    // Revert, specifying memory region with copied returndata.\\n                    revert(0, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to determine if the first word of returndata\\n     *      matches an expected magic value.\\n     *\\n     * @param expected The expected magic value.\\n     *\\n     * @return A boolean indicating whether the expected value matches the one\\n     *         located in the first word of returndata.\\n     */\\n    function _doesNotMatchMagic(bytes4 expected) internal pure returns (bool) {\\n        // Declare a variable for the value held by the return data buffer.\\n        bytes4 result;\\n\\n        // Utilize assembly in order to read directly from returndata buffer.\\n        assembly {\\n            // Only put result on stack if return data is exactly one word.\\n            if eq(returndatasize(), OneWord) {\\n                // Copy the word directly from return data into scratch space.\\n                returndatacopy(0, 0, OneWord)\\n\\n                // Take value from scratch space and place it on the stack.\\n                result := mload(0)\\n            }\\n        }\\n\\n        // Return a boolean indicating whether expected and located value match.\\n        return result != expected;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/TokenTransferrerConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/*\\n * -------------------------- Disambiguation & Other Notes ---------------------\\n *    - The term \\\"head\\\" is used as it is in the documentation for ABI encoding,\\n *      but only in reference to dynamic types, i.e. it always refers to the\\n *      offset or pointer to the body of a dynamic type. In calldata, the head\\n *      is always an offset (relative to the parent object), while in memory,\\n *      the head is always the pointer to the body. More information found here:\\n *      https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#argument-encoding\\n *        - Note that the length of an array is separate from and precedes the\\n *          head of the array.\\n *\\n *    - The term \\\"body\\\" is used in place of the term \\\"head\\\" used in the ABI\\n *      documentation. It refers to the start of the data for a dynamic type,\\n *      e.g. the first word of a struct or the first word of the first element\\n *      in an array.\\n *\\n *    - The term \\\"pointer\\\" is used to describe the absolute position of a value\\n *      and never an offset relative to another value.\\n *        - The suffix \\\"_ptr\\\" refers to a memory pointer.\\n *        - The suffix \\\"_cdPtr\\\" refers to a calldata pointer.\\n *\\n *    - The term \\\"offset\\\" is used to describe the position of a value relative\\n *      to some parent value. For example, OrderParameters_conduit_offset is the\\n *      offset to the \\\"conduit\\\" value in the OrderParameters struct relative to\\n *      the start of the body.\\n *        - Note: Offsets are used to derive pointers.\\n *\\n *    - Some structs have pointers defined for all of their fields in this file.\\n *      Lines which are commented out are fields that are not used in the\\n *      codebase but have been left in for readability.\\n */\\n\\nuint256 constant OneWord = 0x20;\\nuint256 constant TwoWords = 0x40;\\nuint256 constant ThreeWords = 0x60;\\n\\nuint256 constant FreeMemoryPointerSlot = 0x40;\\nuint256 constant ZeroSlot = 0x60;\\nuint256 constant DefaultFreeMemoryPointer = 0x80;\\n\\nuint256 constant Slot0x80 = 0x80;\\nuint256 constant Slot0xA0 = 0xa0;\\nuint256 constant Slot0xC0 = 0xc0;\\n\\n// abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\")\\nuint256 constant ERC20_transferFrom_signature = (\\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\"\\n// )\\nuint256 constant ERC1155_safeTransferFrom_signature = (\\n    0xf242432a00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 196\\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\\"\\n// )\\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\\n);\\n\\nbytes4 constant ERC1155_safeBatchTransferFrom_selector = bytes4(\\n    bytes32(ERC1155_safeBatchTransferFrom_signature)\\n);\\n\\nuint256 constant ERC721_transferFrom_signature = ERC20_transferFrom_signature;\\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\\"NoContract(address)\\\")\\nuint256 constant NoContract_error_signature = (\\n    0x5f15d67200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant NoContract_error_sig_ptr = 0x0;\\nuint256 constant NoContract_error_token_ptr = 0x4;\\nuint256 constant NoContract_error_length = 0x24; // 4 + 32 == 36\\n\\n// abi.encodeWithSignature(\\n//     \\\"TokenTransferGenericFailure(address,address,address,uint256,uint256)\\\"\\n// )\\nuint256 constant TokenTransferGenericFailure_error_signature = (\\n    0xf486bc8700000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant TokenTransferGenericFailure_error_sig_ptr = 0x0;\\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x4;\\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x24;\\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x44;\\nuint256 constant TokenTransferGenericFailure_error_id_ptr = 0x64;\\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0x84;\\n\\n// 4 + 32 * 5 == 164\\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\\n\\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\\n    0xafc445e200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\\n\\n// abi.encodeWithSignature(\\n//     \\\"BadReturnValueFromERC20OnTransfer(address,address,address,uint256)\\\"\\n// )\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_signature = (\\n    0x9889192300000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_sig_ptr = 0x0;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x4;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x24;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x44;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x64;\\n\\n// 4 + 32 * 4 == 132\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\\n\\nuint256 constant ExtraGasBuffer = 0x20;\\nuint256 constant CostPerWord = 3;\\nuint256 constant MemoryExpansionCoefficient = 0x200;\\n\\n// Values are offset by 32 bytes in order to write the token to the beginning\\n// in the event of a revert\\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x44;\\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0x104;\\n\\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\\n\\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\\nuint256 constant BatchTransfer1155Params_amounts_length_baseOffset = 0xc0;\\nuint256 constant BatchTransfer1155Params_data_length_baseOffset = 0xe0;\\n\\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\\n\\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\\nuint256 constant ConduitBatch1155Transfer_amounts_head_offset = 0x80;\\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\\nuint256 constant ConduitBatch1155Transfer_calldata_baseSize = 0xc0;\\n\\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\\n);\\n\"\r\n    },\r\n    \"contracts/lib/FulfillmentApplier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { ItemType, Side } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    OfferItem,\\n    ConsiderationItem,\\n    ReceivedItem,\\n    OrderParameters,\\n    AdvancedOrder,\\n    Execution,\\n    FulfillmentComponent\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\nimport {\\n    FulfillmentApplicationErrors\\n} from \\\"../interfaces/FulfillmentApplicationErrors.sol\\\";\\n\\n/**\\n * @title FulfillmentApplier\\n * @author 0age\\n * @notice FulfillmentApplier contains logic related to applying fulfillments,\\n *         both as part of order matching (where offer items are matched to\\n *         consideration items) as well as fulfilling available orders (where\\n *         order items and consideration items are independently aggregated).\\n */\\ncontract FulfillmentApplier is FulfillmentApplicationErrors {\\n    /**\\n     * @dev Internal view function to match offer items to consideration items\\n     *      on a group of orders via a supplied fulfillment.\\n     *\\n     * @param advancedOrders          The orders to match.\\n     * @param offerComponents         An array designating offer components to\\n     *                                match to consideration components.\\n     * @param considerationComponents An array designating consideration\\n     *                                components to match to offer components.\\n     *                                Note that each consideration amount must\\n     *                                be zero in order for the match operation\\n     *                                to be valid.\\n     *\\n     * @return execution The transfer performed as a result of the fulfillment.\\n     */\\n    function _applyFulfillment(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[] calldata offerComponents,\\n        FulfillmentComponent[] calldata considerationComponents\\n    ) internal view returns (Execution memory execution) {\\n        // Ensure 1+ of both offer and consideration components are supplied.\\n        if (\\n            offerComponents.length == 0 || considerationComponents.length == 0\\n        ) {\\n            revert OfferAndConsiderationRequiredOnFulfillment();\\n        }\\n\\n        // Declare a new Execution struct.\\n        Execution memory considerationExecution;\\n\\n        // Validate & aggregate consideration items to new Execution object.\\n        _aggregateValidFulfillmentConsiderationItems(\\n            advancedOrders,\\n            considerationComponents,\\n            considerationExecution\\n        );\\n\\n        // Retrieve the consideration item from the execution struct.\\n        ReceivedItem memory considerationItem = considerationExecution.item;\\n\\n        // Validate & aggregate offer items to Execution object.\\n        _aggregateValidFulfillmentOfferItems(\\n            advancedOrders,\\n            offerComponents,\\n            execution\\n        );\\n\\n        // Ensure offer and consideration share types, tokens and identifiers.\\n        if (\\n            execution.item.itemType != considerationItem.itemType ||\\n            execution.item.token != considerationItem.token ||\\n            execution.item.identifier != considerationItem.identifier\\n        ) {\\n            revert MismatchedFulfillmentOfferAndConsiderationComponents();\\n        }\\n\\n        // If total consideration amount exceeds the offer amount...\\n        if (considerationItem.amount > execution.item.amount) {\\n            // Retrieve the first consideration component from the fulfillment.\\n            FulfillmentComponent memory targetComponent = (\\n                considerationComponents[0]\\n            );\\n\\n            // Add excess consideration item amount to original array of orders.\\n            advancedOrders[targetComponent.orderIndex]\\n                .parameters\\n                .consideration[targetComponent.itemIndex]\\n                .startAmount = considerationItem.amount - execution.item.amount;\\n\\n            // Reduce total consideration amount to equal the offer amount.\\n            considerationItem.amount = execution.item.amount;\\n        } else {\\n            // Retrieve the first offer component from the fulfillment.\\n            FulfillmentComponent memory targetComponent = (offerComponents[0]);\\n\\n            // Add excess offer item amount to the original array of orders.\\n            advancedOrders[targetComponent.orderIndex]\\n                .parameters\\n                .offer[targetComponent.itemIndex]\\n                .startAmount = execution.item.amount - considerationItem.amount;\\n        }\\n\\n        // Reuse execution struct with consideration amount and recipient.\\n        execution.item.amount = considerationItem.amount;\\n        execution.item.recipient = considerationItem.recipient;\\n\\n        // Return the final execution that will be triggered for relevant items.\\n        return execution; // Execution(considerationItem, offerer, conduitKey);\\n    }\\n\\n    /**\\n     * @dev Internal view function to aggregate offer or consideration items\\n     *      from a group of orders into a single execution via a supplied array\\n     *      of fulfillment components. Items that are not available to aggregate\\n     *      will not be included in the aggregated execution.\\n     *\\n     * @param advancedOrders        The orders to aggregate.\\n     * @param side                  The side (i.e. offer or consideration).\\n     * @param fulfillmentComponents An array designating item components to\\n     *                              aggregate if part of an available order.\\n     * @param fulfillerConduitKey   A bytes32 value indicating what conduit, if\\n     *                              any, to source the fulfiller's token\\n     *                              approvals from. The zero hash signifies that\\n     *                              no conduit should be used, with approvals\\n     *                              set directly on this contract.\\n     *\\n     * @return execution The transfer performed as a result of the fulfillment.\\n     */\\n    function _aggregateAvailable(\\n        AdvancedOrder[] memory advancedOrders,\\n        Side side,\\n        FulfillmentComponent[] memory fulfillmentComponents,\\n        bytes32 fulfillerConduitKey\\n    ) internal view returns (Execution memory execution) {\\n        // Skip overflow / underflow checks; conditions checked or unreachable.\\n        unchecked {\\n            // Retrieve fulfillment components array length and place on stack.\\n            // Ensure at least one fulfillment component has been supplied.\\n            if (fulfillmentComponents.length == 0) {\\n                revert MissingFulfillmentComponentOnAggregation(side);\\n            }\\n\\n            // If the fulfillment components are offer components...\\n            if (side == Side.OFFER) {\\n                // Return execution for aggregated items provided by offerer.\\n                _aggregateValidFulfillmentOfferItems(\\n                    advancedOrders,\\n                    fulfillmentComponents,\\n                    execution\\n                );\\n            } else {\\n                // Otherwise, fulfillment components are consideration\\n                // components. Return execution for aggregated items provided by\\n                // the fulfiller.\\n                _aggregateValidFulfillmentConsiderationItems(\\n                    advancedOrders,\\n                    fulfillmentComponents,\\n                    execution\\n                );\\n\\n                // Set the caller as the offerer on the execution.\\n                execution.offerer = msg.sender;\\n\\n                // Set fulfiller conduit key as the conduit key on execution.\\n                execution.conduitKey = fulfillerConduitKey;\\n            }\\n\\n            // Set the offerer as the receipient if execution amount is nonzero.\\n            if (execution.item.amount == 0) {\\n                execution.item.recipient = payable(execution.offerer);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to aggregate a group of offer items using\\n     *      supplied directives on which component items are candidates for\\n     *      aggregation, skipping items on orders that are not available.\\n     *\\n     * @param advancedOrders  The orders to aggregate offer items from.\\n     * @param offerComponents An array of FulfillmentComponent structs\\n     *                        indicating the order index and item index of each\\n     *                        candidate offer item for aggregation.\\n     * @param execution       The execution to apply the aggregation to.\\n     */\\n    function _aggregateValidFulfillmentOfferItems(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[] memory offerComponents,\\n        Execution memory execution\\n    ) internal view {\\n        assembly {\\n            // Declare function for reverts on invalid fulfillment data.\\n            function throwInvalidFulfillmentComponentData() {\\n                // Store the InvalidFulfillmentComponentData error signature.\\n                mstore(0, InvalidFulfillmentComponentData_error_signature)\\n\\n                // Return, supplying InvalidFulfillmentComponentData signature.\\n                revert(0, InvalidFulfillmentComponentData_error_len)\\n            }\\n\\n            // Declare function for reverts due to arithmetic overflows.\\n            function throwOverflow() {\\n                // Store the Panic error signature.\\n                mstore(0, Panic_error_signature)\\n\\n                // Store the arithmetic (0x11) panic code as initial argument.\\n                mstore(Panic_error_offset, Panic_arithmetic)\\n\\n                // Return, supplying Panic signature and arithmetic code.\\n                revert(0, Panic_error_length)\\n            }\\n\\n            // Get position in offerComponents head.\\n            let fulfillmentHeadPtr := add(offerComponents, OneWord)\\n\\n            // Retrieve the order index using the fulfillment pointer.\\n            let orderIndex := mload(mload(fulfillmentHeadPtr))\\n\\n            // Ensure that the order index is not out of range.\\n            if iszero(lt(orderIndex, mload(advancedOrders))) {\\n                throwInvalidFulfillmentComponentData()\\n            }\\n\\n            // Read advancedOrders[orderIndex] pointer from its array head.\\n            let orderPtr := mload(\\n                // Calculate head position of advancedOrders[orderIndex].\\n                add(add(advancedOrders, OneWord), mul(orderIndex, OneWord))\\n            )\\n\\n            // Read the pointer to OrderParameters from the AdvancedOrder.\\n            let paramsPtr := mload(orderPtr)\\n\\n            // Load the offer array pointer.\\n            let offerArrPtr := mload(\\n                add(paramsPtr, OrderParameters_offer_head_offset)\\n            )\\n\\n            // Retrieve item index using an offset of the fulfillment pointer.\\n            let itemIndex := mload(\\n                add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\\n            )\\n\\n            // Only continue if the fulfillment is not invalid.\\n            if iszero(lt(itemIndex, mload(offerArrPtr))) {\\n                throwInvalidFulfillmentComponentData()\\n            }\\n\\n            // Retrieve consideration item pointer using the item index.\\n            let offerItemPtr := mload(\\n                add(\\n                    // Get pointer to beginning of receivedItem.\\n                    add(offerArrPtr, OneWord),\\n                    // Calculate offset to pointer for desired order.\\n                    mul(itemIndex, OneWord)\\n                )\\n            )\\n\\n            // Declare a variable for the final aggregated item amount.\\n            let amount := 0\\n\\n            // Create variable to track errors encountered with amount.\\n            let errorBuffer := 0\\n\\n            // Only add offer amount to execution amount on a nonzero numerator.\\n            if mload(add(orderPtr, AdvancedOrder_numerator_offset)) {\\n                // Retrieve amount pointer using consideration item pointer.\\n                let amountPtr := add(offerItemPtr, Common_amount_offset)\\n\\n                // Set the amount.\\n                amount := mload(amountPtr)\\n\\n                // Zero out amount on item to indicate it is credited.\\n                mstore(amountPtr, 0)\\n\\n                // Buffer indicating whether issues were found.\\n                errorBuffer := iszero(amount)\\n            }\\n\\n            // Retrieve the received item pointer.\\n            let receivedItemPtr := mload(execution)\\n\\n            // Set the caller as the recipient on the received item.\\n            mstore(\\n                add(receivedItemPtr, ReceivedItem_recipient_offset),\\n                caller()\\n            )\\n\\n            // Set the item type on the received item.\\n            mstore(receivedItemPtr, mload(offerItemPtr))\\n\\n            // Set the token on the received item.\\n            mstore(\\n                add(receivedItemPtr, Common_token_offset),\\n                mload(add(offerItemPtr, Common_token_offset))\\n            )\\n\\n            // Set the identifier on the received item.\\n            mstore(\\n                add(receivedItemPtr, Common_identifier_offset),\\n                mload(add(offerItemPtr, Common_identifier_offset))\\n            )\\n\\n            // Set the offerer on returned execution using order pointer.\\n            mstore(add(execution, Execution_offerer_offset), mload(paramsPtr))\\n\\n            // Set conduitKey on returned execution via offset of order pointer.\\n            mstore(\\n                add(execution, Execution_conduit_offset),\\n                mload(add(paramsPtr, OrderParameters_conduit_offset))\\n            )\\n\\n            // Calculate the hash of (itemType, token, identifier).\\n            let dataHash := keccak256(\\n                receivedItemPtr,\\n                ReceivedItem_CommonParams_size\\n            )\\n\\n            // Get position one word past last element in head of array.\\n            let endPtr := add(\\n                offerComponents,\\n                mul(mload(offerComponents), OneWord)\\n            )\\n\\n            // Iterate over remaining offer components.\\n            for {} lt(fulfillmentHeadPtr,  endPtr) {} {\\n                // Increment the pointer to the fulfillment head by one word.\\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\\n\\n                // Get the order index using the fulfillment pointer.\\n                orderIndex := mload(mload(fulfillmentHeadPtr))\\n\\n                // Ensure the order index is in range.\\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\\n                  throwInvalidFulfillmentComponentData()\\n                }\\n\\n                // Get pointer to AdvancedOrder element.\\n                orderPtr := mload(\\n                    add(\\n                        add(advancedOrders, OneWord),\\n                        mul(orderIndex, OneWord)\\n                    )\\n                )\\n\\n                // Only continue if numerator is not zero.\\n                if iszero(mload(\\n                    add(orderPtr, AdvancedOrder_numerator_offset)\\n                )) {\\n                  continue\\n                }\\n\\n                // Read the pointer to OrderParameters from the AdvancedOrder.\\n                paramsPtr := mload(orderPtr)\\n\\n                // Load offer array pointer.\\n                offerArrPtr := mload(\\n                    add(\\n                        paramsPtr,\\n                        OrderParameters_offer_head_offset\\n                    )\\n                )\\n\\n                // Get the item index using the fulfillment pointer.\\n                itemIndex := mload(add(mload(fulfillmentHeadPtr), OneWord))\\n\\n                // Throw if itemIndex is out of the range of array.\\n                if iszero(\\n                    lt(itemIndex, mload(offerArrPtr))\\n                ) {\\n                    throwInvalidFulfillmentComponentData()\\n                }\\n\\n                // Retrieve offer item pointer using index.\\n                offerItemPtr := mload(\\n                    add(\\n                        // Get pointer to beginning of receivedItem.\\n                        add(offerArrPtr, OneWord),\\n                        // Use offset to pointer for desired order.\\n                        mul(itemIndex, OneWord)\\n                    )\\n                )\\n\\n                // Retrieve amount pointer using offer item pointer.\\n                let amountPtr := add(\\n                      offerItemPtr,\\n                      Common_amount_offset\\n                )\\n\\n                // Add offer amount to execution amount.\\n                let newAmount := add(amount, mload(amountPtr))\\n\\n                // Update error buffer (1 = zero amount, 2 = overflow).\\n                errorBuffer := or(\\n                  errorBuffer,\\n                  or(\\n                    shl(1, lt(newAmount, amount)),\\n                    iszero(mload(amountPtr))\\n                  )\\n                )\\n\\n                // Update the amount to the new, summed amount.\\n                amount := newAmount\\n\\n                // Zero out amount on original item to indicate it is credited.\\n                mstore(amountPtr, 0)\\n\\n                // Ensure the indicated item matches original item.\\n                if iszero(\\n                    and(\\n                        and(\\n                          // The offerer must match on both items.\\n                          eq(\\n                              mload(paramsPtr),\\n                              mload(\\n                                  add(execution, Execution_offerer_offset)\\n                              )\\n                          ),\\n                          // The conduit key must match on both items.\\n                          eq(\\n                              mload(\\n                                  add(\\n                                      paramsPtr,\\n                                      OrderParameters_conduit_offset\\n                                  )\\n                              ),\\n                              mload(\\n                                  add(\\n                                      execution,\\n                                      Execution_conduit_offset\\n                                  )\\n                              )\\n                          )\\n                        ),\\n                        // The itemType, token, and identifier must match.\\n                        eq(\\n                            dataHash,\\n                            keccak256(\\n                                offerItemPtr,\\n                                ReceivedItem_CommonParams_size\\n                            )\\n                        )\\n                    )\\n                ) {\\n                    // Throw if any of the requirements are not met.\\n                    throwInvalidFulfillmentComponentData()\\n                }\\n            }\\n            // Write final amount to execution.\\n            mstore(add(mload(execution), Common_amount_offset), amount)\\n\\n            // Determine if an error code is contained in the error buffer.\\n            switch errorBuffer\\n            case 1 {\\n                // Store the MissingItemAmount error signature.\\n                mstore(0, MissingItemAmount_error_signature)\\n\\n                // Return, supplying MissingItemAmount signature.\\n                revert(0, MissingItemAmount_error_len)\\n            }\\n            case 2 {\\n                // If the sum overflowed, panic.\\n                throwOverflow()\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to aggregate a group of consideration items\\n     *      using supplied directives on which component items are candidates\\n     *      for aggregation, skipping items on orders that are not available.\\n     *\\n     * @param advancedOrders          The orders to aggregate consideration\\n     *                                items from.\\n     * @param considerationComponents An array of FulfillmentComponent structs\\n     *                                indicating the order index and item index\\n     *                                of each candidate consideration item for\\n     *                                aggregation.\\n     * @param execution       The execution to apply the aggregation to.\\n     */\\n    function _aggregateValidFulfillmentConsiderationItems(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[] memory considerationComponents,\\n        Execution memory execution\\n    ) internal pure {\\n        // Utilize assembly in order to efficiently aggregate the items.\\n        assembly {\\n            // Declare function for reverts on invalid fulfillment data.\\n            function throwInvalidFulfillmentComponentData() {\\n                // Store the InvalidFulfillmentComponentData error signature.\\n                mstore(0, InvalidFulfillmentComponentData_error_signature)\\n\\n                // Return, supplying InvalidFulfillmentComponentData signature.\\n                revert(0, InvalidFulfillmentComponentData_error_len)\\n            }\\n\\n            // Declare function for reverts due to arithmetic overflows.\\n            function throwOverflow() {\\n                // Store the Panic error signature.\\n                mstore(0, Panic_error_signature)\\n\\n                // Store the arithmetic (0x11) panic code as initial argument.\\n                mstore(Panic_error_offset, Panic_arithmetic)\\n\\n                // Return, supplying Panic signature and arithmetic code.\\n                revert(0, Panic_error_length)\\n            }\\n\\n            // Get position in considerationComponents head.\\n            let fulfillmentHeadPtr := add(considerationComponents, OneWord)\\n\\n            // Retrieve the order index using the fulfillment pointer.\\n            let orderIndex := mload(mload(fulfillmentHeadPtr))\\n\\n            // Ensure that the order index is not out of range.\\n            if iszero(lt(orderIndex, mload(advancedOrders))) {\\n                throwInvalidFulfillmentComponentData()\\n            }\\n\\n            // Read advancedOrders[orderIndex] pointer from its array head.\\n            let orderPtr := mload(\\n                // Calculate head position of advancedOrders[orderIndex].\\n                add(add(advancedOrders, OneWord), mul(orderIndex, OneWord))\\n            )\\n\\n            // Load consideration array pointer.\\n            let considerationArrPtr := mload(\\n                add(\\n                    // Read pointer to OrderParameters from the AdvancedOrder.\\n                    mload(orderPtr),\\n                    OrderParameters_consideration_head_offset\\n                )\\n            )\\n\\n            // Retrieve item index using an offset of the fulfillment pointer.\\n            let itemIndex := mload(\\n                add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\\n            )\\n\\n            // Ensure that the order index is not out of range.\\n            if iszero(lt(itemIndex, mload(considerationArrPtr))) {\\n                throwInvalidFulfillmentComponentData()\\n            }\\n\\n            // Retrieve consideration item pointer using the item index.\\n            let considerationItemPtr := mload(\\n                add(\\n                    // Get pointer to beginning of receivedItem.\\n                    add(considerationArrPtr, OneWord),\\n                    // Calculate offset to pointer for desired order.\\n                    mul(itemIndex, OneWord)\\n                )\\n            )\\n\\n            // Declare a variable for the final aggregated item amount.\\n            let amount := 0\\n\\n            // Create variable to track errors encountered with amount.\\n            let errorBuffer := 0\\n\\n            // Only add consideration amount to execution amount if numerator is\\n            // greater than zero.\\n            if mload(add(orderPtr, AdvancedOrder_numerator_offset)) {\\n                // Retrieve amount pointer using consideration item pointer.\\n                let amountPtr := add(considerationItemPtr, Common_amount_offset)\\n\\n                // Set the amount.\\n                amount := mload(amountPtr)\\n\\n                // Set error bit if amount is zero.\\n                errorBuffer := iszero(amount)\\n\\n                // Zero out amount on item to indicate it is credited.\\n                mstore(amountPtr, 0)\\n            }\\n\\n            // Retrieve ReceivedItem pointer from Execution.\\n            let receivedItem := mload(execution)\\n\\n            // Set the item type on the received item.\\n            mstore(receivedItem, mload(considerationItemPtr))\\n\\n            // Set the token on the received item.\\n            mstore(\\n                add(receivedItem, Common_token_offset),\\n                mload(add(considerationItemPtr, Common_token_offset))\\n            )\\n\\n            // Set the identifier on the received item.\\n            mstore(\\n                add(receivedItem, Common_identifier_offset),\\n                mload(add(considerationItemPtr, Common_identifier_offset))\\n            )\\n\\n            // Set the recipient on the received item.\\n            mstore(\\n                add(receivedItem, ReceivedItem_recipient_offset),\\n                mload(\\n                    add(\\n                        considerationItemPtr,\\n                        ConsiderationItem_recipient_offset\\n                    )\\n                )\\n            )\\n\\n            // Calculate the hash of (itemType, token, identifier).\\n            let dataHash := keccak256(\\n                receivedItem,\\n                ReceivedItem_CommonParams_size\\n            )\\n\\n            // Get position one word past last element in head of array.\\n            let endPtr := add(\\n                considerationComponents,\\n                mul(mload(considerationComponents), OneWord)\\n            )\\n\\n            // Iterate over remaining offer components.\\n            for {} lt(fulfillmentHeadPtr,  endPtr) {} {\\n                // Increment position in considerationComponents head.\\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\\n\\n                // Get the order index using the fulfillment pointer.\\n                orderIndex := mload(mload(fulfillmentHeadPtr))\\n\\n                // Ensure the order index is in range.\\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\\n                  throwInvalidFulfillmentComponentData()\\n                }\\n\\n                // Get pointer to AdvancedOrder element.\\n                orderPtr := mload(\\n                    add(\\n                        add(advancedOrders, OneWord),\\n                        mul(orderIndex, OneWord)\\n                    )\\n                )\\n\\n                // Only continue if numerator is not zero.\\n                if iszero(\\n                    mload(add(orderPtr, AdvancedOrder_numerator_offset))\\n                ) {\\n                  continue\\n                }\\n\\n                // Load consideration array pointer from OrderParameters.\\n                considerationArrPtr := mload(\\n                    add(\\n                        // Get pointer to OrderParameters from AdvancedOrder.\\n                        mload(orderPtr),\\n                        OrderParameters_consideration_head_offset\\n                    )\\n                )\\n\\n                // Get the item index using the fulfillment pointer.\\n                itemIndex := mload(add(mload(fulfillmentHeadPtr), OneWord))\\n\\n                // Check if itemIndex is within the range of array.\\n                if iszero(lt(itemIndex, mload(considerationArrPtr))) {\\n                    throwInvalidFulfillmentComponentData()\\n                }\\n\\n                // Retrieve consideration item pointer using index.\\n                considerationItemPtr := mload(\\n                    add(\\n                        // Get pointer to beginning of receivedItem.\\n                        add(considerationArrPtr, OneWord),\\n                        // Use offset to pointer for desired order.\\n                        mul(itemIndex, OneWord)\\n                    )\\n                )\\n\\n                // Retrieve amount pointer using consideration item pointer.\\n                let amountPtr := add(\\n                      considerationItemPtr,\\n                      Common_amount_offset\\n                )\\n\\n                // Add offer amount to execution amount.\\n                let newAmount := add(amount, mload(amountPtr))\\n\\n                // Update error buffer (1 = zero amount, 2 = overflow).\\n                errorBuffer := or(\\n                  errorBuffer,\\n                  or(\\n                    shl(1, lt(newAmount, amount)),\\n                    iszero(mload(amountPtr))\\n                  )\\n                )\\n\\n                // Update the amount to the new, summed amount.\\n                amount := newAmount\\n\\n                // Zero out amount on original item to indicate it is credited.\\n                mstore(amountPtr, 0)\\n\\n                // Ensure the indicated item matches original item.\\n                if iszero(\\n                    and(\\n                        // Item recipients must match.\\n                        eq(\\n                            mload(\\n                                add(\\n                                    considerationItemPtr,\\n                                    ConsiderItem_recipient_offset\\n                                )\\n                            ),\\n                            mload(\\n                                add(\\n                                    receivedItem,\\n                                    ReceivedItem_recipient_offset\\n                                )\\n                            )\\n                        ),\\n                        // The itemType, token, identifier must match.\\n                        eq(\\n                          dataHash,\\n                          keccak256(\\n                            considerationItemPtr,\\n                            ReceivedItem_CommonParams_size\\n                          )\\n                        )\\n                    )\\n                ) {\\n                    // Throw if any of the requirements are not met.\\n                    throwInvalidFulfillmentComponentData()\\n                }\\n            }\\n            // Write final amount to execution.\\n            mstore(add(receivedItem, Common_amount_offset), amount)\\n\\n            // Determine if an error code is contained in the error buffer.\\n            switch errorBuffer\\n            case 1 {\\n                // Store the MissingItemAmount error signature.\\n                mstore(0, MissingItemAmount_error_signature)\\n\\n                // Return, supplying MissingItemAmount signature.\\n                revert(0, MissingItemAmount_error_len)\\n            }\\n            case 2 {\\n                // If the sum overflowed, panic.\\n                throwOverflow()\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/FulfillmentApplicationErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { Side } from \\\"../lib/ConsiderationEnums.sol\\\";\\n\\n/**\\n * @title FulfillmentApplicationErrors\\n * @author 0age\\n * @notice FulfillmentApplicationErrors contains errors related to fulfillment\\n *         application and aggregation.\\n */\\ninterface FulfillmentApplicationErrors {\\n    /**\\n     * @dev Revert with an error when a fulfillment is provided as part of an\\n     *      call to fulfill available orders that does not declare at least one\\n     *      component.\\n     */\\n    error MissingFulfillmentComponentOnAggregation(Side side);\\n\\n    /**\\n     * @dev Revert with an error when a fulfillment is provided that does not\\n     *      declare at least one offer component and at least one consideration\\n     *      component.\\n     */\\n    error OfferAndConsiderationRequiredOnFulfillment();\\n\\n    /**\\n     * @dev Revert with an error when the initial offer item named by a\\n     *      fulfillment component does not match the type, token, identifier,\\n     *      or conduit preference of the initial consideration item.\\n     */\\n    error MismatchedFulfillmentOfferAndConsiderationComponents();\\n\\n    /**\\n     * @dev Revert with an error when an order or item index are out of range\\n     *      or a fulfillment component does not match the type, token,\\n     *      identifier, or conduit preference of the initial consideration item.\\n     */\\n    error InvalidFulfillmentComponentData();\\n}\\n\"\r\n    },\r\n    \"contracts/lib/CriteriaResolution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { ItemType, Side } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    OfferItem,\\n    ConsiderationItem,\\n    OrderParameters,\\n    AdvancedOrder,\\n    CriteriaResolver\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\nimport {\\n    CriteriaResolutionErrors\\n} from \\\"../interfaces/CriteriaResolutionErrors.sol\\\";\\n\\n/**\\n * @title CriteriaResolution\\n * @author 0age\\n * @notice CriteriaResolution contains a collection of pure functions related to\\n *         resolving criteria-based items.\\n */\\ncontract CriteriaResolution is CriteriaResolutionErrors {\\n    /**\\n     * @dev Internal pure function to apply criteria resolvers containing\\n     *      specific token identifiers and associated proofs to order items.\\n     *\\n     * @param advancedOrders     The orders to apply criteria resolvers to.\\n     * @param criteriaResolvers  An array where each element contains a\\n     *                           reference to a specific order as well as that\\n     *                           order's offer or consideration, a token\\n     *                           identifier, and a proof that the supplied token\\n     *                           identifier is contained in the order's merkle\\n     *                           root. Note that a root of zero indicates that\\n     *                           any transferrable token identifier is valid and\\n     *                           that no proof needs to be supplied.\\n     */\\n    function _applyCriteriaResolvers(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] memory criteriaResolvers\\n    ) internal pure {\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Retrieve length of criteria resolvers array and place on stack.\\n            uint256 totalCriteriaResolvers = criteriaResolvers.length;\\n\\n            // Retrieve length of orders array and place on stack.\\n            uint256 totalAdvancedOrders = advancedOrders.length;\\n\\n            // Iterate over each criteria resolver.\\n            for (uint256 i = 0; i < totalCriteriaResolvers; ++i) {\\n                // Retrieve the criteria resolver.\\n                CriteriaResolver memory criteriaResolver = (\\n                    criteriaResolvers[i]\\n                );\\n\\n                // Read the order index from memory and place it on the stack.\\n                uint256 orderIndex = criteriaResolver.orderIndex;\\n\\n                // Ensure that the order index is in range.\\n                if (orderIndex >= totalAdvancedOrders) {\\n                    revert OrderCriteriaResolverOutOfRange();\\n                }\\n\\n                // Skip criteria resolution for order if not fulfilled.\\n                if (advancedOrders[orderIndex].numerator == 0) {\\n                    continue;\\n                }\\n\\n                // Retrieve the parameters for the order.\\n                OrderParameters memory orderParameters = (\\n                    advancedOrders[orderIndex].parameters\\n                );\\n\\n                // Read component index from memory and place it on the stack.\\n                uint256 componentIndex = criteriaResolver.index;\\n\\n                // Declare values for item's type and criteria.\\n                ItemType itemType;\\n                uint256 identifierOrCriteria;\\n\\n                // If the criteria resolver refers to an offer item...\\n                if (criteriaResolver.side == Side.OFFER) {\\n                    // Retrieve the offer.\\n                    OfferItem[] memory offer = orderParameters.offer;\\n\\n                    // Ensure that the component index is in range.\\n                    if (componentIndex >= offer.length) {\\n                        revert OfferCriteriaResolverOutOfRange();\\n                    }\\n\\n                    // Retrieve relevant item using the component index.\\n                    OfferItem memory offerItem = offer[componentIndex];\\n\\n                    // Read item type and criteria from memory & place on stack.\\n                    itemType = offerItem.itemType;\\n                    identifierOrCriteria = offerItem.identifierOrCriteria;\\n\\n                    // Optimistically update item type to remove criteria usage.\\n                    ItemType newItemType;\\n                    assembly {\\n                        newItemType := sub(3, eq(itemType, 4))\\n                    }\\n                    offerItem.itemType = newItemType;\\n\\n                    // Optimistically update identifier w/ supplied identifier.\\n                    offerItem.identifierOrCriteria = criteriaResolver\\n                        .identifier;\\n                } else {\\n                    // Otherwise, the resolver refers to a consideration item.\\n                    ConsiderationItem[] memory consideration = (\\n                        orderParameters.consideration\\n                    );\\n\\n                    // Ensure that the component index is in range.\\n                    if (componentIndex >= consideration.length) {\\n                        revert ConsiderationCriteriaResolverOutOfRange();\\n                    }\\n\\n                    // Retrieve relevant item using order and component index.\\n                    ConsiderationItem memory considerationItem = (\\n                        consideration[componentIndex]\\n                    );\\n\\n                    // Read item type and criteria from memory & place on stack.\\n                    itemType = considerationItem.itemType;\\n                    identifierOrCriteria = (\\n                        considerationItem.identifierOrCriteria\\n                    );\\n\\n                    // Optimistically update item type to remove criteria usage.\\n                    ItemType newItemType;\\n                    assembly {\\n                        newItemType := sub(3, eq(itemType, 4))\\n                    }\\n                    considerationItem.itemType = newItemType;\\n\\n                    // Optimistically update identifier w/ supplied identifier.\\n                    considerationItem.identifierOrCriteria = (\\n                        criteriaResolver.identifier\\n                    );\\n                }\\n\\n                // Ensure the specified item type indicates criteria usage.\\n                if (!_isItemWithCriteria(itemType)) {\\n                    revert CriteriaNotEnabledForItem();\\n                }\\n\\n                // If criteria is not 0 (i.e. a collection-wide offer)...\\n                if (identifierOrCriteria != uint256(0)) {\\n                    // Verify identifier inclusion in criteria root using proof.\\n                    _verifyProof(\\n                        criteriaResolver.identifier,\\n                        identifierOrCriteria,\\n                        criteriaResolver.criteriaProof\\n                    );\\n                }\\n            }\\n\\n            // Iterate over each advanced order.\\n            for (uint256 i = 0; i < totalAdvancedOrders; ++i) {\\n                // Retrieve the advanced order.\\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\\n\\n                // Skip criteria resolution for order if not fulfilled.\\n                if (advancedOrder.numerator == 0) {\\n                    continue;\\n                }\\n\\n                // Retrieve the parameters for the order.\\n                OrderParameters memory orderParameters = (\\n                    advancedOrders[i].parameters\\n                );\\n\\n                // Read consideration length from memory and place on stack.\\n                uint256 totalItems = orderParameters.consideration.length;\\n\\n                // Iterate over each consideration item on the order.\\n                for (uint256 j = 0; j < totalItems; ++j) {\\n                    // Ensure item type no longer indicates criteria usage.\\n                    if (\\n                        _isItemWithCriteria(\\n                            orderParameters.consideration[j].itemType\\n                        )\\n                    ) {\\n                        revert UnresolvedConsiderationCriteria();\\n                    }\\n                }\\n\\n                // Read offer length from memory and place on stack.\\n                totalItems = orderParameters.offer.length;\\n\\n                // Iterate over each offer item on the order.\\n                for (uint256 j = 0; j < totalItems; ++j) {\\n                    // Ensure item type no longer indicates criteria usage.\\n                    if (\\n                        _isItemWithCriteria(orderParameters.offer[j].itemType)\\n                    ) {\\n                        revert UnresolvedOfferCriteria();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to check whether a given item type represents\\n     *      a criteria-based ERC721 or ERC1155 item (e.g. an item that can be\\n     *      resolved to one of a number of different identifiers at the time of\\n     *      order fulfillment).\\n     *\\n     * @param itemType The item type in question.\\n     *\\n     * @return withCriteria A boolean indicating that the item type in question\\n     *                      represents a criteria-based item.\\n     */\\n    function _isItemWithCriteria(ItemType itemType)\\n        internal\\n        pure\\n        returns (bool withCriteria)\\n    {\\n        // ERC721WithCriteria is ItemType 4. ERC1155WithCriteria is ItemType 5.\\n        assembly {\\n            withCriteria := gt(itemType, 3)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to ensure that a given element is contained\\n     *      in a merkle root via a supplied proof.\\n     *\\n     * @param leaf  The element for which to prove inclusion.\\n     * @param root  The merkle root that inclusion will be proved against.\\n     * @param proof The merkle proof.\\n     */\\n    function _verifyProof(\\n        uint256 leaf,\\n        uint256 root,\\n        bytes32[] memory proof\\n    ) internal pure {\\n        bool isValid;\\n\\n        assembly {\\n            // Start the hash off as just the starting leaf.\\n            let computedHash := leaf\\n\\n            // Get memory start location of the first element in proof array.\\n            let data := add(proof, OneWord)\\n\\n            // Iterate over proof elements to compute root hash.\\n            for {\\n                let end := add(data, mul(mload(proof), OneWord))\\n            } lt(data, end) {\\n                data := add(data, OneWord)\\n            } {\\n                // Get the proof element.\\n                let loadedData := mload(data)\\n\\n                // Sort and store proof element and hash.\\n                switch gt(computedHash, loadedData)\\n                case 0 {\\n                    mstore(0, computedHash) // Place existing hash first.\\n                    mstore(0x20, loadedData) // Place new hash next.\\n                }\\n                default {\\n                    mstore(0, loadedData) // Place new hash first.\\n                    mstore(0x20, computedHash) // Place existing hash next.\\n                }\\n\\n                // Derive the updated hash.\\n                computedHash := keccak256(0, TwoWords)\\n            }\\n\\n            // Compare the final hash to the supplied root.\\n            isValid := eq(computedHash, root)\\n        }\\n\\n        // Revert if computed hash does not equal supplied root.\\n        if (!isValid) {\\n            revert InvalidProof();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CriteriaResolutionErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/**\\n * @title CriteriaResolutionErrors\\n * @author 0age\\n * @notice CriteriaResolutionErrors contains all errors related to criteria\\n *         resolution.\\n */\\ninterface CriteriaResolutionErrors {\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that refers\\n     *      to an order that has not been supplied.\\n     */\\n    error OrderCriteriaResolverOutOfRange();\\n\\n    /**\\n     * @dev Revert with an error if an offer item still has unresolved criteria\\n     *      after applying all criteria resolvers.\\n     */\\n    error UnresolvedOfferCriteria();\\n\\n    /**\\n     * @dev Revert with an error if a consideration item still has unresolved\\n     *      criteria after applying all criteria resolvers.\\n     */\\n    error UnresolvedConsiderationCriteria();\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that refers\\n     *      to an order with an offer item that has not been supplied.\\n     */\\n    error OfferCriteriaResolverOutOfRange();\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that refers\\n     *      to an order with a consideration item that has not been supplied.\\n     */\\n    error ConsiderationCriteriaResolverOutOfRange();\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that refers\\n     *      to an order with an item that does not expect a criteria to be\\n     *      resolved.\\n     */\\n    error CriteriaNotEnabledForItem();\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that\\n     *      contains an invalid proof with respect to the given item and\\n     *      chosen identifier.\\n     */\\n    error InvalidProof();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ZoneInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport {\\n    AdvancedOrder,\\n    CriteriaResolver\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\ninterface ZoneInterface {\\n    // Called by Consideration whenever extraData is not provided by the caller.\\n    function isValidOrder(\\n        bytes32 orderHash,\\n        address caller,\\n        address offerer,\\n        bytes32 zoneHash\\n    ) external view returns (bytes4 validOrderMagicValue);\\n\\n    // Called by Consideration whenever any extraData is provided by the caller.\\n    function isValidOrderIncludingExtraData(\\n        bytes32 orderHash,\\n        address caller,\\n        AdvancedOrder calldata order,\\n        bytes32[] calldata priorOrderHashes,\\n        CriteriaResolver[] calldata criteriaResolvers\\n    ) external view returns (bytes4 validOrderMagicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ZoneInteraction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { ZoneInterface } from \\\"../interfaces/ZoneInterface.sol\\\";\\n\\nimport { OrderType } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport { AdvancedOrder, CriteriaResolver } from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\nimport {\\n    ZoneInteractionErrors\\n} from \\\"../interfaces/ZoneInteractionErrors.sol\\\";\\n\\nimport { LowLevelHelpers } from \\\"./LowLevelHelpers.sol\\\";\\n\\n/**\\n * @title ZoneInteraction\\n * @author 0age\\n * @notice ZoneInteraction contains logic related to interacting with zones.\\n */\\ncontract ZoneInteraction is ZoneInteractionErrors, LowLevelHelpers {\\n    /**\\n     * @dev Internal view function to determine if an order has a restricted\\n     *      order type and, if so, to ensure that either the offerer or the zone\\n     *      are the fulfiller or that a staticcall to `isValidOrder` on the zone\\n     *      returns a magic value indicating that the order is currently valid.\\n     *\\n     * @param orderHash The hash of the order.\\n     * @param zoneHash  The hash to provide upon calling the zone.\\n     * @param orderType The type of the order.\\n     * @param offerer   The offerer in question.\\n     * @param zone      The zone in question.\\n     */\\n    function _assertRestrictedBasicOrderValidity(\\n        bytes32 orderHash,\\n        bytes32 zoneHash,\\n        OrderType orderType,\\n        address offerer,\\n        address zone\\n    ) internal view {\\n        // Order type 2-3 require zone or offerer be caller or zone to approve.\\n        if (\\n            uint256(orderType) > 1 &&\\n            msg.sender != zone &&\\n            msg.sender != offerer\\n        ) {\\n            // Perform minimal staticcall to the zone.\\n            _callIsValidOrder(zone, orderHash, offerer, zoneHash);\\n        }\\n    }\\n\\n    function _callIsValidOrder(\\n        address zone,\\n        bytes32 orderHash,\\n        address offerer,\\n        bytes32 zoneHash\\n    ) internal view {\\n        // Perform minimal staticcall to the zone.\\n        bool success = _staticcall(\\n            zone,\\n            abi.encodeWithSelector(\\n                ZoneInterface.isValidOrder.selector,\\n                orderHash,\\n                msg.sender,\\n                offerer,\\n                zoneHash\\n            )\\n        );\\n\\n        // Ensure call was successful and returned the correct magic value.\\n        _assertIsValidOrderStaticcallSuccess(success, orderHash);\\n    }\\n\\n    /**\\n     * @dev Internal view function to determine whether an order is a restricted\\n     *      order and, if so, to ensure that it was either submitted by the\\n     *      offerer or the zone for the order, or that the zone returns the\\n     *      expected magic value upon performing a staticcall to `isValidOrder`\\n     *      or `isValidOrderIncludingExtraData` depending on whether the order\\n     *      fulfillment specifies extra data or criteria resolvers.\\n     *\\n     * @param advancedOrder     The advanced order in question.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific offer or consideration, a token\\n     *                          identifier, and a proof that the supplied token\\n     *                          identifier is contained in the order's merkle\\n     *                          root. Note that a criteria of zero indicates\\n     *                          that any (transferrable) token identifier is\\n     *                          valid and that no proof needs to be supplied.\\n     * @param priorOrderHashes  The order hashes of each order supplied prior to\\n     *                          the current order as part of a \\\"match\\\" variety\\n     *                          of order fulfillment (e.g. this array will be\\n     *                          empty for single or \\\"fulfill available\\\").\\n     * @param orderHash         The hash of the order.\\n     * @param zoneHash          The hash to provide upon calling the zone.\\n     * @param orderType         The type of the order.\\n     * @param offerer           The offerer in question.\\n     * @param zone              The zone in question.\\n     */\\n    function _assertRestrictedAdvancedOrderValidity(\\n        AdvancedOrder memory advancedOrder,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        bytes32[] memory priorOrderHashes,\\n        bytes32 orderHash,\\n        bytes32 zoneHash,\\n        OrderType orderType,\\n        address offerer,\\n        address zone\\n    ) internal view {\\n        // Order type 2-3 require zone or offerer be caller or zone to approve.\\n        if (\\n            uint256(orderType) > 1 &&\\n            msg.sender != zone &&\\n            msg.sender != offerer\\n        ) {\\n            // If no extraData or criteria resolvers are supplied...\\n            if (\\n                advancedOrder.extraData.length == 0 &&\\n                criteriaResolvers.length == 0\\n            ) {\\n                // Perform minimal staticcall to the zone.\\n                _callIsValidOrder(zone, orderHash, offerer, zoneHash);\\n            } else {\\n                // Otherwise, extra data or criteria resolvers were supplied; in\\n                // that event, perform a more verbose staticcall to the zone.\\n                bool success = _staticcall(\\n                    zone,\\n                    abi.encodeWithSelector(\\n                        ZoneInterface.isValidOrderIncludingExtraData.selector,\\n                        orderHash,\\n                        msg.sender,\\n                        advancedOrder,\\n                        priorOrderHashes,\\n                        criteriaResolvers\\n                    )\\n                );\\n\\n                // Ensure call was successful and returned correct magic value.\\n                _assertIsValidOrderStaticcallSuccess(success, orderHash);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to ensure that a staticcall to `isValidOrder`\\n     *      or `isValidOrderIncludingExtraData` as part of validating a\\n     *      restricted order that was not submitted by the named offerer or zone\\n     *      was successful and returned the required magic value.\\n     *\\n     * @param success   A boolean indicating the status of the staticcall.\\n     * @param orderHash The order hash of the order in question.\\n     */\\n    function _assertIsValidOrderStaticcallSuccess(\\n        bool success,\\n        bytes32 orderHash\\n    ) internal view {\\n        // If the call failed...\\n        if (!success) {\\n            // Revert and pass reason along if one was returned.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // Otherwise, revert with a generic error message.\\n            revert InvalidRestrictedOrder(orderHash);\\n        }\\n\\n        // Ensure result was extracted and matches isValidOrder magic value.\\n        if (_doesNotMatchMagic(ZoneInterface.isValidOrder.selector)) {\\n            revert InvalidRestrictedOrder(orderHash);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ZoneInteractionErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/**\\n * @title ZoneInteractionErrors\\n * @author 0age\\n * @notice ZoneInteractionErrors contains errors related to zone interaction.\\n */\\ninterface ZoneInteractionErrors {\\n    /**\\n     * @dev Revert with an error when attempting to fill an order that specifies\\n     *      a restricted submitter as its order type when not submitted by\\n     *      either the offerrer or the order's zone or approved as valid by the\\n     *      zone in question via a staticcall to `isValidOrder`.\\n     *\\n     * @param orderHash The order hash for the invalid restricted order.\\n     */\\n    error InvalidRestrictedOrder(bytes32 orderHash);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OrderValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { OrderType } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    OrderParameters,\\n    Order,\\n    AdvancedOrder,\\n    OrderComponents,\\n    OrderStatus,\\n    CriteriaResolver\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { Executor } from \\\"./Executor.sol\\\";\\n\\nimport { ZoneInteraction } from \\\"./ZoneInteraction.sol\\\";\\n\\n/**\\n * @title OrderValidator\\n * @author 0age\\n * @notice OrderValidator contains functionality related to validating orders\\n *         and updating their status.\\n */\\ncontract OrderValidator is Executor, ZoneInteraction {\\n    // Track status of each order (validated, cancelled, and fraction filled).\\n    mapping(bytes32 => OrderStatus) private _orderStatus;\\n\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) Executor(conduitController) {}\\n\\n    /**\\n     * @dev Internal function to verify and update the status of a basic order.\\n     *\\n     * @param orderHash The hash of the order.\\n     * @param offerer   The offerer of the order.\\n     * @param signature A signature from the offerer indicating that the order\\n     *                  has been approved.\\n     */\\n    function _validateBasicOrderAndUpdateStatus(\\n        bytes32 orderHash,\\n        address offerer,\\n        bytes memory signature\\n    ) internal {\\n        // Retrieve the order status for the given order hash.\\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\\n\\n        // Ensure order is fillable and is not cancelled.\\n        _verifyOrderStatus(\\n            orderHash,\\n            orderStatus,\\n            true, // Only allow unused orders when fulfilling basic orders.\\n            true // Signifies to revert if the order is invalid.\\n        );\\n\\n        // If the order is not already validated, verify the supplied signature.\\n        if (!orderStatus.isValidated) {\\n            _verifySignature(offerer, orderHash, signature);\\n        }\\n\\n        // Update order status as fully filled, packing struct values.\\n        _orderStatus[orderHash].isValidated = true;\\n        _orderStatus[orderHash].isCancelled = false;\\n        _orderStatus[orderHash].numerator = 1;\\n        _orderStatus[orderHash].denominator = 1;\\n    }\\n\\n    /**\\n     * @dev Internal function to validate an order, determine what portion to\\n     *      fill, and update its status. The desired fill amount is supplied as\\n     *      a fraction, as is the returned amount to fill.\\n     *\\n     * @param advancedOrder     The order to fulfill as well as the fraction to\\n     *                          fill. Note that all offer and consideration\\n     *                          amounts must divide with no remainder in order\\n     *                          for a partial fill to be valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific offer or consideration, a token\\n     *                          identifier, and a proof that the supplied token\\n     *                          identifier is contained in the order's merkle\\n     *                          root. Note that a criteria of zero indicates\\n     *                          that any (transferrable) token identifier is\\n     *                          valid and that no proof needs to be supplied.\\n     * @param revertOnInvalid   A boolean indicating whether to revert if the\\n     *                          order is invalid due to the time or status.\\n     * @param priorOrderHashes  The order hashes of each order supplied prior to\\n     *                          the current order as part of a \\\"match\\\" variety\\n     *                          of order fulfillment (e.g. this array will be\\n     *                          empty for single or \\\"fulfill available\\\").\\n     *\\n     * @return orderHash      The order hash.\\n     * @return newNumerator   A value indicating the portion of the order that\\n     *                        will be filled.\\n     * @return newDenominator A value indicating the total size of the order.\\n     */\\n    function _validateOrderAndUpdateStatus(\\n        AdvancedOrder memory advancedOrder,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        bool revertOnInvalid,\\n        bytes32[] memory priorOrderHashes\\n    )\\n        internal\\n        returns (\\n            bytes32 orderHash,\\n            uint256 newNumerator,\\n            uint256 newDenominator\\n        )\\n    {\\n        // Retrieve the parameters for the order.\\n        OrderParameters memory orderParameters = advancedOrder.parameters;\\n\\n        // Ensure current timestamp falls between order start time and end time.\\n        if (\\n            !_verifyTime(\\n                orderParameters.startTime,\\n                orderParameters.endTime,\\n                revertOnInvalid\\n            )\\n        ) {\\n            // Assuming an invalid time and no revert, return zeroed out values.\\n            return (bytes32(0), 0, 0);\\n        }\\n\\n        // Read numerator and denominator from memory and place on the stack.\\n        uint256 numerator = uint256(advancedOrder.numerator);\\n        uint256 denominator = uint256(advancedOrder.denominator);\\n\\n        // Ensure that the supplied numerator and denominator are valid.\\n        if (numerator > denominator || numerator == 0) {\\n            revert BadFraction();\\n        }\\n\\n        // If attempting partial fill (n < d) check order type & ensure support.\\n        if (\\n            numerator < denominator &&\\n            _doesNotSupportPartialFills(orderParameters.orderType)\\n        ) {\\n            // Revert if partial fill was attempted on an unsupported order.\\n            revert PartialFillsNotEnabledForOrder();\\n        }\\n\\n        // Retrieve current nonce and use it w/ parameters to derive order hash.\\n        orderHash = _assertConsiderationLengthAndGetNoncedOrderHash(\\n            orderParameters\\n        );\\n\\n        // Ensure restricted orders have a valid submitter or pass a zone check.\\n        _assertRestrictedAdvancedOrderValidity(\\n            advancedOrder,\\n            criteriaResolvers,\\n            priorOrderHashes,\\n            orderHash,\\n            orderParameters.zoneHash,\\n            orderParameters.orderType,\\n            orderParameters.offerer,\\n            orderParameters.zone\\n        );\\n\\n        // Retrieve the order status using the derived order hash.\\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\\n\\n        // Ensure order is fillable and is not cancelled.\\n        if (\\n            !_verifyOrderStatus(\\n                orderHash,\\n                orderStatus,\\n                false, // Allow partially used orders to be filled.\\n                revertOnInvalid\\n            )\\n        ) {\\n            // Assuming an invalid order status and no revert, return zero fill.\\n            return (orderHash, 0, 0);\\n        }\\n\\n        // If the order is not already validated, verify the supplied signature.\\n        if (!orderStatus.isValidated) {\\n            _verifySignature(\\n                orderParameters.offerer,\\n                orderHash,\\n                advancedOrder.signature\\n            );\\n        }\\n\\n        // Read filled amount as numerator and denominator and put on the stack.\\n        uint256 filledNumerator = orderStatus.numerator;\\n        uint256 filledDenominator = orderStatus.denominator;\\n\\n        // If order currently has a non-zero denominator it is partially filled.\\n        if (filledDenominator != 0) {\\n            // If denominator of 1 supplied, fill all remaining amount on order.\\n            if (denominator == 1) {\\n                // Scale numerator & denominator to match current denominator.\\n                numerator = filledDenominator;\\n                denominator = filledDenominator;\\n            }\\n            // Otherwise, if supplied denominator differs from current one...\\n            else if (filledDenominator != denominator) {\\n                // scale current numerator by the supplied denominator, then...\\n                filledNumerator *= denominator;\\n\\n                // the supplied numerator & denominator by current denominator.\\n                numerator *= filledDenominator;\\n                denominator *= filledDenominator;\\n            }\\n\\n            // Once adjusted, if current+supplied numerator exceeds denominator:\\n            if (filledNumerator + numerator > denominator) {\\n                // Skip underflow check: denominator >= orderStatus.numerator\\n                unchecked {\\n                    // Reduce current numerator so it + supplied = denominator.\\n                    numerator = denominator - filledNumerator;\\n                }\\n            }\\n\\n            // Skip overflow check: checked above unless numerator is reduced.\\n            unchecked {\\n                // Update order status and fill amount, packing struct values.\\n                _orderStatus[orderHash].isValidated = true;\\n                _orderStatus[orderHash].isCancelled = false;\\n                _orderStatus[orderHash].numerator = uint120(\\n                    filledNumerator + numerator\\n                );\\n                _orderStatus[orderHash].denominator = uint120(denominator);\\n            }\\n        } else {\\n            // Update order status and fill amount, packing struct values.\\n            _orderStatus[orderHash].isValidated = true;\\n            _orderStatus[orderHash].isCancelled = false;\\n            _orderStatus[orderHash].numerator = uint120(numerator);\\n            _orderStatus[orderHash].denominator = uint120(denominator);\\n        }\\n\\n        // Return order hash, a modified numerator, and a modified denominator.\\n        return (orderHash, numerator, denominator);\\n    }\\n\\n    /**\\n     * @dev Internal function to cancel an arbitrary number of orders. Note that\\n     *      only the offerer or the zone of a given order may cancel it. Callers\\n     *      should ensure that the intended order was cancelled by calling\\n     *      `getOrderStatus` and confirming that `isCancelled` returns `true`.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders were\\n     *                   successfully cancelled.\\n     */\\n    function _cancel(OrderComponents[] calldata orders)\\n        internal\\n        returns (bool cancelled)\\n    {\\n        // Ensure that the reentrancy guard is not currently set.\\n        _assertNonReentrant();\\n\\n        address offerer;\\n        address zone;\\n\\n        // Skip overflow check as for loop is indexed starting at zero.\\n        unchecked {\\n            // Read length of the orders array from memory and place on stack.\\n            uint256 totalOrders = orders.length;\\n\\n            // Iterate over each order.\\n            for (uint256 i = 0; i < totalOrders; ) {\\n                // Retrieve the order.\\n                OrderComponents calldata order = orders[i];\\n\\n                offerer = order.offerer;\\n                zone = order.zone;\\n\\n                // Ensure caller is either offerer or zone of the order.\\n                if (msg.sender != offerer && msg.sender != zone) {\\n                    revert InvalidCanceller();\\n                }\\n\\n                // Derive order hash using the order parameters and the nonce.\\n                bytes32 orderHash = _deriveOrderHash(\\n                    OrderParameters(\\n                        offerer,\\n                        zone,\\n                        order.offer,\\n                        order.consideration,\\n                        order.orderType,\\n                        order.startTime,\\n                        order.endTime,\\n                        order.zoneHash,\\n                        order.salt,\\n                        order.conduitKey,\\n                        order.consideration.length\\n                    ),\\n                    order.nonce\\n                );\\n\\n                // Update the order status as not valid and cancelled.\\n                _orderStatus[orderHash].isValidated = false;\\n                _orderStatus[orderHash].isCancelled = true;\\n\\n                // Emit an event signifying that the order has been cancelled.\\n                emit OrderCancelled(orderHash, offerer, zone);\\n\\n                // Increment counter inside body of loop for gas efficiency.\\n                ++i;\\n            }\\n        }\\n\\n        // Return a boolean indicating that orders were successfully cancelled.\\n        cancelled = true;\\n    }\\n\\n    /**\\n     * @dev Internal function to validate an arbitrary number of orders, thereby\\n     *      registering their signatures as valid and allowing the fulfiller to\\n     *      skip signature verification on fulfillment. Note that validated\\n     *      orders may still be unfulfillable due to invalid item amounts or\\n     *      other factors; callers should determine whether validated orders are\\n     *      fulfillable by simulating the fulfillment call prior to execution.\\n     *      Also note that anyone can validate a signed order, but only the\\n     *      offerer can validate an order without supplying a signature.\\n     *\\n     * @param orders The orders to validate.\\n     *\\n     * @return validated A boolean indicating whether the supplied orders were\\n     *                   successfully validated.\\n     */\\n    function _validate(Order[] calldata orders)\\n        internal\\n        returns (bool validated)\\n    {\\n        // Ensure that the reentrancy guard is not currently set.\\n        _assertNonReentrant();\\n\\n        // Declare variables outside of the loop.\\n        bytes32 orderHash;\\n        address offerer;\\n\\n        // Skip overflow check as for loop is indexed starting at zero.\\n        unchecked {\\n            // Read length of the orders array from memory and place on stack.\\n            uint256 totalOrders = orders.length;\\n\\n            // Iterate over each order.\\n            for (uint256 i = 0; i < totalOrders; ) {\\n                // Retrieve the order.\\n                Order calldata order = orders[i];\\n\\n                // Retrieve the order parameters.\\n                OrderParameters calldata orderParameters = order.parameters;\\n\\n                // Move offerer from memory to the stack.\\n                offerer = orderParameters.offerer;\\n\\n                // Get current nonce and use it w/ params to derive order hash.\\n                orderHash = _assertConsiderationLengthAndGetNoncedOrderHash(\\n                    orderParameters\\n                );\\n\\n                // Retrieve the order status using the derived order hash.\\n                OrderStatus memory orderStatus = _orderStatus[orderHash];\\n\\n                // Ensure order is fillable and retrieve the filled amount.\\n                _verifyOrderStatus(\\n                    orderHash,\\n                    orderStatus,\\n                    false, // Signifies that partially filled orders are valid.\\n                    true // Signifies to revert if the order is invalid.\\n                );\\n\\n                // If the order has not already been validated...\\n                if (!orderStatus.isValidated) {\\n                    // Verify the supplied signature.\\n                    _verifySignature(offerer, orderHash, order.signature);\\n\\n                    // Update order status to mark the order as valid.\\n                    _orderStatus[orderHash].isValidated = true;\\n\\n                    // Emit an event signifying the order has been validated.\\n                    emit OrderValidated(\\n                        orderHash,\\n                        offerer,\\n                        orderParameters.zone\\n                    );\\n                }\\n\\n                // Increment counter inside body of the loop for gas efficiency.\\n                ++i;\\n            }\\n        }\\n\\n        // Return a boolean indicating that orders were successfully validated.\\n        validated = true;\\n    }\\n\\n    /**\\n     * @dev Internal view function to retrieve the status of a given order by\\n     *      hash, including whether the order has been cancelled or validated\\n     *      and the fraction of the order that has been filled.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function _getOrderStatus(bytes32 orderHash)\\n        internal\\n        view\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        )\\n    {\\n        // Retrieve the order status using the order hash.\\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\\n\\n        // Return the fields on the order status.\\n        return (\\n            orderStatus.isValidated,\\n            orderStatus.isCancelled,\\n            orderStatus.numerator,\\n            orderStatus.denominator\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal pure function to check whether a given order type indicates\\n     *      that partial fills are not supported (e.g. only \\\"full fills\\\" are\\n     *      allowed for the order in question).\\n     *\\n     * @param orderType The order type in question.\\n     *\\n     * @return isFullOrder A boolean indicating whether the order type only\\n     *                     supports full fills.\\n     */\\n    function _doesNotSupportPartialFills(OrderType orderType)\\n        internal\\n        pure\\n        returns (bool isFullOrder)\\n    {\\n        // The \\\"full\\\" order types are even, while \\\"partial\\\" order types are odd.\\n        // Bitwise and by 1 is equivalent to modulo by 2, but 2 gas cheaper.\\n        assembly {\\n            // Equivalent to `uint256(orderType) & 1 == 0`.\\n            isFullOrder := iszero(and(orderType, 1))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/BasicOrderFulfiller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport {\\n    OrderType,\\n    ItemType,\\n    BasicOrderRouteType\\n} from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    AdditionalRecipient,\\n    BasicOrderParameters,\\n    OfferItem,\\n    ConsiderationItem,\\n    SpentItem,\\n    ReceivedItem\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { OrderValidator } from \\\"./OrderValidator.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title BasicOrderFulfiller\\n * @author 0age\\n * @notice BasicOrderFulfiller contains functionality for fulfilling \\\"basic\\\"\\n *         orders with minimal overhead. See documentation for details on what\\n *         qualifies as a basic order.\\n */\\ncontract BasicOrderFulfiller is OrderValidator {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) OrderValidator(conduitController) {}\\n\\n    /**\\n     * @dev Internal function to fulfill an order offering an ERC20, ERC721, or\\n     *      ERC1155 item by supplying Ether (or other native tokens), ERC20\\n     *      tokens, an ERC721 item, or an ERC1155 item as consideration. Six\\n     *      permutations are supported: Native token to ERC721, Native token to\\n     *      ERC1155, ERC20 to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and\\n     *      ERC1155 to ERC20 (with native tokens supplied as msg.value). For an\\n     *      order to be eligible for fulfillment via this method, it must\\n     *      contain a single offer item (though that item may have a greater\\n     *      amount if the item is not an ERC721). An arbitrary number of\\n     *      \\\"additional recipients\\\" may also be supplied which will each receive\\n     *      native tokens or ERC20 items from the fulfiller as consideration.\\n     *      Refer to the documentation for a more comprehensive summary of how\\n     *      to utilize this method and what orders are compatible with it.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer and the fulfiller must first approve\\n     *                   this contract (or their chosen conduit if indicated)\\n     *                   before any tokens can be transferred. Also note that\\n     *                   contract recipients of ERC1155 consideration items must\\n     *                   implement `onERC1155Received` in order to receive those\\n     *                   items.\\n     *\\n     * @return A boolean indicating whether the order has been fulfilled.\\n     */\\n    function _validateAndFulfillBasicOrder(\\n        BasicOrderParameters calldata parameters\\n    ) internal returns (bool) {\\n        // Declare enums for order type & route to extract from basicOrderType.\\n        BasicOrderRouteType route;\\n        OrderType orderType;\\n\\n        // Declare additional recipient item type to derive from the route type.\\n        ItemType additionalRecipientsItemType;\\n\\n        // Utilize assembly to extract the order type and the basic order route.\\n        assembly {\\n            // Mask all but 2 least-significant bits to derive the order type.\\n            orderType := and(calldataload(BasicOrder_basicOrderType_cdPtr), 3)\\n\\n            // Divide basicOrderType by four to derive the route.\\n            route := div(calldataload(BasicOrder_basicOrderType_cdPtr), 4)\\n\\n            // If route > 1 additionalRecipient items are ERC20 (1) else Eth (0)\\n            additionalRecipientsItemType := gt(route, 1)\\n        }\\n\\n        {\\n            // Declare temporary variable for enforcing payable status.\\n            bool correctPayableStatus;\\n\\n            // Utilize assembly to compare the route to the callvalue.\\n            assembly {\\n                // route 0 and 1 are payable, otherwise route is not payable.\\n                correctPayableStatus := eq(\\n                    additionalRecipientsItemType,\\n                    iszero(callvalue())\\n                )\\n            }\\n\\n            // Revert if msg.value has not been supplied as part of payable\\n            // routes or has been supplied as part of non-payable routes.\\n            if (!correctPayableStatus) {\\n                revert InvalidMsgValue(msg.value);\\n            }\\n        }\\n\\n        // Declare more arguments that will be derived from route and calldata.\\n        address additionalRecipientsToken;\\n        ItemType receivedItemType;\\n        ItemType offeredItemType;\\n\\n        // Utilize assembly to retrieve function arguments and cast types.\\n        assembly {\\n            // Determine if offered item type == additional recipient item type.\\n            let offerTypeIsAdditionalRecipientsType := gt(route, 3)\\n\\n            // If route > 3 additionalRecipientsToken is at 0xc4 else 0x24.\\n            additionalRecipientsToken := calldataload(\\n                add(\\n                    BasicOrder_considerationToken_cdPtr,\\n                    mul(offerTypeIsAdditionalRecipientsType, FiveWords)\\n                )\\n            )\\n\\n            // If route > 2, receivedItemType is route - 2. If route is 2, then\\n            // receivedItemType is ERC20 (1). Otherwise, it is Eth (0).\\n            receivedItemType := add(\\n                mul(sub(route, 2), gt(route, 2)),\\n                eq(route, 2)\\n            )\\n\\n            // If route > 3, offeredItemType is ERC20 (1). If route is 2 or 3,\\n            // offeredItemType = route. If route is 0 or 1, it is route + 2.\\n            offeredItemType := sub(\\n                add(route, mul(iszero(additionalRecipientsItemType), 2)),\\n                mul(\\n                    offerTypeIsAdditionalRecipientsType,\\n                    add(receivedItemType, 1)\\n                )\\n            )\\n        }\\n\\n        // Derive & validate order using parameters and update order status.\\n        _prepareBasicFulfillmentFromCalldata(\\n            parameters,\\n            orderType,\\n            receivedItemType,\\n            additionalRecipientsItemType,\\n            additionalRecipientsToken,\\n            offeredItemType\\n        );\\n\\n        // Read offerer from calldata and place on the stack.\\n        address payable offerer = parameters.offerer;\\n\\n        // Declare conduitKey argument used by transfer functions.\\n        bytes32 conduitKey;\\n\\n        // Utilize assembly to derive conduit (if relevant) based on route.\\n        assembly {\\n            // use offerer conduit for routes 0-3, fulfiller conduit otherwise.\\n            conduitKey := calldataload(\\n                add(BasicOrder_offererConduit_cdPtr, mul(gt(route, 3), OneWord))\\n            )\\n        }\\n\\n        // Transfer tokens based on the route.\\n        if (additionalRecipientsItemType == ItemType.NATIVE) {\\n            _transferIndividual721Or1155Item(\\n                offeredItemType,\\n                parameters.offerToken,\\n                offerer,\\n                msg.sender,\\n                parameters.offerIdentifier,\\n                parameters.offerAmount,\\n                conduitKey\\n            );\\n\\n            // Transfer native to recipients, return excess to caller & wrap up.\\n            _transferEthAndFinalize(\\n                parameters.considerationAmount,\\n                offerer,\\n                parameters.additionalRecipients\\n            );\\n        } else {\\n            // Initialize an accumulator array. From this point forward, no new\\n            // memory regions can be safely allocated until the accumulator is\\n            // no longer being utilized, as the accumulator operates in an\\n            // open-ended fashion from this memory pointer; existing memory may\\n            // still be accessed and modified, however.\\n            bytes memory accumulator = new bytes(AccumulatorDisarmed);\\n\\n            if (route == BasicOrderRouteType.ERC20_TO_ERC721) {\\n                // Transfer ERC721 to caller using offerer's conduit preference.\\n                _transferERC721(\\n                    parameters.offerToken,\\n                    offerer,\\n                    msg.sender,\\n                    parameters.offerIdentifier,\\n                    parameters.offerAmount,\\n                    conduitKey,\\n                    accumulator\\n                );\\n\\n                // Transfer ERC20 tokens to all recipients and wrap up.\\n                _transferERC20AndFinalize(\\n                    msg.sender,\\n                    offerer,\\n                    parameters.considerationToken,\\n                    parameters.considerationAmount,\\n                    parameters.additionalRecipients,\\n                    false, // Send full amount indicated by consideration items.\\n                    accumulator\\n                );\\n            } else if (route == BasicOrderRouteType.ERC20_TO_ERC1155) {\\n                // Transfer ERC1155 to caller with offerer's conduit preference.\\n                _transferERC1155(\\n                    parameters.offerToken,\\n                    offerer,\\n                    msg.sender,\\n                    parameters.offerIdentifier,\\n                    parameters.offerAmount,\\n                    conduitKey,\\n                    accumulator\\n                );\\n\\n                // Transfer ERC20 tokens to all recipients and wrap up.\\n                _transferERC20AndFinalize(\\n                    msg.sender,\\n                    offerer,\\n                    parameters.considerationToken,\\n                    parameters.considerationAmount,\\n                    parameters.additionalRecipients,\\n                    false, // Send full amount indicated by consideration items.\\n                    accumulator\\n                );\\n            } else if (route == BasicOrderRouteType.ERC721_TO_ERC20) {\\n                // Transfer ERC721 to offerer using caller's conduit preference.\\n                _transferERC721(\\n                    parameters.considerationToken,\\n                    msg.sender,\\n                    offerer,\\n                    parameters.considerationIdentifier,\\n                    parameters.considerationAmount,\\n                    conduitKey,\\n                    accumulator\\n                );\\n\\n                // Transfer ERC20 tokens to all recipients and wrap up.\\n                _transferERC20AndFinalize(\\n                    offerer,\\n                    msg.sender,\\n                    parameters.offerToken,\\n                    parameters.offerAmount,\\n                    parameters.additionalRecipients,\\n                    true, // Reduce fulfiller amount sent by additional amounts.\\n                    accumulator\\n                );\\n            } else {\\n                // route == BasicOrderRouteType.ERC1155_TO_ERC20\\n\\n                // Transfer ERC1155 to offerer with caller's conduit preference.\\n                _transferERC1155(\\n                    parameters.considerationToken,\\n                    msg.sender,\\n                    offerer,\\n                    parameters.considerationIdentifier,\\n                    parameters.considerationAmount,\\n                    conduitKey,\\n                    accumulator\\n                );\\n\\n                // Transfer ERC20 tokens to all recipients and wrap up.\\n                _transferERC20AndFinalize(\\n                    offerer,\\n                    msg.sender,\\n                    parameters.offerToken,\\n                    parameters.offerAmount,\\n                    parameters.additionalRecipients,\\n                    true, // Reduce fulfiller amount sent by additional amounts.\\n                    accumulator\\n                );\\n            }\\n\\n            // Trigger any remaining accumulated transfers via call to conduit.\\n            _triggerIfArmed(accumulator);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function to prepare fulfillment of a basic order with\\n     *      manual calldata and memory access. This calculates the order hash,\\n     *      emits an OrderFulfilled event, and asserts basic order validity.\\n     *      Note that calldata offsets must be validated as this function\\n     *      accesses constant calldata pointers for dynamic types that match\\n     *      default ABI encoding, but valid ABI encoding can use arbitrary\\n     *      offsets. Checking that the offsets were produced by default encoding\\n     *      will ensure that other functions using Solidity's calldata accessors\\n     *      (which calculate pointers from the stored offsets) are reading the\\n     *      same data as the order hash is derived from. Also note that This\\n     *      function accesses memory directly. It does not clear the expanded\\n     *      memory regions used, nor does it update the free memory pointer, so\\n     *      other direct memory access must not assume that unused memory is\\n     *      empty.\\n     *\\n     * @param parameters                   The parameters of the basic order.\\n     * @param orderType                    The order type.\\n     * @param receivedItemType             The item type of the initial\\n     *                                     consideration item on the order.\\n     * @param additionalRecipientsItemType The item type of any additional\\n     *                                     consideration item on the order.\\n     * @param additionalRecipientsToken    The ERC20 token contract address (if\\n     *                                     applicable) for any additional\\n     *                                     consideration item on the order.\\n     * @param offeredItemType              The item type of the offered item on\\n     *                                     the order.\\n     */\\n    function _prepareBasicFulfillmentFromCalldata(\\n        BasicOrderParameters calldata parameters,\\n        OrderType orderType,\\n        ItemType receivedItemType,\\n        ItemType additionalRecipientsItemType,\\n        address additionalRecipientsToken,\\n        ItemType offeredItemType\\n    ) internal {\\n        // Ensure this function cannot be triggered during a reentrant call.\\n        _setReentrancyGuard();\\n\\n        // Ensure current timestamp falls between order start time and end time.\\n        _verifyTime(parameters.startTime, parameters.endTime, true);\\n\\n        // Verify that calldata offsets for all dynamic types were produced by\\n        // default encoding. This ensures that the constants we use for calldata\\n        // pointers to dynamic types are the same as those calculated by\\n        // Solidity using their offsets.\\n        _assertValidBasicOrderParameterOffsets();\\n\\n        // Ensure supplied consideration array length is not less than original.\\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\\n            parameters.additionalRecipients.length + 1,\\n            parameters.totalOriginalAdditionalRecipients\\n        );\\n\\n        // Declare stack element for the order hash.\\n        bytes32 orderHash;\\n\\n        {\\n            /**\\n             * First, handle consideration items. Memory Layout:\\n             *  0x60: final hash of the array of consideration item hashes\\n             *  0x80-0x160: reused space for EIP712 hashing of each item\\n             *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\\n             *   - 0xa0: itemType\\n             *   - 0xc0: token\\n             *   - 0xe0: identifier\\n             *   - 0x100: startAmount\\n             *   - 0x120: endAmount\\n             *   - 0x140: recipient\\n             *  0x160-END_ARR: array of consideration item hashes\\n             *   - 0x160: primary consideration item EIP712 hash\\n             *   - 0x180-END_ARR: additional recipient item EIP712 hashes\\n             *  END_ARR: beginning of data for OrderFulfilled event\\n             *   - END_ARR + 0x120: length of ReceivedItem array\\n             *   - END_ARR + 0x140: beginning of data for first ReceivedItem\\n             * (Note: END_ARR = 0x180 + RECIPIENTS_LENGTH * 0x20)\\n             */\\n\\n            // Load consideration item typehash from runtime and place on stack.\\n            bytes32 typeHash = _CONSIDERATION_ITEM_TYPEHASH;\\n\\n            // Utilize assembly to enable reuse of memory regions and use\\n            // constant pointers when possible.\\n            assembly {\\n                /*\\n                 * 1. Calculate the EIP712 ConsiderationItem hash for the\\n                 * primary consideration item of the basic order.\\n                 */\\n\\n                // Write ConsiderationItem type hash and item type to memory.\\n                mstore(BasicOrder_considerationItem_typeHash_ptr, typeHash)\\n                mstore(\\n                    BasicOrder_considerationItem_itemType_ptr,\\n                    receivedItemType\\n                )\\n\\n                // Copy calldata region with (token, identifier, amount) from\\n                // BasicOrderParameters to ConsiderationItem. The\\n                // considerationAmount is written to startAmount and endAmount\\n                // as basic orders do not have dynamic amounts.\\n                calldatacopy(\\n                    BasicOrder_considerationItem_token_ptr,\\n                    BasicOrder_considerationToken_cdPtr,\\n                    ThreeWords\\n                )\\n\\n                // Copy calldata region with considerationAmount and offerer\\n                // from BasicOrderParameters to endAmount and recipient in\\n                // ConsiderationItem.\\n                calldatacopy(\\n                    BasicOrder_considerationItem_endAmount_ptr,\\n                    BasicOrder_considerationAmount_cdPtr,\\n                    TwoWords\\n                )\\n\\n                // Calculate EIP712 ConsiderationItem hash and store it in the\\n                // array of EIP712 consideration hashes.\\n                mstore(\\n                    BasicOrder_considerationHashesArray_ptr,\\n                    keccak256(\\n                        BasicOrder_considerationItem_typeHash_ptr,\\n                        EIP712_ConsiderationItem_size\\n                    )\\n                )\\n\\n                /*\\n                 * 2. Write a ReceivedItem struct for the primary consideration\\n                 * item to the consideration array in OrderFulfilled.\\n                 */\\n\\n                // Get the length of the additional recipients array.\\n                let totalAdditionalRecipients := calldataload(\\n                    BasicOrder_additionalRecipients_length_cdPtr\\n                )\\n\\n                // Calculate pointer to length of OrderFulfilled consideration\\n                // array.\\n                let eventConsiderationArrPtr := add(\\n                    OrderFulfilled_consideration_length_baseOffset,\\n                    mul(totalAdditionalRecipients, OneWord)\\n                )\\n\\n                // Set the length of the consideration array to the number of\\n                // additional recipients, plus one for the primary consideration\\n                // item.\\n                mstore(\\n                    eventConsiderationArrPtr,\\n                    add(\\n                        calldataload(\\n                            BasicOrder_additionalRecipients_length_cdPtr\\n                        ),\\n                        1\\n                    )\\n                )\\n\\n                // Overwrite the consideration array pointer so it points to the\\n                // body of the first element\\n                eventConsiderationArrPtr := add(\\n                    eventConsiderationArrPtr,\\n                    OneWord\\n                )\\n\\n                // Set itemType at start of the ReceivedItem memory region.\\n                mstore(eventConsiderationArrPtr, receivedItemType)\\n\\n                // Copy calldata region (token, identifier, amount & recipient)\\n                // from BasicOrderParameters to ReceivedItem memory.\\n                calldatacopy(\\n                    add(eventConsiderationArrPtr, Common_token_offset),\\n                    BasicOrder_considerationToken_cdPtr,\\n                    FourWords\\n                )\\n\\n                /*\\n                 * 3. Calculate EIP712 ConsiderationItem hashes for original\\n                 * additional recipients and add a ReceivedItem for each to the\\n                 * consideration array in the OrderFulfilled event. The original\\n                 * additional recipients are all the considerations signed by\\n                 * the offerer aside from the primary consideration of the\\n                 * order. Uses memory region from 0x80-0x160 as a buffer for\\n                 * calculating EIP712 ConsiderationItem hashes.\\n                 */\\n\\n                // Put pointer to consideration hashes array on the stack.\\n                // This will be updated as each additional recipient is hashed\\n                let\\n                    considerationHashesPtr\\n                := BasicOrder_considerationHashesArray_ptr\\n\\n                // Write item type, token, & identifier for additional recipient\\n                // to memory region for hashing EIP712 ConsiderationItem; these\\n                // values will be reused for each recipient.\\n                mstore(\\n                    BasicOrder_considerationItem_itemType_ptr,\\n                    additionalRecipientsItemType\\n                )\\n                mstore(\\n                    BasicOrder_considerationItem_token_ptr,\\n                    additionalRecipientsToken\\n                )\\n                mstore(BasicOrder_considerationItem_identifier_ptr, 0)\\n\\n                // Read length of the additionalRecipients array from calldata\\n                // and iterate.\\n                totalAdditionalRecipients := calldataload(\\n                    BasicOrder_totalOriginalAdditionalRecipients_cdPtr\\n                )\\n\\n                let i := 0\\n                for {} lt(i, totalAdditionalRecipients) {\\n                    i := add(i, 1)\\n                } {\\n                    /*\\n                     * Calculate EIP712 ConsiderationItem hash for recipient.\\n                     */\\n\\n                    // Retrieve calldata pointer for additional recipient.\\n                    let additionalRecipientCdPtr := add(\\n                        BasicOrder_additionalRecipients_data_cdPtr,\\n                        mul(AdditionalRecipients_size, i)\\n                    )\\n\\n                    // Copy startAmount from calldata to the ConsiderationItem\\n                    // struct.\\n                    calldatacopy(\\n                        BasicOrder_considerationItem_startAmount_ptr,\\n                        additionalRecipientCdPtr,\\n                        OneWord\\n                    )\\n\\n                    // Copy endAmount and recipient from calldata to the\\n                    // ConsiderationItem struct.\\n                    calldatacopy(\\n                        BasicOrder_considerationItem_endAmount_ptr,\\n                        additionalRecipientCdPtr,\\n                        AdditionalRecipients_size\\n                    )\\n\\n                    // Add 1 word to the pointer as part of each loop to reduce\\n                    // operations needed to get local offset into the array.\\n                    considerationHashesPtr := add(\\n                        considerationHashesPtr,\\n                        OneWord\\n                    )\\n\\n                    // Calculate EIP712 ConsiderationItem hash and store it in\\n                    // the array of consideration hashes.\\n                    mstore(\\n                        considerationHashesPtr,\\n                        keccak256(\\n                            BasicOrder_considerationItem_typeHash_ptr,\\n                            EIP712_ConsiderationItem_size\\n                        )\\n                    )\\n\\n                    /*\\n                     * Write ReceivedItem to OrderFulfilled data.\\n                     */\\n\\n                    // At this point, eventConsiderationArrPtr points to the\\n                    // beginning of the ReceivedItem struct of the previous\\n                    // element in the array. Increase it by the size of the\\n                    // struct to arrive at the pointer for the current element.\\n                    eventConsiderationArrPtr := add(\\n                        eventConsiderationArrPtr,\\n                        ReceivedItem_size\\n                    )\\n\\n                    // Write itemType to the ReceivedItem struct.\\n                    mstore(\\n                        eventConsiderationArrPtr,\\n                        additionalRecipientsItemType\\n                    )\\n\\n                    // Write token to the next word of the ReceivedItem struct.\\n                    mstore(\\n                        add(eventConsiderationArrPtr, OneWord),\\n                        additionalRecipientsToken\\n                    )\\n\\n                    // Copy endAmount & recipient words to ReceivedItem struct.\\n                    calldatacopy(\\n                        add(\\n                            eventConsiderationArrPtr,\\n                            ReceivedItem_amount_offset\\n                        ),\\n                        additionalRecipientCdPtr,\\n                        TwoWords\\n                    )\\n                }\\n\\n                /*\\n                 * 4. Hash packed array of ConsiderationItem EIP712 hashes:\\n                 *   `keccak256(abi.encodePacked(receivedItemHashes))`\\n                 * Note that it is set at 0x60 — all other memory begins at\\n                 * 0x80. 0x60 is the \\\"zero slot\\\" and will be restored at the end\\n                 * of the assembly section and before required by the compiler.\\n                 */\\n                mstore(\\n                    receivedItemsHash_ptr,\\n                    keccak256(\\n                        BasicOrder_considerationHashesArray_ptr,\\n                        mul(add(totalAdditionalRecipients, 1), OneWord)\\n                    )\\n                )\\n\\n                /*\\n                 * 5. Add a ReceivedItem for each tip to the consideration array\\n                 * in the OrderFulfilled event. The tips are all the\\n                 * consideration items that were not signed by the offerer and\\n                 * were provided by the fulfiller.\\n                 */\\n\\n                // Overwrite length to length of the additionalRecipients array.\\n                totalAdditionalRecipients := calldataload(\\n                    BasicOrder_additionalRecipients_length_cdPtr\\n                )\\n\\n                for {} lt(i, totalAdditionalRecipients) {\\n                    i := add(i, 1)\\n                } {\\n                    // Retrieve calldata pointer for additional recipient.\\n                    let additionalRecipientCdPtr := add(\\n                        BasicOrder_additionalRecipients_data_cdPtr,\\n                        mul(AdditionalRecipients_size, i)\\n                    )\\n\\n                    // At this point, eventConsiderationArrPtr points to the\\n                    // beginning of the ReceivedItem struct of the previous\\n                    // element in the array. Increase it by the size of the\\n                    // struct to arrive at the pointer for the current element.\\n                    eventConsiderationArrPtr := add(\\n                        eventConsiderationArrPtr,\\n                        ReceivedItem_size\\n                    )\\n\\n                    // Write itemType to the ReceivedItem struct.\\n                    mstore(\\n                        eventConsiderationArrPtr,\\n                        additionalRecipientsItemType\\n                    )\\n\\n                    // Write token to the next word of the ReceivedItem struct.\\n                    mstore(\\n                        add(eventConsiderationArrPtr, OneWord),\\n                        additionalRecipientsToken\\n                    )\\n\\n                    // Copy endAmount & recipient words to ReceivedItem struct.\\n                    calldatacopy(\\n                        add(\\n                            eventConsiderationArrPtr,\\n                            ReceivedItem_amount_offset\\n                        ),\\n                        additionalRecipientCdPtr,\\n                        TwoWords\\n                    )\\n                }\\n            }\\n        }\\n\\n        {\\n            /**\\n             * Next, handle offered items. Memory Layout:\\n             *  EIP712 data for OfferItem\\n             *   - 0x80:  OfferItem EIP-712 typehash (constant)\\n             *   - 0xa0:  itemType\\n             *   - 0xc0:  token\\n             *   - 0xe0:  identifier (reused for offeredItemsHash)\\n             *   - 0x100: startAmount\\n             *   - 0x120: endAmount\\n             */\\n\\n            // Place offer item typehash on the stack.\\n            bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\\n\\n            // Utilize assembly to enable reuse of memory regions when possible.\\n            assembly {\\n                /*\\n                 * 1. Calculate OfferItem EIP712 hash\\n                 */\\n\\n                // Write the OfferItem typeHash to memory.\\n                mstore(BasicOrder_offerItem_typeHash_ptr, typeHash)\\n\\n                // Write the OfferItem item type to memory.\\n                mstore(BasicOrder_offerItem_itemType_ptr, offeredItemType)\\n\\n                // Copy calldata region with (offerToken, offerIdentifier,\\n                // offerAmount) from OrderParameters to (token, identifier,\\n                // startAmount) in OfferItem struct. The offerAmount is written\\n                // to startAmount and endAmount as basic orders do not have\\n                // dynamic amounts.\\n                calldatacopy(\\n                    BasicOrder_offerItem_token_ptr,\\n                    BasicOrder_offerToken_cdPtr,\\n                    ThreeWords\\n                )\\n\\n                // Copy offerAmount from calldata to endAmount in OfferItem\\n                // struct.\\n                calldatacopy(\\n                    BasicOrder_offerItem_endAmount_ptr,\\n                    BasicOrder_offerAmount_cdPtr,\\n                    OneWord\\n                )\\n\\n                // Compute EIP712 OfferItem hash, write result to scratch space:\\n                //   `keccak256(abi.encode(offeredItem))`\\n                mstore(\\n                    0,\\n                    keccak256(\\n                        BasicOrder_offerItem_typeHash_ptr,\\n                        EIP712_OfferItem_size\\n                    )\\n                )\\n\\n                /*\\n                 * 2. Calculate hash of array of EIP712 hashes and write the\\n                 * result to the corresponding OfferItem struct:\\n                 *   `keccak256(abi.encodePacked(offerItemHashes))`\\n                 */\\n                mstore(BasicOrder_order_offerHashes_ptr, keccak256(0, OneWord))\\n\\n                /*\\n                 * 3. Write SpentItem to offer array in OrderFulfilled event.\\n                 */\\n                let eventConsiderationArrPtr := add(\\n                    OrderFulfilled_offer_length_baseOffset,\\n                    mul(\\n                        calldataload(\\n                            BasicOrder_additionalRecipients_length_cdPtr\\n                        ),\\n                        OneWord\\n                    )\\n                )\\n\\n                // Set a length of 1 for the offer array.\\n                mstore(eventConsiderationArrPtr, 1)\\n\\n                // Write itemType to the SpentItem struct.\\n                mstore(add(eventConsiderationArrPtr, OneWord), offeredItemType)\\n\\n                // Copy calldata region with (offerToken, offerIdentifier,\\n                // offerAmount) from OrderParameters to (token, identifier,\\n                // amount) in SpentItem struct.\\n                calldatacopy(\\n                    add(eventConsiderationArrPtr, AdditionalRecipients_size),\\n                    BasicOrder_offerToken_cdPtr,\\n                    ThreeWords\\n                )\\n            }\\n        }\\n\\n        {\\n            /**\\n             * Once consideration items and offer items have been handled,\\n             * derive the final order hash. Memory Layout:\\n             *  0x80-0x1c0: EIP712 data for order\\n             *   - 0x80:   Order EIP-712 typehash (constant)\\n             *   - 0xa0:   orderParameters.offerer\\n             *   - 0xc0:   orderParameters.zone\\n             *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\\n             *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\\n             *   - 0x120:  orderParameters.basicOrderType (% 4 = orderType)\\n             *   - 0x140:  orderParameters.startTime\\n             *   - 0x160:  orderParameters.endTime\\n             *   - 0x180:  orderParameters.zoneHash\\n             *   - 0x1a0:  orderParameters.salt\\n             *   - 0x1c0:  orderParameters.conduitKey\\n             *   - 0x1e0:  _nonces[orderParameters.offerer] (from storage)\\n             */\\n\\n            // Read the offerer from calldata and place on the stack.\\n            address offerer;\\n            assembly {\\n                offerer := calldataload(BasicOrder_offerer_cdPtr)\\n            }\\n\\n            // Read offerer's current nonce from storage and place on the stack.\\n            uint256 nonce = _getNonce(offerer);\\n\\n            // Load order typehash from runtime code and place on stack.\\n            bytes32 typeHash = _ORDER_TYPEHASH;\\n\\n            assembly {\\n                // Set the OrderItem typeHash in memory.\\n                mstore(BasicOrder_order_typeHash_ptr, typeHash)\\n\\n                // Copy offerer and zone from OrderParameters in calldata to the\\n                // Order struct.\\n                calldatacopy(\\n                    BasicOrder_order_offerer_ptr,\\n                    BasicOrder_offerer_cdPtr,\\n                    TwoWords\\n                )\\n\\n                // Copy receivedItemsHash from zero slot to the Order struct.\\n                mstore(\\n                    BasicOrder_order_considerationHashes_ptr,\\n                    mload(receivedItemsHash_ptr)\\n                )\\n\\n                // Write the supplied orderType to the Order struct.\\n                mstore(BasicOrder_order_orderType_ptr, orderType)\\n\\n                // Copy startTime, endTime, zoneHash, salt & conduit from\\n                // calldata to the Order struct.\\n                calldatacopy(\\n                    BasicOrder_order_startTime_ptr,\\n                    BasicOrder_startTime_cdPtr,\\n                    FiveWords\\n                )\\n\\n                // Take offerer's nonce retrieved from storage, write to struct.\\n                mstore(BasicOrder_order_nonce_ptr, nonce)\\n\\n                // Compute the EIP712 Order hash.\\n                orderHash := keccak256(\\n                    BasicOrder_order_typeHash_ptr,\\n                    EIP712_Order_size\\n                )\\n            }\\n        }\\n\\n        assembly {\\n            /**\\n             * After the order hash has been derived, emit OrderFulfilled event:\\n             *   event OrderFulfilled(\\n             *     bytes32 orderHash,\\n             *     address indexed offerer,\\n             *     address indexed zone,\\n             *     address fulfiller,\\n             *     SpentItem[] offer,\\n             *       > (itemType, token, id, amount)\\n             *     ReceivedItem[] consideration\\n             *       > (itemType, token, id, amount, recipient)\\n             *   )\\n             * topic0 - OrderFulfilled event signature\\n             * topic1 - offerer\\n             * topic2 - zone\\n             * data:\\n             *  - 0x00: orderHash\\n             *  - 0x20: fulfiller\\n             *  - 0x40: offer arr ptr (0x80)\\n             *  - 0x60: consideration arr ptr (0x120)\\n             *  - 0x80: offer arr len (1)\\n             *  - 0xa0: offer.itemType\\n             *  - 0xc0: offer.token\\n             *  - 0xe0: offer.identifier\\n             *  - 0x100: offer.amount\\n             *  - 0x120: 1 + recipients.length\\n             *  - 0x140: recipient 0\\n             */\\n\\n            // Derive pointer to start of OrderFulfilled event data\\n            let eventDataPtr := add(\\n                OrderFulfilled_baseOffset,\\n                mul(\\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr),\\n                    OneWord\\n                )\\n            )\\n\\n            // Write the order hash to the head of the event's data region.\\n            mstore(eventDataPtr, orderHash)\\n\\n            // Write the fulfiller (i.e. the caller) next.\\n            mstore(add(eventDataPtr, OrderFulfilled_fulfiller_offset), caller())\\n\\n            // Write the SpentItem and ReceivedItem array offsets (constants).\\n            mstore(\\n                // SpentItem array offset\\n                add(eventDataPtr, OrderFulfilled_offer_head_offset),\\n                OrderFulfilled_offer_body_offset\\n            )\\n            mstore(\\n                // ReceivedItem array offset\\n                add(eventDataPtr, OrderFulfilled_consideration_head_offset),\\n                OrderFulfilled_consideration_body_offset\\n            )\\n\\n            // Derive total data size including SpentItem and ReceivedItem data.\\n            // SpentItem portion is already included in the baseSize constant,\\n            // as there can only be one element in the array.\\n            let dataSize := add(\\n                OrderFulfilled_baseSize,\\n                mul(\\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr),\\n                    ReceivedItem_size\\n                )\\n            )\\n\\n            // Emit OrderFulfilled log with three topics (the event signature\\n            // as well as the two indexed arguments, the offerer and the zone).\\n            log3(\\n                // Supply the pointer for event data in memory.\\n                eventDataPtr,\\n                // Supply the size of event data in memory.\\n                dataSize,\\n                // Supply the OrderFulfilled event signature.\\n                OrderFulfilled_selector,\\n                // Supply the first topic (the offerer).\\n                calldataload(BasicOrder_offerer_cdPtr),\\n                // Supply the second topic (the zone).\\n                calldataload(BasicOrder_zone_cdPtr)\\n            )\\n\\n            // Restore the zero slot.\\n            mstore(ZeroSlot, 0)\\n        }\\n\\n        // Determine whether order is restricted and, if so, that it is valid.\\n        _assertRestrictedBasicOrderValidity(\\n            orderHash,\\n            parameters.zoneHash,\\n            orderType,\\n            parameters.offerer,\\n            parameters.zone\\n        );\\n\\n        // Verify and update the status of the derived order.\\n        _validateBasicOrderAndUpdateStatus(\\n            orderHash,\\n            parameters.offerer,\\n            parameters.signature\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer Ether (or other native tokens) to a\\n     *      given recipient as part of basic order fulfillment. Note that\\n     *      conduits are not utilized for native tokens as the transferred\\n     *      amount must be provided as msg.value.\\n     *\\n     * @param amount               The amount to transfer.\\n     * @param to                   The recipient of the native token transfer.\\n     * @param additionalRecipients The additional recipients of the order.\\n     */\\n    function _transferEthAndFinalize(\\n        uint256 amount,\\n        address payable to,\\n        AdditionalRecipient[] calldata additionalRecipients\\n    ) internal {\\n        // Put ether value supplied by the caller on the stack.\\n        uint256 etherRemaining = msg.value;\\n\\n        // Retrieve total number of additional recipients and place on stack.\\n        uint256 totalAdditionalRecipients = additionalRecipients.length;\\n\\n        // Iterate over each additional recipient.\\n        for (uint256 i = 0; i < totalAdditionalRecipients; ) {\\n            // Retrieve the additional recipient.\\n            AdditionalRecipient calldata additionalRecipient = (\\n                additionalRecipients[i]\\n            );\\n\\n            // Read ether amount to transfer to recipient and place on stack.\\n            uint256 additionalRecipientAmount = additionalRecipient.amount;\\n\\n            // Ensure that sufficient Ether is available.\\n            if (additionalRecipientAmount > etherRemaining) {\\n                revert InsufficientEtherSupplied();\\n            }\\n\\n            // Transfer Ether to the additional recipient.\\n            _transferEth(\\n                additionalRecipient.recipient,\\n                additionalRecipientAmount\\n            );\\n\\n            // Skip underflow check as subtracted value is less than remaining.\\n            unchecked {\\n                // Reduce ether value available.\\n                etherRemaining -= additionalRecipientAmount;\\n            }\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Ensure that sufficient Ether is still available.\\n        if (amount > etherRemaining) {\\n            revert InsufficientEtherSupplied();\\n        }\\n\\n        // Transfer Ether to the offerer.\\n        _transferEth(to, amount);\\n\\n        // If any Ether remains after transfers, return it to the caller.\\n        if (etherRemaining > amount) {\\n            // Skip underflow check as etherRemaining > amount.\\n            unchecked {\\n                // Transfer remaining Ether to the caller.\\n                _transferEth(payable(msg.sender), etherRemaining - amount);\\n            }\\n        }\\n\\n        // Clear the reentrancy guard.\\n        _clearReentrancyGuard();\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens to a given recipient as\\n     *      part of basic order fulfillment.\\n     *\\n     * @param from                 The originator of the ERC20 token transfer.\\n     * @param to                   The recipient of the ERC20 token transfer.\\n     * @param erc20Token           The ERC20 token to transfer.\\n     * @param amount               The amount of ERC20 tokens to transfer.\\n     * @param additionalRecipients The additional recipients of the order.\\n     * @param fromOfferer          A boolean indicating whether to decrement\\n     *                             amount from the offered amount.\\n     */\\n    function _transferERC20AndFinalize(\\n        address from,\\n        address to,\\n        address erc20Token,\\n        uint256 amount,\\n        AdditionalRecipient[] calldata additionalRecipients,\\n        bool fromOfferer,\\n        bytes memory accumulator\\n    ) internal {\\n        // Determine the appropriate conduit to utilize.\\n        bytes32 conduitKey;\\n\\n        // Utilize assembly to derive conduit (if relevant) based on route.\\n        assembly {\\n            // use offerer conduit if fromOfferer, fulfiller conduit otherwise.\\n            conduitKey := calldataload(\\n                sub(\\n                    BasicOrder_fulfillerConduit_cdPtr,\\n                    mul(fromOfferer, OneWord)\\n                )\\n            )\\n        }\\n\\n        // Retrieve total number of additional recipients and place on stack.\\n        uint256 totalAdditionalRecipients = additionalRecipients.length;\\n\\n        // Iterate over each additional recipient.\\n        for (uint256 i = 0; i < totalAdditionalRecipients; ) {\\n            // Retrieve the additional recipient.\\n            AdditionalRecipient calldata additionalRecipient = (\\n                additionalRecipients[i]\\n            );\\n\\n            uint256 additionalRecipientAmount = additionalRecipient.amount;\\n\\n            // Decrement the amount to transfer to fulfiller if indicated.\\n            if (fromOfferer) {\\n                amount -= additionalRecipientAmount;\\n            }\\n\\n            // Transfer ERC20 tokens to additional recipient given approval.\\n            _transferERC20(\\n                erc20Token,\\n                from,\\n                additionalRecipient.recipient,\\n                additionalRecipientAmount,\\n                conduitKey,\\n                accumulator\\n            );\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Transfer ERC20 token amount (from account must have proper approval).\\n        _transferERC20(erc20Token, from, to, amount, conduitKey, accumulator);\\n\\n        // Clear the reentrancy guard.\\n        _clearReentrancyGuard();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OrderFulfiller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { OrderType, ItemType } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    OfferItem,\\n    ConsiderationItem,\\n    SpentItem,\\n    ReceivedItem,\\n    OrderParameters,\\n    Order,\\n    AdvancedOrder,\\n    CriteriaResolver\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { BasicOrderFulfiller } from \\\"./BasicOrderFulfiller.sol\\\";\\n\\nimport { CriteriaResolution } from \\\"./CriteriaResolution.sol\\\";\\n\\nimport { AmountDeriver } from \\\"./AmountDeriver.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title OrderFulfiller\\n * @author 0age\\n * @notice OrderFulfiller contains logic related to order fulfillment where a\\n *         single order is being fulfilled and where basic order fulfillment is\\n *         not available as an option.\\n */\\ncontract OrderFulfiller is\\n    BasicOrderFulfiller,\\n    CriteriaResolution,\\n    AmountDeriver\\n{\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController)\\n        BasicOrderFulfiller(conduitController)\\n    {}\\n\\n    /**\\n     * @dev Internal function to validate an order and update its status, adjust\\n     *      prices based on current time, apply criteria resolvers, determine\\n     *      what portion to fill, and transfer relevant tokens.\\n     *\\n     * @param advancedOrder       The order to fulfill as well as the fraction\\n     *                            to fill. Note that all offer and consideration\\n     *                            components must divide with no remainder for\\n     *                            the partial fill to be valid.\\n     * @param criteriaResolvers   An array where each element contains a\\n     *                            reference to a specific offer or\\n     *                            consideration, a token identifier, and a proof\\n     *                            that the supplied token identifier is\\n     *                            contained in the order's merkle root. Note\\n     *                            that a criteria of zero indicates that any\\n     *                            (transferrable) token identifier is valid and\\n     *                            that no proof needs to be supplied.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     *\\n     * @return A boolean indicating whether the order has been fulfilled.\\n     */\\n    function _validateAndFulfillAdvancedOrder(\\n        AdvancedOrder memory advancedOrder,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        bytes32 fulfillerConduitKey\\n    ) internal returns (bool) {\\n        // Ensure this function cannot be triggered during a reentrant call.\\n        _setReentrancyGuard();\\n\\n        // Declare empty bytes32 array (unused, will remain empty).\\n        bytes32[] memory priorOrderHashes;\\n\\n        // Validate order, update status, and determine fraction to fill.\\n        (\\n            bytes32 orderHash,\\n            uint256 fillNumerator,\\n            uint256 fillDenominator\\n        ) = _validateOrderAndUpdateStatus(\\n                advancedOrder,\\n                criteriaResolvers,\\n                true,\\n                priorOrderHashes\\n            );\\n\\n        // Create an array with length 1 containing the order.\\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](1);\\n\\n        // Populate the order as the first and only element of the new array.\\n        advancedOrders[0] = advancedOrder;\\n\\n        // Apply criteria resolvers using generated orders and details arrays.\\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\\n\\n        // Retrieve the order parameters after applying criteria resolvers.\\n        OrderParameters memory orderParameters = advancedOrders[0].parameters;\\n\\n        // Perform each item transfer with the appropriate fractional amount.\\n        _applyFractionsAndTransferEach(\\n            orderParameters,\\n            fillNumerator,\\n            fillDenominator,\\n            orderParameters.conduitKey,\\n            fulfillerConduitKey\\n        );\\n\\n        // Emit an event signifying that the order has been fulfilled.\\n        _emitOrderFulfilledEvent(\\n            orderHash,\\n            orderParameters.offerer,\\n            orderParameters.zone,\\n            msg.sender,\\n            orderParameters.offer,\\n            orderParameters.consideration\\n        );\\n\\n        // Clear the reentrancy guard.\\n        _clearReentrancyGuard();\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer each item contained in a given single\\n     *      order fulfillment after applying a respective fraction to the amount\\n     *      being transferred.\\n     *\\n     * @param orderParameters     The parameters for the fulfilled order.\\n     * @param numerator           A value indicating the portion of the order\\n     *                            that should be filled.\\n     * @param denominator         A value indicating the total order size.\\n     * @param offererConduitKey   An address indicating what conduit, if any, to\\n     *                            source the offerer's token approvals from. The\\n     *                            zero hash signifies that no conduit should be\\n     *                            used, with direct approvals set on\\n     *                            Consideration.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     */\\n    function _applyFractionsAndTransferEach(\\n        OrderParameters memory orderParameters,\\n        uint256 numerator,\\n        uint256 denominator,\\n        bytes32 offererConduitKey,\\n        bytes32 fulfillerConduitKey\\n    ) internal {\\n        // Derive order duration, time elapsed, and time remaining.\\n        uint256 duration = orderParameters.endTime - orderParameters.startTime;\\n        uint256 elapsed = block.timestamp - orderParameters.startTime;\\n        uint256 remaining = duration - elapsed;\\n\\n        // Put ether value supplied by the caller on the stack.\\n        uint256 etherRemaining = msg.value;\\n\\n        // Initialize an accumulator array. From this point forward, no new\\n        // memory regions can be safely allocated until the accumulator is no\\n        // longer being utilized, as the accumulator operates in an open-ended\\n        // fashion from this memory pointer; existing memory may still be\\n        // accessed and modified, however.\\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\\n\\n        // As of solidity 0.6.0, inline assembly cannot directly access function\\n        // definitions, but can still access locally scoped function variables.\\n        // This means that in order to recast the type of a function, we need to\\n        // create a local variable to reference the internal function definition\\n        // (using the same type) and a local variable with the desired type,\\n        // and then cast the original function pointer to the desired type.\\n\\n        /**\\n         * Repurpose existing OfferItem memory regions on the offer array for\\n         * the order by overriding the _transfer function pointer to accept a\\n         * modified OfferItem argument in place of the usual ReceivedItem:\\n         *\\n         *   ========= OfferItem ==========   ====== ReceivedItem ======\\n         *   ItemType itemType; ------------> ItemType itemType;\\n         *   address token; ----------------> address token;\\n         *   uint256 identifierOrCriteria; -> uint256 identifier;\\n         *   uint256 startAmount; ----------> uint256 amount;\\n         *   uint256 endAmount; ------------> address recipient;\\n         */\\n\\n        // Declare a nested scope to minimize stack depth.\\n        {\\n            // Declare a virtual function pointer taking an OfferItem argument.\\n            function(OfferItem memory, address, bytes32, bytes memory)\\n                internal _transferOfferItem;\\n\\n            {\\n                // Assign _transfer function to a new function pointer (it takes\\n                // a ReceivedItem as its initial argument)\\n                function(ReceivedItem memory, address, bytes32, bytes memory)\\n                    internal _transferReceivedItem = _transfer;\\n\\n                // Utilize assembly to override the virtual function pointer.\\n                assembly {\\n                    // Cast initial ReceivedItem type to an OfferItem type.\\n                    _transferOfferItem := _transferReceivedItem\\n                }\\n            }\\n\\n            // Iterate over each offer on the order.\\n            for (uint256 i = 0; i < orderParameters.offer.length; ) {\\n                // Retrieve the offer item.\\n                OfferItem memory offerItem = orderParameters.offer[i];\\n\\n                // Apply fill fraction to derive offer item amount to transfer.\\n                uint256 amount = _applyFraction(\\n                    offerItem.startAmount,\\n                    offerItem.endAmount,\\n                    numerator,\\n                    denominator,\\n                    elapsed,\\n                    remaining,\\n                    duration,\\n                    false\\n                );\\n\\n                // Utilize assembly to set overloaded offerItem arguments.\\n                assembly {\\n                    // Write derived fractional amount to startAmount as amount.\\n                    mstore(add(offerItem, ReceivedItem_amount_offset), amount)\\n                    // Write fulfiller (i.e. caller) to endAmount as recipient.\\n                    mstore(\\n                        add(offerItem, ReceivedItem_recipient_offset),\\n                        caller()\\n                    )\\n                }\\n\\n                // Reduce available value if offer spent ETH or a native token.\\n                if (offerItem.itemType == ItemType.NATIVE) {\\n                    // Ensure that sufficient native tokens are still available.\\n                    if (amount > etherRemaining) {\\n                        revert InsufficientEtherSupplied();\\n                    }\\n\\n                    // Skip underflow check as a comparison has just been made.\\n                    unchecked {\\n                        etherRemaining -= amount;\\n                    }\\n                }\\n\\n                // Transfer the item from the offerer to the caller.\\n                _transferOfferItem(\\n                    offerItem,\\n                    orderParameters.offerer,\\n                    offererConduitKey,\\n                    accumulator\\n                );\\n\\n                // Skip overflow check as for loop is indexed starting at zero.\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Repurpose existing ConsiderationItem memory regions on the\\n         * consideration array for the order by overriding the _transfer\\n         * function pointer to accept a modified ConsiderationItem argument in\\n         * place of the usual ReceivedItem:\\n         *\\n         *   ====== ConsiderationItem =====   ====== ReceivedItem ======\\n         *   ItemType itemType; ------------> ItemType itemType;\\n         *   address token; ----------------> address token;\\n         *   uint256 identifierOrCriteria;--> uint256 identifier;\\n         *   uint256 startAmount; ----------> uint256 amount;\\n         *   uint256 endAmount;        /----> address recipient;\\n         *   address recipient; ------/\\n         */\\n\\n        // Declare a nested scope to minimize stack depth.\\n        {\\n            // Declare virtual function pointer with ConsiderationItem argument.\\n            function(ConsiderationItem memory, address, bytes32, bytes memory)\\n                internal _transferConsiderationItem;\\n            {\\n                // Reassign _transfer function to a new function pointer (it\\n                // takes a ReceivedItem as its initial argument).\\n                function(ReceivedItem memory, address, bytes32, bytes memory)\\n                    internal _transferReceivedItem = _transfer;\\n\\n                // Utilize assembly to override the virtual function pointer.\\n                assembly {\\n                    // Cast ReceivedItem type to ConsiderationItem type.\\n                    _transferConsiderationItem := _transferReceivedItem\\n                }\\n            }\\n\\n            // Iterate over each consideration item on the order.\\n            for (uint256 i = 0; i < orderParameters.consideration.length; ) {\\n                // Retrieve the consideration item.\\n                ConsiderationItem memory considerationItem = (\\n                    orderParameters.consideration[i]\\n                );\\n\\n                // Apply fraction & derive considerationItem amount to transfer.\\n                uint256 amount = _applyFraction(\\n                    considerationItem.startAmount,\\n                    considerationItem.endAmount,\\n                    numerator,\\n                    denominator,\\n                    elapsed,\\n                    remaining,\\n                    duration,\\n                    true\\n                );\\n\\n                // Use assembly to set overloaded considerationItem arguments.\\n                assembly {\\n                    // Write derived fractional amount to startAmount as amount.\\n                    mstore(\\n                        add(considerationItem, ReceivedItem_amount_offset),\\n                        amount\\n                    )\\n\\n                    // Write original recipient to endAmount as recipient.\\n                    mstore(\\n                        add(considerationItem, ReceivedItem_recipient_offset),\\n                        mload(\\n                            add(\\n                                considerationItem,\\n                                ConsiderationItem_recipient_offset\\n                            )\\n                        )\\n                    )\\n                }\\n\\n                // Reduce available value if offer spent ETH or a native token.\\n                if (considerationItem.itemType == ItemType.NATIVE) {\\n                    // Ensure that sufficient native tokens are still available.\\n                    if (amount > etherRemaining) {\\n                        revert InsufficientEtherSupplied();\\n                    }\\n\\n                    // Skip underflow check as a comparison has just been made.\\n                    unchecked {\\n                        etherRemaining -= amount;\\n                    }\\n                }\\n\\n                // Transfer item from caller to recipient specified by the item.\\n                _transferConsiderationItem(\\n                    considerationItem,\\n                    msg.sender,\\n                    fulfillerConduitKey,\\n                    accumulator\\n                );\\n\\n                // Skip overflow check as for loop is indexed starting at zero.\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        // Trigger any remaining accumulated transfers via call to the conduit.\\n        _triggerIfArmed(accumulator);\\n\\n        // If any ether remains after fulfillments...\\n        if (etherRemaining != 0) {\\n            // return it to the caller.\\n            _transferEth(payable(msg.sender), etherRemaining);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to emit an OrderFulfilled event. OfferItems are\\n     *      translated into SpentItems and ConsiderationItems are translated\\n     *      into ReceivedItems.\\n     *\\n     * @param orderHash     The order hash.\\n     * @param offerer       The offerer for the order.\\n     * @param zone          The zone for the order.\\n     * @param fulfiller     The fulfiller of the order, or the null address if\\n     *                      the order was fulfilled via order matching.\\n     * @param offer         The offer items for the order.\\n     * @param consideration The consideration items for the order.\\n     */\\n    function _emitOrderFulfilledEvent(\\n        bytes32 orderHash,\\n        address offerer,\\n        address zone,\\n        address fulfiller,\\n        OfferItem[] memory offer,\\n        ConsiderationItem[] memory consideration\\n    ) internal {\\n        // Cast already-modified offer memory region as spent items.\\n        SpentItem[] memory spentItems;\\n        assembly {\\n            spentItems := offer\\n        }\\n\\n        // Cast already-modified consideration memory region as received items.\\n        ReceivedItem[] memory receivedItems;\\n        assembly {\\n            receivedItems := consideration\\n        }\\n\\n        // Emit an event signifying that the order has been fulfilled.\\n        emit OrderFulfilled(\\n            orderHash,\\n            offerer,\\n            zone,\\n            fulfiller,\\n            spentItems,\\n            receivedItems\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal pure function to convert an order to an advanced order with\\n     *      numerator and denominator of 1 and empty extraData.\\n     *\\n     * @param order The order to convert.\\n     *\\n     * @return advancedOrder The new advanced order.\\n     */\\n    function _convertOrderToAdvanced(Order calldata order)\\n        internal\\n        pure\\n        returns (AdvancedOrder memory advancedOrder)\\n    {\\n        // Convert to partial order (1/1 or full fill) and return new value.\\n        advancedOrder = AdvancedOrder(\\n            order.parameters,\\n            1,\\n            1,\\n            order.signature,\\n            \\\"\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal pure function to convert an array of orders to an array of\\n     *      advanced orders with numerator and denominator of 1.\\n     *\\n     * @param orders The orders to convert.\\n     *\\n     * @return advancedOrders The new array of partial orders.\\n     */\\n    function _convertOrdersToAdvanced(Order[] calldata orders)\\n        internal\\n        pure\\n        returns (AdvancedOrder[] memory advancedOrders)\\n    {\\n        // Read the number of orders from calldata and place on the stack.\\n        uint256 totalOrders = orders.length;\\n\\n        // Allocate new empty array for each partial order in memory.\\n        advancedOrders = new AdvancedOrder[](totalOrders);\\n\\n        // Skip overflow check as the index for the loop starts at zero.\\n        unchecked {\\n            // Iterate over the given orders.\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\n                // Convert to partial order (1/1 or full fill) and update array.\\n                advancedOrders[i] = _convertOrderToAdvanced(orders[i]);\\n            }\\n        }\\n\\n        // Return the array of advanced orders.\\n        return advancedOrders;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AmountDeriver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport {\\n    AmountDerivationErrors\\n} from \\\"../interfaces/AmountDerivationErrors.sol\\\";\\n\\n/**\\n * @title AmountDeriver\\n * @author 0age\\n * @notice AmountDeriver contains pure functions related to deriving item\\n *         amounts based on partial fill quantity and on linear extrapolation\\n *         based on current time when the start amount and end amount differ.\\n */\\ncontract AmountDeriver is AmountDerivationErrors {\\n    /**\\n     * @dev Internal pure function to derive the current amount of a given item\\n     *      based on the current price, the starting price, and the ending\\n     *      price. If the start and end prices differ, the current price will be\\n     *      extrapolated on a linear basis.\\n     *\\n     * @param startAmount The starting amount of the item.\\n     * @param endAmount   The ending amount of the item.\\n     * @param elapsed     The time elapsed since the order's start time.\\n     * @param remaining   The time left until the order's end time.\\n     * @param duration    The total duration of the order.\\n     * @param roundUp     A boolean indicating whether the resultant amount\\n     *                    should be rounded up or down.\\n     *\\n     * @return The current amount.\\n     */\\n    function _locateCurrentAmount(\\n        uint256 startAmount,\\n        uint256 endAmount,\\n        uint256 elapsed,\\n        uint256 remaining,\\n        uint256 duration,\\n        bool roundUp\\n    ) internal pure returns (uint256) {\\n        // Only modify end amount if it doesn't already equal start amount.\\n        if (startAmount != endAmount) {\\n            // Leave extra amount to add for rounding at zero (i.e. round down).\\n            uint256 extraCeiling = 0;\\n\\n            // If rounding up, set rounding factor to one less than denominator.\\n            if (roundUp) {\\n                // Skip underflow check: duration cannot be zero.\\n                unchecked {\\n                    extraCeiling = duration - 1;\\n                }\\n            }\\n\\n            // Aggregate new amounts weighted by time with rounding factor\\n            uint256 totalBeforeDivision = (\\n                (startAmount * remaining) + (endAmount * elapsed) + extraCeiling\\n            );\\n\\n            // Division performed with no zero check as duration cannot be zero.\\n            uint256 newAmount;\\n            assembly {\\n                newAmount := div(totalBeforeDivision, duration)\\n            }\\n\\n            // Return the current amount (expressed as endAmount internally).\\n            return newAmount;\\n        }\\n\\n        // Return the original amount (now expressed as endAmount internally).\\n        return endAmount;\\n    }\\n\\n    /**\\n     * @dev Internal pure function to return a fraction of a given value and to\\n     *      ensure the resultant value does not have any fractional component.\\n     *      Note that this function assumes that zero will never be supplied as\\n     *      the denominator parameter; invalid / undefined behavior will result\\n     *      should a denominator of zero be provided.\\n     *\\n     * @param numerator   A value indicating the portion of the order that\\n     *                    should be filled.\\n     * @param denominator A value indicating the total size of the order. Note\\n     *                    that this value cannot be equal to zero.\\n     * @param value       The value for which to compute the fraction.\\n     *\\n     * @return newValue The value after applying the fraction.\\n     */\\n    function _getFraction(\\n        uint256 numerator,\\n        uint256 denominator,\\n        uint256 value\\n    ) internal pure returns (uint256 newValue) {\\n        // Return value early in cases where the fraction resolves to 1.\\n        if (numerator == denominator) {\\n            return value;\\n        }\\n\\n        // Ensure fraction can be applied to the value with no remainder. Note\\n        // that the denominator cannot be zero.\\n        bool exact;\\n        assembly {\\n            // Ensure new value contains no remainder via mulmod operator.\\n            // Credit to @hrkrshnn + @axic for proposing this optimal solution.\\n            exact := iszero(mulmod(value, numerator, denominator))\\n        }\\n\\n        // Ensure that division gave a final result with no remainder.\\n        if (!exact) {\\n            revert InexactFraction();\\n        }\\n\\n        // Multiply the numerator by the value and ensure no overflow occurs.\\n        uint256 valueTimesNumerator = value * numerator;\\n\\n        // Divide and check for remainder. Note that denominator cannot be zero.\\n        assembly {\\n            // Perform division without zero check.\\n            newValue := div(valueTimesNumerator, denominator)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to apply a fraction to a consideration\\n     * or offer item.\\n     *\\n     * @param startAmount     The starting amount of the item.\\n     * @param endAmount       The ending amount of the item.\\n     * @param numerator       A value indicating the portion of the order that\\n     *                        should be filled.\\n     * @param denominator     A value indicating the total size of the order.\\n     * @param elapsed         The time elapsed since the order's start time.\\n     * @param remaining       The time left until the order's end time.\\n     * @param duration        The total duration of the order.\\n     *\\n     * @return amount The received item to transfer with the final amount.\\n     */\\n    function _applyFraction(\\n        uint256 startAmount,\\n        uint256 endAmount,\\n        uint256 numerator,\\n        uint256 denominator,\\n        uint256 elapsed,\\n        uint256 remaining,\\n        uint256 duration,\\n        bool roundUp\\n    ) internal pure returns (uint256 amount) {\\n        // If start amount equals end amount, apply fraction to end amount.\\n        if (startAmount == endAmount) {\\n            // Apply fraction to end amount.\\n            amount = _getFraction(numerator, denominator, endAmount);\\n        } else {\\n            // Otherwise, apply fraction to both and extrapolate final amount.\\n            amount = _locateCurrentAmount(\\n                _getFraction(numerator, denominator, startAmount),\\n                _getFraction(numerator, denominator, endAmount),\\n                elapsed,\\n                remaining,\\n                duration,\\n                roundUp\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/AmountDerivationErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/**\\n * @title AmountDerivationErrors\\n * @author 0age\\n * @notice AmountDerivationErrors contains errors related to amount derivation.\\n */\\ninterface AmountDerivationErrors {\\n    /**\\n     * @dev Revert with an error when attempting to apply a fraction as part of\\n     *      a partial fill that does not divide the target amount cleanly.\\n     */\\n    error InexactFraction();\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OrderCombiner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { Side, ItemType } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    AdditionalRecipient,\\n    OfferItem,\\n    ConsiderationItem,\\n    SpentItem,\\n    ReceivedItem,\\n    OrderParameters,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Execution,\\n    Order,\\n    AdvancedOrder,\\n    CriteriaResolver\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { OrderFulfiller } from \\\"./OrderFulfiller.sol\\\";\\n\\nimport { FulfillmentApplier } from \\\"./FulfillmentApplier.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title OrderCombiner\\n * @author 0age\\n * @notice OrderCombiner contains logic for fulfilling combinations of orders,\\n *         either by matching offer items to consideration items or by\\n *         fulfilling orders where available.\\n */\\ncontract OrderCombiner is OrderFulfiller, FulfillmentApplier {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) OrderFulfiller(conduitController) {}\\n\\n    /**\\n     * @notice Internal function to attempt to fill a group of orders, fully or\\n     *         partially, with an arbitrary number of items for offer and\\n     *         consideration per order alongside criteria resolvers containing\\n     *         specific token identifiers and associated proofs. Any order that\\n     *         is not currently active, has already been fully filled, or has\\n     *         been cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or a conduit if indicated by\\n     *                                  the order) to transfer any relevant\\n     *                                  tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` in order to receive\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param criteriaResolvers         An array where each element contains a\\n     *                                  reference to a specific offer or\\n     *                                  consideration, a token identifier, and a\\n     *                                  proof that the supplied token identifier\\n     *                                  is contained in the merkle root held by\\n     *                                  the item in question's criteria element.\\n     *                                  Note that an empty criteria indicates\\n     *                                  that any (transferrable) token\\n     *                                  identifier on the token in question is\\n     *                                  valid and that no associated proof needs\\n     *                                  to be supplied.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used (and\\n     *                                  direct approvals set on Consideration).\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders.\\n     */\\n    function _fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        uint256 maximumFulfilled\\n    )\\n        internal\\n        returns (bool[] memory availableOrders, Execution[] memory executions)\\n    {\\n        // Validate orders, apply amounts, & determine if they utilize conduits.\\n        _validateOrdersAndPrepareToFulfill(\\n            advancedOrders,\\n            criteriaResolvers,\\n            false, // Signifies that invalid orders should NOT revert.\\n            maximumFulfilled\\n        );\\n\\n        // Aggregate used offer and consideration items and execute transfers.\\n        (availableOrders, executions) = _executeAvailableFulfillments(\\n            advancedOrders,\\n            offerFulfillments,\\n            considerationFulfillments,\\n            fulfillerConduitKey\\n        );\\n\\n        // Return order fulfillment details and executions.\\n        return (availableOrders, executions);\\n    }\\n\\n    /**\\n     * @dev Internal function to validate a group of orders, update their\\n     *      statuses, reduce amounts by their previously filled fractions, apply\\n     *      criteria resolvers, and emit OrderFulfilled events.\\n     *\\n     * @param advancedOrders    The advanced orders to validate and reduce by\\n     *                          their previously filled amounts.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          a root of zero indicates that any transferrable\\n     *                          token identifier is valid and that no proof\\n     *                          needs to be supplied.\\n     * @param revertOnInvalid   A boolean indicating whether to revert on any\\n     *                          order being invalid; setting this to false will\\n     *                          instead cause the invalid order to be skipped.\\n     * @param maximumFulfilled  The maximum number of orders to fulfill.\\n     */\\n    function _validateOrdersAndPrepareToFulfill(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        bool revertOnInvalid,\\n        uint256 maximumFulfilled\\n    ) internal {\\n        // Ensure this function cannot be triggered during a reentrant call.\\n        _setReentrancyGuard();\\n\\n        // Read length of orders array and place on the stack.\\n        uint256 totalOrders = advancedOrders.length;\\n\\n        // Track the order hash for each order being fulfilled.\\n        bytes32[] memory orderHashes = new bytes32[](totalOrders);\\n\\n        // Override orderHashes length to zero after memory has been allocated.\\n        assembly {\\n            mstore(orderHashes, 0)\\n        }\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over each order.\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\n                // Retrieve the current order.\\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\\n\\n                // Determine if max number orders have already been fulfilled.\\n                if (maximumFulfilled == 0) {\\n                    // Mark fill fraction as zero as the order will not be used.\\n                    advancedOrder.numerator = 0;\\n\\n                    // Update the length of the orderHashes array.\\n                    assembly {\\n                        mstore(orderHashes, add(i, 1))\\n                    }\\n\\n                    // Continue iterating through the remaining orders.\\n                    continue;\\n                }\\n\\n                // Validate it, update status, and determine fraction to fill.\\n                (\\n                    bytes32 orderHash,\\n                    uint256 numerator,\\n                    uint256 denominator\\n                ) = _validateOrderAndUpdateStatus(\\n                        advancedOrder,\\n                        criteriaResolvers,\\n                        revertOnInvalid,\\n                        orderHashes\\n                    );\\n\\n                // Update the length of the orderHashes array.\\n                assembly {\\n                    mstore(orderHashes, add(i, 1))\\n                }\\n\\n                // Do not track hash or adjust prices if order is not fulfilled.\\n                if (numerator == 0) {\\n                    // Mark fill fraction as zero if the order is not fulfilled.\\n                    advancedOrder.numerator = 0;\\n\\n                    // Continue iterating through the remaining orders.\\n                    continue;\\n                }\\n\\n                // Otherwise, track the order hash in question.\\n                orderHashes[i] = orderHash;\\n\\n                // Decrement the number of fulfilled orders.\\n                maximumFulfilled--;\\n\\n                // Place the start time for the order on the stack.\\n                uint256 startTime = advancedOrder.parameters.startTime;\\n\\n                // Derive the duration for the order and place it on the stack.\\n                uint256 duration = advancedOrder.parameters.endTime - startTime;\\n\\n                // Derive time elapsed since the order started & place on stack.\\n                uint256 elapsed = block.timestamp - startTime;\\n\\n                // Derive time remaining until order expires and place on stack.\\n                uint256 remaining = duration - elapsed;\\n\\n                // Retrieve array of offer items for the order in question.\\n                OfferItem[] memory offer = advancedOrder.parameters.offer;\\n\\n                // Iterate over each offer item on the order.\\n                for (uint256 j = 0; j < offer.length; ++j) {\\n                    // Retrieve the offer item.\\n                    OfferItem memory offerItem = offer[j];\\n\\n                    // Apply order fill fraction to offer item end amount.\\n                    uint256 endAmount = _getFraction(\\n                        numerator,\\n                        denominator,\\n                        offerItem.endAmount\\n                    );\\n\\n                    // Reuse same fraction if start and end amounts are equal.\\n                    if (offerItem.startAmount == offerItem.endAmount) {\\n                        // Apply derived amount to both start and end amount.\\n                        offerItem.startAmount = endAmount;\\n                    } else {\\n                        // Apply order fill fraction to offer item start amount.\\n                        offerItem.startAmount = _getFraction(\\n                            numerator,\\n                            denominator,\\n                            offerItem.startAmount\\n                        );\\n                    }\\n\\n                    // Update end amount in memory to match the derived amount.\\n                    offerItem.endAmount = endAmount;\\n\\n                    // Adjust offer amount using current time; round down.\\n                    offerItem.startAmount = _locateCurrentAmount(\\n                        offerItem.startAmount,\\n                        offerItem.endAmount,\\n                        elapsed,\\n                        remaining,\\n                        duration,\\n                        false // round down\\n                    );\\n                }\\n\\n                // Retrieve array of consideration items for order in question.\\n                ConsiderationItem[] memory consideration = (\\n                    advancedOrder.parameters.consideration\\n                );\\n\\n                // Iterate over each consideration item on the order.\\n                for (uint256 j = 0; j < consideration.length; ++j) {\\n                    // Retrieve the consideration item.\\n                    ConsiderationItem memory considerationItem = (\\n                        consideration[j]\\n                    );\\n\\n                    // Apply fraction to consideration item end amount.\\n                    uint256 endAmount = _getFraction(\\n                        numerator,\\n                        denominator,\\n                        considerationItem.endAmount\\n                    );\\n\\n                    // Reuse same fraction if start and end amounts are equal.\\n                    if (\\n                        considerationItem.startAmount ==\\n                        considerationItem.endAmount\\n                    ) {\\n                        // Apply derived amount to both start and end amount.\\n                        considerationItem.startAmount = endAmount;\\n                    } else {\\n                        // Apply fraction to consideration item start amount.\\n                        considerationItem.startAmount = _getFraction(\\n                            numerator,\\n                            denominator,\\n                            considerationItem.startAmount\\n                        );\\n                    }\\n\\n                    // Update end amount in memory to match the derived amount.\\n                    considerationItem.endAmount = endAmount;\\n\\n                    // Adjust consideration amount using current time; round up.\\n                    considerationItem.startAmount = (\\n                        _locateCurrentAmount(\\n                            considerationItem.startAmount,\\n                            considerationItem.endAmount,\\n                            elapsed,\\n                            remaining,\\n                            duration,\\n                            true // round up\\n                        )\\n                    );\\n\\n                    // Utilize assembly to manually \\\"shift\\\" the recipient value.\\n                    assembly {\\n                        // Write recipient to endAmount, as endAmount is not\\n                        // used from this point on and can be repurposed to fit\\n                        // the layout of a ReceivedItem.\\n                        mstore(\\n                            add(\\n                                considerationItem,\\n                                ReceivedItem_recipient_offset // old endAmount\\n                            ),\\n                            mload(\\n                                add(\\n                                    considerationItem,\\n                                    ConsiderationItem_recipient_offset\\n                                )\\n                            )\\n                        )\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Apply criteria resolvers to each order as applicable.\\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\\n\\n        // Determine the fulfiller (revertOnInvalid ? address(0) : msg.sender).\\n        address fulfiller;\\n\\n        // Utilize assembly to operate on revertOnInvalid boolean as an integer.\\n        assembly {\\n            // Set the fulfiller to the caller if revertOnValid is false.\\n            fulfiller := mul(iszero(revertOnInvalid), caller())\\n        }\\n\\n        // Emit an event for each order signifying that it has been fulfilled.\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over each order.\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\n                // Do not emit an event if no order hash is present.\\n                if (orderHashes[i] == bytes32(0)) {\\n                    continue;\\n                }\\n\\n                // Retrieve parameters for the order in question.\\n                OrderParameters memory orderParameters = (\\n                    advancedOrders[i].parameters\\n                );\\n\\n                // Emit an OrderFulfilled event.\\n                _emitOrderFulfilledEvent(\\n                    orderHashes[i],\\n                    orderParameters.offerer,\\n                    orderParameters.zone,\\n                    fulfiller,\\n                    orderParameters.offer,\\n                    orderParameters.consideration\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to fulfill a group of validated orders, fully or\\n     *      partially, with an arbitrary number of items for offer and\\n     *      consideration per order and to execute transfers. Any order that is\\n     *      not currently active, has already been fully filled, or has been\\n     *      cancelled will be omitted. Remaining offer and consideration items\\n     *      will then be aggregated where possible as indicated by the supplied\\n     *      offer and consideration component arrays and aggregated items will\\n     *      be transferred to the fulfiller or to each intended recipient,\\n     *      respectively. Note that a failing item transfer or an issue with\\n     *      order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or the conduit if indicated by\\n     *                                  the order) to transfer any relevant\\n     *                                  tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` in order to receive\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on Consideration.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders.\\n     */\\n    function _executeAvailableFulfillments(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[][] memory offerFulfillments,\\n        FulfillmentComponent[][] memory considerationFulfillments,\\n        bytes32 fulfillerConduitKey\\n    )\\n        internal\\n        returns (bool[] memory availableOrders, Execution[] memory executions)\\n    {\\n        // Retrieve length of offer fulfillments array and place on the stack.\\n        uint256 totalOfferFulfillments = offerFulfillments.length;\\n\\n        // Retrieve length of consideration fulfillments array & place on stack.\\n        uint256 totalConsiderationFulfillments = (\\n            considerationFulfillments.length\\n        );\\n\\n        // Allocate an execution for each offer and consideration fulfillment.\\n        executions = new Execution[](\\n            totalOfferFulfillments + totalConsiderationFulfillments\\n        );\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Track number of filtered executions.\\n            uint256 totalFilteredExecutions = 0;\\n\\n            // Iterate over each offer fulfillment.\\n            for (uint256 i = 0; i < totalOfferFulfillments; ++i) {\\n                /// Retrieve the offer fulfillment components in question.\\n                FulfillmentComponent[] memory components = (\\n                    offerFulfillments[i]\\n                );\\n\\n                // Derive aggregated execution corresponding with fulfillment.\\n                Execution memory execution = _aggregateAvailable(\\n                    advancedOrders,\\n                    Side.OFFER,\\n                    components,\\n                    fulfillerConduitKey\\n                );\\n\\n                // If offerer and recipient on the execution are the same...\\n                if (execution.item.recipient == execution.offerer) {\\n                    // increment total filtered executions.\\n                    totalFilteredExecutions += 1;\\n                } else {\\n                    // Otherwise, assign the execution to the executions array.\\n                    executions[i - totalFilteredExecutions] = execution;\\n                }\\n            }\\n\\n            // Iterate over each consideration fulfillment.\\n            for (uint256 i = 0; i < totalConsiderationFulfillments; ++i) {\\n                /// Retrieve consideration fulfillment components in question.\\n                FulfillmentComponent[] memory components = (\\n                    considerationFulfillments[i]\\n                );\\n\\n                // Derive aggregated execution corresponding with fulfillment.\\n                Execution memory execution = _aggregateAvailable(\\n                    advancedOrders,\\n                    Side.CONSIDERATION,\\n                    components,\\n                    fulfillerConduitKey\\n                );\\n\\n                // If offerer and recipient on the execution are the same...\\n                if (execution.item.recipient == execution.offerer) {\\n                    // increment total filtered executions.\\n                    totalFilteredExecutions += 1;\\n                } else {\\n                    // Otherwise, assign the execution to the executions array.\\n                    executions[\\n                        i + totalOfferFulfillments - totalFilteredExecutions\\n                    ] = execution;\\n                }\\n            }\\n\\n            // If some number of executions have been filtered...\\n            if (totalFilteredExecutions != 0) {\\n                // reduce the total length of the executions array.\\n                assembly {\\n                    mstore(\\n                        executions,\\n                        sub(mload(executions), totalFilteredExecutions)\\n                    )\\n                }\\n            }\\n        }\\n\\n        // Revert if no orders are available.\\n        if (executions.length == 0) {\\n            revert NoSpecifiedOrdersAvailable();\\n        }\\n\\n        // Perform final checks and return.\\n        availableOrders = _performFinalChecksAndExecuteOrders(\\n            advancedOrders,\\n            executions\\n        );\\n\\n        return (availableOrders, executions);\\n    }\\n\\n    /**\\n     * @dev Internal function to perform a final check that each consideration\\n     *      item for an arbitrary number of fulfilled orders has been met and to\\n     *      trigger associated executions, transferring the respective items.\\n     *\\n     * @param advancedOrders     The orders to check and perform executions for.\\n     * @param executions         An array of elements indicating the sequence of\\n     *                           transfers to perform when fulfilling the given\\n     *                           orders.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     */\\n    function _performFinalChecksAndExecuteOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        Execution[] memory executions\\n    ) internal returns (bool[] memory availableOrders) {\\n        // Retrieve the length of the advanced orders array and place on stack.\\n        uint256 totalOrders = advancedOrders.length;\\n\\n        // Initialize array for tracking available orders.\\n        availableOrders = new bool[](totalOrders);\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over orders to ensure all considerations are met.\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\n                // Retrieve the order in question.\\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\\n\\n                // Skip consideration item checks for order if not fulfilled.\\n                if (advancedOrder.numerator == 0) {\\n                    // Note: orders do not need to be marked as unavailable as a\\n                    // new memory region has been allocated. Review carefully if\\n                    // altering compiler version or managing memory manually.\\n                    continue;\\n                }\\n\\n                // Mark the order as available.\\n                availableOrders[i] = true;\\n\\n                // Retrieve consideration items to ensure they are fulfilled.\\n                ConsiderationItem[] memory consideration = (\\n                    advancedOrder.parameters.consideration\\n                );\\n\\n                // Iterate over each consideration item to ensure it is met.\\n                for (uint256 j = 0; j < consideration.length; ++j) {\\n                    // Retrieve remaining amount on the consideration item.\\n                    uint256 unmetAmount = consideration[j].startAmount;\\n\\n                    // Revert if the remaining amount is not zero.\\n                    if (unmetAmount != 0) {\\n                        revert ConsiderationNotMet(i, j, unmetAmount);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Put ether value supplied by the caller on the stack.\\n        uint256 etherRemaining = msg.value;\\n\\n        // Initialize an accumulator array. From this point forward, no new\\n        // memory regions can be safely allocated until the accumulator is no\\n        // longer being utilized, as the accumulator operates in an open-ended\\n        // fashion from this memory pointer; existing memory may still be\\n        // accessed and modified, however.\\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\\n\\n        // Iterate over each execution.\\n        for (uint256 i = 0; i < executions.length; ) {\\n            // Retrieve the execution and the associated received item.\\n            Execution memory execution = executions[i];\\n            ReceivedItem memory item = execution.item;\\n\\n            // If execution transfers native tokens, reduce value available.\\n            if (item.itemType == ItemType.NATIVE) {\\n                // Ensure that sufficient native tokens are still available.\\n                if (item.amount > etherRemaining) {\\n                    revert InsufficientEtherSupplied();\\n                }\\n\\n                // Skip underflow check as amount is less than ether remaining.\\n                unchecked {\\n                    etherRemaining -= item.amount;\\n                }\\n            }\\n\\n            // Transfer the item specified by the execution.\\n            _transfer(\\n                item,\\n                execution.offerer,\\n                execution.conduitKey,\\n                accumulator\\n            );\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Trigger any remaining accumulated transfers via call to the conduit.\\n        _triggerIfArmed(accumulator);\\n\\n        // If any ether remains after fulfillments, return it to the caller.\\n        if (etherRemaining != 0) {\\n            _transferEth(payable(msg.sender), etherRemaining);\\n        }\\n\\n        // Clear the reentrancy guard.\\n        _clearReentrancyGuard();\\n\\n        // Return the array containing available orders.\\n        return (availableOrders);\\n    }\\n\\n    /**\\n     * @dev Internal function to match an arbitrary number of full or partial\\n     *      orders, each with an arbitrary number of items for offer and\\n     *      consideration, supplying criteria resolvers containing specific\\n     *      token identifiers and associated proofs as well as fulfillments\\n     *      allocating offer components to consideration components.\\n     *\\n     * @param advancedOrders    The advanced orders to match. Note that both the\\n     *                          offerer and fulfiller on each order must first\\n     *                          approve this contract (or their conduit if\\n     *                          indicated by the order) to transfer any relevant\\n     *                          tokens on their behalf and each consideration\\n     *                          recipient must implement `onERC1155Received` in\\n     *                          order to receive ERC1155 tokens. Also note that\\n     *                          the offer and consideration components for each\\n     *                          order must have no remainder after multiplying\\n     *                          the respective amount with the supplied fraction\\n     *                          in order for the group of partial fills to be\\n     *                          considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          an empty root indicates that any (transferrable)\\n     *                          token identifier is valid and that no associated\\n     *                          proof needs to be supplied.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function _matchAdvancedOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        Fulfillment[] calldata fulfillments\\n    ) internal returns (Execution[] memory executions) {\\n        // Validate orders, update order status, and determine item amounts.\\n        _validateOrdersAndPrepareToFulfill(\\n            advancedOrders,\\n            criteriaResolvers,\\n            true, // Signifies that invalid orders should revert.\\n            advancedOrders.length\\n        );\\n\\n        // Fulfill the orders using the supplied fulfillments.\\n        return _fulfillAdvancedOrders(advancedOrders, fulfillments);\\n    }\\n\\n    /**\\n     * @dev Internal function to fulfill an arbitrary number of orders, either\\n     *      full or partial, after validating, adjusting amounts, and applying\\n     *      criteria resolvers.\\n     *\\n     * @param advancedOrders     The orders to match, including a fraction to\\n     *                           attempt to fill for each order.\\n     * @param fulfillments       An array of elements allocating offer\\n     *                           components to consideration components. Note\\n     *                           that the final amount of each consideration\\n     *                           component must be zero for a match operation to\\n     *                           be considered valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function _fulfillAdvancedOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        Fulfillment[] calldata fulfillments\\n    ) internal returns (Execution[] memory executions) {\\n        // Retrieve fulfillments array length and place on the stack.\\n        uint256 totalFulfillments = fulfillments.length;\\n\\n        // Allocate executions by fulfillment and apply them to each execution.\\n        executions = new Execution[](totalFulfillments);\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Track number of filtered executions.\\n            uint256 totalFilteredExecutions = 0;\\n\\n            // Iterate over each fulfillment.\\n            for (uint256 i = 0; i < totalFulfillments; ++i) {\\n                /// Retrieve the fulfillment in question.\\n                Fulfillment calldata fulfillment = fulfillments[i];\\n\\n                // Derive the execution corresponding with the fulfillment.\\n                Execution memory execution = _applyFulfillment(\\n                    advancedOrders,\\n                    fulfillment.offerComponents,\\n                    fulfillment.considerationComponents\\n                );\\n\\n                // If offerer and recipient on the execution are the same...\\n                if (execution.item.recipient == execution.offerer) {\\n                    // increment total filtered executions.\\n                    totalFilteredExecutions += 1;\\n                } else {\\n                    // Otherwise, assign the execution to the executions array.\\n                    executions[i - totalFilteredExecutions] = execution;\\n                }\\n            }\\n\\n            // If some number of executions have been filtered...\\n            if (totalFilteredExecutions != 0) {\\n                // reduce the total length of the executions array.\\n                assembly {\\n                    mstore(\\n                        executions,\\n                        sub(mload(executions), totalFilteredExecutions)\\n                    )\\n                }\\n            }\\n        }\\n\\n        // Perform final checks and execute orders.\\n        _performFinalChecksAndExecuteOrders(advancedOrders, executions);\\n\\n        // Return the executions array.\\n        return (executions);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Consideration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport {\\n    ConsiderationInterface\\n} from \\\"./interfaces/ConsiderationInterface.sol\\\";\\n\\nimport {\\n    OrderComponents,\\n    BasicOrderParameters,\\n    OrderParameters,\\n    Order,\\n    AdvancedOrder,\\n    OrderStatus,\\n    CriteriaResolver,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Execution\\n} from \\\"./lib/ConsiderationStructs.sol\\\";\\n\\nimport { OrderCombiner } from \\\"./lib/OrderCombiner.sol\\\";\\n\\n/**\\n * @title Consideration\\n * @author 0age\\n * @custom:coauthor d1ll0n\\n * @custom:coauthor transmissions11\\n * @custom:version 1\\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.\\n *         It minimizes external calls to the greatest extent possible and\\n *         provides lightweight methods for common routes as well as more\\n *         flexible methods for composing advanced orders or groups of orders.\\n *         Each order contains an arbitrary number of items that may be spent\\n *         (the \\\"offer\\\") along with an arbitrary number of items that must be\\n *         received back by the indicated recipients (the \\\"consideration\\\").\\n */\\ncontract Consideration is ConsiderationInterface, OrderCombiner {\\n    /**\\n     * @notice Derive and set hashes, reference chainId, and associated domain\\n     *         separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) OrderCombiner(conduitController) {}\\n\\n    /**\\n     * @notice Fulfill an order offering an ERC20, ERC721, or ERC1155 item by\\n     *         supplying Ether (or other native tokens), ERC20 tokens, an ERC721\\n     *         item, or an ERC1155 item as consideration. Six permutations are\\n     *         supported: Native token to ERC721, Native token to ERC1155, ERC20\\n     *         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to\\n     *         ERC20 (with native tokens supplied as msg.value). For an order to\\n     *         be eligible for fulfillment via this method, it must contain a\\n     *         single offer item (though that item may have a greater amount if\\n     *         the item is not an ERC721). An arbitrary number of \\\"additional\\n     *         recipients\\\" may also be supplied which will each receive native\\n     *         tokens or ERC20 items from the fulfiller as consideration. Refer\\n     *         to the documentation for a more comprehensive summary of how to\\n     *         utilize this method and what orders are compatible with it.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer and the fulfiller must first approve\\n     *                   this contract (or their chosen conduit if indicated)\\n     *                   before any tokens can be transferred. Also note that\\n     *                   contract recipients of ERC1155 consideration items must\\n     *                   implement `onERC1155Received` in order to receive those\\n     *                   items.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillBasicOrder(BasicOrderParameters calldata parameters)\\n        external\\n        payable\\n        override\\n        returns (bool fulfilled)\\n    {\\n        // Validate and fulfill the basic order.\\n        fulfilled = _validateAndFulfillBasicOrder(parameters);\\n    }\\n\\n    /**\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\n     *         consideration. Note that this function does not support\\n     *         criteria-based orders or partial filling of orders (though\\n     *         filling the remainder of a partially-filled order is supported).\\n     *\\n     * @param order               The order to fulfill. Note that both the\\n     *                            offerer and the fulfiller must first approve\\n     *                            this contract (or the corresponding conduit if\\n     *                            indicated) to transfer any relevant tokens on\\n     *                            their behalf and that contracts must implement\\n     *                            `onERC1155Received` to receive ERC1155 tokens\\n     *                            as consideration.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used (and direct approvals set on\\n     *                            Consideration).\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillOrder(Order calldata order, bytes32 fulfillerConduitKey)\\n        external\\n        payable\\n        override\\n        returns (bool fulfilled)\\n    {\\n        // Convert order to \\\"advanced\\\" order, then validate and fulfill it.\\n        fulfilled = _validateAndFulfillAdvancedOrder(\\n            _convertOrderToAdvanced(order),\\n            new CriteriaResolver[](0), // No criteria resolvers supplied.\\n            fulfillerConduitKey\\n        );\\n    }\\n\\n    /**\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\n     *         items for offer and consideration alongside criteria resolvers\\n     *         containing specific token identifiers and associated proofs.\\n     *\\n     * @param advancedOrder       The order to fulfill along with the fraction\\n     *                            of the order to attempt to fill. Note that\\n     *                            both the offerer and the fulfiller must first\\n     *                            approve this contract (or their conduit if\\n     *                            indicated by the order) to transfer any\\n     *                            relevant tokens on their behalf and that\\n     *                            contracts must implement `onERC1155Received`\\n     *                            to receive ERC1155 tokens as consideration.\\n     *                            Also note that all offer and consideration\\n     *                            components must have no remainder after\\n     *                            multiplication of the respective amount with\\n     *                            the supplied fraction for the partial fill to\\n     *                            be considered valid.\\n     * @param criteriaResolvers   An array where each element contains a\\n     *                            reference to a specific offer or\\n     *                            consideration, a token identifier, and a proof\\n     *                            that the supplied token identifier is\\n     *                            contained in the merkle root held by the item\\n     *                            in question's criteria element. Note that an\\n     *                            empty criteria indicates that any\\n     *                            (transferrable) token identifier on the token\\n     *                            in question is valid and that no associated\\n     *                            proof needs to be supplied.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used (and direct approvals set on\\n     *                            Consideration).\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillAdvancedOrder(\\n        AdvancedOrder calldata advancedOrder,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        bytes32 fulfillerConduitKey\\n    ) external payable override returns (bool fulfilled) {\\n        // Validate and fulfill the order.\\n        fulfilled = _validateAndFulfillAdvancedOrder(\\n            advancedOrder,\\n            criteriaResolvers,\\n            fulfillerConduitKey\\n        );\\n    }\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\\n     *         of items for offer and consideration. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *         Note that this function does not support criteria-based orders or\\n     *         partial filling of orders (though filling the remainder of a\\n     *         partially-filled order is supported).\\n     *\\n     * @param orders                    The orders to fulfill. Note that both\\n     *                                  the offerer and the fulfiller must first\\n     *                                  approve this contract (or the\\n     *                                  corresponding conduit if indicated) to\\n     *                                  transfer any relevant tokens on their\\n     *                                  behalf and that contracts must implement\\n     *                                  `onERC1155Received` to receive ERC1155\\n     *                                  tokens as consideration.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used (and\\n     *                                  direct approvals set on Consideration).\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders.\\n     */\\n    function fulfillAvailableOrders(\\n        Order[] calldata orders,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        override\\n        returns (bool[] memory availableOrders, Execution[] memory executions)\\n    {\\n        // Convert orders to \\\"advanced\\\" orders and fulfill all available orders.\\n        return\\n            _fulfillAvailableAdvancedOrders(\\n                _convertOrdersToAdvanced(orders), // Convert to advanced orders.\\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\\n                offerFulfillments,\\n                considerationFulfillments,\\n                fulfillerConduitKey,\\n                maximumFulfilled\\n            );\\n    }\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\n     *         arbitrary number of items for offer and consideration per order\\n     *         alongside criteria resolvers containing specific token\\n     *         identifiers and associated proofs. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or their conduit if indicated\\n     *                                  by the order) to transfer any relevant\\n     *                                  tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` in order to receive\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param criteriaResolvers         An array where each element contains a\\n     *                                  reference to a specific offer or\\n     *                                  consideration, a token identifier, and a\\n     *                                  proof that the supplied token identifier\\n     *                                  is contained in the merkle root held by\\n     *                                  the item in question's criteria element.\\n     *                                  Note that an empty criteria indicates\\n     *                                  that any (transferrable) token\\n     *                                  identifier on the token in question is\\n     *                                  valid and that no associated proof needs\\n     *                                  to be supplied.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used (and\\n     *                                  direct approvals set on Consideration).\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        override\\n        returns (bool[] memory availableOrders, Execution[] memory executions)\\n    {\\n        // Fulfill all available orders.\\n        return\\n            _fulfillAvailableAdvancedOrders(\\n                advancedOrders,\\n                criteriaResolvers,\\n                offerFulfillments,\\n                considerationFulfillments,\\n                fulfillerConduitKey,\\n                maximumFulfilled\\n            );\\n    }\\n\\n    /**\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\n     *         number of items for offer and consideration along with a set of\\n     *         fulfillments allocating offer components to consideration\\n     *         components. Note that this function does not support\\n     *         criteria-based or partial filling of orders (though filling the\\n     *         remainder of a partially-filled order is supported).\\n     *\\n     * @param orders            The orders to match. Note that both the offerer\\n     *                          and fulfiller on each order must first approve\\n     *                          this contract (or their conduit if indicated by\\n     *                          the order) to transfer any relevant tokens on\\n     *                          their behalf and each consideration recipient\\n     *                          must implement `onERC1155Received` in order to\\n     *                          receive ERC1155 tokens.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function matchOrders(\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable override returns (Execution[] memory executions) {\\n        // Convert to advanced, validate, and match orders using fulfillments.\\n        return\\n            _matchAdvancedOrders(\\n                _convertOrdersToAdvanced(orders),\\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\\n                fulfillments\\n            );\\n    }\\n\\n    /**\\n     * @notice Match an arbitrary number of full or partial orders, each with an\\n     *         arbitrary number of items for offer and consideration, supplying\\n     *         criteria resolvers containing specific token identifiers and\\n     *         associated proofs as well as fulfillments allocating offer\\n     *         components to consideration components.\\n     *\\n     * @param advancedOrders    The advanced orders to match. Note that both the\\n     *                          offerer and fulfiller on each order must first\\n     *                          approve this contract (or their conduit if\\n     *                          indicated by the order) to transfer any relevant\\n     *                          tokens on their behalf and each consideration\\n     *                          recipient must implement `onERC1155Received` in\\n     *                          order to receive ERC1155 tokens. Also note that\\n     *                          the offer and consideration components for each\\n     *                          order must have no remainder after multiplying\\n     *                          the respective amount with the supplied fraction\\n     *                          in order for the group of partial fills to be\\n     *                          considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          an empty root indicates that any (transferrable)\\n     *                          token identifier is valid and that no associated\\n     *                          proof needs to be supplied.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function matchAdvancedOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable override returns (Execution[] memory executions) {\\n        // Validate and match the advanced orders using supplied fulfillments.\\n        return\\n            _matchAdvancedOrders(\\n                advancedOrders,\\n                criteriaResolvers,\\n                fulfillments\\n            );\\n    }\\n\\n    /**\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\n     *         or the zone of a given order may cancel it. Callers should ensure\\n     *         that the intended order was cancelled by calling `getOrderStatus`\\n     *         and confirming that `isCancelled` returns `true`.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders have\\n     *                   been successfully cancelled.\\n     */\\n    function cancel(OrderComponents[] calldata orders)\\n        external\\n        override\\n        returns (bool cancelled)\\n    {\\n        // Cancel the orders.\\n        cancelled = _cancel(orders);\\n    }\\n\\n    /**\\n     * @notice Validate an arbitrary number of orders, thereby registering their\\n     *         signatures as valid and allowing the fulfiller to skip signature\\n     *         verification on fulfillment. Note that validated orders may still\\n     *         be unfulfillable due to invalid item amounts or other factors;\\n     *         callers should determine whether validated orders are fulfillable\\n     *         by simulating the fulfillment call prior to execution. Also note\\n     *         that anyone can validate a signed order, but only the offerer can\\n     *         validate an order without supplying a signature.\\n     *\\n     * @param orders The orders to validate.\\n     *\\n     * @return validated A boolean indicating whether the supplied orders have\\n     *                   been successfully validated.\\n     */\\n    function validate(Order[] calldata orders)\\n        external\\n        override\\n        returns (bool validated)\\n    {\\n        // Validate the orders.\\n        validated = _validate(orders);\\n    }\\n\\n    /**\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\n     *         by incrementing a nonce. Note that only the offerer may increment\\n     *         the nonce.\\n     *\\n     * @return newNonce The new nonce.\\n     */\\n    function incrementNonce() external override returns (uint256 newNonce) {\\n        // Increment current nonce for the supplied offerer.\\n        newNonce = _incrementNonce();\\n    }\\n\\n    /**\\n     * @notice Retrieve the order hash for a given order.\\n     *\\n     * @param order The components of the order.\\n     *\\n     * @return orderHash The order hash.\\n     */\\n    function getOrderHash(OrderComponents calldata order)\\n        external\\n        view\\n        override\\n        returns (bytes32 orderHash)\\n    {\\n        // Derive order hash by supplying order parameters along with the nonce.\\n        orderHash = _deriveOrderHash(\\n            OrderParameters(\\n                order.offerer,\\n                order.zone,\\n                order.offer,\\n                order.consideration,\\n                order.orderType,\\n                order.startTime,\\n                order.endTime,\\n                order.zoneHash,\\n                order.salt,\\n                order.conduitKey,\\n                order.consideration.length\\n            ),\\n            order.nonce\\n        );\\n    }\\n\\n    /**\\n     * @notice Retrieve the status of a given order by hash, including whether\\n     *         the order has been cancelled or validated and the fraction of the\\n     *         order that has been filled.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function getOrderStatus(bytes32 orderHash)\\n        external\\n        view\\n        override\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        )\\n    {\\n        // Retrieve the order status using the order hash.\\n        return _getOrderStatus(orderHash);\\n    }\\n\\n    /**\\n     * @notice Retrieve the current nonce for a given offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return nonce The current nonce.\\n     */\\n    function getNonce(address offerer)\\n        external\\n        view\\n        override\\n        returns (uint256 nonce)\\n    {\\n        // Return the nonce for the supplied offerer.\\n        nonce = _getNonce(offerer);\\n    }\\n\\n    /**\\n     * @notice Retrieve configuration information for this contract.\\n     *\\n     * @return version           The contract version.\\n     * @return domainSeparator   The domain separator for this contract.\\n     * @return conduitController The conduit Controller set for this contract.\\n     */\\n    function information()\\n        external\\n        view\\n        override\\n        returns (\\n            string memory version,\\n            bytes32 domainSeparator,\\n            address conduitController\\n        )\\n    {\\n        // Return the information for this contract.\\n        return _information();\\n    }\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return contractName The name of this contract.\\n     */\\n    function name()\\n        external\\n        pure\\n        override\\n        returns (string memory contractName)\\n    {\\n        // Return the name of the contract.\\n        contractName = _name();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ConsiderationInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport {\\n    BasicOrderParameters,\\n    OrderComponents,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Execution,\\n    Order,\\n    AdvancedOrder,\\n    OrderStatus,\\n    CriteriaResolver\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title ConsiderationInterface\\n * @author 0age\\n * @custom:version 1\\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.\\n *         It minimizes external calls to the greatest extent possible and\\n *         provides lightweight methods for common routes as well as more\\n *         flexible methods for composing advanced orders.\\n *\\n * @dev ConsiderationInterface contains all external function interfaces for\\n *      Consideration.\\n */\\ninterface ConsiderationInterface {\\n    /**\\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\\n     *         the native token for the given chain) as consideration for the\\n     *         order. An arbitrary number of \\\"additional recipients\\\" may also be\\n     *         supplied which will each receive native tokens from the fulfiller\\n     *         as consideration.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer must first approve this contract (or\\n     *                   their preferred conduit if indicated by the order) for\\n     *                   their offered ERC721 token to be transferred.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillBasicOrder(BasicOrderParameters calldata parameters)\\n        external\\n        payable\\n        returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\n     *         consideration. Note that this function does not support\\n     *         criteria-based orders or partial filling of orders (though\\n     *         filling the remainder of a partially-filled order is supported).\\n     *\\n     * @param order               The order to fulfill. Note that both the\\n     *                            offerer and the fulfiller must first approve\\n     *                            this contract (or the corresponding conduit if\\n     *                            indicated) to transfer any relevant tokens on\\n     *                            their behalf and that contracts must implement\\n     *                            `onERC1155Received` to receive ERC1155 tokens\\n     *                            as consideration.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillOrder(Order calldata order, bytes32 fulfillerConduitKey)\\n        external\\n        payable\\n        returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\n     *         items for offer and consideration alongside criteria resolvers\\n     *         containing specific token identifiers and associated proofs.\\n     *\\n     * @param advancedOrder       The order to fulfill along with the fraction\\n     *                            of the order to attempt to fill. Note that\\n     *                            both the offerer and the fulfiller must first\\n     *                            approve this contract (or their preferred\\n     *                            conduit if indicated by the order) to transfer\\n     *                            any relevant tokens on their behalf and that\\n     *                            contracts must implement `onERC1155Received`\\n     *                            to receive ERC1155 tokens as consideration.\\n     *                            Also note that all offer and consideration\\n     *                            components must have no remainder after\\n     *                            multiplication of the respective amount with\\n     *                            the supplied fraction for the partial fill to\\n     *                            be considered valid.\\n     * @param criteriaResolvers   An array where each element contains a\\n     *                            reference to a specific offer or\\n     *                            consideration, a token identifier, and a proof\\n     *                            that the supplied token identifier is\\n     *                            contained in the merkle root held by the item\\n     *                            in question's criteria element. Note that an\\n     *                            empty criteria indicates that any\\n     *                            (transferrable) token identifier on the token\\n     *                            in question is valid and that no associated\\n     *                            proof needs to be supplied.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillAdvancedOrder(\\n        AdvancedOrder calldata advancedOrder,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        bytes32 fulfillerConduitKey\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\\n     *         of items for offer and consideration. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *         Note that this function does not support criteria-based orders or\\n     *         partial filling of orders (though filling the remainder of a\\n     *         partially-filled order is supported).\\n     *\\n     * @param orders                    The orders to fulfill. Note that both\\n     *                                  the offerer and the fulfiller must first\\n     *                                  approve this contract (or the\\n     *                                  corresponding conduit if indicated) to\\n     *                                  transfer any relevant tokens on their\\n     *                                  behalf and that contracts must implement\\n     *                                  `onERC1155Received` to receive ERC1155\\n     *                                  tokens as consideration.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders.\\n     */\\n    function fulfillAvailableOrders(\\n        Order[] calldata orders,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\n     *         arbitrary number of items for offer and consideration per order\\n     *         alongside criteria resolvers containing specific token\\n     *         identifiers and associated proofs. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or their preferred conduit if\\n     *                                  indicated by the order) to transfer any\\n     *                                  relevant tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` to enable receipt of\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param criteriaResolvers         An array where each element contains a\\n     *                                  reference to a specific offer or\\n     *                                  consideration, a token identifier, and a\\n     *                                  proof that the supplied token identifier\\n     *                                  is contained in the merkle root held by\\n     *                                  the item in question's criteria element.\\n     *                                  Note that an empty criteria indicates\\n     *                                  that any (transferrable) token\\n     *                                  identifier on the token in question is\\n     *                                  valid and that no associated proof needs\\n     *                                  to be supplied.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] calldata advancedOrders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\n     *         number of items for offer and consideration along with as set of\\n     *         fulfillments allocating offer components to consideration\\n     *         components. Note that this function does not support\\n     *         criteria-based or partial filling of orders (though filling the\\n     *         remainder of a partially-filled order is supported).\\n     *\\n     * @param orders       The orders to match. Note that both the offerer and\\n     *                     fulfiller on each order must first approve this\\n     *                     contract (or their conduit if indicated by the order)\\n     *                     to transfer any relevant tokens on their behalf and\\n     *                     each consideration recipient must implement\\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\\n     * @param fulfillments An array of elements allocating offer components to\\n     *                     consideration components. Note that each\\n     *                     consideration component must be fully met for the\\n     *                     match operation to be valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function matchOrders(\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of full or partial orders, each with an\\n     *         arbitrary number of items for offer and consideration, supplying\\n     *         criteria resolvers containing specific token identifiers and\\n     *         associated proofs as well as fulfillments allocating offer\\n     *         components to consideration components.\\n     *\\n     * @param orders            The advanced orders to match. Note that both the\\n     *                          offerer and fulfiller on each order must first\\n     *                          approve this contract (or a preferred conduit if\\n     *                          indicated by the order) to transfer any relevant\\n     *                          tokens on their behalf and each consideration\\n     *                          recipient must implement `onERC1155Received` in\\n     *                          order toreceive ERC1155 tokens. Also note that\\n     *                          the offer and consideration components for each\\n     *                          order must have no remainder after multiplying\\n     *                          the respective amount with the supplied fraction\\n     *                          in order for the group of partial fills to be\\n     *                          considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          an empty root indicates that any (transferrable)\\n     *                          token identifier is valid and that no associated\\n     *                          proof needs to be supplied.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function matchAdvancedOrders(\\n        AdvancedOrder[] calldata orders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\n     *         or the zone of a given order may cancel it. Callers should ensure\\n     *         that the intended order was cancelled by calling `getOrderStatus`\\n     *         and confirming that `isCancelled` returns `true`.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders have\\n     *                   been successfully cancelled.\\n     */\\n    function cancel(OrderComponents[] calldata orders)\\n        external\\n        returns (bool cancelled);\\n\\n    /**\\n     * @notice Validate an arbitrary number of orders, thereby registering their\\n     *         signatures as valid and allowing the fulfiller to skip signature\\n     *         verification on fulfillment. Note that validated orders may still\\n     *         be unfulfillable due to invalid item amounts or other factors;\\n     *         callers should determine whether validated orders are fulfillable\\n     *         by simulating the fulfillment call prior to execution. Also note\\n     *         that anyone can validate a signed order, but only the offerer can\\n     *         validate an order without supplying a signature.\\n     *\\n     * @param orders The orders to validate.\\n     *\\n     * @return validated A boolean indicating whether the supplied orders have\\n     *                   been successfully validated.\\n     */\\n    function validate(Order[] calldata orders)\\n        external\\n        returns (bool validated);\\n\\n    /**\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\n     *         by incrementing a nonce. Note that only the offerer may increment\\n     *         the nonce.\\n     *\\n     * @return newNonce The new nonce.\\n     */\\n    function incrementNonce() external returns (uint256 newNonce);\\n\\n    /**\\n     * @notice Retrieve the order hash for a given order.\\n     *\\n     * @param order The components of the order.\\n     *\\n     * @return orderHash The order hash.\\n     */\\n    function getOrderHash(OrderComponents calldata order)\\n        external\\n        view\\n        returns (bytes32 orderHash);\\n\\n    /**\\n     * @notice Retrieve the status of a given order by hash, including whether\\n     *         the order has been cancelled or validated and the fraction of the\\n     *         order that has been filled.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function getOrderStatus(bytes32 orderHash)\\n        external\\n        view\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        );\\n\\n    /**\\n     * @notice Retrieve the current nonce for a given offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return nonce The current nonce.\\n     */\\n    function getNonce(address offerer) external view returns (uint256 nonce);\\n\\n    /**\\n     * @notice Retrieve configuration information for this contract.\\n     *\\n     * @return version           The contract version.\\n     * @return domainSeparator   The domain separator for this contract.\\n     * @return conduitController The conduit Controller set for this contract.\\n     */\\n    function information()\\n        external\\n        view\\n        returns (\\n            string memory version,\\n            bytes32 domainSeparator,\\n            address conduitController\\n        );\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return contractName The name of this contract.\\n     */\\n    function name() external view returns (string memory contractName);\\n}\\n\"\r\n    },\r\n    \"contracts/Seaport.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport { Consideration } from \\\"./Consideration.sol\\\";\\n\\n/**\\n * @title Seaport\\n * @author 0age\\n * @custom:coauthor d1ll0n\\n * @custom:coauthor transmissions11\\n * @custom:version 1\\n * @notice Seaport is a generalized ETH/ERC20/ERC721/ERC1155 marketplace. It\\n *         minimizes external calls to the greatest extent possible and provides\\n *         lightweight methods for common routes as well as more flexible\\n *         methods for composing advanced orders or groups of orders. Each order\\n *         contains an arbitrary number of items that may be spent (the \\\"offer\\\")\\n *         along with an arbitrary number of items that must be received back by\\n *         the indicated recipients (the \\\"consideration\\\").\\n */\\ncontract Seaport is Consideration {\\n    /**\\n     * @notice Derive and set hashes, reference chainId, and associated domain\\n     *         separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) Consideration(conduitController) {}\\n\\n    /**\\n     * @dev Internal pure function to retrieve and return the name of this\\n     *      contract.\\n     *\\n     * @return The name of this contract.\\n     */\\n    function _name() internal pure override returns (string memory) {\\n        // Return the name of the contract.\\n        assembly {\\n            mstore(0, 0x20)\\n            mstore(0x27, 0x07536561706f7274)\\n            return(0, 0x60)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to retrieve the name of this contract as a\\n     *      string that will be used to derive the name hash in the constructor.\\n     *\\n     * @return The name of this contract as a string.\\n     */\\n    function _nameString() internal pure override returns (string memory) {\\n        // Return the name of the contract.\\n        return \\\"Seaport\\\";\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 15000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduitController\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadContractSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadFraction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BadReturnValueFromERC20OnTransfer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"BadSignatureV\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConsiderationCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfallAmount\",\"type\":\"uint256\"}],\"name\":\"ConsiderationNotMet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CriteriaNotEnabledForItem\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"identifiers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"ERC1155BatchTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InexactFraction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientEtherSupplied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBasicOrderParameterEncoding\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidCallToConduit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCanceller\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidConduit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidERC721TransferAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFulfillmentComponentData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InvalidMsgValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidRestrictedOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MismatchedFulfillmentOfferAndConsiderationComponents\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"MissingFulfillmentComponentOnAggregation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingItemAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingOriginalConsiderationItems\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NoContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoReentrantCalls\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSpecifiedOrdersAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferAndConsiderationRequiredOnFulfillment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderAlreadyFilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OrderCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderIsCancelled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderPartiallyFilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartialFillsNotEnabledForOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnresolvedConsiderationCriteria\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnresolvedOfferCriteria\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newNonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"NonceIncremented\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fulfiller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct SpentItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct ReceivedItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"}],\"name\":\"OrderFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"}],\"name\":\"OrderValidated\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderComponents[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder\",\"name\":\"advancedOrder\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"criteriaResolvers\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"}],\"name\":\"fulfillAdvancedOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"advancedOrders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"criteriaResolvers\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"offerFulfillments\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"considerationFulfillments\",\"type\":\"tuple[][]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maximumFulfilled\",\"type\":\"uint256\"}],\"name\":\"fulfillAvailableAdvancedOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"availableOrders\",\"type\":\"bool[]\"},{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"executions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"offerFulfillments\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"considerationFulfillments\",\"type\":\"tuple[][]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maximumFulfilled\",\"type\":\"uint256\"}],\"name\":\"fulfillAvailableOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"availableOrders\",\"type\":\"bool[]\"},{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"executions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"considerationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"considerationIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"offerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum BasicOrderType\",\"name\":\"basicOrderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"offererConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalAdditionalRecipients\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct AdditionalRecipient[]\",\"name\":\"additionalRecipients\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct BasicOrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"fulfillBasicOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"}],\"name\":\"fulfillOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderComponents\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"getOrderStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValidated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCancelled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalFilled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incrementNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newNonce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"information\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduitController\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"advancedOrders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"criteriaResolvers\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"offerComponents\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"considerationComponents\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fulfillment[]\",\"name\":\"fulfillments\",\"type\":\"tuple[]\"}],\"name\":\"matchAdvancedOrders\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"executions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"offerComponents\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"considerationComponents\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fulfillment[]\",\"name\":\"fulfillments\",\"type\":\"tuple[]\"}],\"name\":\"matchOrders\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"executions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"validated\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Seaport","CompilerVersion":"v0.8.13+commit.abaa5c0e","OptimizationUsed":"1","Runs":"15000","ConstructorArguments":"00000000000000000000000000000000006cE100a8b5eD8eDf18ceeF9e500697","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://172d3cee2d5e82e6527b51be3ef04a08b90aaf51e21707f9aaae262b4770c3c6"}]