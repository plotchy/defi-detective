[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lib/graphics/SVGWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"../Base64.sol\\\";\\r\\nimport \\\"./ISVGWrapper.sol\\\";\\r\\n\\r\\ncontract SVGWrapper is ISVGWrapper {\\r\\n    bytes public constant SVG_URI_PREFIX = \\\"data:image/svg+xml;base64,\\\";\\r\\n\\r\\n    function getWrappedImage(\\r\\n        string memory imageUri,\\r\\n        uint256 canonicalWidth,\\r\\n        uint256 canonicalHeight\\r\\n    ) public pure virtual returns (string memory imageDataUri) {\\r\\n        string memory imageData = string(\\r\\n            abi.encodePacked(\\r\\n                '<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 ',\\r\\n                Strings.toString(canonicalWidth),\\r\\n                \\\" \\\",\\r\\n                Strings.toString(canonicalHeight),\\r\\n                '\\\" x=\\\"0\\\" y=\\\"0\\\" width=\\\"100%\\\" height=\\\"100%\\\" style=\\\"',\\r\\n                \\\"image-rendering:pixelated;image-rendering:-moz-crisp-edges;-ms-interpolation-mode:nearest-neighbor;\\\",\\r\\n                \\\"background-color:transparent;background-repeat:no-repeat;background-size:100%;background-image:url(\\\",\\r\\n                imageUri,\\r\\n                ');\\\"></svg>'\\r\\n            )\\r\\n        );\\r\\n\\r\\n        imageDataUri = string(\\r\\n            abi.encodePacked(\\r\\n                SVG_URI_PREFIX,\\r\\n                Base64.encode(bytes(imageData), bytes(imageData).length)\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\n/// @title Base64\\r\\n/// @author Brecht Devos - <brecht@loopring.org>\\r\\n/// @notice Provides functions for encoding/decoding base64\\r\\nlibrary Base64 {\\r\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\r\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\r\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\r\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\r\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\r\\n\\r\\n    function encode(bytes memory data) internal pure returns (string memory) {\\r\\n        return encode(data, data.length);\\r\\n    }\\r\\n    \\r\\n    function encode(bytes memory data, uint length) internal pure returns (string memory) {\\r\\n        if (length == 0) return '';\\r\\n\\r\\n        // load the table into memory\\r\\n        string memory table = TABLE_ENCODE;\\r\\n\\r\\n        // multiply by 4/3 rounded up\\r\\n        uint256 encodedLen = 4 * ((length + 2) / 3);\\r\\n\\r\\n        // add some extra buffer at the end required for the writing\\r\\n        string memory result = new string(encodedLen + 32);\\r\\n\\r\\n        assembly {\\r\\n            // set the actual output length\\r\\n            mstore(result, encodedLen)\\r\\n\\r\\n            // prepare the lookup table\\r\\n            let tablePtr := add(table, 1)\\r\\n\\r\\n            // input ptr\\r\\n            let dataPtr := data\\r\\n            let endPtr := add(dataPtr, mload(data))\\r\\n\\r\\n            // result ptr, jump over length\\r\\n            let resultPtr := add(result, 32)\\r\\n\\r\\n            // run over the input, 3 bytes at a time\\r\\n            for {} lt(dataPtr, endPtr) {}\\r\\n            {\\r\\n                // read 3 bytes\\r\\n                dataPtr := add(dataPtr, 3)\\r\\n                let input := mload(dataPtr)\\r\\n\\r\\n                // write 4 characters\\r\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\r\\n                resultPtr := add(resultPtr, 1)\\r\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\r\\n                resultPtr := add(resultPtr, 1)\\r\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\r\\n                resultPtr := add(resultPtr, 1)\\r\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\r\\n                resultPtr := add(resultPtr, 1)\\r\\n            }\\r\\n\\r\\n            // padding with '='\\r\\n            switch mod(mload(data), 3)\\r\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\r\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\r\\n        bytes memory data = bytes(_data);\\r\\n\\r\\n        if (data.length == 0) return new bytes(0);\\r\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\r\\n\\r\\n        // load the table into memory\\r\\n        bytes memory table = TABLE_DECODE;\\r\\n\\r\\n        // every 4 characters represent 3 bytes\\r\\n        uint256 decodedLen = (data.length / 4) * 3;\\r\\n\\r\\n        // add some extra buffer at the end required for the writing\\r\\n        bytes memory result = new bytes(decodedLen + 32);\\r\\n\\r\\n        assembly {\\r\\n            // padding with '='\\r\\n            let lastBytes := mload(add(data, mload(data)))\\r\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\r\\n                decodedLen := sub(decodedLen, 1)\\r\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\r\\n                    decodedLen := sub(decodedLen, 1)\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // set the actual output length\\r\\n            mstore(result, decodedLen)\\r\\n\\r\\n            // prepare the lookup table\\r\\n            let tablePtr := add(table, 1)\\r\\n\\r\\n            // input ptr\\r\\n            let dataPtr := data\\r\\n            let endPtr := add(dataPtr, mload(data))\\r\\n\\r\\n            // result ptr, jump over length\\r\\n            let resultPtr := add(result, 32)\\r\\n\\r\\n            // run over the input, 4 characters at a time\\r\\n            for {} lt(dataPtr, endPtr) {}\\r\\n            {\\r\\n               // read 4 characters\\r\\n               dataPtr := add(dataPtr, 4)\\r\\n               let input := mload(dataPtr)\\r\\n\\r\\n               // write 3 bytes\\r\\n               let output := add(\\r\\n                   add(\\r\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\r\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\r\\n                   add(\\r\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\r\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\r\\n                    )\\r\\n                )\\r\\n                mstore(resultPtr, shl(232, output))\\r\\n                resultPtr := add(resultPtr, 3)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/graphics/ISVGWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\ninterface ISVGWrapper {\\r\\n    function getWrappedImage(\\r\\n        string memory imageUri,\\r\\n        uint256 canonicalWidth,\\r\\n        uint256 canonicalHeight\\r\\n    ) external view returns (string memory imageDataUri);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"SVG_URI_PREFIX\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"imageUri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"canonicalWidth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"canonicalHeight\",\"type\":\"uint256\"}],\"name\":\"getWrappedImage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"imageDataUri\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"SVGWrapper","CompilerVersion":"v0.8.13+commit.abaa5c0e","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]