[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MevWalletV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport {Mevitize} from \\\"mev-weth/Mevitize.sol\\\";\\n\\ncontract MevWalletV1 is Mevitize {\\n    error ProvideValue(uint256); // 0x73883387\\n    error HighBaseFee(uint256); // 0x74878d58\\n    error WrongSigner(address); // 0x32c15fc2\\n    error Reverted(bytes); // 0xa8159920\\n    error NotBefore(uint64); // 0x08567e55\\n    error UsedNonce(uint256); // 0x6ac964b0\\n    error MissingNonce(uint256); // 0x299aa731\\n\\n    error PermanentlyInvalid(); // 0xa04d981f\\n\\n    // 0xbcf6a68a2f901be4a23a41b53acd7697893a7e34def4e28acba584da75283b67\\n    event Executed(uint256 indexed nonce);\\n\\n    // 0x5679fb6ec38d3c67731b4def49181a8fbbb334cda5c263b0993e50cfe699d4e8\\n    bytes32 public constant TX_TYPEHASH = keccak256(\\n        \\\"MevTx(address to,bytes data,int256 value,bool delegate,int256 tip,uint256 maxBaseFee,uint256 timing,uint256 nonce)\\\"\\n    );\\n    bytes32 public _DOMAIN_SEPARATOR;\\n\\n    address public owner;\\n    uint256 public nonce;\\n\\n    fallback() external payable {}\\n    receive() external payable {}\\n\\n    constructor() {\\n        owner = address(0xff); // factor that, jerks\\n    }\\n\\n    /**\\n     * @notice initializes the owner and domain separator\\n     */\\n    function initialize(address newOwner) public {\\n        require(owner == address(0));\\n        // Enforced because contracts cannot produce signatures\\n        uint256 s;\\n        assembly {\\n            s := extcodesize(newOwner)\\n        }\\n        require(s == 0, \\\"No contract owner\\\");\\n        owner = newOwner;\\n        _DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(\\\"MevTx\\\"),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice onlyOwner does what it says on the tin\\n     */\\n    modifier onlyOwner() {\\n        // we allow address(this) so that the wallet can be administered with\\n        // its own meta-tx\\n        require(msg.sender == owner || msg.sender == address(this));\\n        _;\\n    }\\n\\n    /**\\n     * @notice transferOwnership does what it says on the tin\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0) && newOwner != address(this));\\n        uint256 s;\\n        // Enforced because contracts cannot produce signatures\\n        assembly {\\n            s := extcodesize(newOwner)\\n        }\\n        require(s == 0, \\\"No contract owner\\\");\\n        owner = newOwner;\\n    }\\n\\n    /**\\n     * @notice checks the EIP-712 signsture\\n     */\\n    function check712(\\n        address to,\\n        bytes memory data,\\n        int256 value,\\n        bool delegate,\\n        int256 tip,\\n        uint256 maxBaseFee,\\n        uint256 timing,\\n        uint256 n,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view {\\n        bytes32 hashStruct =\\n            keccak256(abi.encode(TX_TYPEHASH, to, keccak256(data), value, delegate, tip, maxBaseFee, timing, n));\\n        bytes32 h = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", _DOMAIN_SEPARATOR, hashStruct));\\n        address signer = ecrecover(h, v, r, s);\\n        // signature must be valid\\n        if (signer == address(0)) revert PermanentlyInvalid();\\n        // signature must be from owner\\n        if (signer != owner) revert WrongSigner(signer);\\n    }\\n\\n    /**\\n     * @notice checks that the basefee is in user-acceptable range.\\n     */\\n    function checkBaseFee(uint256 maxBaseFee) internal view {\\n        // if there's a limit on the basefee, it cannot be over that limit\\n        if (maxBaseFee != 0 && block.basefee > maxBaseFee) revert HighBaseFee(maxBaseFee);\\n    }\\n\\n    /**\\n     * @notice checks that the block timestamp is in user-acceptable range.\\n     */\\n    function checkTiming(uint256 timing) internal view {\\n        // Timing is encoded as `notBefore << 64 | notAfter`\\n        uint64 time = uint64(block.timestamp);\\n        uint64 notAfter = uint64(timing);\\n        uint64 notBefore = uint64(timing >> 64);\\n        // if notAfter is non-zero, timestamp cannot be after it\\n        if (notAfter != 0 && time > notAfter) {\\n            revert PermanentlyInvalid();\\n        }\\n        // if notBefore  is non-zero, timestamp cannot be before it\\n        if (notBefore != 0 && time < notBefore) {\\n            revert NotBefore(notBefore);\\n        }\\n    }\\n\\n    /**\\n     * @notice checks that the value is as user specified.\\n     */\\n    function checkValue(bool delegate, int256 value) internal view {\\n        // value cannot be negative\\n        if (value < 0) revert PermanentlyInvalid();\\n        // delegate calls cannot have value\\n        if (delegate && value != 0) revert PermanentlyInvalid();\\n        unchecked {\\n            // cast checked by previous if statement\\n            uint256 val = uint256(value);\\n            uint256 bal = address(this).balance;\\n            uint256 msgVal = msg.value;\\n            // becase bal cannot be less than msgval\\n            uint256 preBal = bal - msgVal;\\n            // if the value BEFORE getting the Searcher's input ETH was\\n            // sufficient, don't allow input ETH. This prevents the Searcher\\n            // from converting wallet MevWeth into ETH by providing extra value\\n            if (preBal >= val && msgVal != 0) revert ProvideValue(0);\\n            // if the value BEFORE getting the Searcher's input ETH was\\n            // insufficient, require the msg has the exact value necessary\\n            if (preBal < val) {\\n                // checked by the if statement\\n                uint256 deficit = val - preBal;\\n                if (msgVal != deficit) revert ProvideValue(deficit);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice checks that the nonce is correct\\n     */\\n    function checkNonce(uint256 n) internal view {\\n        uint256 _nonce = nonce;\\n        // Nonce cannot be\\n        if (n < _nonce) revert UsedNonce(_nonce);\\n        if (n > _nonce) revert MissingNonce(_nonce);\\n        // pass if equal\\n    }\\n\\n    /**\\n     * @notice executes the meta-tx\\n     */\\n    function execute(address to, bytes memory data, uint256 value, bool delegate) internal {\\n        bool success;\\n        // overwrite data because we don't need it anymore\\n        if (delegate) {\\n            (success, data) = to.delegatecall(data);\\n        } else {\\n            (success, data) = to.call{value: value}(data);\\n        }\\n        // okay this seems crazy but hear me out\\n        // MEV block builders already drop reverting txns.\\n        // This just makes it so they never get included at all\\n        // which is desirable for a metatx\\n        if (!success) {\\n            revert Reverted(data);\\n        }\\n    }\\n\\n    /**\\n     * @notice execute a MEV-driven meta-transaction\\n     */\\n    function mevTx(\\n        address to,\\n        bytes memory data,\\n        int256 value,\\n        bool delegate,\\n        int256 tip,\\n        uint256 maxBaseFee,\\n        uint256 timing,\\n        uint256 n,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable subsidize(tip + int256(msg.value)) {\\n        // check sig first, as this is most likely to produce reverts\\n        check712(to, data, value, delegate, tip, maxBaseFee, timing, n, v, r, s);\\n\\n        // other condition of use checks\\n        if (to == address(0)) revert PermanentlyInvalid();\\n        checkBaseFee(maxBaseFee);\\n        checkTiming(timing);\\n        checkValue(delegate, value);\\n        checkNonce(n);\\n\\n        // re-entrancy protection\\n        nonce = type(uint256).max;\\n\\n        // execute the tx\\n        execute(to, data, uint256(value), delegate);\\n\\n        // emit executed, and incement nonce\\n        nonce = n + 1;\\n        emit Executed(n);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/mev-weth/src/IMevWeth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0 OR MIT OR GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\n\\ninterface IMevWeth {\\n    function mev() external returns (uint256);\\n    function addMev(uint256 value) external;\\n    function addMev(address from, uint256 value) external;\\n    function getMev() external;\\n    function getMev(uint256 value) external;\\n    function getMev(address to) external;\\n    function getMev(address to, uint256 value) external;\\n}\\n\"\r\n    },\r\n    \"lib/mev-weth/src/Mevitize.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0 OR MIT OR GPL-3.0-or-later\\npragma solidity ^0.8.17;\\n\\nimport {IMevWeth} from \\\"./IMevWeth.sol\\\";\\n\\ncontract Mevitize {\\n    IMevWeth constant mevWeth = IMevWeth(0x00000000008C43efC014746c230049e330039Cb3);\\n\\n    error ExactBaseFee(); // 0x2daf442d\\n\\n    modifier mev(int256 loot) {\\n        if (loot > 0) {\\n            mevWeth.addMev(uint256(loot));\\n        } else {\\n            mevWeth.getMev(uint256(-1 * loot));\\n        }\\n        _;\\n    }\\n\\n    modifier mevFrom(address from, int256 loot) {\\n        if (loot > 0) {\\n            mevWeth.addMev(from, uint256(loot));\\n        } else {\\n            mevWeth.getMev(from, uint256(-1 * loot));\\n        }\\n        _;\\n    }\\n\\n    modifier subsidize(int256 tip) {\\n        uint256 gp = tx.gasprice;\\n        uint256 bf = block.basefee;\\n        if (bf != gp) revert ExactBaseFee(); // this asserts that there is no tip\\n        uint256 pre = gasleft();\\n        _;\\n        uint256 post = gasleft();\\n        int256 loot = tip + int256(gp * (pre - post));\\n        if (loot > 0) {\\n            mevWeth.addMev(uint256(loot));\\n        } else {\\n            mevWeth.getMev(uint256(-1 * loot));\\n        }\\n    }\\n\\n    modifier subsidizeFrom(address from, int256 tip) {\\n        uint256 gp = tx.gasprice;\\n        uint256 bf = block.basefee;\\n        if (bf != gp) revert ExactBaseFee(); // this asserts that there is no tip\\n        uint256 pre = gasleft();\\n        _;\\n        uint256 post = gasleft();\\n        int256 loot = tip + int256(gp * (pre - post));\\n        if (loot > 0) {\\n            mevWeth.addMev(from, uint256(loot));\\n        } else {\\n            mevWeth.getMev(from, uint256(-1 * loot));\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"WETH10/=lib/mev-weth/lib/WETH10/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"mev-weth/=lib/mev-weth/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ExactBaseFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"HighBaseFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MissingNonce\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"NotBefore\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermanentlyInvalid\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ProvideValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"Reverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"UsedNonce\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"WrongSigner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"TX_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"delegate\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"tip\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"maxBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"mevTx\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MevWalletV1","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]