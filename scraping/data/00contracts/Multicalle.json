[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Multicaller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Multicaller\\n * @author vectorized.eth\\n * @notice Contract that allows for efficient aggregation\\n *         of multiple calls in a single transaction.\\n */\\ncontract Multicaller {\\n    // =============================================================\\n    //                            EVENTS\\n    // =============================================================\\n\\n    /**\\n     * @dev The lengths of the input arrays are not the same.\\n     */\\n    error ArrayLengthsMismatch();\\n\\n    /**\\n     * @dev This function does not support reentrancy.\\n     */\\n    error Reentrancy();\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    /**\\n     * @dev The storage slot for the sender and reentrancy guard flag.\\n     */\\n    bytes32 private _sender;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor() payable {\\n        assembly {\\n            sstore(_sender.slot, shl(160, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                    AGGREGATION OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the address that called `aggregateWithSender` on this contract.\\n     *      The value is always the zero address outside a transaction.\\n     * @return The caller address.\\n     */\\n    function sender() external view returns (address) {\\n        assembly {\\n            mstore(0x00, and(sub(shl(160, 1), 1), sload(_sender.slot)))\\n            return(0x00, 0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Aggregates multiple calls in a single transaction.\\n     *      The `msg.value` will be forwarded to the starting call.\\n     *      This method will set `sender` to the `msg.sender` temporarily\\n     *      for the span of its execution.\\n     *      This method does not support reentrancy.\\n     * @param targets An array of addresses to call.\\n     * @param data    An array of calldata to forward to the targets.\\n     * @return An array of the returndata from each of the call.\\n     */\\n    function aggregateWithSender(address[] calldata targets, bytes[] calldata data)\\n        external\\n        payable\\n        returns (bytes[] memory)\\n    {\\n        assembly {\\n            if iszero(eq(targets.length, data.length)) {\\n                // Store the function selector of `ArrayLengthsMismatch()`.\\n                mstore(0x00, 0x3b800a46)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            if iszero(and(sload(_sender.slot), shl(160, 1))) {\\n                // Store the function selector of `Reentrancy()`.\\n                mstore(0x00, 0xab143c06)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the `_sender` slot temporarily for the span of this transaction.\\n            sstore(_sender.slot, caller())\\n\\n            mstore(0x00, 0x20) // Store the memory offset of the `results`.\\n            mstore(0x20, data.length) // Store `data.length` into `results`.\\n            // Early return if no data.\\n            if iszero(data.length) { return(0x00, 0x40) }\\n\\n            let results := 0x40\\n            // `shl` 5 is equivalent to multiplying by 0x20.\\n            let end := shl(5, data.length)\\n            // Copy the offsets from calldata into memory.\\n            calldatacopy(0x40, data.offset, end)\\n            // Pointer to the top of the memory (i.e. start of the free memory).\\n            let resultsOffset := end\\n            // The callvalue to forward to the starting call.\\n            let v := callvalue()\\n\\n            for { end := add(results, end) } 1 {} {\\n                // The offset of the current bytes in the calldata.\\n                let o := add(data.offset, mload(results))\\n                let memPtr := add(resultsOffset, 0x40)\\n                // Copy the current bytes from calldata to the memory.\\n                calldatacopy(\\n                    memPtr,\\n                    add(o, 0x20), // The offset of the current bytes' bytes.\\n                    calldataload(o) // The length of the current bytes.\\n                )\\n                if iszero(\\n                    call(\\n                        gas(), // Remaining gas.\\n                        calldataload(targets.offset), // Address to call.\\n                        v, // Amount of ETH to send.\\n                        memPtr, // Start of input calldata in memory.\\n                        calldataload(o), // Size of input calldata.\\n                        0x00, // We will use returndatacopy instead.\\n                        0x00 // We will use returndatacopy instead.\\n                    )\\n                ) {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n                // We only forward the callvalue for the starting call.\\n                v := 0\\n                // Advance the `targets.offset`.\\n                targets.offset := add(targets.offset, 0x20)\\n                // Append the current `resultsOffset` into `results`.\\n                mstore(results, resultsOffset)\\n                results := add(results, 0x20)\\n                // Append the returndatasize, and the return data.\\n                mstore(memPtr, returndatasize())\\n                returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\\n                // Advance the `resultsOffset` by `returndatasize() + 0x20`,\\n                // rounded up to the next multiple of 32.\\n                resultsOffset := and(add(add(resultsOffset, returndatasize()), 0x3f), not(0x1f))\\n                if iszero(lt(results, end)) { break }\\n            }\\n            // Restore the `_sender` slot.\\n            sstore(_sender.slot, shl(160, 1))\\n            // Direct return.\\n            return(0x00, add(resultsOffset, 0x40))\\n        }\\n    }\\n\\n    /**\\n     * @dev Aggregates multiple calls in a single transaction.\\n     *      The `msg.value` will be forwarded to the starting call.\\n     * @param targets An array of addresses to call.\\n     * @param data    An array of calldata to forward to the targets.\\n     * @return An array of the returndata from each of the call.\\n     */\\n    function aggregate(address[] calldata targets, bytes[] calldata data)\\n        external\\n        payable\\n        returns (bytes[] memory)\\n    {\\n        assembly {\\n            if iszero(eq(targets.length, data.length)) {\\n                // Store the function selector of `ArrayLengthsMismatch()`.\\n                mstore(0x00, 0x3b800a46)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x00, 0x20) // Store the memory offset of the `results`.\\n            mstore(0x20, data.length) // Store `data.length` into `results`.\\n            // Early return if no data.\\n            if iszero(data.length) { return(0x00, 0x40) }\\n\\n            let results := 0x40\\n            // `shl` 5 is equivalent to multiplying by 0x20.\\n            let end := shl(5, data.length)\\n            // Copy the offsets from calldata into memory.\\n            calldatacopy(0x40, data.offset, end)\\n            // Pointer to the top of the memory (i.e. start of the free memory).\\n            let resultsOffset := end\\n            // The callvalue to forward to the starting call.\\n            let v := callvalue()\\n\\n            for { end := add(results, end) } 1 {} {\\n                // The offset of the current bytes in the calldata.\\n                let o := add(data.offset, mload(results))\\n                let memPtr := add(resultsOffset, 0x40)\\n                // Copy the current bytes from calldata to the memory.\\n                calldatacopy(\\n                    memPtr,\\n                    add(o, 0x20), // The offset of the current bytes' bytes.\\n                    calldataload(o) // The length of the current bytes.\\n                )\\n                if iszero(\\n                    call(\\n                        gas(), // Remaining gas.\\n                        calldataload(targets.offset), // Address to call.\\n                        v, // Amount of ETH to send.\\n                        memPtr, // Start of input calldata in memory.\\n                        calldataload(o), // Size of input calldata.\\n                        0x00, // We will use returndatacopy instead.\\n                        0x00 // We will use returndatacopy instead.\\n                    )\\n                ) {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n                // We only forward the callvalue for the starting call.\\n                v := 0\\n                // Advance the `targets.offset`.\\n                targets.offset := add(targets.offset, 0x20)\\n                // Append the current `resultsOffset` into `results`.\\n                mstore(results, resultsOffset)\\n                results := add(results, 0x20)\\n                // Append the returndatasize, and the return data.\\n                mstore(memPtr, returndatasize())\\n                returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\\n                // Advance the `resultsOffset` by `returndatasize() + 0x20`,\\n                // rounded up to the next multiple of 32.\\n                resultsOffset := and(add(add(resultsOffset, returndatasize()), 0x3f), not(0x1f))\\n                if iszero(lt(results, end)) { break }\\n            }\\n            // Direct return.\\n            return(0x00, add(resultsOffset, 0x40))\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ArrayLengthsMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"aggregate\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"aggregateWithSender\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Multicaller","CompilerVersion":"v0.8.18+commit.87f61d96","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://361324acc35acb26ed6e4ca9f66b9e8f21c556287fb7ea22ef2e2f4eb9749c9c"}]