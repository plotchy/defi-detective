[{"SourceCode":"pragma solidity 0.4.17;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract TripCash is Ownable {\r\n\r\n    uint256 public totalSupply = 5000000000 * 1 ether;\r\n\r\n\r\n    string public constant name = \"TripCash\";\r\n    string public constant symbol = \"TASH\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    mapping (address => uint256) public balances; //Addresses map\r\n    mapping (address => mapping(address => uint256)) public allowed;\r\n    mapping (address => bool) public notransfer;\r\n\r\n\r\n    uint256 public startPreICO = 1523840400; // preICO  start date\r\n    uint256 public endPreICO = 1528675199; // preICO  finish date\r\n    uint256 public startTime = 1529884800; // ICO  start date\r\n    uint256 public endTime = 1532303999; // ICO  finish date\r\n\r\n\r\n    address public constant ownerWallet = 0x9dA14C46f0182D850B12866AB0f3e397Fbd4FaC4; // Owner wallet address\r\n    address public constant teamWallet1 = 0xe82F49A648FADaafd468E65a13C050434a4C4a6f ; // Team wallet address\r\n    address public constant teamWallet2 = 0x16Eb7B7E232590787F1Fe3742acB1a1d0e43AF2A; // Team wallet address\r\n    address public constant fundWallet = 0x949844acF5C722707d02A037D074cabe7474e0CB; // Fund wallet address\r\n    address public constant frozenWallet2y = 0xAc77c90b37AFd80D2227f74971e7c3ad3e29D1fb; // For rest token frozen 2 year\r\n    address public constant frozenWallet4y = 0x265B8e89DAbA5Bdc330E55cA826a9f2e0EFf0870; // For rest token frozen 4 year\r\n\r\n    uint256 public constant ownerPercent = 10; // Owner percent token rate\r\n    uint256 public constant teamPercent = 10; // Team percent token rate\r\n    uint256 public constant bountyPercent = 10; // Bounty percent token rate\r\n\r\n    bool public transferAllowed = false;\r\n    bool public refundToken = false;\r\n\r\n    /**\r\n     * Token constructor\r\n     *\r\n     **/\r\n    function TripCash() public {\r\n        balances[owner] = totalSupply;\r\n    }\r\n\r\n    /**\r\n     *  Modifier for checking token transfer\r\n     */\r\n    modifier canTransferToken(address _from) {\r\n        if (_from != owner) {\r\n            require(transferAllowed);\r\n        }\r\n        \r\n        if (_from == teamWallet1) {\r\n            require(now >= endTime + 15552000);\r\n        }\r\n\r\n        if (_from == teamWallet2) {\r\n            require(now >= endTime + 31536000);\r\n        }\r\n        \r\n        _;\r\n    }\r\n\r\n    /**\r\n     *  Modifier for checking transfer allownes\r\n     */\r\n    modifier notAllowed(){\r\n        require(!transferAllowed);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     *  Modifier for checking ICO period\r\n     */\r\n    modifier saleIsOn() {\r\n        require((now > startTime && now < endTime)||(now > startPreICO && now < endPreICO));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     *  Modifier for checking refund allownes\r\n     */\r\n\r\n    modifier canRefundToken() {\r\n        require(refundToken);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) onlyOwner public {\r\n        require(_newOwner != address(0));\r\n        uint256 tokenValue = balances[owner];\r\n\r\n        transfer(_newOwner, tokenValue);\r\n        owner = _newOwner;\r\n\r\n        OwnershipTransferred(owner, _newOwner);\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     *   Adding bonus tokens for bounty, team and owner needs. Should be used by DAPPs\r\n     */\r\n    function dappsBonusCalc(address _to, uint256 _value) onlyOwner saleIsOn() notAllowed public returns (bool) {\r\n\r\n        require(_value != 0);\r\n        transfer(_to, _value);\r\n        notransfer[_to] = true;\r\n\r\n        uint256 bountyTokenAmount = 0;\r\n        uint256 ownerTokenAmount = 0;\r\n        uint256 teamTokenAmount = 0;\r\n\r\n        //calc bounty bonuses\r\n        bountyTokenAmount = _value * bountyPercent / 60;\r\n\r\n        //calc owner bonuses\r\n        ownerTokenAmount = _value * ownerPercent / 60;\r\n\r\n        //calc teamTokenAmount bonuses\r\n        teamTokenAmount = _value * teamPercent / 60;\r\n        \r\n        transfer(ownerWallet, ownerTokenAmount);\r\n        transfer(fundWallet, bountyTokenAmount);\r\n        transfer(teamWallet1, teamTokenAmount);\r\n        transfer(teamWallet2, teamTokenAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     *   Return number of tokens for address\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transfer(address _to, uint256 _value) canTransferToken(msg.sender) public returns (bool){\r\n        require(_to != address(0));\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] = balances[msg.sender] - _value;\r\n        balances[_to] = balances[_to] + _value;\r\n        if (notransfer[msg.sender] == true) {\r\n            notransfer[msg.sender] = false;\r\n        }\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) canTransferToken(_from) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from] - _value;\r\n        balances[_to] = balances[_to] + _value;\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\r\n\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue - _subtractedValue;\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev function for rewarding token holders, who didn't transfer in 1 or 2 years\r\n     * @param _holder token holders address\r\n     */\r\n\r\n    function rewarding(address _holder) public onlyOwner returns(uint){\r\n        if(notransfer[_holder]==true){\r\n            if(now >= endTime + 63072000){\r\n                uint noTransfer2BonusYear = balances[_holder]*25 / 100;\r\n                if (balances[fundWallet] >= noTransfer2BonusYear) {\r\n                    balances[fundWallet] = balances[fundWallet] - noTransfer2BonusYear;\r\n                    balances[_holder] = balances[_holder] + noTransfer2BonusYear;\r\n                    assert(balances[_holder] >= noTransfer2BonusYear);\r\n                    Transfer(fundWallet, _holder, noTransfer2BonusYear);\r\n                    notransfer[_holder]=false;\r\n                    return noTransfer2BonusYear;\r\n                }\r\n            } else if (now >= endTime + 31536000) {\r\n                uint noTransferBonusYear = balances[_holder]*15 / 100;\r\n                if (balances[fundWallet] >= noTransferBonusYear) {\r\n                    balances[fundWallet] = balances[fundWallet] - noTransferBonusYear;\r\n                    balances[_holder] = balances[_holder] + noTransferBonusYear;\r\n                    assert(balances[_holder] >= noTransferBonusYear);\r\n                    Transfer(fundWallet, _holder, noTransferBonusYear);\r\n                    notransfer[_holder]=false;\r\n                    return noTransferBonusYear;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Unsold and undistributed tokens will be vested (50% for 2 years, 50% for 4 years) \r\n     * to be allocated for the future development needs of the project; \r\n     * in case of high unexpected volatility of the token, \r\n     * part or all of the vested tokens can be burned to support the token's value.\r\n     * /\r\n    /**\r\n     * function for after ICO burning tokens which was not bought\r\n     * @param _value uint256 Amount of burning tokens\r\n     */\r\n    function burn(uint256 _value) onlyOwner public returns (bool){\r\n        require(_value > 0);\r\n        require(_value <= balances[msg.sender]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner] - _value;\r\n        totalSupply = totalSupply - _value;\r\n        Burn(burner, _value);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     *  Allownes refund\r\n     */\r\n    function changeRefundToken() public onlyOwner {\r\n        require(now >= endTime);\r\n        refundToken = true;\r\n    }\r\n    \r\n     /**\r\n     *  function for finishing ICO and allowed token transfer\r\n     */\r\n    function finishICO() public onlyOwner returns (bool) {\r\n        uint frozenBalance = balances[msg.sender]/2;\r\n        transfer(frozenWallet2y, frozenBalance);\r\n        transfer(frozenWallet4y, balances[msg.sender]);\r\n        transferAllowed = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * return investor tokens and burning\r\n     * \r\n     */\r\n    function refund()  canRefundToken public returns (bool){\r\n        uint256 _value = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        totalSupply = totalSupply - _value;\r\n        Refund(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed burner, uint256 value);\r\n    event Refund(address indexed refuner, uint256 value);\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"dappsBonusCalc\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamWallet1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeRefundToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozenWallet2y\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamWallet2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishICO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozenWallet4y\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"rewarding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"notransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"refuner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"}]","ContractName":"TripCash","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4191b2d09511f372a1870c1bf68e91275956132e2f0a8126c20bf3c3bb54515e"}]