[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/vault/VaultNonUpgradableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../external/@openzeppelin/proxy/Proxy.sol\\\";\\r\\nimport \\\"../interfaces/vault/IVaultImmutable.sol\\\";\\r\\nimport \\\"../interfaces/vault/IVaultDetails.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice This contract is a non-upgradable proxy for Spool vault implementation.\\r\\n *\\r\\n * @dev\\r\\n * It is used to lower the gas cost of vault creation.\\r\\n * The contract holds vault specific immutable variables.\\r\\n */\\r\\ncontract VaultNonUpgradableProxy is Proxy, IVaultImmutable {\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    /// @notice The address of vault implementation\\r\\n    address public immutable vaultImplementation;\\r\\n\\r\\n    /// @notice Vault underlying asset\\r\\n    IERC20 public override immutable underlying;\\r\\n\\r\\n    /// @notice Vault risk provider address\\r\\n    address public override immutable riskProvider;\\r\\n\\r\\n    /// @notice A number from -10 to 10 indicating the risk tolerance of the vault\\r\\n    int8 public override immutable riskTolerance;\\r\\n\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n    \\r\\n    /**\\r\\n     * @notice Sets the vault specific immutable values.\\r\\n     *\\r\\n     * @param _vaultImplementation implementation contract address of the vault\\r\\n     * @param vaultImmutables vault immutable values\\r\\n     */\\r\\n    constructor(\\r\\n        address _vaultImplementation,\\r\\n        VaultImmutables memory vaultImmutables\\r\\n    ) {\\r\\n        vaultImplementation = _vaultImplementation;\\r\\n        underlying = vaultImmutables.underlying;\\r\\n        riskProvider = vaultImmutables.riskProvider;\\r\\n        riskTolerance = vaultImmutables.riskTolerance;\\r\\n    }\\r\\n\\r\\n    /* ========== INTERNAL FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Return contract address of vault implementation.\\r\\n     *\\r\\n     * @return vault implementation contract address\\r\\n     */\\r\\n    function _implementation() internal view override returns (address) {\\r\\n        return vaultImplementation;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.0 (proxy/Proxy.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\r\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\r\\n * be specified by overriding the virtual {_implementation} function.\\r\\n *\\r\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\r\\n * different contract through the {_delegate} function.\\r\\n *\\r\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\r\\n */\\r\\nabstract contract Proxy {\\r\\n    /**\\r\\n     * @dev Delegates the current call to `implementation`.\\r\\n     *\\r\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\r\\n     */\\r\\n    function _delegate(address implementation) internal virtual {\\r\\n        assembly {\\r\\n            // Copy msg.data. We take full control of memory in this inline assembly\\r\\n            // block because it will not return to Solidity code. We overwrite the\\r\\n            // Solidity scratch pad at memory position 0.\\r\\n            calldatacopy(0, 0, calldatasize())\\r\\n\\r\\n            // Call the implementation.\\r\\n            // out and outsize are 0 because we don't know the size yet.\\r\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\r\\n\\r\\n            // Copy the returned data.\\r\\n            returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n            switch result\\r\\n            // delegatecall returns 0 on error.\\r\\n            case 0 {\\r\\n                revert(0, returndatasize())\\r\\n            }\\r\\n            default {\\r\\n                return(0, returndatasize())\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\r\\n     * and {_fallback} should delegate.\\r\\n     */\\r\\n    function _implementation() internal view virtual returns (address);\\r\\n\\r\\n    /**\\r\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\r\\n     *\\r\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\r\\n     */\\r\\n    function _fallback() internal virtual {\\r\\n        _beforeFallback();\\r\\n        _delegate(_implementation());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\r\\n     * function in the contract matches the call data.\\r\\n     */\\r\\n    fallback() external payable virtual {\\r\\n        _fallback();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\r\\n     * is empty.\\r\\n     */\\r\\n    receive() external payable virtual {\\r\\n        _fallback();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\r\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\r\\n     *\\r\\n     * If overriden should call `super._beforeFallback()`.\\r\\n     */\\r\\n    function _beforeFallback() internal virtual {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/vault/IVaultImmutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nstruct VaultImmutables {\\r\\n    IERC20 underlying;\\r\\n    address riskProvider;\\r\\n    int8 riskTolerance;\\r\\n}\\r\\n\\r\\ninterface IVaultImmutable {\\r\\n    /* ========== FUNCTIONS ========== */\\r\\n\\r\\n    function underlying() external view returns (IERC20);\\r\\n\\r\\n    function riskProvider() external view returns (address);\\r\\n\\r\\n    function riskTolerance() external view returns (int8);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/vault/IVaultDetails.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nstruct VaultDetails {\\r\\n    address underlying;\\r\\n    address[] strategies;\\r\\n    uint256[] proportions;\\r\\n    address creator;\\r\\n    uint16 vaultFee;\\r\\n    address riskProvider;\\r\\n    int8 riskTolerance;\\r\\n    string name;\\r\\n}\\r\\n\\r\\nstruct VaultInitializable {\\r\\n    string name;\\r\\n    address owner;\\r\\n    uint16 fee;\\r\\n    address[] strategies;\\r\\n    uint256[] proportions;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultImplementation\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"riskProvider\",\"type\":\"address\"},{\"internalType\":\"int8\",\"name\":\"riskTolerance\",\"type\":\"int8\"}],\"internalType\":\"struct VaultImmutables\",\"name\":\"vaultImmutables\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"riskProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"riskTolerance\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"\",\"type\":\"int8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"VaultNonUpgradableProxy","CompilerVersion":"v0.8.11+commit.d7f03943","OptimizationUsed":"1","Runs":"9999","ConstructorArguments":"00000000000000000000000035b725f9a1c73021ef74856c456fa18d30bd63e5000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c216ad6280f4fa92a5159ef383a1206d432481c80000000000000000000000000000000000000000000000000000000000000008","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"1","Implementation":"0x35b725f9a1c73021ef74856c456fa18d30bd63e5","SwarmSource":""}]