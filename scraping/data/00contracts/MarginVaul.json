[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/gge/ribbon-finance/avocado/contracts/libs/MarginVault.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: UNLICENSED\\n */\\npragma solidity =0.6.10;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath} from \\\"../packages/oz/SafeMath.sol\\\";\\n\\n/**\\n * MarginVault Error Codes\\n * V1: invalid short otoken amount\\n * V2: invalid short otoken index\\n * V3: short otoken address mismatch\\n * V4: invalid long otoken amount\\n * V5: invalid long otoken index\\n * V6: long otoken address mismatch\\n * V7: invalid collateral amount\\n * V8: invalid collateral token index\\n * V9: collateral token address mismatch\\n */\\n\\n/**\\n * @title MarginVault\\n * @author Opyn Team\\n * @notice A library that provides the Controller with a Vault struct and the functions that manipulate vaults.\\n * Vaults describe discrete position combinations of long options, short options, and collateral assets that a user can have.\\n */\\nlibrary MarginVault {\\n    using SafeMath for uint256;\\n\\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\\n    struct Vault {\\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\\n        address[] shortOtokens;\\n        // addresses of oTokens a user has bought and deposited in this vault\\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral in order to write oTokens against (i.e. in spreads)\\n        address[] longOtokens;\\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\\n        address[] collateralAssets;\\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\\n        uint256[] shortAmounts;\\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\\n        uint256[] longAmounts;\\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\\n        uint256[] collateralAmounts;\\n    }\\n\\n    /**\\n     * @dev increase the short oToken balance in a vault when a new oToken is minted\\n     * @param _vault vault to add or increase the short position in\\n     * @param _shortOtoken address of the _shortOtoken being minted from the user's vault\\n     * @param _amount number of _shortOtoken being minted from the user's vault\\n     * @param _index index of _shortOtoken in the user's vault.shortOtokens array\\n     */\\n    function addShort(\\n        Vault storage _vault,\\n        address _shortOtoken,\\n        uint256 _amount,\\n        uint256 _index\\n    ) external {\\n        require(_amount > 0, \\\"V1\\\");\\n\\n        // valid indexes in any array are between 0 and array.length - 1.\\n        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\\n        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {\\n            _vault.shortOtokens.push(_shortOtoken);\\n            _vault.shortAmounts.push(_amount);\\n        } else {\\n            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), \\\"V2\\\");\\n            address existingShort = _vault.shortOtokens[_index];\\n            require((existingShort == _shortOtoken) || (existingShort == address(0)), \\\"V3\\\");\\n\\n            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);\\n            _vault.shortOtokens[_index] = _shortOtoken;\\n        }\\n    }\\n\\n    /**\\n     * @dev decrease the short oToken balance in a vault when an oToken is burned\\n     * @param _vault vault to decrease short position in\\n     * @param _shortOtoken address of the _shortOtoken being reduced in the user's vault\\n     * @param _amount number of _shortOtoken being reduced in the user's vault\\n     * @param _index index of _shortOtoken in the user's vault.shortOtokens array\\n     */\\n    function removeShort(\\n        Vault storage _vault,\\n        address _shortOtoken,\\n        uint256 _amount,\\n        uint256 _index\\n    ) external {\\n        // check that the removed short oToken exists in the vault at the specified index\\n        require(_index < _vault.shortOtokens.length, \\\"V2\\\");\\n        require(_vault.shortOtokens[_index] == _shortOtoken, \\\"V3\\\");\\n\\n        uint256 newShortAmount = _vault.shortAmounts[_index].sub(_amount);\\n\\n        if (newShortAmount == 0) {\\n            delete _vault.shortOtokens[_index];\\n        }\\n        _vault.shortAmounts[_index] = newShortAmount;\\n    }\\n\\n    /**\\n     * @dev increase the long oToken balance in a vault when an oToken is deposited\\n     * @param _vault vault to add a long position to\\n     * @param _longOtoken address of the _longOtoken being added to the user's vault\\n     * @param _amount number of _longOtoken the protocol is adding to the user's vault\\n     * @param _index index of _longOtoken in the user's vault.longOtokens array\\n     */\\n    function addLong(\\n        Vault storage _vault,\\n        address _longOtoken,\\n        uint256 _amount,\\n        uint256 _index\\n    ) external {\\n        require(_amount > 0, \\\"V4\\\");\\n\\n        // valid indexes in any array are between 0 and array.length - 1.\\n        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\\n        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {\\n            _vault.longOtokens.push(_longOtoken);\\n            _vault.longAmounts.push(_amount);\\n        } else {\\n            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), \\\"V5\\\");\\n            address existingLong = _vault.longOtokens[_index];\\n            require((existingLong == _longOtoken) || (existingLong == address(0)), \\\"V6\\\");\\n\\n            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);\\n            _vault.longOtokens[_index] = _longOtoken;\\n        }\\n    }\\n\\n    /**\\n     * @dev decrease the long oToken balance in a vault when an oToken is withdrawn\\n     * @param _vault vault to remove a long position from\\n     * @param _longOtoken address of the _longOtoken being removed from the user's vault\\n     * @param _amount number of _longOtoken the protocol is removing from the user's vault\\n     * @param _index index of _longOtoken in the user's vault.longOtokens array\\n     */\\n    function removeLong(\\n        Vault storage _vault,\\n        address _longOtoken,\\n        uint256 _amount,\\n        uint256 _index\\n    ) external {\\n        // check that the removed long oToken exists in the vault at the specified index\\n        require(_index < _vault.longOtokens.length, \\\"V5\\\");\\n        require(_vault.longOtokens[_index] == _longOtoken, \\\"V6\\\");\\n\\n        uint256 newLongAmount = _vault.longAmounts[_index].sub(_amount);\\n\\n        if (newLongAmount == 0) {\\n            delete _vault.longOtokens[_index];\\n        }\\n        _vault.longAmounts[_index] = newLongAmount;\\n    }\\n\\n    /**\\n     * @dev increase the collateral balance in a vault\\n     * @param _vault vault to add collateral to\\n     * @param _collateralAsset address of the _collateralAsset being added to the user's vault\\n     * @param _amount number of _collateralAsset being added to the user's vault\\n     * @param _index index of _collateralAsset in the user's vault.collateralAssets array\\n     */\\n    function addCollateral(\\n        Vault storage _vault,\\n        address _collateralAsset,\\n        uint256 _amount,\\n        uint256 _index\\n    ) external {\\n        require(_amount > 0, \\\"V7\\\");\\n\\n        // valid indexes in any array are between 0 and array.length - 1.\\n        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\\n        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {\\n            _vault.collateralAssets.push(_collateralAsset);\\n            _vault.collateralAmounts.push(_amount);\\n        } else {\\n            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), \\\"V8\\\");\\n            address existingCollateral = _vault.collateralAssets[_index];\\n            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), \\\"V9\\\");\\n\\n            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);\\n            _vault.collateralAssets[_index] = _collateralAsset;\\n        }\\n    }\\n\\n    /**\\n     * @dev decrease the collateral balance in a vault\\n     * @param _vault vault to remove collateral from\\n     * @param _collateralAsset address of the _collateralAsset being removed from the user's vault\\n     * @param _amount number of _collateralAsset being removed from the user's vault\\n     * @param _index index of _collateralAsset in the user's vault.collateralAssets array\\n     */\\n    function removeCollateral(\\n        Vault storage _vault,\\n        address _collateralAsset,\\n        uint256 _amount,\\n        uint256 _index\\n    ) external {\\n        // check that the removed collateral exists in the vault at the specified index\\n        require(_index < _vault.collateralAssets.length, \\\"V8\\\");\\n        require(_vault.collateralAssets[_index] == _collateralAsset, \\\"V9\\\");\\n\\n        uint256 newCollateralAmount = _vault.collateralAmounts[_index].sub(_amount);\\n\\n        if (newCollateralAmount == 0) {\\n            delete _vault.collateralAssets[_index];\\n        }\\n        _vault.collateralAmounts[_index] = newCollateralAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/gge/ribbon-finance/avocado/contracts/packages/oz/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// openzeppelin-contracts v3.1.0\\n\\n/* solhint-disable */\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[]","ContractName":"MarginVault","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]