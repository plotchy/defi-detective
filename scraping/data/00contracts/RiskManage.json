[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/RiskManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../BaseLogic.sol\\\";\\nimport \\\"../IRiskManager.sol\\\";\\nimport \\\"../vendor/TickMath.sol\\\";\\nimport \\\"../vendor/FullMath.sol\\\";\\n\\n\\n\\ninterface IUniswapV3Factory {\\n    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool);\\n}\\n\\ninterface IUniswapV3Pool {\\n    function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked);\\n    function observe(uint32[] calldata secondsAgos) external view returns (int56[] memory tickCumulatives, uint160[] memory liquidityCumulatives);\\n    function observations(uint256 index) external view returns (uint32 blockTimestamp, int56 tickCumulative, uint160 liquidityCumulative, bool initialized);\\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\\n}\\n\\n\\ncontract RiskManager is IRiskManager, BaseLogic {\\n    // Construction\\n\\n    address immutable referenceAsset; // Token must have 18 decimals\\n    address immutable uniswapFactory;\\n    bytes32 immutable uniswapPoolInitCodeHash;\\n\\n    struct RiskManagerSettings {\\n        address referenceAsset;\\n        address uniswapFactory;\\n        bytes32 uniswapPoolInitCodeHash;\\n    }\\n\\n    constructor(bytes32 moduleGitCommit_, RiskManagerSettings memory settings) BaseLogic(MODULEID__RISK_MANAGER, moduleGitCommit_) {\\n        referenceAsset = settings.referenceAsset;\\n        uniswapFactory = settings.uniswapFactory;\\n        uniswapPoolInitCodeHash = settings.uniswapPoolInitCodeHash;\\n    }\\n\\n\\n    // Default market parameters\\n\\n    function getNewMarketParameters(address underlying) external override returns (NewMarketParameters memory p) {\\n        p.config.borrowIsolated = true;\\n        p.config.collateralFactor = uint32(0);\\n        p.config.borrowFactor = type(uint32).max;\\n        p.config.twapWindow = type(uint24).max;\\n\\n        if (underlying == referenceAsset) {\\n            // 1:1 peg\\n\\n            p.pricingType = PRICINGTYPE__PEGGED;\\n            p.pricingParameters = uint32(0);\\n        } else if (pTokenLookup[underlying] != address(0)) {\\n            p.pricingType = PRICINGTYPE__FORWARDED;\\n            p.pricingParameters = uint32(0);\\n\\n            p.config.collateralFactor = underlyingLookup[pTokenLookup[underlying]].collateralFactor;\\n        } else {\\n            // Uniswap3 TWAP\\n\\n            // The selected fee level is the first existing pool found in the following order.\\n            // This may need to be corrected by a governance action if there is insufficient liquidity in the pool.\\n\\n            uint24 fee;\\n            if (IUniswapV3Factory(uniswapFactory).getPool(underlying, referenceAsset, 3000) != address(0)) fee = 3000;\\n            else if (IUniswapV3Factory(uniswapFactory).getPool(underlying, referenceAsset, 500) != address(0)) fee = 500;\\n            else if (IUniswapV3Factory(uniswapFactory).getPool(underlying, referenceAsset, 10000) != address(0)) fee = 10000;\\n            else revert(\\\"e/no-uniswap-pool-avail\\\");\\n\\n            p.pricingType = PRICINGTYPE__UNISWAP3_TWAP;\\n            p.pricingParameters = uint32(fee);\\n\\n            address pool = computeUniswapPoolAddress(underlying, fee);\\n            require(IUniswapV3Factory(uniswapFactory).getPool(underlying, referenceAsset, fee) == pool, \\\"e/bad-uniswap-pool-addr\\\");\\n\\n            try IUniswapV3Pool(pool).increaseObservationCardinalityNext(MIN_UNISWAP3_OBSERVATION_CARDINALITY) {\\n                // Success\\n            } catch Error(string memory err) {\\n                if (keccak256(bytes(err)) == keccak256(\\\"LOK\\\")) revert(\\\"e/risk/uniswap-pool-not-inited\\\");\\n                revert(string(abi.encodePacked(\\\"e/risk/uniswap/\\\", err)));\\n            } catch (bytes memory returnData) {\\n                revertBytes(returnData);\\n            }\\n        }\\n    }\\n\\n\\n\\n    // Pricing\\n\\n    function computeUniswapPoolAddress(address underlying, uint24 fee) private view returns (address) {\\n        address tokenA = underlying;\\n        address tokenB = referenceAsset;\\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\\n\\n        return address(uint160(uint256(keccak256(abi.encodePacked(\\n                   hex'ff',\\n                   uniswapFactory,\\n                   keccak256(abi.encode(tokenA, tokenB, fee)),\\n                   uniswapPoolInitCodeHash\\n               )))));\\n    }\\n\\n\\n    function decodeSqrtPriceX96(AssetCache memory assetCache, uint sqrtPriceX96) private view returns (uint price) {\\n        if (uint160(assetCache.underlying) < uint160(referenceAsset)) {\\n            price = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, uint(2**(96*2)) / 1e18) / assetCache.underlyingDecimalsScaler;\\n        } else {\\n            price = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, uint(2**(96*2)) / (1e18 * assetCache.underlyingDecimalsScaler));\\n            if (price == 0) return 1e36;\\n            price = 1e36 / price;\\n        }\\n\\n        if (price > 1e36) price = 1e36;\\n        else if (price == 0) price = 1;\\n    }\\n\\n    function callUniswapObserve(AssetCache memory assetCache, address pool, uint ago) private returns (uint, uint) {\\n        uint32[] memory secondsAgos = new uint32[](2);\\n\\n        secondsAgos[0] = uint32(ago);\\n        secondsAgos[1] = 0;\\n\\n        (bool success, bytes memory data) = pool.staticcall(abi.encodeWithSelector(IUniswapV3Pool.observe.selector, secondsAgos));\\n\\n        if (!success) {\\n            if (keccak256(data) != keccak256(abi.encodeWithSignature(\\\"Error(string)\\\", \\\"OLD\\\"))) revertBytes(data);\\n\\n            // The oldest available observation in the ring buffer is the index following the current (accounting for wrapping),\\n            // since this is the one that will be overwritten next.\\n\\n            (,, uint16 index, uint16 cardinality, uint16 cardinalityNext,,) = IUniswapV3Pool(pool).slot0();\\n\\n            (uint32 oldestAvailableAge,,,bool initialized) = IUniswapV3Pool(pool).observations((index + 1) % cardinality);\\n\\n            // If the following observation in a ring buffer of our current cardinality is uninitialized, then all the\\n            // observations at higher indices are also uninitialized, so we wrap back to index 0, which we now know\\n            // to be the oldest available observation.\\n\\n            if (!initialized) (oldestAvailableAge,,,) = IUniswapV3Pool(pool).observations(0);\\n\\n            if (cardinality == cardinalityNext && cardinality < 65535) {\\n                // Apply negative feedback: If we don't have an observation old enough to satisfy the desired TWAP,\\n                // then increase the size of the ring buffer so that in the future hopefully we will.\\n\\n                IUniswapV3Pool(pool).increaseObservationCardinalityNext(cardinality + 1);\\n            }\\n\\n            // Call observe() again to get the oldest available\\n\\n            ago = block.timestamp - oldestAvailableAge;\\n            secondsAgos[0] = uint32(ago);\\n\\n            (success, data) = pool.staticcall(abi.encodeWithSelector(IUniswapV3Pool.observe.selector, secondsAgos));\\n            if (!success) revertBytes(data);\\n        }\\n\\n        // If uniswap pool doesn't exist, then data will be empty and this decode will throw:\\n\\n        int56[] memory tickCumulatives = abi.decode(data, (int56[])); // don't bother decoding the liquidityCumulatives array\\n\\n        int24 tick = int24((tickCumulatives[1] - tickCumulatives[0]) / int56(int(ago)));\\n\\n        uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(tick);\\n\\n        return (decodeSqrtPriceX96(assetCache, sqrtPriceX96), ago);\\n    }\\n\\n    function resolvePricingConfig(AssetCache memory assetCache, AssetConfig memory config) private view returns (address underlying, uint16 pricingType, uint32 pricingParameters, uint24 twapWindow) {\\n        if (assetCache.pricingType == PRICINGTYPE__FORWARDED) {\\n            underlying = pTokenLookup[assetCache.underlying];\\n\\n            AssetConfig memory newConfig = resolveAssetConfig(underlying);\\n            twapWindow = newConfig.twapWindow;\\n\\n            AssetStorage storage newAssetStorage = eTokenLookup[newConfig.eTokenAddress];\\n            pricingType = newAssetStorage.pricingType;\\n            pricingParameters = newAssetStorage.pricingParameters;\\n\\n            require(pricingType != PRICINGTYPE__FORWARDED, \\\"e/nested-price-forwarding\\\");\\n        } else {\\n            underlying = assetCache.underlying;\\n            pricingType = assetCache.pricingType;\\n            pricingParameters = assetCache.pricingParameters;\\n            twapWindow = config.twapWindow;\\n        }\\n    }\\n\\n    function getPriceInternal(AssetCache memory assetCache, AssetConfig memory config) public FREEMEM returns (uint twap, uint twapPeriod) {\\n        (address underlying, uint16 pricingType, uint32 pricingParameters, uint24 twapWindow) = resolvePricingConfig(assetCache, config);\\n\\n        if (pricingType == PRICINGTYPE__PEGGED) {\\n            twap = 1e18;\\n            twapPeriod = twapWindow;\\n        } else if (pricingType == PRICINGTYPE__UNISWAP3_TWAP) {\\n            address pool = computeUniswapPoolAddress(underlying, uint24(pricingParameters));\\n            (twap, twapPeriod) = callUniswapObserve(assetCache, pool, twapWindow);\\n        } else {\\n            revert(\\\"e/unknown-pricing-type\\\");\\n        }\\n    }\\n\\n    function getPrice(address underlying) external override returns (uint twap, uint twapPeriod) {\\n        AssetConfig memory config = resolveAssetConfig(underlying);\\n        AssetStorage storage assetStorage = eTokenLookup[config.eTokenAddress];\\n        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);\\n\\n        (twap, twapPeriod) = getPriceInternal(assetCache, config);\\n    }\\n\\n    // This function is only meant to be called from a view so it doesn't need to be optimised.\\n    // The Euler protocol itself doesn't ever use currPrice as returned by this function.\\n\\n    function getPriceFull(address underlying) external override returns (uint twap, uint twapPeriod, uint currPrice) {\\n        AssetConfig memory config = resolveAssetConfig(underlying);\\n        AssetStorage storage assetStorage = eTokenLookup[config.eTokenAddress];\\n        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);\\n\\n        (twap, twapPeriod) = getPriceInternal(assetCache, config);\\n\\n        (address newUnderlying, uint16 pricingType, uint32 pricingParameters,) = resolvePricingConfig(assetCache, config);\\n\\n        if (pricingType == PRICINGTYPE__PEGGED) {\\n            currPrice = 1e18;\\n        } else if (pricingType == PRICINGTYPE__UNISWAP3_TWAP || pricingType == PRICINGTYPE__FORWARDED) {\\n            AssetCache memory newAssetCache = loadAssetCache(newUnderlying, assetStorage);\\n            address pool = computeUniswapPoolAddress(newUnderlying, uint24(pricingParameters));\\n            (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(pool).slot0();\\n            currPrice = decodeSqrtPriceX96(newAssetCache, sqrtPriceX96);\\n        } else {\\n            revert(\\\"e/unknown-pricing-type\\\");\\n        }\\n    }\\n\\n\\n    // Liquidity\\n\\n    function computeLiquidityRaw(address account, address[] memory underlyings) private returns (LiquidityStatus memory status) {\\n        status.collateralValue = 0;\\n        status.liabilityValue = 0;\\n        status.numBorrows = 0;\\n        status.borrowIsolated = false;\\n\\n        AssetConfig memory config;\\n        AssetStorage storage assetStorage;\\n        AssetCache memory assetCache;\\n\\n        for (uint i = 0; i < underlyings.length; ++i) {\\n            address underlying = underlyings[i];\\n            bool assetCacheAndPriceInited = false;\\n            uint price;\\n\\n            config = resolveAssetConfig(underlying);\\n            assetStorage = eTokenLookup[config.eTokenAddress];\\n\\n            uint balance = assetStorage.users[account].balance;\\n            uint owed = assetStorage.users[account].owed;\\n\\n            if (balance != 0 && config.collateralFactor != 0) {\\n                initAssetCache(underlying, assetStorage, assetCache);\\n                (price,) = getPriceInternal(assetCache, config);\\n                assetCacheAndPriceInited = true;\\n\\n                uint assetCollateral = balanceToUnderlyingAmount(assetCache, balance);\\n                assetCollateral = assetCollateral * price / 1e18;\\n                assetCollateral = assetCollateral * config.collateralFactor / CONFIG_FACTOR_SCALE;\\n                status.collateralValue += assetCollateral;\\n            }\\n\\n            if (owed != 0) {\\n                if (!assetCacheAndPriceInited) {\\n                    initAssetCache(underlying, assetStorage, assetCache);\\n                    (price,) = getPriceInternal(assetCache, config);\\n                    assetCacheAndPriceInited = true;\\n                }\\n\\n                status.numBorrows++;\\n                if (config.borrowIsolated) status.borrowIsolated = true;\\n\\n                uint assetLiability = getCurrentOwed(assetStorage, assetCache, account);\\n                assetLiability = assetLiability * price / 1e18;\\n                assetLiability = assetLiability * CONFIG_FACTOR_SCALE / config.borrowFactor;\\n                status.liabilityValue += assetLiability;\\n            }\\n        }\\n    }\\n\\n    function computeLiquidity(address account) public override returns (LiquidityStatus memory) {\\n        return computeLiquidityRaw(account, getEnteredMarketsArray(account));\\n    }\\n\\n    function computeAssetLiquidities(address account) external override returns (AssetLiquidity[] memory) {\\n        address[] memory underlyings = getEnteredMarketsArray(account);\\n\\n        AssetLiquidity[] memory output = new AssetLiquidity[](underlyings.length);\\n\\n        address[] memory singleUnderlying = new address[](1);\\n\\n        for (uint i = 0; i < underlyings.length; ++i) {\\n            output[i].underlying = singleUnderlying[0] = underlyings[i];\\n            output[i].status = computeLiquidityRaw(account, singleUnderlying);\\n        }\\n\\n        return output;\\n    }\\n\\n    function requireLiquidity(address account) external override {\\n        LiquidityStatus memory status = computeLiquidity(account);\\n\\n        require(!status.borrowIsolated || status.numBorrows == 1, \\\"e/borrow-isolation-violation\\\");\\n        require(status.collateralValue >= status.liabilityValue, \\\"e/collateral-violation\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BaseLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BaseModule.sol\\\";\\nimport \\\"./BaseIRM.sol\\\";\\nimport \\\"./Interfaces.sol\\\";\\nimport \\\"./Utils.sol\\\";\\nimport \\\"./vendor/RPow.sol\\\";\\nimport \\\"./IRiskManager.sol\\\";\\n\\n\\nabstract contract BaseLogic is BaseModule {\\n    constructor(uint moduleId_, bytes32 moduleGitCommit_) BaseModule(moduleId_, moduleGitCommit_) {}\\n\\n\\n    // Account auth\\n\\n    function getSubAccount(address primary, uint subAccountId) internal pure returns (address) {\\n        require(subAccountId < 256, \\\"e/sub-account-id-too-big\\\");\\n        return address(uint160(primary) ^ uint160(subAccountId));\\n    }\\n\\n    function isSubAccountOf(address primary, address subAccount) internal pure returns (bool) {\\n        return (uint160(primary) | 0xFF) == (uint160(subAccount) | 0xFF);\\n    }\\n\\n\\n\\n    // Entered markets array\\n\\n    function getEnteredMarketsArray(address account) internal view returns (address[] memory) {\\n        uint32 numMarketsEntered = accountLookup[account].numMarketsEntered;\\n        address firstMarketEntered = accountLookup[account].firstMarketEntered;\\n\\n        address[] memory output = new address[](numMarketsEntered);\\n        if (numMarketsEntered == 0) return output;\\n\\n        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];\\n\\n        output[0] = firstMarketEntered;\\n\\n        for (uint i = 1; i < numMarketsEntered; ++i) {\\n            output[i] = markets[i];\\n        }\\n\\n        return output;\\n    }\\n\\n    function isEnteredInMarket(address account, address underlying) internal view returns (bool) {\\n        uint32 numMarketsEntered = accountLookup[account].numMarketsEntered;\\n        address firstMarketEntered = accountLookup[account].firstMarketEntered;\\n\\n        if (numMarketsEntered == 0) return false;\\n        if (firstMarketEntered == underlying) return true;\\n\\n        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];\\n\\n        for (uint i = 1; i < numMarketsEntered; ++i) {\\n            if (markets[i] == underlying) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function doEnterMarket(address account, address underlying) internal {\\n        AccountStorage storage accountStorage = accountLookup[account];\\n\\n        uint32 numMarketsEntered = accountStorage.numMarketsEntered;\\n        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];\\n\\n        if (numMarketsEntered != 0) {\\n            if (accountStorage.firstMarketEntered == underlying) return; // already entered\\n            for (uint i = 1; i < numMarketsEntered; i++) {\\n                if (markets[i] == underlying) return; // already entered\\n            }\\n        }\\n\\n        require(numMarketsEntered < MAX_ENTERED_MARKETS, \\\"e/too-many-entered-markets\\\");\\n\\n        if (numMarketsEntered == 0) accountStorage.firstMarketEntered = underlying;\\n        else markets[numMarketsEntered] = underlying;\\n\\n        accountStorage.numMarketsEntered = numMarketsEntered + 1;\\n\\n        emit EnterMarket(underlying, account);\\n    }\\n\\n    // Liquidity check must be done by caller after calling this\\n\\n    function doExitMarket(address account, address underlying) internal {\\n        AccountStorage storage accountStorage = accountLookup[account];\\n\\n        uint32 numMarketsEntered = accountStorage.numMarketsEntered;\\n        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];\\n        uint searchIndex = type(uint).max;\\n\\n        if (numMarketsEntered == 0) return; // already exited\\n\\n        if (accountStorage.firstMarketEntered == underlying) {\\n            searchIndex = 0;\\n        } else {\\n            for (uint i = 1; i < numMarketsEntered; i++) {\\n                if (markets[i] == underlying) {\\n                    searchIndex = i;\\n                    break;\\n                }\\n            }\\n\\n            if (searchIndex == type(uint).max) return; // already exited\\n        }\\n\\n        uint lastMarketIndex = numMarketsEntered - 1;\\n\\n        if (searchIndex != lastMarketIndex) {\\n            if (searchIndex == 0) accountStorage.firstMarketEntered = markets[lastMarketIndex];\\n            else markets[searchIndex] = markets[lastMarketIndex];\\n        }\\n\\n        accountStorage.numMarketsEntered = uint32(lastMarketIndex);\\n\\n        if (lastMarketIndex != 0) markets[lastMarketIndex] = address(0); // zero out for storage refund\\n\\n        emit ExitMarket(underlying, account);\\n    }\\n\\n\\n\\n    // AssetConfig\\n\\n    function resolveAssetConfig(address underlying) internal view returns (AssetConfig memory) {\\n        AssetConfig memory config = underlyingLookup[underlying];\\n        require(config.eTokenAddress != address(0), \\\"e/market-not-activated\\\");\\n\\n        if (config.borrowFactor == type(uint32).max) config.borrowFactor = DEFAULT_BORROW_FACTOR;\\n        if (config.twapWindow == type(uint24).max) config.twapWindow = DEFAULT_TWAP_WINDOW_SECONDS;\\n\\n        return config;\\n    }\\n\\n\\n    // AssetCache\\n\\n    struct AssetCache {\\n        address underlying;\\n\\n        uint112 totalBalances;\\n        uint144 totalBorrows;\\n\\n        uint96 reserveBalance;\\n\\n        uint interestAccumulator;\\n\\n        uint40 lastInterestAccumulatorUpdate;\\n        uint8 underlyingDecimals;\\n        uint32 interestRateModel;\\n        int96 interestRate;\\n        uint32 reserveFee;\\n        uint16 pricingType;\\n        uint32 pricingParameters;\\n\\n        uint poolSize; // result of calling balanceOf on underlying (in external units)\\n\\n        uint underlyingDecimalsScaler;\\n        uint maxExternalAmount;\\n    }\\n\\n    function initAssetCache(address underlying, AssetStorage storage assetStorage, AssetCache memory assetCache) internal view returns (bool dirty) {\\n        dirty = false;\\n\\n        assetCache.underlying = underlying;\\n\\n        // Storage loads\\n\\n        assetCache.lastInterestAccumulatorUpdate = assetStorage.lastInterestAccumulatorUpdate;\\n        uint8 underlyingDecimals = assetCache.underlyingDecimals = assetStorage.underlyingDecimals;\\n        assetCache.interestRateModel = assetStorage.interestRateModel;\\n        assetCache.interestRate = assetStorage.interestRate;\\n        assetCache.reserveFee = assetStorage.reserveFee;\\n        assetCache.pricingType = assetStorage.pricingType;\\n        assetCache.pricingParameters = assetStorage.pricingParameters;\\n\\n        assetCache.reserveBalance = assetStorage.reserveBalance;\\n\\n        assetCache.totalBalances = assetStorage.totalBalances;\\n        assetCache.totalBorrows = assetStorage.totalBorrows;\\n\\n        assetCache.interestAccumulator = assetStorage.interestAccumulator;\\n\\n        // Derived state\\n\\n        unchecked {\\n            assetCache.underlyingDecimalsScaler = 10**(18 - underlyingDecimals);\\n            assetCache.maxExternalAmount = MAX_SANE_AMOUNT / assetCache.underlyingDecimalsScaler;\\n        }\\n\\n        uint poolSize = callBalanceOf(assetCache, address(this));\\n        if (poolSize <= assetCache.maxExternalAmount) {\\n            unchecked { assetCache.poolSize = poolSize * assetCache.underlyingDecimalsScaler; }\\n        } else {\\n            assetCache.poolSize = 0;\\n        }\\n\\n        // Update interest accumulator and reserves\\n\\n        if (block.timestamp != assetCache.lastInterestAccumulatorUpdate) {\\n            dirty = true;\\n\\n            uint deltaT = block.timestamp - assetCache.lastInterestAccumulatorUpdate;\\n\\n            // Compute new values\\n\\n            uint newInterestAccumulator = (RPow.rpow(uint(int(assetCache.interestRate) + 1e27), deltaT, 1e27) * assetCache.interestAccumulator) / 1e27;\\n\\n            uint newTotalBorrows = assetCache.totalBorrows * newInterestAccumulator / assetCache.interestAccumulator;\\n\\n            uint newReserveBalance = assetCache.reserveBalance;\\n            uint newTotalBalances = assetCache.totalBalances;\\n\\n            uint feeAmount = (newTotalBorrows - assetCache.totalBorrows)\\n                               * (assetCache.reserveFee == type(uint32).max ? DEFAULT_RESERVE_FEE : assetCache.reserveFee)\\n                               / (RESERVE_FEE_SCALE * INTERNAL_DEBT_PRECISION);\\n\\n            if (feeAmount != 0) {\\n                uint poolAssets = assetCache.poolSize + (newTotalBorrows / INTERNAL_DEBT_PRECISION);\\n                newTotalBalances = poolAssets * newTotalBalances / (poolAssets - feeAmount);\\n                newReserveBalance += newTotalBalances - assetCache.totalBalances;\\n            }\\n\\n            // Store new values in assetCache, only if no overflows will occur\\n\\n            if (newTotalBalances <= MAX_SANE_AMOUNT && newTotalBorrows <= MAX_SANE_DEBT_AMOUNT) {\\n                assetCache.totalBorrows = encodeDebtAmount(newTotalBorrows);\\n                assetCache.interestAccumulator = newInterestAccumulator;\\n                assetCache.lastInterestAccumulatorUpdate = uint40(block.timestamp);\\n\\n                if (newTotalBalances != assetCache.totalBalances) {\\n                    assetCache.reserveBalance = encodeSmallAmount(newReserveBalance);\\n                    assetCache.totalBalances = encodeAmount(newTotalBalances);\\n                }\\n            }\\n        }\\n    }\\n\\n    function loadAssetCache(address underlying, AssetStorage storage assetStorage) internal returns (AssetCache memory assetCache) {\\n        if (initAssetCache(underlying, assetStorage, assetCache)) {\\n            assetStorage.lastInterestAccumulatorUpdate = assetCache.lastInterestAccumulatorUpdate;\\n\\n            assetStorage.underlying = assetCache.underlying; // avoid an SLOAD of this slot\\n            assetStorage.reserveBalance = assetCache.reserveBalance;\\n\\n            assetStorage.totalBalances = assetCache.totalBalances;\\n            assetStorage.totalBorrows = assetCache.totalBorrows;\\n\\n            assetStorage.interestAccumulator = assetCache.interestAccumulator;\\n        }\\n    }\\n\\n    function loadAssetCacheRO(address underlying, AssetStorage storage assetStorage) internal view returns (AssetCache memory assetCache) {\\n        initAssetCache(underlying, assetStorage, assetCache);\\n    }\\n\\n\\n\\n    // Utils\\n\\n    function decodeExternalAmount(AssetCache memory assetCache, uint externalAmount) internal pure returns (uint scaledAmount) {\\n        require(externalAmount <= assetCache.maxExternalAmount, \\\"e/amount-too-large\\\");\\n        unchecked { scaledAmount = externalAmount * assetCache.underlyingDecimalsScaler; }\\n    }\\n\\n    function encodeAmount(uint amount) internal pure returns (uint112) {\\n        require(amount <= MAX_SANE_AMOUNT, \\\"e/amount-too-large-to-encode\\\");\\n        return uint112(amount);\\n    }\\n\\n    function encodeSmallAmount(uint amount) internal pure returns (uint96) {\\n        require(amount <= MAX_SANE_SMALL_AMOUNT, \\\"e/small-amount-too-large-to-encode\\\");\\n        return uint96(amount);\\n    }\\n\\n    function encodeDebtAmount(uint amount) internal pure returns (uint144) {\\n        require(amount <= MAX_SANE_DEBT_AMOUNT, \\\"e/debt-amount-too-large-to-encode\\\");\\n        return uint144(amount);\\n    }\\n\\n    function computeExchangeRate(AssetCache memory assetCache) private pure returns (uint) {\\n        if (assetCache.totalBalances == 0) return 1e18;\\n        return (assetCache.poolSize + (assetCache.totalBorrows / INTERNAL_DEBT_PRECISION)) * 1e18 / assetCache.totalBalances;\\n    }\\n\\n    function underlyingAmountToBalance(AssetCache memory assetCache, uint amount) internal pure returns (uint) {\\n        uint exchangeRate = computeExchangeRate(assetCache);\\n        return amount * 1e18 / exchangeRate;\\n    }\\n\\n    function underlyingAmountToBalanceRoundUp(AssetCache memory assetCache, uint amount) internal pure returns (uint) {\\n        uint exchangeRate = computeExchangeRate(assetCache);\\n        return (amount * 1e18 + (exchangeRate - 1)) / exchangeRate;\\n    }\\n\\n    function balanceToUnderlyingAmount(AssetCache memory assetCache, uint amount) internal pure returns (uint) {\\n        uint exchangeRate = computeExchangeRate(assetCache);\\n        return amount * exchangeRate / 1e18;\\n    }\\n\\n    function callBalanceOf(AssetCache memory assetCache, address account) internal view FREEMEM returns (uint) {\\n        // We set a gas limit so that a malicious token can't eat up all gas and cause a liquidity check to fail.\\n\\n        (bool success, bytes memory data) = assetCache.underlying.staticcall{gas: 20000}(abi.encodeWithSelector(IERC20.balanceOf.selector, account));\\n\\n        // If token's balanceOf() call fails for any reason, return 0. This prevents malicious tokens from causing liquidity checks to fail.\\n        // If the contract doesn't exist (maybe because selfdestructed), then data.length will be 0 and we will return 0.\\n        // Data length > 32 is allowed because some legitimate tokens append extra data that can be safely ignored.\\n\\n        if (!success || data.length < 32) return 0;\\n\\n        return abi.decode(data, (uint256));\\n    }\\n\\n    function updateInterestRate(AssetStorage storage assetStorage, AssetCache memory assetCache) internal {\\n        uint32 utilisation;\\n\\n        {\\n            uint totalBorrows = assetCache.totalBorrows / INTERNAL_DEBT_PRECISION;\\n            uint poolAssets = assetCache.poolSize + totalBorrows;\\n            if (poolAssets == 0) utilisation = 0; // empty pool arbitrarily given utilisation of 0\\n            else utilisation = uint32(totalBorrows * (uint(type(uint32).max) * 1e18) / poolAssets / 1e18);\\n        }\\n\\n        bytes memory result = callInternalModule(assetCache.interestRateModel,\\n                                                 abi.encodeWithSelector(BaseIRM.computeInterestRate.selector, assetCache.underlying, utilisation));\\n\\n        (int96 newInterestRate) = abi.decode(result, (int96));\\n\\n        assetStorage.interestRate = assetCache.interestRate = newInterestRate;\\n    }\\n\\n    function logAssetStatus(AssetCache memory a) internal {\\n        emit AssetStatus(a.underlying, a.totalBalances, a.totalBorrows / INTERNAL_DEBT_PRECISION, a.reserveBalance, a.poolSize, a.interestAccumulator, a.interestRate, block.timestamp);\\n    }\\n\\n\\n\\n    // Balances\\n\\n    function increaseBalance(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address account, uint amount) internal {\\n        assetStorage.users[account].balance = encodeAmount(assetStorage.users[account].balance + amount);\\n\\n        assetStorage.totalBalances = assetCache.totalBalances = encodeAmount(uint(assetCache.totalBalances) + amount);\\n\\n        updateInterestRate(assetStorage, assetCache);\\n\\n        emit Deposit(assetCache.underlying, account, amount);\\n        emitViaProxy_Transfer(eTokenAddress, address(0), account, amount);\\n    }\\n\\n    function decreaseBalance(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address account, uint amount) internal {\\n        uint origBalance = assetStorage.users[account].balance;\\n        require(origBalance >= amount, \\\"e/insufficient-balance\\\");\\n        assetStorage.users[account].balance = encodeAmount(origBalance - amount);\\n\\n        assetStorage.totalBalances = assetCache.totalBalances = encodeAmount(assetCache.totalBalances - amount);\\n\\n        updateInterestRate(assetStorage, assetCache);\\n\\n        emit Withdraw(assetCache.underlying, account, amount);\\n        emitViaProxy_Transfer(eTokenAddress, account, address(0), amount);\\n    }\\n\\n    function transferBalance(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address from, address to, uint amount) internal {\\n        uint origFromBalance = assetStorage.users[from].balance;\\n        require(origFromBalance >= amount, \\\"e/insufficient-balance\\\");\\n        uint newFromBalance;\\n        unchecked { newFromBalance = origFromBalance - amount; }\\n\\n        assetStorage.users[from].balance = encodeAmount(newFromBalance);\\n        assetStorage.users[to].balance = encodeAmount(assetStorage.users[to].balance + amount);\\n\\n        emit Withdraw(assetCache.underlying, from, amount);\\n        emit Deposit(assetCache.underlying, to, amount);\\n        emitViaProxy_Transfer(eTokenAddress, from, to, amount);\\n    }\\n\\n    function withdrawAmounts(AssetStorage storage assetStorage, AssetCache memory assetCache, address account, uint amount) internal view returns (uint, uint) {\\n        uint amountInternal;\\n        if (amount == type(uint).max) {\\n            amountInternal = assetStorage.users[account].balance;\\n            amount = balanceToUnderlyingAmount(assetCache, amountInternal);\\n        } else {\\n            amount = decodeExternalAmount(assetCache, amount);\\n            amountInternal = underlyingAmountToBalanceRoundUp(assetCache, amount);\\n        }\\n\\n        return (amount, amountInternal);\\n    }\\n\\n    // Borrows\\n\\n    // Returns internal precision\\n\\n    function getCurrentOwedExact(AssetStorage storage assetStorage, AssetCache memory assetCache, address account, uint owed) internal view returns (uint) {\\n        // Don't bother loading the user's accumulator\\n        if (owed == 0) return 0;\\n\\n        // Can't divide by 0 here: If owed is non-zero, we must've initialised the user's interestAccumulator\\n        return owed * assetCache.interestAccumulator / assetStorage.users[account].interestAccumulator;\\n    }\\n\\n    // When non-zero, we round *up* to the smallest external unit so that outstanding dust in a loan can be repaid.\\n    // unchecked is OK here since owed is always loaded from storage, so we know it fits into a uint144 (pre-interest accural)\\n    // Takes and returns 27 decimals precision.\\n\\n    function roundUpOwed(AssetCache memory assetCache, uint owed) private pure returns (uint) {\\n        if (owed == 0) return 0;\\n\\n        unchecked {\\n            uint scale = INTERNAL_DEBT_PRECISION * assetCache.underlyingDecimalsScaler;\\n            return (owed + scale - 1) / scale * scale;\\n        }\\n    }\\n\\n    // Returns 18-decimals precision (debt amount is rounded up)\\n\\n    function getCurrentOwed(AssetStorage storage assetStorage, AssetCache memory assetCache, address account) internal view returns (uint) {\\n        return roundUpOwed(assetCache, getCurrentOwedExact(assetStorage, assetCache, account, assetStorage.users[account].owed)) / INTERNAL_DEBT_PRECISION;\\n    }\\n\\n    function updateUserBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address account) private returns (uint newOwedExact, uint prevOwedExact) {\\n        prevOwedExact = assetStorage.users[account].owed;\\n\\n        newOwedExact = getCurrentOwedExact(assetStorage, assetCache, account, prevOwedExact);\\n\\n        assetStorage.users[account].owed = encodeDebtAmount(newOwedExact);\\n        assetStorage.users[account].interestAccumulator = assetCache.interestAccumulator;\\n    }\\n\\n    function logBorrowChange(AssetCache memory assetCache, address dTokenAddress, address account, uint prevOwed, uint owed) private {\\n        prevOwed = roundUpOwed(assetCache, prevOwed) / INTERNAL_DEBT_PRECISION;\\n        owed = roundUpOwed(assetCache, owed) / INTERNAL_DEBT_PRECISION;\\n\\n        if (owed > prevOwed) {\\n            uint change = owed - prevOwed;\\n            emit Borrow(assetCache.underlying, account, change);\\n            emitViaProxy_Transfer(dTokenAddress, address(0), account, change);\\n        } else if (prevOwed > owed) {\\n            uint change = prevOwed - owed;\\n            emit Repay(assetCache.underlying, account, change);\\n            emitViaProxy_Transfer(dTokenAddress, account, address(0), change);\\n        }\\n    }\\n\\n    function increaseBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address account, uint amount) internal {\\n        amount *= INTERNAL_DEBT_PRECISION;\\n\\n        require(assetCache.pricingType != PRICINGTYPE__FORWARDED || pTokenLookup[assetCache.underlying] == address(0), \\\"e/borrow-not-supported\\\");\\n\\n        (uint owed, uint prevOwed) = updateUserBorrow(assetStorage, assetCache, account);\\n\\n        if (owed == 0) doEnterMarket(account, assetCache.underlying);\\n\\n        owed += amount;\\n\\n        assetStorage.users[account].owed = encodeDebtAmount(owed);\\n        assetStorage.totalBorrows = assetCache.totalBorrows = encodeDebtAmount(assetCache.totalBorrows + amount);\\n\\n        updateInterestRate(assetStorage, assetCache);\\n\\n        logBorrowChange(assetCache, dTokenAddress, account, prevOwed, owed);\\n    }\\n\\n    function decreaseBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address account, uint origAmount) internal {\\n        uint amount = origAmount * INTERNAL_DEBT_PRECISION;\\n\\n        (uint owed, uint prevOwed) = updateUserBorrow(assetStorage, assetCache, account);\\n        uint owedRoundedUp = roundUpOwed(assetCache, owed);\\n\\n        require(amount <= owedRoundedUp, \\\"e/repay-too-much\\\");\\n        uint owedRemaining;\\n        unchecked { owedRemaining = owedRoundedUp - amount; }\\n\\n        if (owed > assetCache.totalBorrows) owed = assetCache.totalBorrows;\\n\\n        assetStorage.users[account].owed = encodeDebtAmount(owedRemaining);\\n        assetStorage.totalBorrows = assetCache.totalBorrows = encodeDebtAmount(assetCache.totalBorrows - owed + owedRemaining);\\n\\n        updateInterestRate(assetStorage, assetCache);\\n\\n        logBorrowChange(assetCache, dTokenAddress, account, prevOwed, owedRemaining);\\n    }\\n\\n    function transferBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address from, address to, uint origAmount) internal {\\n        uint amount = origAmount * INTERNAL_DEBT_PRECISION;\\n\\n        (uint fromOwed, uint fromOwedPrev) = updateUserBorrow(assetStorage, assetCache, from);\\n        (uint toOwed, uint toOwedPrev) = updateUserBorrow(assetStorage, assetCache, to);\\n\\n        if (toOwed == 0) doEnterMarket(to, assetCache.underlying);\\n\\n        // If amount was rounded up, transfer exact amount owed\\n        if (amount > fromOwed && amount - fromOwed < INTERNAL_DEBT_PRECISION) amount = fromOwed;\\n\\n        require(fromOwed >= amount, \\\"e/insufficient-balance\\\");\\n        unchecked { fromOwed -= amount; }\\n\\n        // Transfer any residual dust\\n        if (fromOwed < INTERNAL_DEBT_PRECISION) {\\n            amount += fromOwed;\\n            fromOwed = 0;\\n        }\\n\\n        toOwed += amount;\\n\\n        assetStorage.users[from].owed = encodeDebtAmount(fromOwed);\\n        assetStorage.users[to].owed = encodeDebtAmount(toOwed);\\n\\n        logBorrowChange(assetCache, dTokenAddress, from, fromOwedPrev, fromOwed);\\n        logBorrowChange(assetCache, dTokenAddress, to, toOwedPrev, toOwed);\\n    }\\n\\n\\n\\n    // Reserves\\n\\n    function increaseReserves(AssetStorage storage assetStorage, AssetCache memory assetCache, uint amount) internal {\\n        assetStorage.reserveBalance = assetCache.reserveBalance = encodeSmallAmount(assetCache.reserveBalance + amount);\\n        assetStorage.totalBalances = assetCache.totalBalances = encodeAmount(assetCache.totalBalances + amount);\\n    }\\n\\n\\n\\n    // Token asset transfers\\n\\n    // amounts are in underlying units\\n\\n    function pullTokens(AssetCache memory assetCache, address from, uint amount) internal returns (uint amountTransferred) {\\n        uint poolSizeBefore = assetCache.poolSize;\\n\\n        Utils.safeTransferFrom(assetCache.underlying, from, address(this), amount / assetCache.underlyingDecimalsScaler);\\n        uint poolSizeAfter = assetCache.poolSize = decodeExternalAmount(assetCache, callBalanceOf(assetCache, address(this)));\\n\\n        require(poolSizeAfter >= poolSizeBefore, \\\"e/negative-transfer-amount\\\");\\n        unchecked { amountTransferred = poolSizeAfter - poolSizeBefore; }\\n    }\\n\\n    function pushTokens(AssetCache memory assetCache, address to, uint amount) internal returns (uint amountTransferred) {\\n        uint poolSizeBefore = assetCache.poolSize;\\n\\n        Utils.safeTransfer(assetCache.underlying, to, amount / assetCache.underlyingDecimalsScaler);\\n        uint poolSizeAfter = assetCache.poolSize = decodeExternalAmount(assetCache, callBalanceOf(assetCache, address(this)));\\n\\n        require(poolSizeBefore >= poolSizeAfter, \\\"e/negative-transfer-amount\\\");\\n        unchecked { amountTransferred = poolSizeBefore - poolSizeAfter; }\\n    }\\n\\n\\n\\n\\n    // Liquidity\\n\\n    function getAssetPrice(address asset) internal returns (uint) {\\n        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.getPrice.selector, asset));\\n        return abi.decode(result, (uint));\\n    }\\n\\n    function getAccountLiquidity(address account) internal returns (uint collateralValue, uint liabilityValue) {\\n        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.computeLiquidity.selector, account));\\n        (IRiskManager.LiquidityStatus memory status) = abi.decode(result, (IRiskManager.LiquidityStatus));\\n\\n        collateralValue = status.collateralValue;\\n        liabilityValue = status.liabilityValue;\\n    }\\n\\n    function checkLiquidity(address account) internal {\\n        uint8 status = accountLookup[account].deferLiquidityStatus;\\n\\n        if (status == DEFERLIQUIDITY__NONE) {\\n            callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.requireLiquidity.selector, account));\\n        } else if (status == DEFERLIQUIDITY__CLEAN) {\\n            accountLookup[account].deferLiquidityStatus = DEFERLIQUIDITY__DIRTY;\\n        }\\n    }\\n\\n\\n\\n    // Optional average liquidity tracking\\n\\n    function computeNewAverageLiquidity(address account, uint deltaT) private returns (uint) {\\n        uint currDuration = deltaT >= AVERAGE_LIQUIDITY_PERIOD ? AVERAGE_LIQUIDITY_PERIOD : deltaT;\\n        uint prevDuration = AVERAGE_LIQUIDITY_PERIOD - currDuration;\\n\\n        uint currAverageLiquidity;\\n\\n        {\\n            (uint collateralValue, uint liabilityValue) = getAccountLiquidity(account);\\n            currAverageLiquidity = collateralValue > liabilityValue ? collateralValue - liabilityValue : 0;\\n        }\\n\\n        return (accountLookup[account].averageLiquidity * prevDuration / AVERAGE_LIQUIDITY_PERIOD) +\\n               (currAverageLiquidity * currDuration / AVERAGE_LIQUIDITY_PERIOD);\\n    }\\n\\n    function getUpdatedAverageLiquidity(address account) internal returns (uint) {\\n        uint lastAverageLiquidityUpdate = accountLookup[account].lastAverageLiquidityUpdate;\\n        if (lastAverageLiquidityUpdate == 0) return 0;\\n\\n        uint deltaT = block.timestamp - lastAverageLiquidityUpdate;\\n        if (deltaT == 0) return accountLookup[account].averageLiquidity;\\n\\n        return computeNewAverageLiquidity(account, deltaT);\\n    }\\n\\n    function getUpdatedAverageLiquidityWithDelegate(address account) internal returns (uint) {\\n        address delegate = accountLookup[account].averageLiquidityDelegate;\\n\\n        return delegate != address(0) && accountLookup[delegate].averageLiquidityDelegate == account\\n            ? getUpdatedAverageLiquidity(delegate)\\n            : getUpdatedAverageLiquidity(account);\\n    }\\n\\n    function updateAverageLiquidity(address account) internal {\\n        uint lastAverageLiquidityUpdate = accountLookup[account].lastAverageLiquidityUpdate;\\n        if (lastAverageLiquidityUpdate == 0) return;\\n\\n        uint deltaT = block.timestamp - lastAverageLiquidityUpdate;\\n        if (deltaT == 0) return;\\n\\n        accountLookup[account].lastAverageLiquidityUpdate = uint40(block.timestamp);\\n        accountLookup[account].averageLiquidity = computeNewAverageLiquidity(account, deltaT);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IRiskManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Storage.sol\\\";\\n\\n// This interface is used to avoid a circular dependency between BaseLogic and RiskManager\\n\\ninterface IRiskManager {\\n    struct NewMarketParameters {\\n        uint16 pricingType;\\n        uint32 pricingParameters;\\n\\n        Storage.AssetConfig config;\\n    }\\n\\n    struct LiquidityStatus {\\n        uint collateralValue;\\n        uint liabilityValue;\\n        uint numBorrows;\\n        bool borrowIsolated;\\n    }\\n\\n    struct AssetLiquidity {\\n        address underlying;\\n        LiquidityStatus status;\\n    }\\n\\n    function getNewMarketParameters(address underlying) external returns (NewMarketParameters memory);\\n\\n    function requireLiquidity(address account) external;\\n    function computeLiquidity(address account) external returns (LiquidityStatus memory status);\\n    function computeAssetLiquidities(address account) external returns (AssetLiquidity[] memory assets);\\n\\n    function getPrice(address underlying) external returns (uint twap, uint twapPeriod);\\n    function getPriceFull(address underlying) external returns (uint twap, uint twapPeriod, uint currPrice);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/TickMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\n// From Uniswap3 Core\\n\\n// Updated to Solidity 0.8 by Euler:\\n//   * Cast MAX_TICK to int256 before casting to uint\\n//   * Wrapped function bodies with \\\"unchecked {}\\\" so as to not add any extra gas costs\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n      unchecked {\\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n        require(absTick <= uint256(int(MAX_TICK)), 'T');\\n\\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n      }\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n      unchecked {\\n        // second inequality must be < because the price can never reach the price at the max tick\\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n        uint256 r = ratio;\\n        uint256 msb = 0;\\n\\n        assembly {\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(4, gt(r, 0xFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(3, gt(r, 0xFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(2, gt(r, 0xF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(1, gt(r, 0x3))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := gt(r, 0x1)\\n            msb := or(msb, f)\\n        }\\n\\n        if (msb >= 128) r = ratio >> (msb - 127);\\n        else r = ratio << (127 - msb);\\n\\n        int256 log_2 = (int256(msb) - 128) << 64;\\n\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(63, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(62, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(61, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(60, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(59, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(58, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(57, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(56, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(55, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(54, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(53, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(52, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(51, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(50, f))\\n        }\\n\\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n      }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// From Uniswap3 Core\\n\\n// Updated to Solidity 0.8 by Euler:\\n//   * Rewrite unary negation of denominator, which is a uint\\n//   * Wrapped function bodies with \\\"unchecked {}\\\" so as to not add any extra gas costs\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n      unchecked {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = denominator & (~denominator + 1);\\n\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n      }\\n    }\\n\\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n      unchecked {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n      }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BaseModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Base.sol\\\";\\n\\n\\nabstract contract BaseModule is Base {\\n    // Construction\\n\\n    // public accessors common to all modules\\n\\n    uint immutable public moduleId;\\n    bytes32 immutable public moduleGitCommit;\\n\\n    constructor(uint moduleId_, bytes32 moduleGitCommit_) {\\n        moduleId = moduleId_;\\n        moduleGitCommit = moduleGitCommit_;\\n    }\\n\\n\\n    // Accessing parameters\\n\\n    function unpackTrailingParamMsgSender() internal pure returns (address msgSender) {\\n        assembly {\\n            mstore(0, 0)\\n\\n            calldatacopy(12, sub(calldatasize(), 40), 20)\\n            msgSender := mload(0)\\n        }\\n    }\\n\\n    function unpackTrailingParams() internal pure returns (address msgSender, address proxyAddr) {\\n        assembly {\\n            mstore(0, 0)\\n\\n            calldatacopy(12, sub(calldatasize(), 40), 20)\\n            msgSender := mload(0)\\n\\n            calldatacopy(12, sub(calldatasize(), 20), 20)\\n            proxyAddr := mload(0)\\n        }\\n    }\\n\\n\\n    // Emit logs via proxies\\n\\n    function emitViaProxy_Transfer(address proxyAddr, address from, address to, uint value) internal FREEMEM {\\n        (bool success,) = proxyAddr.call(abi.encodePacked(\\n                               uint8(3),\\n                               keccak256(bytes('Transfer(address,address,uint256)')),\\n                               bytes32(uint(uint160(from))),\\n                               bytes32(uint(uint160(to))),\\n                               value\\n                          ));\\n        require(success, \\\"e/log-proxy-fail\\\");\\n    }\\n\\n    function emitViaProxy_Approval(address proxyAddr, address owner, address spender, uint value) internal FREEMEM {\\n        (bool success,) = proxyAddr.call(abi.encodePacked(\\n                               uint8(3),\\n                               keccak256(bytes('Approval(address,address,uint256)')),\\n                               bytes32(uint(uint160(owner))),\\n                               bytes32(uint(uint160(spender))),\\n                               value\\n                          ));\\n        require(success, \\\"e/log-proxy-fail\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BaseIRM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BaseModule.sol\\\";\\n\\nabstract contract BaseIRM is BaseModule {\\n    constructor(uint moduleId_, bytes32 moduleGitCommit_) BaseModule(moduleId_, moduleGitCommit_) {}\\n\\n    int96 internal constant MAX_ALLOWED_INTEREST_RATE = int96(int(uint(5 * 1e27) / SECONDS_PER_YEAR)); // 500% APR\\n    int96 internal constant MIN_ALLOWED_INTEREST_RATE = 0;\\n\\n    function computeInterestRateImpl(address, uint32) internal virtual returns (int96);\\n\\n    function computeInterestRate(address underlying, uint32 utilisation) external returns (int96) {\\n        int96 rate = computeInterestRateImpl(underlying, utilisation);\\n\\n        if (rate > MAX_ALLOWED_INTEREST_RATE) rate = MAX_ALLOWED_INTEREST_RATE;\\n        else if (rate < MIN_ALLOWED_INTEREST_RATE) rate = MIN_ALLOWED_INTEREST_RATE;\\n\\n        return rate;\\n    }\\n\\n    function reset(address underlying, bytes calldata resetParams) external virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\\ninterface IERC3156FlashBorrower {\\n    function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external returns (bytes32);\\n}\\n\\ninterface IERC3156FlashLender {\\n    function maxFlashLoan(address token) external view returns (uint256);\\n    function flashFee(address token, uint256 amount) external view returns (uint256);\\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Interfaces.sol\\\";\\n\\nlibrary Utils {\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), string(data));\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), string(data));\\n    }\\n\\n    function safeApprove(address token, address to, uint value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), string(data));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/RPow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\n// From MakerDAO DSS\\n\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nlibrary RPow {\\n    function rpow(uint x, uint n, uint base) internal pure returns (uint z) {\\n        assembly {\\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\\n            default {\\n                switch mod(n, 2) case 0 { z := base } default { z := x }\\n                let half := div(base, 2)  // for rounding.\\n                for { n := div(n, 2) } n { n := div(n,2) } {\\n                    let xx := mul(x, x)\\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\\n                    let xxRound := add(xx, half)\\n                    if lt(xxRound, xx) { revert(0,0) }\\n                    x := div(xxRound, base)\\n                    if mod(n,2) {\\n                        let zx := mul(z, x)\\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\\n                        let zxRound := add(zx, half)\\n                        if lt(zxRound, zx) { revert(0,0) }\\n                        z := div(zxRound, base)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n//import \\\"hardhat/console.sol\\\"; // DEV_MODE\\n\\nimport \\\"./Storage.sol\\\";\\nimport \\\"./Events.sol\\\";\\nimport \\\"./Proxy.sol\\\";\\n\\nabstract contract Base is Storage, Events {\\n    // Modules\\n\\n    function _createProxy(uint proxyModuleId) internal returns (address) {\\n        require(proxyModuleId != 0, \\\"e/create-proxy/invalid-module\\\");\\n        require(proxyModuleId <= MAX_EXTERNAL_MODULEID, \\\"e/create-proxy/internal-module\\\");\\n\\n        // If we've already created a proxy for a single-proxy module, just return it:\\n\\n        if (proxyLookup[proxyModuleId] != address(0)) return proxyLookup[proxyModuleId];\\n\\n        // Otherwise create a proxy:\\n\\n        address proxyAddr = address(new Proxy());\\n\\n        if (proxyModuleId <= MAX_EXTERNAL_SINGLE_PROXY_MODULEID) proxyLookup[proxyModuleId] = proxyAddr;\\n\\n        trustedSenders[proxyAddr] = TrustedSenderInfo({ moduleId: uint32(proxyModuleId), moduleImpl: address(0) });\\n\\n        emit ProxyCreated(proxyAddr, proxyModuleId);\\n\\n        return proxyAddr;\\n    }\\n\\n    function callInternalModule(uint moduleId, bytes memory input) internal returns (bytes memory) {\\n        (bool success, bytes memory result) = moduleLookup[moduleId].delegatecall(input);\\n        if (!success) revertBytes(result);\\n        return result;\\n    }\\n\\n\\n\\n    // Modifiers\\n\\n    modifier nonReentrant() {\\n        require(reentrancyLock == REENTRANCYLOCK__UNLOCKED, \\\"e/reentrancy\\\");\\n\\n        reentrancyLock = REENTRANCYLOCK__LOCKED;\\n        _;\\n        reentrancyLock = REENTRANCYLOCK__UNLOCKED;\\n    }\\n\\n    modifier reentrantOK() { // documentation only\\n        _;\\n    }\\n\\n    // WARNING: Must be very careful with this modifier. It resets the free memory pointer\\n    // to the value it was when the function started. This saves gas if more memory will\\n    // be allocated in the future. However, if the memory will be later referenced\\n    // (for example because the function has returned a pointer to it) then you cannot\\n    // use this modifier.\\n\\n    modifier FREEMEM() {\\n        uint origFreeMemPtr;\\n\\n        assembly {\\n            origFreeMemPtr := mload(0x40)\\n        }\\n\\n        _;\\n\\n        /*\\n        assembly { // DEV_MODE: overwrite the freed memory with garbage to detect bugs\\n            let garbage := 0xDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF\\n            for { let i := origFreeMemPtr } lt(i, mload(0x40)) { i := add(i, 32) } { mstore(i, garbage) }\\n        }\\n        */\\n\\n        assembly {\\n            mstore(0x40, origFreeMemPtr)\\n        }\\n    }\\n\\n\\n\\n    // Error handling\\n\\n    function revertBytes(bytes memory errMsg) internal pure {\\n        if (errMsg.length > 0) {\\n            assembly {\\n                revert(add(32, errMsg), mload(errMsg))\\n            }\\n        }\\n\\n        revert(\\\"e/empty-error\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Constants.sol\\\";\\n\\nabstract contract Storage is Constants {\\n    // Dispatcher and upgrades\\n\\n    uint reentrancyLock;\\n\\n    address upgradeAdmin;\\n    address governorAdmin;\\n\\n    mapping(uint => address) moduleLookup; // moduleId => module implementation\\n    mapping(uint => address) proxyLookup; // moduleId => proxy address (only for single-proxy modules)\\n\\n    struct TrustedSenderInfo {\\n        uint32 moduleId; // 0 = un-trusted\\n        address moduleImpl; // only non-zero for external single-proxy modules\\n    }\\n\\n    mapping(address => TrustedSenderInfo) trustedSenders; // sender address => moduleId (0 = un-trusted)\\n\\n\\n\\n    // Account-level state\\n    // Sub-accounts are considered distinct accounts\\n\\n    struct AccountStorage {\\n        // Packed slot: 1 + 5 + 4 + 20 = 30\\n        uint8 deferLiquidityStatus;\\n        uint40 lastAverageLiquidityUpdate;\\n        uint32 numMarketsEntered;\\n        address firstMarketEntered;\\n\\n        uint averageLiquidity;\\n        address averageLiquidityDelegate;\\n    }\\n\\n    mapping(address => AccountStorage) accountLookup;\\n    mapping(address => address[MAX_POSSIBLE_ENTERED_MARKETS]) marketsEntered;\\n\\n\\n\\n    // Markets and assets\\n\\n    struct AssetConfig {\\n        // Packed slot: 20 + 1 + 4 + 4 + 3 = 32\\n        address eTokenAddress;\\n        bool borrowIsolated;\\n        uint32 collateralFactor;\\n        uint32 borrowFactor;\\n        uint24 twapWindow;\\n    }\\n\\n    struct UserAsset {\\n        uint112 balance;\\n        uint144 owed;\\n\\n        uint interestAccumulator;\\n    }\\n\\n    struct AssetStorage {\\n        // Packed slot: 5 + 1 + 4 + 12 + 4 + 2 + 4 = 32\\n        uint40 lastInterestAccumulatorUpdate;\\n        uint8 underlyingDecimals; // Not dynamic, but put here to live in same storage slot\\n        uint32 interestRateModel;\\n        int96 interestRate;\\n        uint32 reserveFee;\\n        uint16 pricingType;\\n        uint32 pricingParameters;\\n\\n        address underlying;\\n        uint96 reserveBalance;\\n\\n        address dTokenAddress;\\n\\n        uint112 totalBalances;\\n        uint144 totalBorrows;\\n\\n        uint interestAccumulator;\\n\\n        mapping(address => UserAsset) users;\\n\\n        mapping(address => mapping(address => uint)) eTokenAllowance;\\n        mapping(address => mapping(address => uint)) dTokenAllowance;\\n    }\\n\\n    mapping(address => AssetConfig) internal underlyingLookup; // underlying => AssetConfig\\n    mapping(address => AssetStorage) internal eTokenLookup; // EToken => AssetStorage\\n    mapping(address => address) internal dTokenLookup; // DToken => EToken\\n    mapping(address => address) internal pTokenLookup; // PToken => underlying\\n    mapping(address => address) internal reversePTokenLookup; // underlying => PToken\\n}\\n\"\r\n    },\r\n    \"contracts/Events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Storage.sol\\\";\\n\\nabstract contract Events {\\n    event Genesis();\\n\\n\\n    event ProxyCreated(address indexed proxy, uint moduleId);\\n    event MarketActivated(address indexed underlying, address indexed eToken, address indexed dToken);\\n    event PTokenActivated(address indexed underlying, address indexed pToken);\\n\\n    event EnterMarket(address indexed underlying, address indexed account);\\n    event ExitMarket(address indexed underlying, address indexed account);\\n\\n    event Deposit(address indexed underlying, address indexed account, uint amount);\\n    event Withdraw(address indexed underlying, address indexed account, uint amount);\\n    event Borrow(address indexed underlying, address indexed account, uint amount);\\n    event Repay(address indexed underlying, address indexed account, uint amount);\\n\\n    event Liquidation(address indexed liquidator, address indexed violator, address indexed underlying, address collateral, uint repay, uint yield, uint healthScore, uint baseDiscount, uint discount);\\n\\n    event TrackAverageLiquidity(address indexed account);\\n    event UnTrackAverageLiquidity(address indexed account);\\n    event DelegateAverageLiquidity(address indexed account, address indexed delegate);\\n\\n    event PTokenWrap(address indexed underlying, address indexed account, uint amount);\\n    event PTokenUnWrap(address indexed underlying, address indexed account, uint amount);\\n\\n    event AssetStatus(address indexed underlying, uint totalBalances, uint totalBorrows, uint96 reserveBalance, uint poolSize, uint interestAccumulator, int96 interestRate, uint timestamp);\\n\\n\\n    event RequestDeposit(address indexed account, uint amount);\\n    event RequestWithdraw(address indexed account, uint amount);\\n    event RequestMint(address indexed account, uint amount);\\n    event RequestBurn(address indexed account, uint amount);\\n    event RequestTransferEToken(address indexed from, address indexed to, uint amount);\\n\\n    event RequestBorrow(address indexed account, uint amount);\\n    event RequestRepay(address indexed account, uint amount);\\n    event RequestTransferDToken(address indexed from, address indexed to, uint amount);\\n\\n    event RequestLiquidate(address indexed liquidator, address indexed violator, address indexed underlying, address collateral, uint repay, uint minYield);\\n\\n\\n    event InstallerSetUpgradeAdmin(address indexed newUpgradeAdmin);\\n    event InstallerSetGovernorAdmin(address indexed newGovernorAdmin);\\n    event InstallerInstallModule(uint indexed moduleId, address indexed moduleImpl, bytes32 moduleGitCommit);\\n\\n\\n    event GovSetAssetConfig(address indexed underlying, Storage.AssetConfig newConfig);\\n    event GovSetIRM(address indexed underlying, uint interestRateModel, bytes resetParams);\\n    event GovSetPricingConfig(address indexed underlying, uint16 newPricingType, uint32 newPricingParameter);\\n    event GovSetReserveFee(address indexed underlying, uint32 newReserveFee);\\n    event GovConvertReserves(address indexed underlying, address indexed recipient, uint amount);\\n\\n    event RequestSwap(address indexed accountIn, address indexed accountOut, address indexed underlyingIn, address underlyingOut, uint amount, uint swapType);\\n}\\n\"\r\n    },\r\n    \"contracts/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\ncontract Proxy {\\n    address immutable creator;\\n\\n    constructor() {\\n        creator = msg.sender;\\n    }\\n\\n    // External interface\\n\\n    fallback() external {\\n        address creator_ = creator;\\n\\n        if (msg.sender == creator_) {\\n            assembly {\\n                mstore(0, 0)\\n                calldatacopy(31, 0, calldatasize())\\n\\n                switch mload(0) // numTopics\\n                    case 0 { log0(32,  sub(calldatasize(), 1)) }\\n                    case 1 { log1(64,  sub(calldatasize(), 33),  mload(32)) }\\n                    case 2 { log2(96,  sub(calldatasize(), 65),  mload(32), mload(64)) }\\n                    case 3 { log3(128, sub(calldatasize(), 97),  mload(32), mload(64), mload(96)) }\\n                    case 4 { log4(160, sub(calldatasize(), 129), mload(32), mload(64), mload(96), mload(128)) }\\n                    default { revert(0, 0) }\\n\\n                return(0, 0)\\n            }\\n        } else {\\n            assembly {\\n                mstore(0, 0xe9c4a3ac00000000000000000000000000000000000000000000000000000000) // dispatch() selector\\n                calldatacopy(4, 0, calldatasize())\\n                mstore(add(4, calldatasize()), shl(96, caller()))\\n\\n                let result := call(gas(), creator_, 0, 0, add(24, calldatasize()), 0, 0)\\n                returndatacopy(0, 0, returndatasize())\\n\\n                switch result\\n                    case 0 { revert(0, returndatasize()) }\\n                    default { return(0, returndatasize()) }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nabstract contract Constants {\\n    // Universal\\n\\n    uint internal constant SECONDS_PER_YEAR = 365.2425 * 86400; // Gregorian calendar\\n\\n\\n    // Protocol parameters\\n\\n    uint internal constant MAX_SANE_AMOUNT = type(uint112).max;\\n    uint internal constant MAX_SANE_SMALL_AMOUNT = type(uint96).max;\\n    uint internal constant MAX_SANE_DEBT_AMOUNT = type(uint144).max;\\n    uint internal constant INTERNAL_DEBT_PRECISION = 1e9;\\n    uint internal constant MAX_ENTERED_MARKETS = 10; // per sub-account\\n    uint internal constant MAX_POSSIBLE_ENTERED_MARKETS = 2**32; // limited by size of AccountStorage.numMarketsEntered\\n    uint internal constant CONFIG_FACTOR_SCALE = 4_000_000_000; // must fit into a uint32\\n    uint internal constant RESERVE_FEE_SCALE = 4_000_000_000; // must fit into a uint32\\n    uint32 internal constant DEFAULT_RESERVE_FEE = uint32(0.23 * 4_000_000_000);\\n    uint internal constant INITIAL_INTEREST_ACCUMULATOR = 1e27;\\n    uint internal constant AVERAGE_LIQUIDITY_PERIOD = 24 * 60 * 60;\\n    uint16 internal constant MIN_UNISWAP3_OBSERVATION_CARDINALITY = 10;\\n    uint24 internal constant DEFAULT_TWAP_WINDOW_SECONDS = 30 * 60;\\n    uint32 internal constant DEFAULT_BORROW_FACTOR = uint32(0.28 * 4_000_000_000);\\n\\n\\n    // Implementation internals\\n\\n    uint internal constant REENTRANCYLOCK__UNLOCKED = 1;\\n    uint internal constant REENTRANCYLOCK__LOCKED = 2;\\n\\n    uint8 internal constant DEFERLIQUIDITY__NONE = 0;\\n    uint8 internal constant DEFERLIQUIDITY__CLEAN = 1;\\n    uint8 internal constant DEFERLIQUIDITY__DIRTY = 2;\\n\\n\\n    // Pricing types\\n\\n    uint16 internal constant PRICINGTYPE__PEGGED = 1;\\n    uint16 internal constant PRICINGTYPE__UNISWAP3_TWAP = 2;\\n    uint16 internal constant PRICINGTYPE__FORWARDED = 3;\\n\\n\\n    // Modules\\n\\n    // Public single-proxy modules\\n    uint internal constant MODULEID__INSTALLER = 1;\\n    uint internal constant MODULEID__MARKETS = 2;\\n    uint internal constant MODULEID__LIQUIDATION = 3;\\n    uint internal constant MODULEID__GOVERNANCE = 4;\\n    uint internal constant MODULEID__EXEC = 5;\\n    uint internal constant MODULEID__SWAP = 6;\\n\\n    uint internal constant MAX_EXTERNAL_SINGLE_PROXY_MODULEID = 499_999;\\n\\n    // Public multi-proxy modules\\n    uint internal constant MODULEID__ETOKEN = 500_000;\\n    uint internal constant MODULEID__DTOKEN = 500_001;\\n\\n    uint internal constant MAX_EXTERNAL_MODULEID = 999_999;\\n\\n    // Internal modules\\n    uint internal constant MODULEID__RISK_MANAGER = 1_000_000;\\n\\n    // Interest rate models\\n    //   Default for new markets\\n    uint internal constant MODULEID__IRM_DEFAULT = 2_000_000;\\n    //   Testing-only\\n    uint internal constant MODULEID__IRM_ZERO = 2_000_001;\\n    uint internal constant MODULEID__IRM_FIXED = 2_000_002;\\n    uint internal constant MODULEID__IRM_LINEAR = 2_000_100;\\n    //   Classes\\n    uint internal constant MODULEID__IRM_CLASS__STABLE = 2_000_500;\\n    uint internal constant MODULEID__IRM_CLASS__MAJOR = 2_000_501;\\n    uint internal constant MODULEID__IRM_CLASS__MIDCAP = 2_000_502;\\n\\n    // Swap types\\n    uint internal constant SWAP_TYPE__UNI_EXACT_INPUT_SINGLE = 1;\\n    uint internal constant SWAP_TYPE__UNI_EXACT_INPUT = 2;\\n    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT_SINGLE = 3;\\n    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT = 4;\\n    uint internal constant SWAP_TYPE__1INCH = 5;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleGitCommit_\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"referenceAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapFactory\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"uniswapPoolInitCodeHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct RiskManager.RiskManagerSettings\",\"name\":\"settings\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalances\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"reserveBalance\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestAccumulator\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int96\",\"name\":\"interestRate\",\"type\":\"int96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AssetStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"DelegateAverageLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"EnterMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExitMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Genesis\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GovConvertReserves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"eTokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"borrowIsolated\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"collateralFactor\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"borrowFactor\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"twapWindow\",\"type\":\"uint24\"}],\"indexed\":false,\"internalType\":\"struct Storage.AssetConfig\",\"name\":\"newConfig\",\"type\":\"tuple\"}],\"name\":\"GovSetAssetConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestRateModel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"resetParams\",\"type\":\"bytes\"}],\"name\":\"GovSetIRM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newPricingType\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newPricingParameter\",\"type\":\"uint32\"}],\"name\":\"GovSetPricingConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newReserveFee\",\"type\":\"uint32\"}],\"name\":\"GovSetReserveFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"moduleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"moduleImpl\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"moduleGitCommit\",\"type\":\"bytes32\"}],\"name\":\"InstallerInstallModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernorAdmin\",\"type\":\"address\"}],\"name\":\"InstallerSetGovernorAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newUpgradeAdmin\",\"type\":\"address\"}],\"name\":\"InstallerSetUpgradeAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"violator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"yield\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"healthScore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseDiscount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"}],\"name\":\"Liquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"eToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dToken\",\"type\":\"address\"}],\"name\":\"MarketActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"}],\"name\":\"PTokenActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PTokenUnWrap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PTokenWrap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"moduleId\",\"type\":\"uint256\"}],\"name\":\"ProxyCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Repay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"violator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minYield\",\"type\":\"uint256\"}],\"name\":\"RequestLiquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestRepay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accountIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accountOut\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlyingOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapType\",\"type\":\"uint256\"}],\"name\":\"RequestSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestTransferDToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestTransferEToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"TrackAverageLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnTrackAverageLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"computeAssetLiquidities\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liabilityValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numBorrows\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"borrowIsolated\",\"type\":\"bool\"}],\"internalType\":\"struct IRiskManager.LiquidityStatus\",\"name\":\"status\",\"type\":\"tuple\"}],\"internalType\":\"struct IRiskManager.AssetLiquidity[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"computeLiquidity\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liabilityValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numBorrows\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"borrowIsolated\",\"type\":\"bool\"}],\"internalType\":\"struct IRiskManager.LiquidityStatus\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getNewMarketParameters\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"pricingType\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"pricingParameters\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"eTokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"borrowIsolated\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"collateralFactor\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"borrowFactor\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"twapWindow\",\"type\":\"uint24\"}],\"internalType\":\"struct Storage.AssetConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"internalType\":\"struct IRiskManager.NewMarketParameters\",\"name\":\"p\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"twap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"twapPeriod\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getPriceFull\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"twap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"twapPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint112\",\"name\":\"totalBalances\",\"type\":\"uint112\"},{\"internalType\":\"uint144\",\"name\":\"totalBorrows\",\"type\":\"uint144\"},{\"internalType\":\"uint96\",\"name\":\"reserveBalance\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"interestAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"lastInterestAccumulatorUpdate\",\"type\":\"uint40\"},{\"internalType\":\"uint8\",\"name\":\"underlyingDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"interestRateModel\",\"type\":\"uint32\"},{\"internalType\":\"int96\",\"name\":\"interestRate\",\"type\":\"int96\"},{\"internalType\":\"uint32\",\"name\":\"reserveFee\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"pricingType\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"pricingParameters\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"poolSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimalsScaler\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxExternalAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseLogic.AssetCache\",\"name\":\"assetCache\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"eTokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"borrowIsolated\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"collateralFactor\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"borrowFactor\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"twapWindow\",\"type\":\"uint24\"}],\"internalType\":\"struct Storage.AssetConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"getPriceInternal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"twap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"twapPeriod\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moduleGitCommit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moduleId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"requireLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RiskManager","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"000000000000000000000000df359cfaa399c01a62b1f64767460715eb7df4d3000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000001f98431c8ad98523631ae4a59f267346ea31f984e34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9ee57a53e9eb3e4736e7043cc16354b4b5324ae040836c9377b0c7d785752e50"}]