[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n//Define the pool\r\ncontract SmartPool {\r\n\r\n    //Pool info\r\n    uint currAmount;    //Current amount in the pool (=balance)\r\n    uint ticketPrice;   //Price of one ticket\r\n    uint startDate;\t\t//The date of opening\r\n\tuint endDate;\t\t//The date of closing (or 0 if still open)\r\n\t\r\n\t//Block infos (better to use block number than dates to trigger the end)\r\n\tuint startBlock;\r\n\tuint endBlock;\r\n\t\r\n\t//End triggers\r\n\tuint duration;\t\t//The pool ends when the duration expire\r\n    uint ticketCount;\t//Or when the reserve of tickets has been sold\r\n    bool ended;\t\t\t//Current state (can't buy tickets when ended)\r\n\tbool terminated;\t//true if a winner has been picked\r\n\tbool moneySent;\t\t//true if the winner has picked his money\r\n    \r\n\t//Min wait duration between ended and terminated states\r\n\tuint constant blockDuration = 15; // we use 15 sec for the block duration\r\n\tuint constant minWaitDuration = 240; // (= 3600 / blockDuration => 60 minutes waiting between 'ended' and 'terminated')\r\n\t\r\n    //Players\r\n    address[] players;\t//List of tickets owners, each ticket gives an entry in the array\r\n\t\r\n\t//Winning info\r\n    address winner;\t\t//The final winner (only available when terminated == true)\r\n     \r\n    //Pool manager address (only the manager can call modifiers of this contract, see PoolManager.sol)\r\n    address poolManager;\r\n    \r\n    //Create a pool with a fixed ticket price, a ticket reserve and/or a duration)\r\n    function SmartPool(uint _ticketPrice, uint _ticketCount, uint _duration) public\r\n    {\r\n\t\t//Positive ticket price and either ticketCount or duration must be provided\r\n        require(_ticketPrice > 0 && (_ticketCount > 0 || _duration > blockDuration));\r\n\t\t\r\n\t\t//Check for overflows\r\n\t\trequire(now + _duration >= now);\r\n\t\t\r\n\t\t//Set ticketCount if needed (according to max balance)\r\n\t\tif (_ticketCount == 0)\r\n\t\t{\r\n\t\t\t_ticketCount = (2 ** 256 - 1) / _ticketPrice;\r\n\t\t}\r\n\t\t\r\n\t\trequire(_ticketCount * _ticketPrice >= _ticketPrice);\r\n\t\t\r\n\t\t//Store manager\r\n\t\tpoolManager = msg.sender;\r\n\t\t\r\n        //Init\r\n        currAmount = 0;\r\n\t\tstartDate = now;\r\n\t\tendDate = 0;\r\n\t\tstartBlock = block.number;\r\n\t\tendBlock = 0;\r\n        ticketPrice = _ticketPrice;\r\n        ticketCount = _ticketCount;\r\n\t\tduration = _duration / blockDuration; // compute duration in blocks\r\n        ended = false;\r\n\t\tterminated = false;\r\n\t\tmoneySent = false;\r\n\t\twinner = 0x0000000000000000000000000000000000000000;\r\n    }\r\n\r\n\t\r\n\t//Accessors\r\n\tfunction getPlayers() public constant returns (address[])\r\n    {\r\n    \treturn players;\r\n    }\r\n\t\r\n\tfunction getStartDate() public constant returns (uint)\r\n    {\r\n    \treturn startDate;\r\n    }\r\n\t\r\n\tfunction getStartBlock() public constant returns (uint)\r\n    {\r\n    \treturn startBlock;\r\n    }\r\n\t\r\n    function getCurrAmount() public constant returns (uint)\r\n    {\r\n    \treturn currAmount;\r\n    }\r\n\t\r\n\tfunction getTicketPrice() public constant returns (uint)\r\n\t{\r\n\t\treturn ticketPrice;\r\n\t}\r\n\t\r\n\tfunction getTicketCount() public constant returns (uint)\r\n\t{\r\n\t\treturn ticketCount;\r\n\t}\r\n\t\r\n\tfunction getBoughtTicketCount() public constant returns (uint)\r\n\t{\r\n\t\treturn players.length;\r\n\t}\r\n\t\r\n\tfunction getAvailableTicketCount() public constant returns (uint)\r\n\t{\r\n\t\treturn ticketCount - players.length;\r\n\t}\r\n\t\r\n\tfunction getEndDate() public constant returns (uint)\r\n\t{\r\n\t\treturn endDate;\r\n\t}\r\n\t\r\n\tfunction getEndBlock() public constant returns (uint)\r\n    {\r\n    \treturn endBlock;\r\n    }\r\n\t\r\n\tfunction getDuration() public constant returns (uint)\r\n\t{\r\n\t\treturn duration; // duration in blocks\r\n\t}\r\n\t\r\n\tfunction getDurationS() public constant returns (uint)\r\n\t{\r\n\t\treturn duration * blockDuration; // duration in seconds\r\n\t}\r\n\t\t\r\n\tfunction isEnded() public constant returns (bool)\r\n\t{\r\n\t\treturn ended;\r\n\t}\r\n\r\n\tfunction isTerminated() public constant returns (bool)\r\n\t{\r\n\t\treturn terminated;\r\n\t}\r\n\t\r\n\tfunction isMoneySent() public constant returns (bool)\r\n\t{\r\n\t\treturn moneySent;\r\n\t}\r\n\t\r\n\tfunction getWinner() public constant returns (address)\r\n\t{\r\n\t\treturn winner;\r\n\t}\r\n\r\n\t//End trigger\r\n\tfunction checkEnd() public\r\n\t{\r\n\t\tif ( (duration > 0 && block.number >= startBlock + duration) || (players.length >= ticketCount) )\r\n        {\r\n\t\t\tended = true;\r\n\t\t\tendDate = now;\r\n\t\t\tendBlock = block.number;\r\n        }\r\n\t}\r\n\t\r\n    //Add player with ticketCount to the pool (only poolManager can do this)\r\n    function addPlayer(address player, uint ticketBoughtCount, uint amount) public  \r\n\t{\r\n\t\t//Only manager can call this\r\n\t\trequire(msg.sender == poolManager);\r\n\t\t\r\n        //Revert if pool ended (should not happen because the manager check this too)\r\n        require (!ended);\r\n\t\t\r\n        //Add amount to the pool\r\n        currAmount += amount; // amount has been checked by the manager\r\n        \r\n        //Add player to the ticket owner array, for each bought ticket\r\n\t\tfor (uint i = 0; i < ticketBoughtCount; i++)\r\n\t\t\tplayers.push(player);\r\n        \r\n        //Check end\t\r\n\t\tcheckEnd();\r\n    }\r\n\t\r\n\tfunction canTerminate() public constant returns(bool)\r\n\t{\r\n\t\treturn ended && !terminated && block.number - endBlock >= minWaitDuration;\r\n\t}\r\n\r\n    //Terminate the pool by picking a winner (only poolManager can do this, after the pool is ended and some time has passed so the seed has changed many times)\r\n    function terminate(uint randSeed) public \r\n\t{\t\t\r\n\t\t//Only manager can call this\r\n\t\trequire(msg.sender == poolManager);\r\n\t\t\r\n        //The pool need to be ended, but not terminated\r\n        require(ended && !terminated);\r\n\t\t\r\n\t\t//Min duration between ended and terminated\r\n\t\trequire(block.number - endBlock >= minWaitDuration);\r\n\t\t\r\n\t\t//Only one call to this function\r\n        terminated = true;\r\n\r\n\t\t//Pick a winner\r\n\t\tif (players.length > 0)\r\n\t\t\twinner = players[randSeed % players.length];\r\n    }\r\n\t\r\n\t//Update pool state (only poolManager can call this when the money has been sent)\r\n\tfunction onMoneySent() public\r\n\t{\r\n\t\t//Only manager can call this\r\n\t\trequire(msg.sender == poolManager);\r\n\t\t\r\n\t\t//The pool must be terminated (winner picked)\r\n\t\trequire(terminated);\r\n\t\t\r\n\t\t//Update money sent (only one call to this function)\r\n\t\trequire(!moneySent);\r\n\t\tmoneySent = true;\r\n\t}\r\n}\r\n\r\n       \r\n//Wallet interface\r\ncontract WalletContract\r\n{\r\n\tfunction payMe() public payable;\r\n}\r\n\t   \r\n\t   \r\ncontract PoolManager {\r\n\r\n\t//Pool owner (address which manage the pool creation)\r\n    address owner;\r\n\t\r\n\t//Wallet which receive the fees (1% of ticket price)\r\n\taddress wallet;\r\n\t\r\n\t//Fees infos (external websites providing access to pools get 1% too)\r\n\tmapping(address => uint) fees;\r\n\t\t\r\n\t//Fees divider (1% for the wallet, and 1% for external website where player can buy tickets)\r\n\tuint constant feeDivider = 100; //(1/100 of the amount)\r\n\r\n\t//The ticket price for pools must be a multiple of 0.010205 ether (to avoid truncating the fees, and having a minimum to send to the winner)\r\n    uint constant ticketPriceMultiple = 10205000000000000; //(multiple of 0.010205 ether for ticketPrice)\r\n\r\n\t//Pools infos (current active pools. When a pool is done, it goes into the poolsDone array bellow and a new pool is created to replace it at the same index)\r\n\tSmartPool[] pools;\r\n\t\r\n\t//Ended pools (cleaned automatically after winners get their prices)\r\n\tSmartPool[] poolsDone;\r\n\t\r\n\t//History (contains all the pools since the deploy)\r\n\tSmartPool[] poolsHistory;\r\n\t\r\n\t//Current rand seed (it changes a lot so it's pretty hard to know its value when the winner is picked)\r\n\tuint randSeed;\r\n\r\n\t//Constructor (only owner)\r\n\tfunction PoolManager(address wal) public\r\n\t{\r\n\t\towner = msg.sender;\r\n\t\twallet = wal;\r\n\r\n\t\trandSeed = 0;\r\n\t}\r\n\t\r\n\t//Called frequently by other functions to keep the seed moving\r\n\tfunction updateSeed() private\r\n\t{\r\n\t\trandSeed += (uint(block.blockhash(block.number - 1)));\r\n\t}\r\n\t\r\n\t//Create a new pool (only owner can do this)\r\n\tfunction addPool(uint ticketPrice, uint ticketCount, uint duration) public\r\n\t{\r\n\t\trequire(msg.sender == owner);\r\n\t\trequire(ticketPrice >= ticketPriceMultiple && ticketPrice % ticketPriceMultiple == 0);\r\n\t\t\r\n\t\t//Deploy a new pool\r\n\t\tpools.push(new SmartPool(ticketPrice, ticketCount, duration));\r\n\t}\r\n\t\r\n\t//Accessors (public)\r\n\t\r\n\t//Get Active Pools\r\n\tfunction getPoolCount() public constant returns(uint)\r\n\t{\r\n\t\treturn pools.length;\r\n\t}\r\n\tfunction getPool(uint index) public constant returns(address)\r\n\t{\r\n\t\trequire(index < pools.length);\r\n\t\treturn pools[index];\r\n\t}\r\n\t\r\n\t//Get Ended Pools\r\n\tfunction getPoolDoneCount() public constant returns(uint)\r\n\t{\r\n\t\treturn poolsDone.length;\r\n\t}\r\n\tfunction getPoolDone(uint index) public constant returns(address)\r\n\t{\r\n\t\trequire(index < poolsDone.length);\r\n\t\treturn poolsDone[index];\r\n\t}\r\n\r\n\t//Get History\r\n\tfunction getPoolHistoryCount() public constant returns(uint)\r\n\t{\r\n\t\treturn poolsHistory.length;\r\n\t}\r\n\tfunction getPoolHistory(uint index) public constant returns(address)\r\n\t{\r\n\t\trequire(index < poolsHistory.length);\r\n\t\treturn poolsHistory[index];\r\n\t}\r\n\t\t\r\n\t//Buy tickets for a pool (public)\r\n\tfunction buyTicket(uint poolIndex, uint ticketCount, address websiteFeeAddr) public payable\r\n\t{\r\n\t\trequire(poolIndex < pools.length);\r\n\t\trequire(ticketCount > 0);\r\n\t\t\r\n\t\t//Get pool and check state\r\n\t\tSmartPool pool = pools[poolIndex];\r\n\t\tpool.checkEnd();\r\n\t\trequire (!pool.isEnded());\r\n\t\t\r\n\t\t//Adjust ticketCount according to available tickets\r\n\t\tuint availableCount = pool.getAvailableTicketCount();\r\n\t\tif (ticketCount > availableCount)\r\n\t\t\tticketCount = availableCount;\r\n\t\t\r\n\t\t//Get amount required and check msg.value\r\n\t\tuint amountRequired = ticketCount * pool.getTicketPrice();\r\n\t\trequire(msg.value >= amountRequired);\r\n\t\t\r\n\t\t//If too much value sent, we send it back to player\r\n\t\tuint amountLeft = msg.value - amountRequired;\r\n\t\t\r\n\t\t//if no websiteFeeAddr given, the wallet get the fee\r\n\t\tif (websiteFeeAddr == address(0))\r\n\t\t\twebsiteFeeAddr = wallet;\r\n\t\t\r\n\t\t//Compute fee\r\n\t\tuint feeAmount = amountRequired / feeDivider;\r\n\t\t\r\n\t\taddFee(websiteFeeAddr, feeAmount);\r\n\t\taddFee(wallet, feeAmount);\r\n\t\t\r\n\t\t//Add player to the pool with the amount minus the fees (1% + 1% = 2%)\r\n\t\tpool.addPlayer(msg.sender, ticketCount, amountRequired - 2 * feeAmount);\r\n\t\t\r\n\t\t//Send back amountLeft to player if too much value sent\r\n\t\tif (amountLeft > 0 && !msg.sender.send(amountLeft))\r\n\t\t{\r\n\t\t\taddFee(wallet, amountLeft); // if it fails, we take it as a fee..\r\n\t\t}\r\n\t\t\r\n\t\tupdateSeed();\r\n\t}\r\n\r\n\t//Check pools end. (called by our console each 10 minutes, or can be called by anybody)\r\n\tfunction checkPoolsEnd() public \r\n\t{\r\n\t\tfor (uint i = 0; i < pools.length; i++)\r\n\t\t{\r\n\t\t\t//Check each pool and restart the ended ones\r\n\t\t\tcheckPoolEnd(i);\r\n\t\t}\r\n\t}\r\n\t\r\n\t//Check end of a pool and restart it if it's ended (public)\r\n\tfunction checkPoolEnd(uint i) public \r\n\t{\r\n\t\trequire(i < pools.length);\r\n\t\t\r\n\t\t//Check end (if not triggered yet)\r\n\t\tSmartPool pool = pools[i];\r\n\t\tif (!pool.isEnded())\r\n\t\t\tpool.checkEnd();\r\n\t\t\t\r\n\t\tif (!pool.isEnded())\r\n\t\t{\r\n\t\t\treturn; // not ended yet\r\n\t\t}\r\n\t\t\r\n\t\tupdateSeed();\r\n\t\t\r\n\t\t//Store pool done and restart a pool to replace it\r\n\t\tpoolsDone.push(pool);\r\n\t\tpools[i] = new SmartPool(pool.getTicketPrice(), pool.getTicketCount(), pool.getDurationS());\r\n\t}\r\n\t\r\n\t//Check pools done. (called by our console, or can be called by anybody)\r\n\tfunction checkPoolsDone() public \r\n\t{\r\n\t\tfor (uint i = 0; i < poolsDone.length; i++)\r\n\t\t{\r\n\t\t\tcheckPoolDone(i);\r\n\t\t}\r\n\t}\r\n\t\r\n\t//Check end of one pool\r\n\tfunction checkPoolDone(uint i) public\r\n\t{\r\n\t\trequire(i < poolsDone.length);\r\n\t\t\r\n\t\tSmartPool pool = poolsDone[i];\r\n\t\tif (pool.isTerminated())\r\n\t\t\treturn; // already terminated\r\n\t\t\t\r\n\t\tif (!pool.canTerminate())\r\n\t\t\treturn; // we need to wait a bit more before random occurs, so the seed has changed enough (60 minutes before ended and terminated states)\r\n\t\t\t\r\n\t\tupdateSeed();\r\n\t\t\r\n\t\t//Terminate (pick a winner) and store pool done\r\n\t\tpool.terminate(randSeed);\r\n\t}\r\n\r\n\t//Send money of the pool to the winner (public)\r\n\tfunction sendPoolMoney(uint i) public\r\n\t{\r\n\t\trequire(i < poolsDone.length);\r\n\t\t\r\n\t\tSmartPool pool = poolsDone[i];\r\n\t\trequire (pool.isTerminated()); // we need a winner picked\r\n\t\t\r\n\t\trequire(!pool.isMoneySent()); // money not sent\r\n\t\t\r\n\t\tuint amount = pool.getCurrAmount();\r\n\t\taddress winner = pool.getWinner();\r\n\t\tpool.onMoneySent();\r\n\t\tif (amount > 0 && !winner.send(amount)) // the winner can't get his money (should not happen)\r\n\t\t{\r\n\t\t\taddFee(wallet, amount);\r\n\t\t}\r\n\t\t\r\n\t\t//Pool goes into history array\r\n\t\tpoolsHistory.push(pool);\r\n\t}\r\n\t\t\r\n\t//Clear pools done array (called once a week by our console, or can be called by anybody)\r\n\tfunction clearPoolsDone() public\r\n\t{\r\n\t\t//Make sure all pools are terminated with no money left\r\n\t\tfor (uint i = 0; i < poolsDone.length; i++)\r\n\t\t{\r\n\t\t\tif (!poolsDone[i].isMoneySent())\r\n\t\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t//\"Clear\" poolsDone array (just reset the length, instances will be override)\r\n\t\tpoolsDone.length = 0;\r\n\t}\r\n\t\r\n\t//Get current fee value\r\n\tfunction getFeeValue(address a) public constant returns (uint)\r\n\t{\r\n\t\tif (a == address(0))\r\n\t\t\ta = msg.sender;\r\n\t\treturn fees[a];\r\n\t}\r\n\r\n\t//Send fee to address (public, with a min amount required)\r\n\tfunction getMyFee(address a) public\r\n\t{\r\n\t\tif (a == address(0))\r\n\t\t\ta = msg.sender;\r\n\t\tuint amount = fees[a];\r\n\t\trequire (amount > 0);\r\n\t\t\r\n\t\tfees[a] = 0;\r\n\t\t\r\n\t\tif (a == wallet)\r\n\t\t{\r\n\t\t\tWalletContract walletContract = WalletContract(a);\r\n\t\t\twalletContract.payMe.value(amount)();\r\n\t\t}\r\n\t\telse if (!a.send(amount))\r\n\t\t\taddFee(wallet, amount); // the fee can't be sent (hacking attempt?), so we take it... :-p\r\n\t}\r\n\t\r\n\t//Add fee (private)\r\n\tfunction addFee(address a, uint fee) private\r\n\t{\r\n\t\tif (fees[a] == 0)\r\n\t\t\tfees[a] = fee;\r\n\t\telse\r\n\t\t\tfees[a] += fee; // we don't check for overflow, if you're billionaire in fees, call getMyFee sometimes :-)\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"poolIndex\",\"type\":\"uint256\"},{\"name\":\"ticketCount\",\"type\":\"uint256\"},{\"name\":\"websiteFeeAddr\",\"type\":\"address\"}],\"name\":\"buyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getPool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkPoolsEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"checkPoolDone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getPoolHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getPoolDone\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"getFeeValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"sendPoolMoney\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"getMyFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPoolDoneCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkPoolsDone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPoolHistoryCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPoolCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"checkPoolEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ticketPrice\",\"type\":\"uint256\"},{\"name\":\"ticketCount\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"addPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"clearPoolsDone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"wal\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"PoolManager","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006f91cbcdddc3ac1c0f8153fed260c4ba33c041ab","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d15f2356d03b77e96f80ec1fe3f65fdf40b118a5a10f8349bbc01bb658271b5d"}]