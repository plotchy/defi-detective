[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LQTY/LockupContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.11;\\r\\n\\r\\nimport \\\"../Dependencies/SafeMath.sol\\\";\\r\\nimport \\\"../Interfaces/ILQTYToken.sol\\\";\\r\\n\\r\\n/*\\r\\n* The lockup contract architecture utilizes a single LockupContract, with an unlockTime. The unlockTime is passed as an argument \\r\\n* to the LockupContract's constructor. The contract's balance can be withdrawn by the beneficiary when block.timestamp > unlockTime. \\r\\n* At construction, the contract checks that unlockTime is at least one year later than the Liquity system's deployment time. \\r\\n\\r\\n* Within the first year from deployment, the deployer of the LQTYToken (Liquity AG's address) may transfer LQTY only to valid \\r\\n* LockupContracts, and no other addresses (this is enforced in LQTYToken.sol's transfer() function).\\r\\n* \\r\\n* The above two restrictions ensure that until one year after system deployment, LQTY tokens originating from Liquity AG cannot \\r\\n* enter circulating supply and cannot be staked to earn system revenue.\\r\\n*/\\r\\ncontract LockupContract {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    // --- Data ---\\r\\n    string constant public NAME = \\\"LockupContract\\\";\\r\\n\\r\\n    uint constant public SECONDS_IN_ONE_YEAR = 31536000; \\r\\n\\r\\n    address public immutable beneficiary;\\r\\n\\r\\n    ILQTYToken public lqtyToken;\\r\\n\\r\\n    // Unlock time is the Unix point in time at which the beneficiary can withdraw.\\r\\n    uint public unlockTime;\\r\\n\\r\\n    // --- Events ---\\r\\n\\r\\n    event LockupContractCreated(address _beneficiary, uint _unlockTime);\\r\\n    event LockupContractEmptied(uint _LQTYwithdrawal);\\r\\n\\r\\n    // --- Functions ---\\r\\n\\r\\n    constructor \\r\\n    (\\r\\n        address _lqtyTokenAddress, \\r\\n        address _beneficiary, \\r\\n        uint _unlockTime\\r\\n    )\\r\\n        public \\r\\n    {\\r\\n        lqtyToken = ILQTYToken(_lqtyTokenAddress);\\r\\n\\r\\n        /*\\r\\n        * Set the unlock time to a chosen instant in the future, as long as it is at least 1 year after\\r\\n        * the system was deployed \\r\\n        */\\r\\n        _requireUnlockTimeIsAtLeastOneYearAfterSystemDeployment(_unlockTime);\\r\\n        unlockTime = _unlockTime;\\r\\n        \\r\\n        beneficiary =  _beneficiary;\\r\\n        emit LockupContractCreated(_beneficiary, _unlockTime);\\r\\n    }\\r\\n\\r\\n    function withdrawLQTY() external {\\r\\n        _requireCallerIsBeneficiary();\\r\\n        _requireLockupDurationHasPassed();\\r\\n\\r\\n        ILQTYToken lqtyTokenCached = lqtyToken;\\r\\n        uint LQTYBalance = lqtyTokenCached.balanceOf(address(this));\\r\\n        lqtyTokenCached.transfer(beneficiary, LQTYBalance);\\r\\n        emit LockupContractEmptied(LQTYBalance);\\r\\n    }\\r\\n\\r\\n    // --- 'require' functions ---\\r\\n\\r\\n    function _requireCallerIsBeneficiary() internal view {\\r\\n        require(msg.sender == beneficiary, \\\"LockupContract: caller is not the beneficiary\\\");\\r\\n    }\\r\\n\\r\\n    function _requireLockupDurationHasPassed() internal view {\\r\\n        require(block.timestamp >= unlockTime, \\\"LockupContract: The lockup duration must have passed\\\");\\r\\n    }\\r\\n\\r\\n    function _requireUnlockTimeIsAtLeastOneYearAfterSystemDeployment(uint _unlockTime) internal view {\\r\\n        uint systemDeploymentTime = lqtyToken.getDeploymentStartTime();\\r\\n        require(_unlockTime >= systemDeploymentTime.add(SECONDS_IN_ONE_YEAR), \\\"LockupContract: unlock time must be at least one year after system deployment\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.11;\\r\\n\\r\\n/**\\r\\n * Based on OpenZeppelin's SafeMath:\\r\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\\r\\n *\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/ILQTYToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.11;\\r\\n\\r\\nimport \\\"../Dependencies/IERC20.sol\\\";\\r\\nimport \\\"../Dependencies/IERC2612.sol\\\";\\r\\n\\r\\ninterface ILQTYToken is IERC20, IERC2612 { \\r\\n   \\r\\n    // --- Events ---\\r\\n    \\r\\n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\\r\\n    event LQTYStakingAddressSet(address _lqtyStakingAddress);\\r\\n    event LockupContractFactoryAddressSet(address _lockupContractFactoryAddress);\\r\\n\\r\\n    // --- Functions ---\\r\\n    \\r\\n    function sendToLQTYStaking(address _sender, uint256 _amount) external;\\r\\n\\r\\n    function getDeploymentStartTime() external view returns (uint256);\\r\\n\\r\\n    function getLpRewardsEntitlement() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.11;\\r\\n\\r\\n/**\\r\\n * Based on the OpenZeppelin IER20 interface:\\r\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\\r\\n *\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"\r\n    },\r\n    \"contracts/Dependencies/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.11;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\r\\n *\\r\\n * Adds the {permit} method, which can be used to change one's\\r\\n * {IERC20-allowance} without having to send a transaction, by signing a\\r\\n * message. This allows users to spend tokens without having to hold Ether.\\r\\n *\\r\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\r\\n * \\r\\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\\r\\n */\\r\\ninterface IERC2612 {\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\r\\n     * given `owner`'s signed approval.\\r\\n     *\\r\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\r\\n     * ordering also apply here.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `deadline` must be a timestamp in the future.\\r\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\r\\n     * over the EIP712-formatted function arguments.\\r\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\r\\n     *\\r\\n     * For more information on the signature format, see the\\r\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\r\\n     * section].\\r\\n     */\\r\\n    function permit(address owner, address spender, uint256 amount, \\r\\n                    uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\r\\n     * included whenever a signature is generated for {permit}.\\r\\n     *\\r\\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\\r\\n     * prevents a signature from being used multiple times.\\r\\n     *\\r\\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to \\r\\n     * a value in the near future. The deadline argument can be set to uint(-1) to \\r\\n     * create Permits that effectively never expire.\\r\\n     */\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n    \\r\\n    function version() external view returns (string memory);\\r\\n    function permitTypeHash() external view returns (bytes32);\\r\\n    function domainSeparator() external view returns (bytes32);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lqtyTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_unlockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_unlockTime\",\"type\":\"uint256\"}],\"name\":\"LockupContractCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_LQTYwithdrawal\",\"type\":\"uint256\"}],\"name\":\"LockupContractEmptied\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_IN_ONE_YEAR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lqtyToken\",\"outputs\":[{\"internalType\":\"contract ILQTYToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLQTY\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LockupContract","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"0000000000000000000000006dea81c8171d0ba574754ef6f8b412f2ed88c54d000000000000000000000000d89852fa2f66b54f485bca0cce3af4e67015597e00000000000000000000000000000000000000000000000000000000624bfec6","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]