[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/EdenNetwork.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IERC20Extended.sol\\\";\\nimport \\\"./interfaces/ILockManager.sol\\\";\\nimport \\\"./lib/Initializable.sol\\\";\\n\\n/**\\n * @title EdenNetwork\\n * @dev It is VERY IMPORTANT that modifications to this contract do not change the storage layout of the existing variables.  \\n * Be especially careful when importing any external contracts/libraries.\\n * If you do not know what any of this means, BACK AWAY FROM THE CODE NOW!!\\n */\\ncontract EdenNetwork is Initializable {\\n\\n    /// @notice Slot bid details\\n    struct Bid {\\n        address bidder;\\n        uint16 taxNumerator;\\n        uint16 taxDenominator;\\n        uint64 periodStart;\\n        uint128 bidAmount;\\n    }\\n\\n    /// @notice Expiration timestamp of current bid for specified slot index\\n    mapping (uint8 => uint64) public slotExpiration;\\n    \\n    /// @dev Address to be prioritized for given slot\\n    mapping (uint8 => address) private _slotDelegate;\\n\\n    /// @dev Address that owns a given slot and is able to set the slot delegate\\n    mapping (uint8 => address) private _slotOwner;\\n\\n    /// @notice Current bid for given slot\\n    mapping (uint8 => Bid) public slotBid;\\n\\n    /// @notice Staked balance in contract\\n    mapping (address => uint128) public stakedBalance;\\n\\n    /// @notice Balance in contract that was previously used for bid\\n    mapping (address => uint128) public lockedBalance;\\n\\n    /// @notice Token used to reserve slot\\n    IERC20Extended public token;\\n\\n    /// @notice Lock Manager contract\\n    ILockManager public lockManager;\\n\\n    /// @notice Admin that can set the contract tax rate\\n    address public admin;\\n\\n    /// @notice Numerator for tax rate\\n    uint16 public taxNumerator;\\n\\n    /// @notice Denominator for tax rate\\n    uint16 public taxDenominator;\\n\\n    /// @notice Minimum bid to reserve slot\\n    uint128 public MIN_BID;\\n\\n    /// @dev Reentrancy var used like bool, but with refunds\\n    uint256 private _NOT_ENTERED;\\n\\n    /// @dev Reentrancy var used like bool, but with refunds\\n    uint256 private _ENTERED;\\n\\n    /// @dev Reentrancy status\\n    uint256 private _status;\\n\\n    /// @notice Only admin can call\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"not admin\\\");\\n        _;\\n    }\\n\\n    /// @notice Only slot owner can call\\n    modifier onlySlotOwner(uint8 slot) {\\n        require(msg.sender == slotOwner(slot), \\\"not slot owner\\\");\\n        _;\\n    }\\n\\n    /// @notice Reentrancy prevention\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /// @notice Event emitted when admin is updated\\n    event AdminUpdated(address indexed newAdmin, address indexed oldAdmin);\\n\\n    /// @notice Event emitted when the tax rate is updated\\n    event TaxRateUpdated(uint16 newNumerator, uint16 newDenominator, uint16 oldNumerator, uint16 oldDenominator);\\n\\n    /// @notice Event emitted when slot is claimed\\n    event SlotClaimed(uint8 indexed slot, address indexed owner, address indexed delegate, uint128 newBidAmount, uint128 oldBidAmount, uint16 taxNumerator, uint16 taxDenominator);\\n    \\n    /// @notice Event emitted when slot delegate is updated\\n    event SlotDelegateUpdated(uint8 indexed slot, address indexed owner, address indexed newDelegate, address oldDelegate);\\n\\n    /// @notice Event emitted when a user stakes tokens\\n    event Stake(address indexed staker, uint256 stakeAmount);\\n\\n    /// @notice Event emitted when a user unstakes tokens\\n    event Unstake(address indexed staker, uint256 unstakedAmount);\\n\\n    /// @notice Event emitted when a user withdraws locked tokens\\n    event Withdraw(address indexed withdrawer, uint256 withdrawalAmount);\\n\\n    /**\\n     * @notice Initialize EdenNetwork contract\\n     * @param _token Token address\\n     * @param _lockManager Lock Manager address\\n     * @param _admin Admin address\\n     * @param _taxNumerator Numerator for tax rate\\n     * @param _taxDenominator Denominator for tax rate\\n     */\\n    function initialize(\\n        IERC20Extended _token,\\n        ILockManager _lockManager,\\n        address _admin,\\n        uint16 _taxNumerator,\\n        uint16 _taxDenominator\\n    ) public initializer {\\n        token = _token;\\n        lockManager = _lockManager;\\n        admin = _admin;\\n        emit AdminUpdated(_admin, address(0));\\n\\n        taxNumerator = _taxNumerator;\\n        taxDenominator = _taxDenominator;\\n        emit TaxRateUpdated(_taxNumerator, _taxDenominator, 0, 0);\\n\\n        MIN_BID = 10000000000000000;\\n        _NOT_ENTERED = 1;\\n        _ENTERED = 2;\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @notice Get current owner of slot\\n     * @param slot Slot index\\n     * @return Slot owner address\\n     */\\n    function slotOwner(uint8 slot) public view returns (address) {\\n        if(slotForeclosed(slot)) {\\n            return address(0);\\n        }\\n        return _slotOwner[slot];\\n    }\\n\\n    /**\\n     * @notice Get current slot delegate\\n     * @param slot Slot index\\n     * @return Slot delegate address\\n     */\\n    function slotDelegate(uint8 slot) public view returns (address) {\\n        if(slotForeclosed(slot)) {\\n            return address(0);\\n        }\\n        return _slotDelegate[slot];\\n    }\\n\\n    /**\\n     * @notice Get current cost to claim slot\\n     * @param slot Slot index\\n     * @return Slot cost\\n     */\\n    function slotCost(uint8 slot) external view returns (uint128) {\\n        if(slotForeclosed(slot)) {\\n            return MIN_BID;\\n        }\\n\\n        Bid memory currentBid = slotBid[slot];\\n        return currentBid.bidAmount * 110 / 100;\\n    }\\n\\n    /**\\n     * @notice Claim slot\\n     * @param slot Slot index\\n     * @param bid Bid amount\\n     * @param delegate Delegate for slot\\n     */\\n    function claimSlot(\\n        uint8 slot, \\n        uint128 bid, \\n        address delegate\\n    ) external nonReentrant {\\n        _claimSlot(slot, bid, delegate);\\n    }\\n\\n    /**\\n     * @notice Claim slot using permit for approval\\n     * @param slot Slot index\\n     * @param bid Bid amount\\n     * @param delegate Delegate for slot\\n     * @param deadline The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function claimSlotWithPermit(\\n        uint8 slot, \\n        uint128 bid, \\n        address delegate, \\n        uint256 deadline, \\n        uint8 v, \\n        bytes32 r, \\n        bytes32 s\\n    ) external nonReentrant {\\n        token.permit(msg.sender, address(this), bid, deadline, v, r, s);\\n        _claimSlot(slot, bid, delegate);\\n    }\\n\\n    /**\\n     * @notice Get untaxed balance for current slot bid\\n     * @param slot Slot index\\n     * @return balance Slot balance\\n     */\\n    function slotBalance(uint8 slot) public view returns (uint128 balance) {\\n        Bid memory currentBid = slotBid[slot];\\n        if (currentBid.bidAmount == 0 || slotForeclosed(slot)) {\\n            return 0;\\n        } else if (block.timestamp == currentBid.periodStart) {\\n            return currentBid.bidAmount;\\n        } else {\\n            return uint128(uint256(currentBid.bidAmount) - (uint256(currentBid.bidAmount) * (block.timestamp - currentBid.periodStart) * currentBid.taxNumerator / (uint256(currentBid.taxDenominator) * 86400)));\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns true if a given slot bid has expired\\n     * @param slot Slot index\\n     * @return True if slot is foreclosed\\n     */\\n    function slotForeclosed(uint8 slot) public view returns (bool) {\\n        if(slotExpiration[slot] <= block.timestamp) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Stake tokens\\n     * @param amount Amount of tokens to stake\\n     */\\n    function stake(uint128 amount) external nonReentrant {\\n        _stake(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Stake tokens using permit for approval\\n     * @param amount Amount of tokens to stake\\n     * @param deadline The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function stakeWithPermit(\\n        uint128 amount, \\n        uint256 deadline, \\n        uint8 v, \\n        bytes32 r, \\n        bytes32 s\\n    ) external nonReentrant {\\n        token.permit(msg.sender, address(this), amount, deadline, v, r, s);\\n        _stake(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Stake tokens on behalf of recipient\\n     * @param recipient Recipient of staked tokens\\n     * @param amount Amount of tokens to stake\\n     */\\n    function stakeFor(address recipient, uint128 amount) external nonReentrant {\\n        _stake(recipient, amount);\\n    }\\n\\n    /**\\n     * @notice Stake tokens on behalf of recipient using permit for approval\\n     * @param recipient Recipient of staked tokens\\n     * @param amount Amount of tokens to stake\\n     * @param deadline The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function stakeForWithPermit(\\n        address recipient,\\n        uint128 amount, \\n        uint256 deadline, \\n        uint8 v, \\n        bytes32 r, \\n        bytes32 s\\n    ) external nonReentrant {\\n        token.permit(msg.sender, address(this), amount, deadline, v, r, s);\\n        _stake(recipient, amount);\\n    }\\n\\n    /**\\n     * @notice Unstake tokens\\n     * @param amount Amount of tokens to unstake\\n     */\\n    function unstake(uint128 amount) external nonReentrant {\\n        require(stakedBalance[msg.sender] >= amount, \\\"amount > unlocked balance\\\");\\n        lockManager.removeVotingPower(msg.sender, address(token), amount);\\n        stakedBalance[msg.sender] -= amount;\\n        token.transfer(msg.sender, amount);\\n        emit Unstake(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Withdraw locked tokens\\n     * @param amount Amount of tokens to withdraw\\n     */\\n    function withdraw(uint128 amount) external nonReentrant {\\n        require(lockedBalance[msg.sender] >= amount, \\\"amount > unlocked balance\\\");\\n        lockedBalance[msg.sender] -= amount;\\n        token.transfer(msg.sender, amount);\\n        emit Withdraw(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Allows slot owners to set a new slot delegate\\n     * @param slot Slot index\\n     * @param delegate Delegate address\\n     */\\n    function setSlotDelegate(uint8 slot, address delegate) external onlySlotOwner(slot) {\\n        require(delegate != address(0), \\\"cannot delegate to 0 address\\\");\\n        emit SlotDelegateUpdated(slot, msg.sender, delegate, slotDelegate(slot));\\n        _slotDelegate[slot] = delegate;\\n    }\\n\\n    /**\\n     * @notice Set new tax rate\\n     * @param numerator New tax numerator\\n     * @param denominator New tax denominator\\n     */\\n    function setTaxRate(uint16 numerator, uint16 denominator) external onlyAdmin {\\n        require(denominator > numerator, \\\"denominator must be > numerator\\\");\\n        emit TaxRateUpdated(numerator, denominator, taxNumerator, taxDenominator);\\n        taxNumerator = numerator;\\n        taxDenominator = denominator;\\n    }\\n\\n    /**\\n     * @notice Set new admin\\n     * @param newAdmin Nex admin address\\n     */\\n    function setAdmin(address newAdmin) external onlyAdmin {\\n        emit AdminUpdated(newAdmin, admin);\\n        admin = newAdmin;\\n    }\\n\\n    /**\\n     * @notice Internal implementation of claimSlot\\n     * @param slot Slot index\\n     * @param bid Bid amount\\n     * @param delegate Delegate address\\n     */\\n    function _claimSlot(uint8 slot, uint128 bid, address delegate) internal {\\n        require(delegate != address(0), \\\"cannot delegate to 0 address\\\");\\n        Bid storage currentBid = slotBid[slot];\\n        uint128 existingBidAmount = currentBid.bidAmount;\\n        uint128 existingSlotBalance = slotBalance(slot);\\n        uint128 taxedBalance = existingBidAmount - existingSlotBalance;\\n        require((existingSlotBalance == 0 && bid >= MIN_BID) || bid >= existingBidAmount * 110 / 100, \\\"bid too small\\\");\\n\\n        uint128 bidderLockedBalance = lockedBalance[msg.sender];\\n        uint128 bidIncrement = currentBid.bidder == msg.sender ? bid - existingSlotBalance : bid;\\n        if (bidderLockedBalance > 0) {\\n            if (bidderLockedBalance >= bidIncrement) {\\n                lockedBalance[msg.sender] -= bidIncrement;\\n            } else {\\n                lockedBalance[msg.sender] = 0;\\n                token.transferFrom(msg.sender, address(this), bidIncrement - bidderLockedBalance);\\n            }\\n        } else {\\n            token.transferFrom(msg.sender, address(this), bidIncrement);\\n        }\\n\\n        if (currentBid.bidder != msg.sender) {\\n            lockedBalance[currentBid.bidder] += existingSlotBalance;\\n        }\\n        \\n        if (taxedBalance > 0) {\\n            token.burn(taxedBalance);\\n        }\\n\\n        _slotOwner[slot] = msg.sender;\\n        _slotDelegate[slot] = delegate;\\n\\n        currentBid.bidder = msg.sender;\\n        currentBid.periodStart = uint64(block.timestamp);\\n        currentBid.bidAmount = bid;\\n        currentBid.taxNumerator = taxNumerator;\\n        currentBid.taxDenominator = taxDenominator;\\n\\n        slotExpiration[slot] = uint64(block.timestamp + uint256(taxDenominator) * 86400 / uint256(taxNumerator));\\n\\n        emit SlotClaimed(slot, msg.sender, delegate, bid, existingBidAmount, taxNumerator, taxDenominator);\\n    }\\n\\n    /**\\n     * @notice Internal implementation of stake\\n     * @param amount Amount of tokens to stake\\n     */\\n    function _stake(address recipient, uint128 amount) internal {\\n        token.transferFrom(msg.sender, address(this), amount);\\n        lockManager.grantVotingPower(recipient, address(token), amount);\\n        stakedBalance[recipient] += amount;\\n        emit Stake(recipient, amount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Burnable is IERC20 {\\n    function burn(uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Metadata.sol\\\";\\nimport \\\"./IERC20Mintable.sol\\\";\\nimport \\\"./IERC20Burnable.sol\\\";\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"./IERC20TransferWithAuth.sol\\\";\\nimport \\\"./IERC20SafeAllowance.sol\\\";\\n\\ninterface IERC20Extended is \\n    IERC20Metadata, \\n    IERC20Mintable, \\n    IERC20Burnable, \\n    IERC20Permit,\\n    IERC20TransferWithAuth,\\n    IERC20SafeAllowance \\n{}\\n    \"\r\n    },\r\n    \"contracts/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Mintable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Mintable is IERC20 {\\n    function mint(address dst, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Permit is IERC20 {\\n    function getDomainSeparator() external view returns (bytes32);\\n    function DOMAIN_TYPEHASH() external view returns (bytes32);\\n    function VERSION_HASH() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external view returns (bytes32);\\n    function nonces(address) external view returns (uint);\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20SafeAllowance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20SafeAllowance is IERC20 {\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20TransferWithAuth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20TransferWithAuth is IERC20 {\\n    function transferWithAuthorization(address from, address to, uint256 value, uint256 validAfter, uint256 validBefore, bytes32 nonce, uint8 v, bytes32 r, bytes32 s) external;\\n    function receiveWithAuthorization(address from, address to, uint256 value, uint256 validAfter, uint256 validBefore, bytes32 nonce, uint8 v, bytes32 r, bytes32 s) external;\\n    function TRANSFER_WITH_AUTHORIZATION_TYPEHASH() external view returns (bytes32);\\n    function RECEIVE_WITH_AUTHORIZATION_TYPEHASH() external view returns (bytes32);\\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ILockManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ILockManager {\\n    struct LockedStake {\\n        uint256 amount;\\n        uint256 votingPower;\\n    }\\n\\n    function getAmountStaked(address staker, address stakedToken) external view returns (uint256);\\n    function getStake(address staker, address stakedToken) external view returns (LockedStake memory);\\n    function calculateVotingPower(address token, uint256 amount) external view returns (uint256);\\n    function grantVotingPower(address receiver, address token, uint256 tokenAmount) external returns (uint256 votingPowerGranted);\\n    function removeVotingPower(address receiver, address token, uint256 tokenAmount) external returns (uint256 votingPowerRemoved);\\n}\"\r\n    },\r\n    \"contracts/lib/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"AdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newBidAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"oldBidAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"taxNumerator\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"taxDenominator\",\"type\":\"uint16\"}],\"name\":\"SlotClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDelegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDelegate\",\"type\":\"address\"}],\"name\":\"SlotDelegateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newNumerator\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newDenominator\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"oldNumerator\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"oldDenominator\",\"type\":\"uint16\"}],\"name\":\"TaxRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unstakedAmount\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawalAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIN_BID\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"bid\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"claimSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"bid\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"claimSlotWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Extended\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract ILockManager\",\"name\":\"_lockManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_taxNumerator\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_taxDenominator\",\"type\":\"uint16\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockManager\",\"outputs\":[{\"internalType\":\"contract ILockManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedBalance\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"setSlotDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"numerator\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"denominator\",\"type\":\"uint16\"}],\"name\":\"setTaxRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"}],\"name\":\"slotBalance\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"balance\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"slotBid\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"taxNumerator\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"taxDenominator\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"periodStart\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"bidAmount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"}],\"name\":\"slotCost\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"}],\"name\":\"slotDelegate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"slotExpiration\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"}],\"name\":\"slotForeclosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"}],\"name\":\"slotOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"stakeForWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"stakeWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakedBalance\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxDenominator\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxNumerator\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20Extended\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EdenNetwork","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]