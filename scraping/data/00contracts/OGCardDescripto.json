[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/OGCardDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./interfaces/IOGCards.sol\\\";\\nimport \\\"./interfaces/ILayerDescriptor.sol\\\";\\n\\nimport 'base64-sol/base64.sol';\\n\\ncontract OGCardDescriptor is Ownable {\\n    using Strings for uint256;\\n    using Strings for uint8;\\n\\n    string public ogCardUrl = '';\\n    string public ogCardDescription = 'OGCards are NFTs which evolve after each different holder';\\n    address public immutable frontLayerDescriptor;\\n    address public backLayerDescriptor;\\n\\n    constructor(address _frontLayerDescriptor, address _backLayerDescriptor)\\n    {\\n        frontLayerDescriptor = _frontLayerDescriptor;\\n        backLayerDescriptor = _backLayerDescriptor;\\n    }\\n\\n    function setOGCardUrl(string memory _ogCardUrl)\\n        external\\n        onlyOwner\\n    {\\n        ogCardUrl = _ogCardUrl;\\n    }\\n\\n    function setOGCardDescription(string memory _ogCardDescription)\\n        external\\n        onlyOwner\\n    {\\n        ogCardDescription = _ogCardDescription;\\n    }\\n\\n    function setBackLayerDescriptor(address _backLayerDescriptor)\\n        external\\n        onlyOwner\\n    {\\n        backLayerDescriptor = _backLayerDescriptor;\\n    }\\n\\n    function tokenURI(address ogCards, uint256 tokenId)\\n        external\\n        view\\n        returns (string memory)\\n    {\\n        return string(\\n            abi.encodePacked(\\n                'data:application/json;base64,',\\n                    Base64.encode(\\n                        bytes(\\n                            metadata(ogCards, tokenId)\\n                        )\\n                    )\\n            )\\n        );\\n    }\\n\\n    function metadata(address ogCards, uint256 tokenId)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        IOGCards.Card memory card = IOGCards(ogCards).cardDetails(tokenId);\\n        (, string[] memory names) = IOGCards(ogCards).ogHolders(tokenId);\\n        string memory attributes = cardAttributes(card.borderType, card.transparencyLevel, card.maskType, card.dna, card.mintTokenId, card.isGiveaway, names);\\n\\n        string memory externalUrl = '';\\n        if (bytes(ogCardUrl).length > 0) {\\n            externalUrl = string(abi.encodePacked(\\n                '\\\"external_url\\\": \\\"',\\n                ogCardUrl,\\n                tokenId.toString(),\\n                '\\\",'\\n            ));\\n        }\\n\\n        return string(abi.encodePacked(\\n\\t\\t\\t'{',\\n\\t\\t\\t\\t'\\\"name\\\": \\\"OGCard #', tokenId.toString(), '\\\",', \\n\\t\\t\\t\\t'\\\"description\\\": \\\"',ogCardDescription,'\\\",',\\n                '\\\"image\\\": \\\"',\\n                    'data:image/svg+xml;base64,', Base64.encode(bytes(svgImage(ogCards, tokenId, card))), '\\\",',\\n                    externalUrl,\\n\\t\\t\\t\\t'\\\"attributes\\\": [', attributes, ']',\\n\\t\\t\\t'}'\\n\\t\\t));\\n    }\\n\\n    function cardAttributes(uint8 borderType, uint8 transparencyLevel, uint8 maskType, uint256 dna, uint256 mintTokenId, bool isGiveaway, string[] memory names)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory attributes = string(abi.encodePacked(\\n            borderColorTrait(borderType),\\n            ',',\\n            transparencyTrait(transparencyLevel),\\n            ',',\\n            maskTrait(maskType),\\n            ',',\\n            dnaTrait(dna),\\n            ',',\\n            ogsTraits(names),\\n            ',',\\n            mintTokenIdTrait(mintTokenId, maskType, isGiveaway),\\n            ',',\\n            giveawayTrait(isGiveaway)\\n        ));\\n\\n        return attributes;\\n    }\\n\\n    // Traits\\n    function traitDefinition(string memory name, string memory value)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(\\n            '{',\\n                '\\\"trait_type\\\": \\\"', name ,'\\\",',\\n                '\\\"value\\\": \\\"', value ,'\\\"',\\n            '}'\\n        ));\\n    }\\n\\n    function borderColorTrait(uint8 borderType)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return traitDefinition('Border Color', borderColorString(borderType));\\n    }\\n\\n    function transparencyTrait(uint8 transparencyLevel)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return traitDefinition('Transparency Level', transparencyLevelString(transparencyLevel));\\n    }\\n\\n    function maskTrait(uint8 maskType)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return traitDefinition('Mask', maskTypeString(maskType));\\n    }\\n\\n    function dnaTrait(uint256 dna)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return traitDefinition('DNA', dna.toString());\\n    }\\n\\n    function giveawayTrait(bool isGiveaway)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory value = isGiveaway ? 'true' : 'false';\\n        return traitDefinition('Giveaway', value);\\n    }\\n\\n    function mintTokenIdTrait(uint256 mintTokenId, uint8 maskType, bool isGiveaway)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory value = !isGiveaway && maskType > 0 ? mintTokenId.toString() : 'None';\\n        return traitDefinition('MintTokenId', value);\\n    }\\n\\n    function ogsTraits(string[] memory names)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory traitsDefinitions = string(abi.encodePacked(\\n            '{',\\n                '\\\"trait_type\\\": \\\"OGs\\\",',\\n                '\\\"value\\\": ', names.length.toString(),\\n            '}'\\n        ));\\n\\n        if (names.length > 0) {\\n            for (uint256 i = 0; i < names.length; i++) {\\n                string memory name = names[i];\\n                traitsDefinitions = string(abi.encodePacked(\\n                    traitsDefinitions,\\n                    ',',\\n                    traitDefinition('OG', name)\\n                ));\\n            }\\n        }\\n\\n        return traitsDefinitions;\\n    }\\n\\n    // Attributes to String\\n    function borderColorString(uint8 borderType)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return (borderType == 0 ? \\\"#00ccff\\\": // Light blue\\n                    (borderType == 1 ? \\\"#ffffff\\\" : // White\\n                        (borderType == 2 ? \\\"#1eff00\\\" : // Green\\n                            (borderType == 3 ? \\\"#0070dd\\\" : // Blue\\n                                (borderType == 4 ? \\\"#a335ee\\\" : \\\"#daa520\\\"))))); // Purple and Gold\\n    }\\n\\n    function maskTypeString(uint8 maskType)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return (maskType == 0 ? \\\"Ethereum\\\" :\\n                    (maskType == 1 ? \\\"CryptoPunk\\\" :\\n                        (maskType == 2 ? \\\"Animal Coloring Book\\\" :\\n                            (maskType == 3 ? \\\"Purrnelope's Country Club\\\" : \\\"\\\"))));\\n    }\\n\\n    function transparencyLevelString(uint8 transparencyLevel)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return transparencyLevel.toString();\\n    }\\n\\n    function svgImage(address ogCards, uint256 tokenId, IOGCards.Card memory card)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        string memory font = \\\"Avenir, Helvetica, Arial, sans-serif\\\";\\n        string memory borderColor = borderColorString(card.borderType);\\n\\n        return string(abi.encodePacked(\\n            '<svg id=\\\"ogcard-',tokenId.toString(),'\\\" data-name=\\\"OGCard\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"300\\\" height=\\\"300\\\" class=\\\"ogcard-svg\\\">',\\n                svgDefsAndStyles(tokenId, card.maskType, font, borderColor),\\n                '<g clip-path=\\\"url(#corners)\\\">',\\n                    svgLayers(ogCards, tokenId, font, borderColor, card),\\n                    '<rect width=\\\"100%\\\" height=\\\"100%\\\" rx=\\\"30\\\" ry=\\\"30\\\" stroke=\\\"',borderColor,'\\\" stroke-width=\\\"2\\\" fill=\\\"rgba(0,0,0,0)\\\"></rect>',\\n                '</g>',\\n                '</svg>'\\n\\t\\t));\\n    }\\n\\n    function svgLayers(address ogCards, uint256 tokenId, string memory font, string memory borderColor, IOGCards.Card memory card)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(\\n            ILayerDescriptor(backLayerDescriptor).svgLayer(ogCards, tokenId, font, borderColor, card),\\n            ILayerDescriptor(frontLayerDescriptor).svgLayer(ogCards, tokenId, font, borderColor, card)\\n        ));\\n    }\\n\\n    function svgDefsAndStyles(uint256 tokenId, uint8 maskType, string memory font, string memory borderColor)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(\\n            '<defs>',\\n                '<rect id=\\\"rect-corners\\\" width=\\\"100%\\\" height=\\\"100%\\\" rx=\\\"30\\\" ry=\\\"30\\\" />',\\n                ILayerDescriptor(frontLayerDescriptor).svgMask(maskType, borderColor, true, false),\\n                '<text id=\\\"token-id\\\" x=\\\"205\\\" y=\\\"270\\\" font-family=\\\"',font,'\\\" font-weight=\\\"bold\\\" font-size=\\\"30px\\\" fill=\\\"#000000\\\">',\\n                '#',uint2strMask(tokenId),\\n                '</text>',\\n                '<path id=\\\"text-path-border\\\" d=\\\"M35 15 H265 a20 20 0 0 1 20 20 V265 a20 20 0 0 1 -20 20 H35 a20 20 0 0 1 -20 -20 V35 a20 20 0 0 1 20 -20 z\\\"></path>',\\n                '<clipPath id=\\\"corners\\\"><use href=\\\"#rect-corners\\\" /></clipPath>',\\n                '<mask id=\\\"mask\\\">',\\n                    '<rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"#ffffff\\\"></rect>',\\n                    '<g class=\\\"mask-path\\\">',\\n                        ILayerDescriptor(frontLayerDescriptor).svgMask(maskType, borderColor, true, true),\\n                    '</g>',\\n                    '<use href=\\\"#token-id\\\" />',\\n                '</mask>',\\n            '</defs>',\\n            '<style>',\\n                '.mask-path {animation: 2s mask-path infinite alternate linear;} @keyframes mask-path {0%, 100% {transform: translateY(-3%)}50% {transform: translateY(3%)}}',\\n            '</style>'\\n        ));\\n    }\\n\\n    function uint2strMask(uint _i) internal pure returns (string memory _uintAsString) {\\n        uint maskSize = 3;\\n        if (_i == 0) {\\n            return \\\"000\\\";\\n        }\\n        uint j = _i;\\n        uint len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(maskSize);\\n        uint k = maskSize;\\n        while (_i != 0) {\\n            k = k-1;\\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        while (k != 0) {\\n            k = k-1;\\n            uint8 temp = 48;\\n            bstr[k] = bytes1(temp);\\n        }\\n        return string(bstr);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOGCards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IOGCards {\\n    struct Card {\\n        bool isGiveaway;\\n        uint8 borderType;\\n        uint8 transparencyLevel;\\n        uint8 maskType;\\n        uint256 dna;\\n        uint256 mintTokenId;\\n        address[] holders;\\n    }\\n\\n    function cardDetails(uint256 tokenId) external view returns (Card memory);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function isOG(address _og) external view returns (bool);\\n\\n    function holderName(address _holder) external view returns (string memory);\\n\\n    function ogHolders(uint256 tokenId)\\n        external\\n        view\\n        returns (address[] memory, string[] memory);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ILayerDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IOGCards.sol\\\";\\n\\ninterface ILayerDescriptor {\\n    struct Layer {\\n        bool isGiveaway;\\n        uint8 maskType;\\n        uint8 transparencyLevel;\\n        uint256 tokenId;\\n        uint256 dna;\\n        uint256 mintTokenId;\\n        string font;\\n        string borderColor;\\n        address ogCards;\\n    }\\n    function svgLayer(address ogCards, uint256 tokenId, string memory font, string memory borderColor, IOGCards.Card memory card)\\n        external\\n        view\\n        returns (string memory);\\n\\n    function svgMask(uint8 maskType, string memory borderColor, bool isDef, bool isMask)\\n        external\\n        pure\\n        returns (string memory);\\n}\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides a function for encoding some bytes in base64\\nlibrary Base64 {\\n    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n        \\n        // load the table into memory\\n        string memory table = TABLE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n            \\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n            \\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n            \\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n            \\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               dataPtr := add(dataPtr, 3)\\n               \\n               // read 3 bytes\\n               let input := mload(dataPtr)\\n               \\n               // write 4 characters\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n            }\\n            \\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": false\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_frontLayerDescriptor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_backLayerDescriptor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"backLayerDescriptor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"borderType\",\"type\":\"uint8\"}],\"name\":\"borderColorString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"borderType\",\"type\":\"uint8\"}],\"name\":\"borderColorTrait\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"borderType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"transparencyLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maskType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dna\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isGiveaway\",\"type\":\"bool\"},{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"}],\"name\":\"cardAttributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dna\",\"type\":\"uint256\"}],\"name\":\"dnaTrait\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"frontLayerDescriptor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isGiveaway\",\"type\":\"bool\"}],\"name\":\"giveawayTrait\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"maskType\",\"type\":\"uint8\"}],\"name\":\"maskTrait\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"maskType\",\"type\":\"uint8\"}],\"name\":\"maskTypeString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ogCards\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"maskType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isGiveaway\",\"type\":\"bool\"}],\"name\":\"mintTokenIdTrait\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ogCardDescription\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ogCardUrl\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"}],\"name\":\"ogsTraits\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_backLayerDescriptor\",\"type\":\"address\"}],\"name\":\"setBackLayerDescriptor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_ogCardDescription\",\"type\":\"string\"}],\"name\":\"setOGCardDescription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_ogCardUrl\",\"type\":\"string\"}],\"name\":\"setOGCardUrl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"maskType\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"font\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"borderColor\",\"type\":\"string\"}],\"name\":\"svgDefsAndStyles\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ogCards\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isGiveaway\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"borderType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"transparencyLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maskType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dna\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"holders\",\"type\":\"address[]\"}],\"internalType\":\"struct IOGCards.Card\",\"name\":\"card\",\"type\":\"tuple\"}],\"name\":\"svgImage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ogCards\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"font\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"borderColor\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isGiveaway\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"borderType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"transparencyLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"maskType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dna\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"holders\",\"type\":\"address[]\"}],\"internalType\":\"struct IOGCards.Card\",\"name\":\"card\",\"type\":\"tuple\"}],\"name\":\"svgLayers\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ogCards\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"traitDefinition\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"transparencyLevel\",\"type\":\"uint8\"}],\"name\":\"transparencyLevelString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"transparencyLevel\",\"type\":\"uint8\"}],\"name\":\"transparencyTrait\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"OGCardDescriptor","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f63ccf6f7ef7e8f225271758df74f252becd4cac00000000000000000000000085d9c980ac674e36bca9a5e8bd8ff419f7b4e46b","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]