[{"SourceCode":"// File: .deps/TripodMath.sol\r\n\r\n\r\npragma solidity ^0.8.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\ninterface IFeedRegistry {\r\n    function getFeed(address, address) external view returns (address);\r\n    function latestRoundData(address, address) external view returns (\r\n        uint80 roundId,\r\n        int256 answer,\r\n        uint256 startedAt,\r\n        uint256 updatedAt,\r\n        uint80 answeredInRound\r\n    );\r\n}\r\n\r\n\r\n\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ninterface IERC20Extended is IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface ITripod{\r\n    function pool() external view returns(address);\r\n    function tokenA() external view returns (address);\r\n    function balanceOfA() external view returns(uint256);\r\n    function tokenB() external view returns (address);\r\n    function balanceOfB() external view returns(uint256);\r\n    function tokenC() external view returns (address);\r\n    function balanceOfC() external view returns(uint256);\r\n    function invested(address) external view returns(uint256);\r\n    function totalLpBalance() external view returns(uint256);\r\n    function investedWeight(address)external view returns(uint256);\r\n    function quote(address, address, uint256) external view returns(uint256);\r\n    function usingReference() external view returns(bool);\r\n    function referenceToken() external view returns(address);\r\n    function balanceOfTokensInLP() external view returns(uint256, uint256, uint256);\r\n    function getRewardTokens() external view returns(address[] memory);\r\n    function pendingRewards() external view returns(uint256[] memory);\r\n}\r\n\r\ninterface IBalancerTripod is ITripod{\r\n    //Struct for each bb pool that makes up the main pool\r\n    struct PoolInfo {\r\n        address token;\r\n        address bbPool;\r\n        bytes32 poolId;\r\n    }\r\n    function poolInfo(uint256) external view returns(PoolInfo memory);\r\n    function curveIndex(address) external view returns(int128);\r\n    function poolId() external view returns(bytes32);\r\n    function toSwapToIndex() external view returns(uint256); \r\n    function toSwapToPoolId() external view returns(bytes32);\r\n}\r\n\r\n/// @title Tripod Math\r\n/// @notice Contains the Rebalancing Logic and Math for the Tripod Base. Used during both the rebalance and quote rebalance functions\r\nlibrary TripodMath {\r\n\r\n    /*\r\n    * @notice\r\n    *   The rebalancing math aims to have each tokens relative return be equal after the rebalance irregardless of the strating weights or exchange rates\r\n    *   These functions are called during swapOneToTwo() or swapTwoToOne() in the Tripod.sol https://github.com/Schlagonia/Tripod/blob/master/src/Tripod.sol\r\n    *   All math was adopted from the original joint strategies https://github.com/fp-crypto/joint-strategy\r\n\r\n        All equations will use the following variables:\r\n            a0 = The invested balance of the first token\r\n            a1 = The ending balance of the first token\r\n            b0 = The invested balance of the second token\r\n            b1 = The ending balance of the second token\r\n            c0 = the invested balance of the third token\r\n            c1 = The ending balance of the third token\r\n            eOfB = The exchange rate of either a => b or b => a depending on which way we are swapping\r\n            eOfC = The exchange rate of either a => c or c => a depending on which way we are swapping\r\n            precision = 10 ** first token decimals\r\n            precisionB = 10 ** second token decimals\r\n            precisionC = 10 ** third token decimals\r\n\r\n            Variables specific to swapOneToTwo()\r\n            n = The amount of a token we will be selling\r\n            p = The % of n we will be selling from a => b\r\n\r\n            Variables specific to swapTwoToOne()\r\n            nb = The amount of b we will be swapping to a\r\n            nc = The amount of c we will be swapping to a \r\n\r\n        The starting equations that all of the following are derived from is:\r\n\r\n         a1 - n       b1 + eOfB*n*p      c1 + eOfC*n*(1-p) \r\n        --------  =  --------------  =  -------------------\r\n           a0              b0                   c0\r\n\r\n    */\r\n\r\n    struct RebalanceInfo {\r\n        uint256 precisionA;\r\n        uint256 a0;\r\n        uint256 a1;\r\n        uint256 b0;\r\n        uint256 b1;\r\n        uint256 eOfB;\r\n        uint256 precisionB;\r\n        uint256 c0;\r\n        uint256 c1;\r\n        uint256 eOfC;\r\n        uint256 precisionC;\r\n    }   \r\n\r\n    struct Tokens {\r\n        address tokenA;\r\n        uint256 ratioA;\r\n        address tokenB;\r\n        uint256 ratioB;\r\n        address tokenC;\r\n        uint256 ratioC;\r\n    }\r\n    \r\n    uint256 private constant RATIO_PRECISION = 1e18;\r\n    /*\r\n    * @notice\r\n    *   Internal function to be called during swapOneToTwo to return n: the amount of a to sell and p: the % of n to sell to b\r\n    * @param info, Rebalance info struct with all needed variables\r\n    * @return n, The amount of a to sell\r\n    * @return p, The percent of a we will sell to b repersented as 1e18. i.e. 50% == .5e18\r\n    */\r\n    function getNandP(RebalanceInfo memory info) public pure returns(uint256 n, uint256 p) {\r\n        p = getP(info);\r\n        n = getN(info, p);\r\n    }\r\n\r\n    /*\r\n    * @notice\r\n    *   Internal function used to calculate the percent of n that will be sold to b\r\n    *   p is repersented as 1e18\r\n    * @param info, RebalanceInfo stuct\r\n    * @return the percent of a to sell to b as 1e18\r\n    */\r\n    function getP(RebalanceInfo memory info) public pure returns (uint256 p) {\r\n        /*\r\n        *             a1*b0*eOfC + b0c1 - b1c0 - a0*b1*eOfC\r\n        *   p = ----------------------------------------------------\r\n        *        a1*c0*eOfB + a1*b0*eOfC - a0*c1*eOfB - a0*b1*eOfC\r\n        */\r\n        unchecked {\r\n            //pre-calculate a couple of parts that are used twice\r\n            //var1 = a0*b1*eOfC\r\n            uint256 var1 = info.a0 * info.b1 * info.eOfC / info.precisionA;\r\n            //var2 = a1*b0*eOfC\r\n            uint256 var2 = info.a1 * info.b0 * info.eOfC / info.precisionA;\r\n\r\n            uint256 numerator = var2 + (info.b0 * info.c1) - (info.b1 * info.c0) - var1;\r\n\r\n            uint256 denominator = \r\n                (info.a1 * info.c0 * info.eOfB / info.precisionA) + \r\n                    var2 - \r\n                        (info.a0 * info.c1 * info.eOfB / info.precisionA) - \r\n                            var1;\r\n    \r\n            p = numerator * 1e18 / denominator;\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @notice\r\n    *   Internal function used to calculate the amount of a to sell once p has been calculated\r\n    *   Converts all uint's to int's because the numerator will be negative\r\n    * @param info, RebalanceInfo stuct\r\n    * @param p, % calculated to of b to sell to a in 1e18\r\n    * @return The amount of a to sell\r\n    */\r\n    function getN(RebalanceInfo memory info, uint256 p) public pure returns(uint256) {\r\n        /*\r\n        *          (a1*b0) - (a0*b1)  \r\n        *    n = -------------------- \r\n        *           b0 + eOfB*a0*P\r\n        */\r\n        unchecked{\r\n            uint256 numerator = \r\n                (info.a1 * info.b0) -\r\n                    (info.a0 * info.b1);\r\n\r\n            uint256 denominator = \r\n                (info.b0 * 1e18) + \r\n                    (info.eOfB * info.a0 / info.precisionA * p);\r\n\r\n            return numerator * 1e18 / denominator;\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @notice\r\n    *   Internal function used to calculate the _nb: the amount of b to sell to a\r\n    *       and nc : the amount of c to sell to a. For the swapTwoToOne() function.\r\n    *   The calculations for both b and c use the same denominator and the numerator is the same consturction but the variables for b or c are swapped \r\n    * @param info, RebalanceInfo stuct\r\n    * @return _nb, the amount of b to sell to a in terms of b\r\n    * @return nc, the amount of c to sell to a in terms of c \r\n    */\r\n    function getNbAndNc(RebalanceInfo memory info) public pure returns(uint256 nb, uint256 nc) {\r\n        /*\r\n        *          a0*x1 + y0*eOfy*x1 - a1*x0 - y1*eOfy*x0\r\n        *   nx = ------------------------------------------\r\n        *               a0 + eOfc*c0 + b0*eOfb\r\n        */\r\n        unchecked {\r\n            uint256 numeratorB = \r\n                (info.a0 * info.b1) + \r\n                    (info.c0 * info.eOfC * info.b1 / info.precisionC) - \r\n                        (info.a1 * info.b0) - \r\n                            (info.c1 * info.eOfC * info.b0 / info.precisionC);\r\n\r\n            uint256 numeratorC = \r\n                (info.a0 * info.c1) + \r\n                    (info.b0 * info.eOfB * info.c1 / info.precisionB) - \r\n                        (info.a1 * info.c0) - \r\n                            (info.b1 * info.eOfB * info.c0 / info.precisionB);\r\n\r\n            uint256 denominator = \r\n                info.a0 + \r\n                    (info.eOfC * info.c0 / info.precisionC) + \r\n                        (info.b0 * info.eOfB / info.precisionB);\r\n\r\n            nb = numeratorB / denominator;\r\n            nc = numeratorC / denominator;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function available publicly estimating the balancing ratios for the tokens in the form:\r\n     * ratio = currentBalance / invested Balance\r\n     * @param startingA, the invested balance of TokenA\r\n     * @param currentA, current balance of tokenA\r\n     * @param startingB, the invested balance of TokenB\r\n     * @param currentB, current balance of tokenB\r\n     * @param startingC, the invested balance of TokenC\r\n     * @param currentC, current balance of tokenC\r\n     * @return _a, _b _c, ratios for tokenA tokenB and tokenC. Will return 0's if there is nothing invested\r\n     */\r\n    function getRatios(\r\n        uint256 startingA,\r\n        uint256 currentA,\r\n        uint256 startingB,\r\n        uint256 currentB,\r\n        uint256 startingC,\r\n        uint256 currentC\r\n    ) public pure returns (uint256 _a, uint256 _b, uint256 _c) {\r\n        unchecked {\r\n            _a = (currentA * RATIO_PRECISION) / startingA;\r\n            _b = (currentB * RATIO_PRECISION) / startingB;\r\n            _c = (currentC * RATIO_PRECISION) / startingC;\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @notice \r\n    *   Internal function called when a new position has been opened to store the relative weights of each token invested\r\n    *   uses the most recent oracle price to get the dollar value of the amount invested. This is so the rebalance function\r\n    *   can work with different dollar amounts invested upon lp creation\r\n    * @param investedA, the amount of tokenA that was invested\r\n    * @param investedB, the amount of tokenB that was invested\r\n    * @param investedC, the amoun of tokenC that was invested\r\n    * @return, the relative weight for each token expressed as 1e18\r\n    */\r\n    function getWeights(\r\n        uint256 investedA,\r\n        uint256 investedB,\r\n        uint256 investedC\r\n    ) public view returns (uint256 wA, uint256 wB, uint256 wC) {\r\n        ITripod tripod = ITripod(address(this));\r\n        unchecked {\r\n            uint256 adjustedA = getOraclePrice(tripod.tokenA(), investedA);\r\n            uint256 adjustedB = getOraclePrice(tripod.tokenB(), investedB);\r\n            uint256 adjustedC = getOraclePrice(tripod.tokenC(), investedC);\r\n            uint256 total = adjustedA + adjustedB + adjustedC; \r\n                        \r\n            wA = adjustedA * RATIO_PRECISION / total;\r\n            wB = adjustedB * RATIO_PRECISION / total;\r\n            wC = adjustedC * RATIO_PRECISION / total;\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @notice\r\n    *   Returns the oracle adjusted price for a specific token and amount expressed in the oracle terms of 1e8\r\n    *   This uses the chainlink feed Registry and returns in terms of the USD\r\n    * @param _token, the address of the token to get the price for\r\n    * @param _amount, the amount of the token we have\r\n    * @return USD price of the _amount of the token as 1e8\r\n    */\r\n    function getOraclePrice(address _token, uint256 _amount) public view returns(uint256) {\r\n        address token = _token;\r\n        //Adjust if we are using WETH of WBTC for chainlink to work\r\n        if(_token == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) token = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n        if(_token == 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599) token = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\r\n\r\n        (uint80 roundId, int256 price,, uint256 updateTime, uint80 answeredInRound) = IFeedRegistry(0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf).latestRoundData(\r\n                token,\r\n                address(0x0000000000000000000000000000000000000348) // USD\r\n            );\r\n\r\n        require(price > 0 && updateTime != 0 && answeredInRound >= roundId);\r\n        //return the dollar amount to 1e8\r\n        return uint256(price) * _amount / (10 ** IERC20Extended(_token).decimals());\r\n    }\r\n\r\n    /*\r\n    * @notice\r\n    *   Function to be called during harvests that attempts to rebalance all 3 tokens evenly\r\n    *   in comparision to the amounts the started with, i.e. return the same % return\r\n    * @return uint8 that corresponds to what action Tripod should take, 0 means no swaps,\r\n    *   1 means swap one token to the other two and 2 means swap two to the other one\r\n    *   The tokens are returned in order of how they should be swapped\r\n    */\r\n    function rebalance() public view returns(uint8, address, address, address){\r\n        ITripod tripod = ITripod(address(this));\r\n        //We use the tokens struct to cache our variables and avoid stack to deep\r\n        Tokens memory tokens = Tokens(tripod.tokenA(), 0, tripod.tokenB(), 0, tripod.tokenC(), 0);\r\n\r\n        (tokens.ratioA, tokens.ratioB, tokens.ratioC) = getRatios(\r\n                    tripod.invested(tokens.tokenA),\r\n                    tripod.balanceOfA(),\r\n                    tripod.invested(tokens.tokenB),\r\n                    tripod.balanceOfB(),\r\n                    tripod.invested(tokens.tokenC),\r\n                    tripod.balanceOfC()\r\n                );\r\n        \r\n        //If they are all the same or very close we dont need to do anything\r\n        if(isCloseEnough(tokens.ratioA, tokens.ratioB) && isCloseEnough(tokens.ratioB, tokens.ratioC)) {\r\n            //Return a 0 for direction to do nothing\r\n            return(0, tokens.tokenA, tokens.tokenB, tokens.tokenC);\r\n        }\r\n        // Calculate the average ratio. Could be at a loss does not matter here\r\n        uint256 avgRatio;\r\n        unchecked{\r\n            avgRatio = (tokens.ratioA * tripod.investedWeight(tokens.tokenA) + \r\n                            tokens.ratioB * tripod.investedWeight(tokens.tokenB) + \r\n                                tokens.ratioC * tripod.investedWeight(tokens.tokenC)) / \r\n                                    RATIO_PRECISION;\r\n        }\r\n        //If only one is higher than the average ratio, then ratioX - avgRatio is split between the other two in relation to their diffs\r\n        //If two are higher than the average each has its diff traded to the third\r\n        //We know all three cannot be above the avg\r\n        //This flow allows us to keep track of exactly what tokens need to be swapped from and to \r\n        //as well as how much with little extra memory/storage used and a max of 3 if() checks\r\n        if(tokens.ratioA > avgRatio) {\r\n\r\n            if (tokens.ratioB > avgRatio) {\r\n                //Swapping A and B -> C\r\n                return(2, tokens.tokenA, tokens.tokenB, tokens.tokenC);\r\n            } else if (tokens.ratioC > avgRatio) {\r\n                //swapping A and C -> B\r\n                return(2, tokens.tokenA, tokens.tokenC, tokens.tokenB);\r\n            } else {\r\n                //Swapping A -> B and C\r\n                return(1, tokens.tokenA, tokens.tokenB, tokens.tokenC);\r\n            }\r\n            \r\n        } else if (tokens.ratioB > avgRatio) {\r\n            //We know A is below avg so we just need to check C\r\n            if (tokens.ratioC > avgRatio) {\r\n                //Swap B and C -> A\r\n                return(2, tokens.tokenB, tokens.tokenC, tokens.tokenA);\r\n            } else {\r\n                //swapping B -> C and A\r\n                return(1, tokens.tokenB, tokens.tokenA, tokens.tokenC);\r\n            }\r\n\r\n        } else {\r\n            //We know A and B are below so C has to be the only one above the avg\r\n            //swap C -> A and B\r\n            return(1, tokens.tokenC, tokens.tokenA, tokens.tokenB);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @notice\r\n     *  Function estimating the current assets in the tripod, taking into account:\r\n     * - current balance of tokens in the LP\r\n     * - pending rewards from the LP (if any)\r\n     * - hedge profit (if any)\r\n     * - rebalancing of tokens to maintain token ratios\r\n     * @return estimated tokenA tokenB and tokenC balances\r\n     */\r\n    function estimatedTotalAssetsAfterBalance()\r\n        public\r\n        view\r\n        returns (uint256, uint256, uint256)\r\n    {\r\n        ITripod tripod = ITripod(address(this));\r\n        // Current status of tokens in LP (includes potential IL)\r\n        (uint256 _aBalance, uint256 _bBalance, uint256 _cBalance) = tripod.balanceOfTokensInLP();\r\n\r\n        // Add remaining balance in tripod (if any)\r\n        unchecked{\r\n            _aBalance += tripod.balanceOfA();\r\n            _bBalance += tripod.balanceOfB();\r\n            _cBalance += tripod.balanceOfC();\r\n        }\r\n\r\n        // Include rewards (swapping them if not one of the LP tokens)\r\n        uint256[] memory _rewardsPending = tripod.pendingRewards();\r\n        address[] memory _rewardTokens = tripod.getRewardTokens();\r\n        address reward;\r\n        for (uint256 i; i < _rewardsPending.length; ++i) {\r\n            reward = _rewardTokens[i];\r\n            if (reward == tripod.tokenA()) {\r\n                _aBalance += _rewardsPending[i];\r\n            } else if (reward == tripod.tokenB()) {\r\n                _bBalance += _rewardsPending[i];\r\n            } else if (reward == tripod.tokenC()) {\r\n                _cBalance += _rewardsPending[i];\r\n            } else if (_rewardsPending[i] != 0) {\r\n                //If we are using the reference token swap to that otherwise use A\r\n                address swapTo = tripod.usingReference() ? tripod.referenceToken() : tripod.tokenA();\r\n                uint256 outAmount = tripod.quote(\r\n                    reward,\r\n                    swapTo,\r\n                    _rewardsPending[i]\r\n                );\r\n\r\n                if (swapTo == tripod.tokenA()) { \r\n                    _aBalance += outAmount;\r\n                } else if (swapTo == tripod.tokenB()) {\r\n                    _bBalance += outAmount;\r\n                } else if (swapTo == tripod.tokenC()) {\r\n                    _cBalance += outAmount;\r\n                }\r\n            }\r\n        }\r\n        return quoteRebalance(_aBalance, _bBalance, _cBalance);\r\n    }\r\n\r\n    /*\r\n    * @notice \r\n    *    This function is a fucking disaster.\r\n    *    But it works...\r\n    */\r\n    function quoteRebalance(\r\n        uint256 startingA,\r\n        uint256 startingB,\r\n        uint256 startingC\r\n    ) public view returns(uint256, uint256, uint256) {\r\n        ITripod tripod = ITripod(address(this));\r\n        //Use tokens struct to avoid stack to deep error\r\n        Tokens memory tokens = Tokens(tripod.tokenA(), 0, tripod.tokenB(), 0, tripod.tokenC(), 0);\r\n\r\n        //We cannot rebalance with a 0 starting position, should only be applicable if called when everything is 0 so just return\r\n        if(tripod.invested(tokens.tokenA) == 0 || tripod.invested(tokens.tokenB) == 0 || tripod.invested(tokens.tokenC) == 0) {\r\n            return (startingA, startingB, startingC);\r\n        }\r\n\r\n        (tokens.ratioA, tokens.ratioB, tokens.ratioC) = getRatios(\r\n                    tripod.invested(tokens.tokenA),\r\n                    startingA,\r\n                    tripod.invested(tokens.tokenB),\r\n                    startingB,\r\n                    tripod.invested(tokens.tokenC),\r\n                    startingC\r\n                );\r\n        \r\n        //If they are all the same or very close we dont need to do anything\r\n        if(isCloseEnough(tokens.ratioA, tokens.ratioB) && isCloseEnough(tokens.ratioB, tokens.ratioC)) {\r\n            return(startingA, startingB, startingC);\r\n        }\r\n        // Calculate the average ratio. Could be at a loss does not matter here\r\n        uint256 avgRatio;\r\n        unchecked{\r\n            avgRatio = (tokens.ratioA * tripod.investedWeight(tokens.tokenA) + \r\n                            tokens.ratioB * tripod.investedWeight(tokens.tokenB) + \r\n                                tokens.ratioC * tripod.investedWeight(tokens.tokenC)) / \r\n                                    RATIO_PRECISION;\r\n        }\r\n        \r\n        uint256 change0;\r\n        uint256 change1;\r\n        uint256 change2;\r\n        RebalanceInfo memory info;\r\n        //See Rebalance() for explanation\r\n        if(tokens.ratioA > avgRatio) {\r\n            if (tokens.ratioB > avgRatio) {\r\n                //Swapping A and B -> C\r\n                info = RebalanceInfo(0, 0, startingC, 0, startingA, 0, 0, 0, startingB, 0, 0);\r\n                (change0, change1, change2) = \r\n                    _quoteSwapTwoToOne(tripod, info, tokens.tokenA, tokens.tokenB, tokens.tokenC);\r\n                return ((startingA - change0), \r\n                            (startingB - change1), \r\n                                (startingC + change2));\r\n            } else if (tokens.ratioC > avgRatio) {\r\n                //swapping A and C -> B\r\n                info = RebalanceInfo(0, 0, startingB, 0, startingA, 0, 0, 0, startingC, 0, 0);\r\n                (change0, change1, change2) = \r\n                    _quoteSwapTwoToOne(tripod, info, tokens.tokenA, tokens.tokenC, tokens.tokenB);\r\n                return ((startingA - change0), \r\n                            (startingB + change2), \r\n                                (startingC - change1));\r\n            } else {\r\n                //Swapping A -> B and C\r\n                info = RebalanceInfo(0, 0, startingA, 0, startingB, 0, 0, 0, startingC, 0, 0);\r\n                (change0, change1, change2) = \r\n                    _quoteSwapOneToTwo(tripod, info, tokens.tokenA, tokens.tokenB, tokens.tokenC);\r\n                return ((startingA - change0), \r\n                            (startingB + change1), \r\n                                (startingC + change2));\r\n            }\r\n        } else if (tokens.ratioB > avgRatio) {\r\n            //We know A is below avg so we just need to check C\r\n            if (tokens.ratioC > avgRatio) {\r\n                //Swap B and C -> A\r\n                info = RebalanceInfo(0, 0, startingA, 0, startingB, 0, 0, 0, startingC, 0, 0);\r\n                (change0, change1, change2) = \r\n                    _quoteSwapTwoToOne(tripod, info, tokens.tokenB, tokens.tokenC, tokens.tokenA);\r\n                return ((startingA + change2), \r\n                            (startingB - change0), \r\n                                (startingC - change1));\r\n            } else {\r\n                //swapping B -> A and C\r\n                info = RebalanceInfo(0, 0, startingB, 0, startingA, 0, 0, 0, startingC, 0, 0);\r\n                (change0, change1, change2) = \r\n                    _quoteSwapOneToTwo(tripod, info, tokens.tokenB, tokens.tokenA, tokens.tokenC);\r\n                return ((startingA + change1), \r\n                            (startingB - change0), \r\n                                (startingC + change2));\r\n            }\r\n        } else {\r\n            //We know A and B are below so C has to be the only one above the avg\r\n            //swap C -> A and B\r\n            info = RebalanceInfo(0, 0, startingC, 0, startingA, 0, 0, 0, startingB, 0, 0);\r\n            (change0, change1, change2) = \r\n                _quoteSwapOneToTwo(tripod, info, tokens.tokenC, tokens.tokenA, tokens.tokenB);\r\n            return ((startingA + change1), \r\n                        (startingB + change2), \r\n                            (startingC - change0));\r\n        }   \r\n    }\r\n    \r\n    \r\n    /*\r\n     * @notice\r\n     *  Function to be called during mock rebalancing.\r\n     *  This will quote swapping the extra tokens from the one that has returned the highest amount to the other two\r\n     *  in relation to what they need attempting to make everything as equal as possible\r\n     *  will return the absolute changes expected for each token, accounting will take place in parent function\r\n     * @param tripod, the instance of the tripod to use\r\n     * @param info, struct of all needed info OF token addresses and amounts\r\n     * @param toSwapToken, the token we will be swapping from to the other two\r\n     * @param token0Address, address of one of the tokens we are swapping to\r\n     * @param token1Address, address of the second token we are swapping to\r\n     * @return negative change in toSwapToken, positive change for token0, positive change for token1\r\n    */\r\n    function _quoteSwapOneToTwo(\r\n        ITripod tripod,\r\n        RebalanceInfo memory info, \r\n        address toSwapFrom, \r\n        address toSwapTo0, \r\n        address toSwapTo1\r\n    ) internal view returns (uint256 n, uint256 amountOut, uint256 amountOut2) {\r\n        uint256 swapTo0;\r\n        uint256 swapTo1;\r\n\r\n        unchecked {\r\n            uint256 precisionA = 10 ** IERC20Extended(toSwapFrom).decimals();\r\n            \r\n            uint256 p;\r\n\r\n            (n, p) = getNandP(RebalanceInfo({\r\n                precisionA : precisionA,\r\n                a0 : tripod.invested(toSwapFrom),\r\n                a1 : info.a1,\r\n                b0 : tripod.invested(toSwapTo0),\r\n                b1 : info.b1,\r\n                eOfB : tripod.quote(toSwapFrom, toSwapTo0, precisionA),\r\n                precisionB : 0, //Not needed for this calculation\r\n                c0 : tripod.invested(toSwapTo1),\r\n                c1 : info.c1,\r\n                eOfC : tripod.quote(toSwapFrom, toSwapTo1, precisionA),\r\n                precisionC : 0 // Not needed\r\n            }));\r\n\r\n            swapTo0 = n * p / RATIO_PRECISION;\r\n            //To assure we dont sell to much \r\n            swapTo1 = n - swapTo0;\r\n        }\r\n\r\n        amountOut = tripod.quote(\r\n            toSwapFrom, \r\n            toSwapTo0, \r\n            swapTo0\r\n        );\r\n\r\n        amountOut2 = tripod.quote(\r\n            toSwapFrom, \r\n            toSwapTo1, \r\n            swapTo1\r\n        );\r\n    }   \r\n\r\n    /*\r\n     * @notice\r\n     *  Function to be called during mock rebalancing.\r\n     *  This will quote swap the extra tokens from the two that returned raios higher than target return to the other one\r\n     *  in relation to what they gained attempting to make everything as equal as possible\r\n     *  will return the absolute changes expected for each token, accounting will take place in parent function\r\n     * @param tripod, the instance of the tripod to use\r\n     * @param info, struct of all needed info OF token addresses and amounts\r\n     * @param token0Address, address of one of the tokens we are swapping from\r\n     * @param token1Address, address of the second token we are swapping from\r\n     * @param toTokenAddress, address of the token we are swapping to\r\n     * @return negative change for token0, negative change for token1, positive change for toTokenAddress\r\n    */\r\n    function _quoteSwapTwoToOne(\r\n        ITripod tripod,\r\n        RebalanceInfo memory info,\r\n        address token0Address,\r\n        address token1Address,\r\n        address toTokenAddress\r\n    ) internal view returns(uint256, uint256, uint256) {\r\n\r\n        (uint256 toSwapFrom0, uint256 toSwapFrom1) = \r\n            getNbAndNc(RebalanceInfo({\r\n                precisionA : 0, //Not needed\r\n                a0 : tripod.invested(toTokenAddress),\r\n                a1 : info.a1,\r\n                b0 : tripod.invested(token0Address),\r\n                b1 : info.b1,\r\n                eOfB : tripod.quote(token0Address, toTokenAddress, 10 ** IERC20Extended(token0Address).decimals()),\r\n                precisionB : 10 ** IERC20Extended(token0Address).decimals(),\r\n                c0 : tripod.invested(token1Address),\r\n                c1 : info.c1,\r\n                eOfC : tripod.quote(token1Address, toTokenAddress, 10 ** IERC20Extended(token1Address).decimals()),\r\n                precisionC : 10 ** IERC20Extended(token1Address).decimals()\r\n            }));\r\n\r\n        uint256 amountOut = tripod.quote(\r\n            token0Address, \r\n            toTokenAddress, \r\n            toSwapFrom0\r\n        );\r\n\r\n        uint256 amountOut2 = tripod.quote(\r\n            token1Address, \r\n            toTokenAddress, \r\n            toSwapFrom1\r\n        );\r\n\r\n        return (toSwapFrom0, toSwapFrom1, (amountOut + amountOut2));\r\n    }\r\n    \r\n    /*\r\n    * @notice\r\n    *   Function used to determine wether or not the ratios between the 3 tokens are close enough \r\n    *       that it is not worth the cost to do any rebalancing\r\n    * @param ratio0, the current ratio of the first token to check\r\n    * @param ratio1, the current ratio of the second token to check\r\n    * @return boolean repersenting true if the ratios are withen the range to not need to rebalance \r\n    */\r\n    function isCloseEnough(uint256 ratio0, uint256 ratio1) public pure returns(bool) {\r\n        if(ratio0 == 0 && ratio1 == 0) return true;\r\n\r\n        uint256 delta = ratio0 > ratio1 ? ratio0 - ratio1 : ratio1 - ratio0;\r\n        //We wont rebalance withen .01\r\n        uint256 maxRelDelta = ratio1 / 10_000;\r\n\r\n        if (delta < maxRelDelta) return true;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"name\":\"estimatedTotalAssetsAfterBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"precisionA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eOfB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"precisionB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"c0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"c1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eOfC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"precisionC\",\"type\":\"uint256\"}],\"internalType\":\"struct TripodMath.RebalanceInfo\",\"name\":\"info\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"p\",\"type\":\"uint256\"}],\"name\":\"getN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"precisionA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eOfB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"precisionB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"c0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"c1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eOfC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"precisionC\",\"type\":\"uint256\"}],\"internalType\":\"struct TripodMath.RebalanceInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"name\":\"getNandP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"p\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"precisionA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eOfB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"precisionB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"c0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"c1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eOfC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"precisionC\",\"type\":\"uint256\"}],\"internalType\":\"struct TripodMath.RebalanceInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"name\":\"getNbAndNc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nc\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getOraclePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"precisionA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eOfB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"precisionB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"c0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"c1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eOfC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"precisionC\",\"type\":\"uint256\"}],\"internalType\":\"struct TripodMath.RebalanceInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"name\":\"getP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"p\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startingA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentC\",\"type\":\"uint256\"}],\"name\":\"getRatios\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_b\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_c\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"investedA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investedB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investedC\",\"type\":\"uint256\"}],\"name\":\"getWeights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wC\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio1\",\"type\":\"uint256\"}],\"name\":\"isCloseEnough\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startingA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingC\",\"type\":\"uint256\"}],\"name\":\"quoteRebalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalance\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TripodMath","CompilerVersion":"v0.8.12+commit.f00d7308","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6299b99a304f015ea7af1af30ebee3531f1e9f257f14ea683ac21317a112cde5"}]