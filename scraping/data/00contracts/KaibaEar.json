[{"SourceCode":"/*\r\n\r\n /$$   /$$           /$$ /$$                 /$$$$$$$$                              \r\n| $$  /$$/          |__/| $$                | $$_____/                              \r\n| $$ /$$/   /$$$$$$  /$$| $$$$$$$   /$$$$$$ | $$        /$$$$$$   /$$$$$$  /$$$$$$$ \r\n| $$$$$/   |____  $$| $$| $$__  $$ |____  $$| $$$$$    |____  $$ /$$__  $$| $$__  $$\r\n| $$  $$    /$$$$$$$| $$| $$  \\ $$  /$$$$$$$| $$__/     /$$$$$$$| $$  \\__/| $$  \\ $$\r\n| $$\\  $$  /$$__  $$| $$| $$  | $$ /$$__  $$| $$       /$$__  $$| $$      | $$  | $$\r\n| $$ \\  $$|  $$$$$$$| $$| $$$$$$$/|  $$$$$$$| $$$$$$$$|  $$$$$$$| $$      | $$  | $$\r\n|__/  \\__/ \\_______/|__/|_______/  \\_______/|________/ \\_______/|__/      |__/  |__/\r\n                                                                                                                                                                    \r\n                                                                            \r\n               .-'''''-.\r\n             .'         `.\r\n            :             :\r\n           :               :\r\n           :      _/|      :\r\n            :   =/_/      :\r\n             `._/ |     .'\r\n          (   /  ,|...-'\r\n           \\_/^\\/||__\r\n        _/~  `\"\"~`\"` \\_\r\n     __/  -'/  `-._ `\\_\\__\r\n   /     /-'`  `\\   \\  \\-.\\\r\n\r\n*/\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface IUniswapV2Pair {\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  function name() external pure returns (string memory);\r\n  function symbol() external pure returns (string memory);\r\n  function decimals() external pure returns (uint8);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address owner) external view returns (uint);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n  function nonces(address owner) external view returns (uint);\r\n\r\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n  event Mint(address indexed sender, uint amount0, uint amount1);\r\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n  event Swap(\r\n      address indexed sender,\r\n      uint amount0In,\r\n      uint amount1In,\r\n      uint amount0Out,\r\n      uint amount1Out,\r\n      address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n  function factory() external view returns (address);\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function price0CumulativeLast() external view returns (uint);\r\n  function price1CumulativeLast() external view returns (uint);\r\n  function kLast() external view returns (uint);\r\n\r\n  function mint(address to) external returns (uint liquidity);\r\n  function burn(address to) external returns (uint amount0, uint amount1);\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n  function skim(address to) external;\r\n  function sync() external;\r\n}\r\ninterface IUniswapV2Router01 {\r\n  function factory() external pure returns (address);\r\n  function WETH() external pure returns (address);\r\n\r\n  function addLiquidity(\r\n      address tokenA,\r\n      address tokenB,\r\n      uint amountADesired,\r\n      uint amountBDesired,\r\n      uint amountAMin,\r\n      uint amountBMin,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint amountA, uint amountB, uint liquidity);\r\n  function addLiquidityETH(\r\n      address token,\r\n      uint amountTokenDesired,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline\r\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n  function removeLiquidity(\r\n      address tokenA,\r\n      address tokenB,\r\n      uint liquidity,\r\n      uint amountAMin,\r\n      uint amountBMin,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint amountA, uint amountB);\r\n  function removeLiquidityETH(\r\n      address token,\r\n      uint liquidity,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint amountToken, uint amountETH);\r\n  function removeLiquidityWithPermit(\r\n      address tokenA,\r\n      address tokenB,\r\n      uint liquidity,\r\n      uint amountAMin,\r\n      uint amountBMin,\r\n      address to,\r\n      uint deadline,\r\n      bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountA, uint amountB);\r\n  function removeLiquidityETHWithPermit(\r\n      address token,\r\n      uint liquidity,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline,\r\n      bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountToken, uint amountETH);\r\n  function swapExactTokensForTokens(\r\n      uint amountIn,\r\n      uint amountOutMin,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapTokensForExactTokens(\r\n      uint amountOut,\r\n      uint amountInMax,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n      external\r\n      payable\r\n      returns (uint[] memory amounts);\r\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n      external\r\n      returns (uint[] memory amounts);\r\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n      external\r\n      returns (uint[] memory amounts);\r\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n      external\r\n      payable\r\n      returns (uint[] memory amounts);\r\n\r\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\ninterface IUniswapV2Factory {\r\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n  function allPairs(uint) external view returns (address pair);\r\n  function allPairsLength() external view returns (uint);\r\n\r\n  function feeTo() external view returns (address);\r\n  function feeToSetter() external view returns (address);\r\n\r\n  function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\ninterface ERC20 {\r\n    function decimals() external view returns(uint);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface ERC20RewardToken is ERC20 {\r\n    function mint_rewards(uint256 qty, address receiver) external;\r\n\r\n    function burn_tokens(uint256 qty, address burned) external;\r\n}\r\n\r\n\r\ncontract protected {\r\n    mapping(address => bool) is_auth;\r\n\r\n    function is_it_auth(address addy) public view returns (bool) {\r\n        return is_auth[addy];\r\n    }\r\n\r\n    function set_is_auth(address addy, bool booly) public onlyAuth {\r\n        is_auth[addy] = booly;\r\n    }\r\n\r\n    modifier onlyAuth() {\r\n        require(is_auth[msg.sender] || msg.sender == owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    address owner;\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    bool locked;\r\n    modifier safe() {\r\n        require(!locked, \"reentrant\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n\r\ncontract KaibaEarn is protected {\r\n    string public name = \"Kaiba Earn\";\r\n\r\n    // Variable to get the right rewards\r\n    uint32 year_divisor = 1000000000;\r\n\r\n    // create 2 state variables\r\n    address public Kaiba = 0xF2210f65235c2FB391aB8650520237E6378e5C5A;\r\n    address public Fang = 0x988FC5E37281F6c165886Db96B3FdD2f61E6Bb3F;\r\n\r\n    address public router_address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address public factory_address;\r\n    IUniswapV2Router02 router;\r\n\r\n    uint32 public year = 2252571;\r\n    uint32 public day = 1 days;\r\n    uint32 public week = 7 days;\r\n    uint32 public month = 30 days;\r\n\r\n    constructor(address[] memory _authorized) {\r\n        /// @notice initial authorized addresses\r\n        if(_authorized.length > 0 && _authorized.length < 4) {\r\n            for(uint16 init; init < _authorized.length; init++) {\r\n                is_auth[_authorized[init]] = true;\r\n            }\r\n        }\r\n        owner = msg.sender;\r\n        is_auth[owner] = true;\r\n        name = \"Kaiba Earn\";\r\n        router = IUniswapV2Router02(router_address);\r\n        factory_address = router.factory();\r\n    }\r\n\r\n    ////////////////////////////////\r\n    ///////// Struct Stuff /////////\r\n    ////////////////////////////////\r\n\r\n    struct STAKE {\r\n        bool active;\r\n        address token_staked;\r\n        address token_reward;\r\n        uint128 quantity;\r\n        uint128 start_time;\r\n        uint128 last_retrieved;\r\n        uint128 total_earned;\r\n        uint128 total_withdraw;\r\n        uint128 unlock_time;\r\n        uint128 time_period;\r\n    }\r\n\r\n    struct STAKER {\r\n        mapping(uint96 => STAKE) stake;\r\n        uint96 last_id;\r\n        uint[] closed_pools;\r\n    }\r\n\r\n    mapping(address => STAKER) public staker;\r\n\r\n    struct STAKABLE {\r\n        bool enabled;\r\n        bool is_mintable;\r\n        uint128 unlocked_rewards;\r\n        address token_reward;\r\n        mapping(uint128 => bool) allowed_rewards;\r\n        mapping(uint128 => uint128) timed_rewards;\r\n        mapping(address => uint128) pools;\r\n        address[] all_stakeholders;\r\n        uint128 balance_unlocked;\r\n        uint128 balance_locked;\r\n        uint128 balance;\r\n    }\r\n\r\n    mapping(address => STAKABLE) public stakable;\r\n\r\n    ////////////////////////////////\r\n    ////////// View Stuff //////////\r\n    ////////////////////////////////\r\n\r\n    function get_token_farms_statistics(address token) public view  returns(address[] memory stakeholders,\r\n                                                                            uint balance,\r\n                                                                            uint unlocked,\r\n                                                                            uint locked,\r\n                                                                            bool mintable){\r\n        require(stakable[token].enabled, \"Not enabled\");\r\n        return (\r\n            stakable[token].all_stakeholders,\r\n            stakable[token].balance,\r\n            stakable[token].balance_unlocked,\r\n            stakable[token].balance_locked,\r\n            stakable[token].is_mintable\r\n        );\r\n    }\r\n\r\n    function get_stakable_token(address token)\r\n        public\r\n        view\r\n        returns (\r\n            bool enabled,\r\n            uint256 unlocked,\r\n            uint256 amount_in\r\n        )\r\n    {\r\n        if (!stakable[token].enabled) {\r\n            return (false, 0, 0);\r\n        } else {\r\n            return (\r\n                true,\r\n                stakable[token].unlocked_rewards,\r\n                stakable[token].balance\r\n            );\r\n        }\r\n    }\r\n\r\n    function get_single_pool(address actor, uint96 pool)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 quantity,\r\n            uint256 unlock_block,\r\n            uint256 start_block\r\n        )\r\n    {\r\n        require(staker[actor].stake[pool].active, \"Inactive\");\r\n\r\n        return (\r\n            staker[actor].stake[pool].quantity,\r\n            staker[actor].stake[pool].unlock_time,\r\n            staker[actor].stake[pool].start_time\r\n        );\r\n    }\r\n\r\n    function get_reward_on_pool(address actor, uint96 pool, bool yearly)\r\n        public\r\n        view\r\n        returns (uint128 reward)\r\n    {\r\n        require(staker[actor].stake[pool].active, \"Inactive\");\r\n\r\n        uint128 local_pool_amount = staker[actor].stake[pool].quantity;\r\n        uint128 local_time_period = staker[actor].stake[pool].time_period;\r\n        address local_token_staked = staker[actor].stake[pool].token_staked;\r\n        uint local_time_passed;\r\n        if(yearly) {\r\n            local_time_passed = 365 days;\r\n        } else {\r\n            local_time_passed = block.timestamp -\r\n            staker[actor].stake[pool].start_time;\r\n        }\r\n        uint128 local_total_pool = stakable[local_token_staked].balance;\r\n        uint128 local_reward_timed;\r\n        if (\r\n            !(stakable[local_token_staked].timed_rewards[local_time_period] ==\r\n                0)\r\n        ) {\r\n            local_reward_timed = stakable[local_token_staked].timed_rewards[\r\n                local_time_period\r\n            ];\r\n        } else {\r\n            local_reward_timed = stakable[local_token_staked].unlocked_rewards;\r\n        }\r\n        /// @notice Multiplying the staked quantity with the part on an year staked time;\r\n        ///         Dividng this for the total of the pool.\r\n        ///         AKA: staked * (reward_in_a_year * part_of_time_on_a_year) / total_pool;\r\n        uint128 local_reward = uint128(((local_pool_amount *\r\n            ((local_reward_timed * ((local_time_passed * 1000000) / year)))) /\r\n            year_divisor) / local_total_pool);\r\n        /// @notice Exclude already withdrawn tokens\r\n        uint128 local_reward_adjusted = local_reward -\r\n            staker[msg.sender].stake[pool].total_withdraw;\r\n        return local_reward_adjusted;\r\n    }\r\n\r\n    function get_reward_yearly_timed(address token, uint96 locktime) public view returns(uint) {\r\n        uint256 local_reward_timed;\r\n        if (\r\n            !(stakable[token].timed_rewards[locktime] ==\r\n                0)\r\n        ) {\r\n            local_reward_timed = stakable[token].timed_rewards[\r\n                locktime\r\n            ];\r\n        } else {\r\n            local_reward_timed = stakable[token].unlocked_rewards;\r\n        }\r\n\r\n        return local_reward_timed;\r\n    }\r\n\r\n    function get_apy(address staked, address rewarded, uint staked_amount, uint rewarded_amount) \r\n                        public view returns(uint16 current_apy) {\r\n\r\n        /// @dev Get the price in ETH of the two tokens\r\n        IUniswapV2Factory factory = IUniswapV2Factory(factory_address);\r\n        address staked_pair_address = factory.getPair(staked, router.WETH());\r\n        address rewarded_pair_address = factory.getPair(rewarded, router.WETH());\r\n        uint staked_price = getTokenPrice(staked_pair_address, staked_amount);\r\n        uint rewarded_price = getTokenPrice(rewarded_pair_address, rewarded_amount);\r\n\r\n        /// @dev Get the values of deposited tokens and expected yearly reward\r\n        uint staked_value = staked_amount * staked_price;\r\n        uint rewarded_value = rewarded_amount * rewarded_price;\r\n\r\n        /// @dev Calculate APY with the values we extracted\r\n        uint16 apy = uint16((rewarded_value * 100) / staked_value);\r\n\r\n        return apy;\r\n\r\n    }\r\n\r\n        \r\n    function getTokenPrice(address pairAddress, uint amount) public view returns(uint)\r\n        {\r\n            IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\r\n            ERC20 token1 = ERC20(pair.token1());\r\n        \r\n        \r\n            (uint Res0, uint Res1,) = pair.getReserves();\r\n\r\n            // decimals\r\n            uint res0 = Res0*(10**token1.decimals());\r\n            return((amount*res0)/Res1); // return amount of token0 needed to buy token1\r\n        }\r\n\r\n\r\n    function get_staker(address stakeholder) public view returns(uint pools, uint[] memory closed) {\r\n        return (staker[stakeholder].last_id, staker[stakeholder].closed_pools);\r\n    }\r\n\r\n    ////////////////////////////////\r\n    ///////// Write Stuff //////////\r\n    ////////////////////////////////\r\n\r\n    function stake_token(\r\n        address token,\r\n        uint128 amount,\r\n        uint256 timelock\r\n    ) public safe {\r\n        ERC20 erc_token = ERC20(token);\r\n        require(\r\n            erc_token.allowance(msg.sender, address(this)) >= amount,\r\n            \"Allowance\"\r\n        );\r\n        require(stakable[token].enabled, \"Not stakable\");\r\n        erc_token.transferFrom(msg.sender, address(this), amount);\r\n        uint96 pool_id = staker[msg.sender].last_id;\r\n        staker[msg.sender].last_id += 1;\r\n        staker[msg.sender].stake[pool_id].active = true;\r\n        staker[msg.sender].stake[pool_id].quantity = amount;\r\n        staker[msg.sender].stake[pool_id].token_staked = token;\r\n        staker[msg.sender].stake[pool_id].token_reward = stakable[token]\r\n            .token_reward;\r\n        staker[msg.sender].stake[pool_id].start_time = uint96(block.timestamp);\r\n        staker[msg.sender].stake[pool_id].unlock_time =\r\n            uint128(block.timestamp +\r\n            timelock);\r\n        staker[msg.sender].stake[pool_id].time_period = uint128(timelock);\r\n        /// @notice updating stakable token stats\r\n        stakable[token].balance += amount;\r\n        if (timelock == 0) {\r\n            stakable[token].balance_unlocked += amount;\r\n        } else {\r\n            stakable[token].balance_locked += amount;\r\n        }\r\n    }\r\n\r\n    function withdraw_earnings(uint96 pool) public safe {\r\n        address actor = msg.sender;\r\n        address local_token_staked = staker[actor].stake[pool].token_staked;\r\n        address local_token_rewarded = staker[actor].stake[pool].token_reward;\r\n\r\n        /// @notice no flashloans\r\n\r\n        require(staker[actor].stake[pool].start_time < block.timestamp);\r\n\r\n        /// @notice Authorized addresses can withdraw freely\r\n        if (!is_auth[actor]) {\r\n            require(\r\n                staker[actor].stake[pool].unlock_time < block.timestamp,\r\n                \"Locked\"\r\n            );\r\n        }\r\n\r\n        uint128 rewards = get_reward_on_pool(actor, pool, false);\r\n\r\n        /// @notice Differentiate minting and not minting rewards\r\n        if (stakable[local_token_staked].is_mintable) {\r\n            ERC20RewardToken local_erc_rewarded = ERC20RewardToken(\r\n                local_token_rewarded\r\n            );\r\n            local_erc_rewarded.mint_rewards(rewards, msg.sender);\r\n        } else {\r\n            ERC20 local_erc_rewarded = ERC20(local_token_rewarded);\r\n            require(local_erc_rewarded.balanceOf(address(this)) >= rewards);\r\n            local_erc_rewarded.transfer(msg.sender, rewards);\r\n        }\r\n        /// @notice Update those variables that control the status of the stake\r\n        staker[msg.sender].stake[pool].total_earned += rewards;\r\n        staker[msg.sender].stake[pool].total_withdraw += rewards;\r\n        staker[msg.sender].stake[pool].last_retrieved = uint96(block.timestamp);\r\n    }\r\n\r\n    function unstake(uint96 pool) public safe {\r\n\r\n        /// @notice no flashloans\r\n\r\n        require(staker[msg.sender].stake[pool].start_time < block.timestamp);\r\n\r\n        /// @notice Authorized addresses can withdraw freely\r\n        if (!is_auth[msg.sender]) {\r\n            require(\r\n                staker[msg.sender].stake[pool].unlock_time < block.timestamp,\r\n                \"Locked\"\r\n            );\r\n        }\r\n\r\n        withdraw_earnings(pool);\r\n        ERC20 token = ERC20(staker[msg.sender].stake[pool].token_staked);\r\n        token.transfer(msg.sender, staker[msg.sender].stake[pool].quantity);\r\n        /// @notice Set to zero and disable pool\r\n        staker[msg.sender].stake[pool].quantity = 0;\r\n        staker[msg.sender].stake[pool].active = false;\r\n        staker[msg.sender].closed_pools.push(pool);\r\n    }\r\n\r\n    ////////////////////////////////\r\n    ////////// Admin Stuff /////////\r\n    ////////////////////////////////\r\n\r\n    ///@dev Control the actual level of the available pool in the contract\r\n    function ADMIN_control_supply(address addy, uint128 suppli) public onlyAuth {\r\n        require(ERC20(addy).balanceOf(address(this)) >= suppli, \"Not enough tokens\");\r\n        stakable[addy].balance = suppli;\r\n    }\r\n\r\n    function ADMIN_control_pool(address addy, uint96 id,\r\n                            bool active, address token_staked, address token_reward,\r\n                            uint128 quantity, uint128 start_time, uint128 last_retrieved, uint128 total_earned,\r\n                            uint128 total_withdraw, uint128 unlock_time, uint128 time_period) public onlyAuth \r\n    {\r\n        uint128 old_stake = staker[addy].stake[id].quantity;\r\n\r\n        staker[addy].stake[id].active = active;\r\n        staker[addy].stake[id].token_staked = token_staked;\r\n        staker[addy].stake[id].token_reward = token_reward;\r\n        staker[addy].stake[id].quantity = quantity;\r\n        staker[addy].stake[id].start_time = start_time;\r\n        staker[addy].stake[id].last_retrieved = last_retrieved;\r\n        staker[addy].stake[id].total_earned = total_earned;\r\n        staker[addy].stake[id].total_withdraw = total_withdraw;\r\n        staker[addy].stake[id].unlock_time = unlock_time;\r\n        staker[addy].stake[id].time_period = time_period;\r\n\r\n        stakable[token_staked].balance += quantity;\r\n        stakable[token_staked].balance -= old_stake;\r\n    }\r\n\r\n    function ADMIN_set_auth(address addy, bool booly) public onlyAuth {\r\n        is_auth[addy] = booly;\r\n    }\r\n\r\n    function ADMIN_set_token_state(address token, bool _stakable)\r\n        public\r\n        onlyAuth\r\n    {\r\n        stakable[token].enabled = _stakable;\r\n    }\r\n\r\n    function ADMIN_configure_token_stake(\r\n        address token,\r\n        bool _stakable,\r\n        bool mintable,\r\n        uint128 unlocked_reward,\r\n        address token_given,\r\n        uint128[] calldata times_allowed,\r\n        uint128[] calldata times_reward\r\n    ) public onlyAuth {\r\n        require(stakable[token].enabled);\r\n        stakable[token].enabled = _stakable;\r\n        stakable[token].is_mintable = mintable;\r\n        stakable[token].unlocked_rewards = unlocked_reward;\r\n        stakable[token].token_reward = token_given;\r\n\r\n        /// @notice If specified, assign a different reward value for locked stakings\r\n        if (times_allowed.length > 0) {\r\n            require(\r\n                times_allowed.length == times_reward.length,\r\n                \"Set a reward per time\"\r\n            );\r\n            for (uint256 i; i < times_allowed.length; i++) {\r\n                stakable[token].allowed_rewards[times_allowed[i]] = true;\r\n                stakable[token].timed_rewards[times_allowed[i]] = times_reward[\r\n                    i\r\n                ];\r\n            }\r\n        }\r\n    }\r\n\r\n    ////////////////////////////////\r\n    ///////// Fallbacks ////////////\r\n    ////////////////////////////////\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_authorized\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_stakable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"mintable\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"unlocked_reward\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"token_given\",\"type\":\"address\"},{\"internalType\":\"uint128[]\",\"name\":\"times_allowed\",\"type\":\"uint128[]\"},{\"internalType\":\"uint128[]\",\"name\":\"times_reward\",\"type\":\"uint128[]\"}],\"name\":\"ADMIN_configure_token_stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"id\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token_staked\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_reward\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"quantity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"start_time\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"last_retrieved\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"total_earned\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"total_withdraw\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"unlock_time\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"time_period\",\"type\":\"uint128\"}],\"name\":\"ADMIN_control_pool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"suppli\",\"type\":\"uint128\"}],\"name\":\"ADMIN_control_supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"ADMIN_set_auth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_stakable\",\"type\":\"bool\"}],\"name\":\"ADMIN_set_token_state\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Fang\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Kaiba\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"day\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staked\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewarded\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"staked_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewarded_amount\",\"type\":\"uint256\"}],\"name\":\"get_apy\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"current_apy\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"actor\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"pool\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"yearly\",\"type\":\"bool\"}],\"name\":\"get_reward_on_pool\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"reward\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"locktime\",\"type\":\"uint96\"}],\"name\":\"get_reward_yearly_timed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"actor\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"pool\",\"type\":\"uint96\"}],\"name\":\"get_single_pool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlock_block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start_block\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"get_stakable_token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"unlocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_in\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeholder\",\"type\":\"address\"}],\"name\":\"get_staker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pools\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"closed\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"get_token_farms_statistics\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"stakeholders\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"locked\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"mintable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"is_it_auth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"month\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"set_is_auth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"is_mintable\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"unlocked_rewards\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"token_reward\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"balance_unlocked\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"balance_locked\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"balance\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"}],\"name\":\"stake_token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"staker\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"last_id\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"pool\",\"type\":\"uint96\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"week\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"pool\",\"type\":\"uint96\"}],\"name\":\"withdraw_earnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"year\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"KaibaEarn","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000005c61a31d854e00c7446598898c67cc27744f8b88","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e49dc034d4f369f34be3359071ac628f51820796c46fc4ad8c24665a248cae19"}]