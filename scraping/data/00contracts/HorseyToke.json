[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: ..\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: ..\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n}\r\n\r\n// File: ..\\openzeppelin-solidity\\contracts\\lifecycle\\Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts\\HorseyExchange.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic {\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n}\r\n\r\n/**\r\n    @dev HorseyExchange contract - handles horsey market exchange which\r\n    includes the following set of functions:\r\n    1. Deposit to Exchange\r\n    2. Cancel sale\r\n    3. Purchase token\r\n**/\r\ncontract HorseyExchange is Pausable { //also Ownable\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event HorseyDeposit(uint256 tokenId, uint256 price);\r\n    event SaleCanceled(uint256 tokenId);\r\n    event HorseyPurchased(uint256 tokenId, address newOwner, uint256 totalToPay);\r\n\r\n    /// @dev Fee applied to market maker - measured as percentage\r\n    uint256 public marketMakerFee = 3;\r\n\r\n    /// @dev Amount collected in fees\r\n    uint256 collectedFees = 0;\r\n\r\n    /// @dev  RoyalStables TOKEN\r\n    ERC721Basic public token;\r\n\r\n    /**\r\n        @dev used to store the price and the owner address of a token on sale\r\n    */\r\n    struct SaleData {\r\n        uint256 price;\r\n        address owner;\r\n    }\r\n\r\n    /// @dev Market spec to lookup price and original owner based on token id\r\n    mapping (uint256 => SaleData) market;\r\n\r\n    /// @dev mapping of current tokens on market by owner\r\n    mapping (address => uint256[]) userBarn;\r\n\r\n    /// @dev initialize\r\n    constructor() Pausable() public {\r\n    }\r\n\r\n    /**\r\n        @dev Since the exchange requires the horsey contract and horsey contract\r\n            requires exchange address, we cant initialize both of them in constructors\r\n        @param _token Address of the stables contract\r\n    */\r\n    function setStables(address _token) external\r\n    onlyOwner()\r\n    {\r\n        require(address(_token) != 0,\"Address of token is zero\");\r\n        token = ERC721Basic(_token);\r\n    }\r\n\r\n    /**\r\n        @dev Allows the owner to change market fees\r\n        @param fees The new fees to apply (can be zero)\r\n    */\r\n    function setMarketFees(uint256 fees) external\r\n    onlyOwner()\r\n    {\r\n        marketMakerFee = fees;\r\n    }\r\n\r\n    /// @return the tokens on sale based on the user address\r\n    function getTokensOnSale(address user) external view returns(uint256[]) {\r\n        return userBarn[user];\r\n    }\r\n\r\n    /// @return the token price with the fees\r\n    function getTokenPrice(uint256 tokenId) public view\r\n    isOnMarket(tokenId) returns (uint256) {\r\n        return market[tokenId].price + (market[tokenId].price.div(100).mul(marketMakerFee));\r\n    }\r\n\r\n    /**\r\n        @dev User sends token to sell to exchange - at this point the exchange contract takes\r\n            ownership, but will map token ownership back to owner for auotmated withdraw on\r\n            cancel - requires that user is the rightful owner and is not\r\n            asking for a null price\r\n    */\r\n    function depositToExchange(uint256 tokenId, uint256 price) external\r\n    whenNotPaused()\r\n    isTokenOwner(tokenId)\r\n    nonZeroPrice(price)\r\n    tokenAvailable() {\r\n        require(token.getApproved(tokenId) == address(this),\"Exchange is not allowed to transfer\");\r\n        //Transfers token from depositee to exchange (contract address)\r\n        token.transferFrom(msg.sender, address(this), tokenId);\r\n        \r\n        //add the token to the market\r\n        market[tokenId] = SaleData(price,msg.sender);\r\n\r\n        //Add token to exchange map - tracking by owner of all tokens\r\n        userBarn[msg.sender].push(tokenId);\r\n\r\n        emit HorseyDeposit(tokenId, price);\r\n    }\r\n\r\n    /**\r\n        @dev Allows true owner of token to cancel sale at anytime\r\n        @param tokenId ID of the token to remove from the market\r\n        @return true if user still has tokens for sale\r\n    */\r\n    function cancelSale(uint256 tokenId) external \r\n    whenNotPaused()\r\n    originalOwnerOf(tokenId) \r\n    tokenAvailable() returns (bool) {\r\n        //throws on fail - transfers token from exchange back to original owner\r\n        token.transferFrom(address(this),msg.sender,tokenId);\r\n        \r\n        //Reset token on market - remove\r\n        delete market[tokenId];\r\n\r\n        //Reset barn tracker for user\r\n        _removeTokenFromBarn(tokenId, msg.sender);\r\n\r\n        emit SaleCanceled(tokenId);\r\n\r\n        //Return true if this user is still 'active' within the exchange\r\n        //This will help with client side actions\r\n        return userBarn[msg.sender].length > 0;\r\n    }\r\n\r\n    /**\r\n        @dev Performs the purchase of a token that is present on the market - this includes checking that the\r\n            proper amount is sent + appliced fee, updating seller's balance, updated collected fees and\r\n            transfering token to buyer\r\n            Only market tokens can be purchased\r\n        @param tokenId ID of the token we wish to purchase\r\n    */\r\n    function purchaseToken(uint256 tokenId) external payable \r\n    whenNotPaused()\r\n    isOnMarket(tokenId) \r\n    tokenAvailable()\r\n    notOriginalOwnerOf(tokenId)\r\n    {\r\n        //Did the sender accidently pay over? - if so track the amount over\r\n        uint256 totalToPay = getTokenPrice(tokenId);\r\n        require(msg.value >= totalToPay, \"Not paying enough\");\r\n\r\n        //fetch this tokens sale data\r\n        SaleData memory sale = market[tokenId];\r\n\r\n        //Add to collected fee amount payable to DEVS\r\n        collectedFees += totalToPay - sale.price;\r\n\r\n        //pay the seller\r\n        sale.owner.transfer(sale.price);\r\n\r\n        //Reset barn tracker for user\r\n        _removeTokenFromBarn(tokenId,  sale.owner);\r\n\r\n        //Reset token on market - remove\r\n        delete market[tokenId];\r\n\r\n        //Transfer the ERC721 to the buyer - we leave the sale amount\r\n        //to be withdrawn by the user (transferred from exchange)\r\n        token.transferFrom(address(this), msg.sender, tokenId);\r\n\r\n        //Return over paid amount to sender if necessary\r\n        if(msg.value > totalToPay) //overpaid\r\n        {\r\n            msg.sender.transfer(msg.value.sub(totalToPay));\r\n        }\r\n\r\n        emit HorseyPurchased(tokenId, msg.sender, totalToPay);\r\n    }\r\n\r\n    /// @dev Transfers the collected fees to the owner\r\n    function withdraw() external\r\n    onlyOwner()\r\n    {\r\n        assert(collectedFees <= address(this).balance);\r\n        owner.transfer(collectedFees);\r\n        collectedFees = 0;\r\n    }\r\n\r\n    /**\r\n        @dev Internal function to remove a token from the users barn array\r\n        @param tokenId ID of the token to remove\r\n        @param barnAddress Address of the user selling tokens\r\n    */\r\n    function _removeTokenFromBarn(uint tokenId, address barnAddress)  internal {\r\n        uint256[] storage barnArray = userBarn[barnAddress];\r\n        require(barnArray.length > 0,\"No tokens to remove\");\r\n        int index = _indexOf(tokenId, barnArray);\r\n        require(index >= 0, \"Token not found in barn\");\r\n\r\n        // Shift entire array :(\r\n        for (uint256 i = uint256(index); i<barnArray.length-1; i++){\r\n            barnArray[i] = barnArray[i+1];\r\n        }\r\n\r\n        // Remove element, update length, return array\r\n        // this should be enough since https://ethereum.stackexchange.com/questions/1527/how-to-delete-an-element-at-a-certain-index-in-an-array\r\n        barnArray.length--;\r\n    }\r\n\r\n    /**\r\n        @dev Helper function which stores in memory an array which is passed in, and\r\n        @param item element we are looking for\r\n        @param array the array to look into\r\n        @return the index of the item of interest\r\n    */\r\n    function _indexOf(uint item, uint256[] memory array) internal pure returns (int256){\r\n\r\n        //Iterate over array to find indexOf(token)\r\n        for(uint256 i = 0; i < array.length; i++){\r\n            if(array[i] == item){\r\n                return int256(i);\r\n            }\r\n        }\r\n\r\n        //Item not found\r\n        return -1;\r\n    }\r\n\r\n    /// @dev requires token to be on the market = current owner is exchange\r\n    modifier isOnMarket(uint256 tokenId) {\r\n        require(token.ownerOf(tokenId) == address(this),\"Token not on market\");\r\n        _;\r\n    }\r\n    \r\n    /// @dev Is the user the owner of this token?\r\n    modifier isTokenOwner(uint256 tokenId) {\r\n        require(token.ownerOf(tokenId) == msg.sender,\"Not tokens owner\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Is this the original owner of the token - at exchange level\r\n    modifier originalOwnerOf(uint256 tokenId) {\r\n        require(market[tokenId].owner == msg.sender,\"Not the original owner of\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Is this the original owner of the token - at exchange level\r\n    modifier notOriginalOwnerOf(uint256 tokenId) {\r\n        require(market[tokenId].owner != msg.sender,\"Is the original owner\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Is a nonzero price being sent?\r\n    modifier nonZeroPrice(uint256 price){\r\n        require(price > 0,\"Price is zero\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Do we have a token address\r\n    modifier tokenAvailable(){\r\n        require(address(token) != 0,\"Token address not set\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts\\EthorseHelpers.sol\r\n\r\ncontract BettingControllerInterface {\r\n    address public owner;\r\n}\r\n/**\r\n    @title Race contract - used for linking ethorse Race struct \r\n    @dev This interface is losely based on ethorse race contract\r\n*/\r\ncontract EthorseRace {\r\n\r\n    //Encapsulation of racing information \r\n    struct chronus_info {\r\n        bool  betting_open; // boolean: check if betting is open\r\n        bool  race_start; //boolean: check if race has started\r\n        bool  race_end; //boolean: check if race has ended\r\n        bool  voided_bet; //boolean: check if race has been voided\r\n        uint32  starting_time; // timestamp of when the race starts\r\n        uint32  betting_duration;\r\n        uint32  race_duration; // duration of the race\r\n        uint32 voided_timestamp;\r\n    }\r\n\r\n    address public owner;\r\n    \r\n    //Point to racing information\r\n    chronus_info public chronus;\r\n\r\n    //Coin index mapping to flag - true if index is winner\r\n    mapping (bytes32 => bool) public winner_horse;\r\n    /*\r\n            // exposing the coin pool details for DApp\r\n    function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint) {\r\n        return (coinIndex[index].total, coinIndex[index].pre, coinIndex[index].post, coinIndex[index].price_check, voterIndex[candidate].bets[index]);\r\n    }\r\n    */\r\n    // exposing the coin pool details for DApp\r\n    function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint);\r\n}\r\n\r\n/**\r\n    @title API contract - used to connect with Race contract and \r\n        encapsulate race information for token inidices and winner\r\n        checking.\r\n*/\r\ncontract EthorseHelpers {\r\n\r\n    /// @dev Convert all symbols to bytes array\r\n    bytes32[] public all_horses = [bytes32(\"BTC\"),bytes32(\"ETH\"),bytes32(\"LTC\")];\r\n    mapping(address => bool) private _legitOwners;\r\n\r\n    /// @dev Used to add new symbol to the bytes array \r\n    function _addHorse(bytes32 newHorse) internal {\r\n        all_horses.push(newHorse);\r\n    }\r\n\r\n    function _addLegitOwner(address newOwner) internal\r\n    {\r\n        _legitOwners[newOwner] = true;\r\n    }\r\n\r\n    function getall_horsesCount() public view returns(uint) {\r\n        return all_horses.length;\r\n    }\r\n\r\n    /**\r\n        @param raceAddress - address of this race\r\n        @param eth_address - user's ethereum wallet address\r\n        @return true if user is winner + name of the winning horse (LTC,BTC,ETH,...)\r\n    */\r\n    function _isWinnerOf(address raceAddress, address eth_address) internal view returns (bool,bytes32)\r\n    {\r\n        //acquire race, fails if doesnt exist\r\n        EthorseRace race = EthorseRace(raceAddress);\r\n        //acquire races betting controller\r\n        BettingControllerInterface bc = BettingControllerInterface(race.owner());\r\n        //make sure the betting controllers owner is in the legit list given by devs\r\n        require(_legitOwners[bc.owner()]);\r\n        //acquire chronus\r\n        bool  voided_bet; //boolean: check if race has been voided\r\n        bool  race_end; //boolean: check if race has ended\r\n        (,,race_end,voided_bet,,,,) = race.chronus();\r\n\r\n        //cant be winner if race was refunded or didnt end yet\r\n        if(voided_bet || !race_end)\r\n            return (false,bytes32(0));\r\n\r\n        //aquire winner race index\r\n        bytes32 horse;\r\n        bool found = false;\r\n        uint256 arrayLength = all_horses.length;\r\n\r\n        //Iterate over coin symbols to find winner - tie could be possible?\r\n        for(uint256 i = 0; i < arrayLength; i++)\r\n        {\r\n            if(race.winner_horse(all_horses[i])) {\r\n                horse = all_horses[i];\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        //no winner horse? shouldnt happen unless this horse isnt registered\r\n        if(!found)\r\n            return (false,bytes32(0));\r\n\r\n        //check the bet amount of the eth_address on the winner horse\r\n        uint256 bet_amount = 0;\r\n        if(eth_address != address(0)) {\r\n            (,,,, bet_amount) = race.getCoinIndex(horse, eth_address);\r\n        }\r\n        \r\n        //winner if the eth_address had a bet > 0 on the winner horse\r\n        return (bet_amount > 0, horse);\r\n    }\r\n}\r\n\r\n// File: contracts\\HorseyToken.sol\r\n\r\ncontract RoyalStablesInterface {\r\n    \r\n    struct Horsey {\r\n        address race;\r\n        bytes32 dna;\r\n        uint8 feedingCounter;\r\n        uint8 tier;\r\n    }\r\n\r\n    mapping(uint256 => Horsey) public horseys;\r\n    mapping(address => uint32) public carrot_credits;\r\n    mapping(uint256 => string) public names;\r\n    address public master;\r\n\r\n    function getOwnedTokens(address eth_address) public view returns (uint256[]);\r\n    function storeName(uint256 tokenId, string newName) public;\r\n    function storeCarrotsCredit(address client, uint32 amount) public;\r\n    function storeHorsey(address client, uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public;\r\n    function modifyHorsey(uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public;\r\n    function modifyHorseyDna(uint256 tokenId, bytes32 dna) public;\r\n    function modifyHorseyFeedingCounter(uint256 tokenId, uint8 feedingCounter) public;\r\n    function modifyHorseyTier(uint256 tokenId, uint8 tier) public;\r\n    function unstoreHorsey(uint256 tokenId) public;\r\n    function ownerOf(uint256 tokenId) public returns (address);\r\n}\r\n\r\n/**\r\n    @title HorseyToken ERC721 Token\r\n    @dev Horse contract - horse derives fro AccessManager built on top of ERC721 token and uses \r\n    @dev EthorseHelpers and AccessManager\r\n*/\r\ncontract HorseyToken is EthorseHelpers,Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev called when someone claims a token\r\n    event Claimed(address raceAddress, address eth_address, uint256 tokenId);\r\n    \r\n    /// @dev called when someone starts a feeding process\r\n    event Feeding(uint256 tokenId);\r\n\r\n    /// @dev called when someone ends a feeding process\r\n    event ReceivedCarrot(uint256 tokenId, bytes32 newDna);\r\n\r\n    /// @dev called when someone fails to end a feeding on the 255 blocks timer\r\n    event FeedingFailed(uint256 tokenId);\r\n\r\n    /// @dev called when a horsey is renamed\r\n    event HorseyRenamed(uint256 tokenId, string newName);\r\n\r\n    /// @dev called when a horsey is freed for carrots\r\n    event HorseyFreed(uint256 tokenId);\r\n\r\n    /// @dev address of the RoyalStables\r\n    RoyalStablesInterface public stables;\r\n\r\n    ///@dev multiplier applied to carrots received from burning a horsey\r\n    uint8 public carrotsMultiplier = 1;\r\n\r\n    ///@dev multiplier applied to rarity bounds when feeding horsey\r\n    uint8 public rarityMultiplier = 1;\r\n\r\n    ///@dev fee to pay when claiming a token\r\n    uint256 public claimingFee = 0.008 ether;\r\n\r\n    /**\r\n        @dev Holds the necessary data to feed a horsey\r\n            The user has to create begin feeding and wait for the block\r\n            with the feeding transaction to be hashed\r\n            Only then he can stop the feeding\r\n    */\r\n    struct FeedingData {\r\n        uint256 blockNumber;    ///@dev Holds the block number where the feeding began\r\n        uint256 horsey;         ///@dev Holds the horsey id\r\n    }\r\n\r\n    /// @dev Maps a user to his pending feeding\r\n    mapping(address => FeedingData) public pendingFeedings;\r\n\r\n    /// @dev Stores the renaming fees per character a user has to pay upon renaming a horsey\r\n    uint256 public renamingCostsPerChar = 0.001 ether;\r\n\r\n    /**\r\n        @dev Contracts constructor\r\n            Initializes token data\r\n            is pausable,ownable\r\n        @param stablesAddress Address of the official RoyalStables contract\r\n    */\r\n    constructor(address stablesAddress) \r\n    EthorseHelpers() \r\n    Pausable() public {\r\n        stables = RoyalStablesInterface(stablesAddress);\r\n    }\r\n\r\n    /**\r\n        @dev Changes multiplier for rarity on feed\r\n        @param newRarityMultiplier The cost to charge in wei for each character of the name\r\n    */\r\n    function setRarityMultiplier(uint8 newRarityMultiplier) external \r\n    onlyOwner()  {\r\n        rarityMultiplier = newRarityMultiplier;\r\n    }\r\n\r\n    /**\r\n        @dev Sets a new muliplier for freeing a horse\r\n        @param newCarrotsMultiplier the new multiplier for feeding\r\n    */\r\n    function setCarrotsMultiplier(uint8 newCarrotsMultiplier) external \r\n    onlyOwner()  {\r\n        carrotsMultiplier = newCarrotsMultiplier;\r\n    }\r\n\r\n    /**\r\n        @dev Sets a new renaming per character cost in wei\r\n            Any CLevel can call this function\r\n        @param newRenamingCost The cost to charge in wei for each character of the name\r\n    */\r\n    function setRenamingCosts(uint256 newRenamingCost) external \r\n    onlyOwner()  {\r\n        renamingCostsPerChar = newRenamingCost;\r\n    }\r\n\r\n    /**\r\n        @dev Sets a new claiming fee in wei\r\n            Any CLevel can call this function\r\n        @param newClaimingFee The cost to charge in wei for each claimed HRSY\r\n    */\r\n    function setClaimingCosts(uint256 newClaimingFee) external\r\n    onlyOwner()  {\r\n        claimingFee = newClaimingFee;\r\n    }\r\n\r\n    /**\r\n        @dev Allows to add a legit owner address for races validation\r\n        @param newAddress the dev address deploying BettingController to add\r\n    */\r\n    function addLegitDevAddress(address newAddress) external\r\n    onlyOwner() {\r\n        _addLegitOwner(newAddress);\r\n    }\r\n\r\n    /**\r\n        @dev Owner can withdraw the current balance\r\n    */\r\n    function withdraw() external \r\n    onlyOwner()  {\r\n        owner.transfer(address(this).balance); //throws on fail\r\n    }\r\n\r\n    //allows owner to add a horse name to the possible horses list (BTC,ETH,LTC,...)\r\n    /**\r\n        @dev Adds a new horse index to the possible horses list (BTC,ETH,LTC,...)\r\n            This is in case ethorse adds a new coin\r\n            Any CLevel can call this function\r\n        @param newHorse Index of the horse to add (same data type as the original ethorse erc20 contract code)\r\n    */\r\n    function addHorseIndex(bytes32 newHorse) external\r\n    onlyOwner() {\r\n        _addHorse(newHorse);\r\n    }\r\n\r\n    /**\r\n        @dev Gets the complete list of token ids which belongs to an address\r\n        @param eth_address The address you want to lookup owned tokens from\r\n        @return List of all owned by eth_address tokenIds\r\n    */\r\n    function getOwnedTokens(address eth_address) public view returns (uint256[]) {\r\n        return stables.getOwnedTokens(eth_address);\r\n    }\r\n    \r\n    /**\r\n        @dev Allows to check if an eth_address can claim a horsey from this contract\r\n            should we also check if already claimed here?\r\n        @param raceAddress The ethorse race you want to claim from\r\n        @param eth_address The users address you want to claim the token for\r\n        @return True only if eth_address is a winner of the race contract at raceAddress\r\n    */\r\n    function can_claim(address raceAddress, address eth_address) public view returns (bool) {\r\n        bool res;\r\n        (res,) = _isWinnerOf(raceAddress, eth_address);\r\n        return res;\r\n    }\r\n\r\n    /**\r\n        @dev Allows a user to claim a special horsey with the same dna as the race one\r\n            Cant be used on paused\r\n            The sender has to be a winner of the race and must never have claimed a special horsey from this race\r\n        @param raceAddress The race's address\r\n    */\r\n    function claim(address raceAddress) external payable\r\n    costs(claimingFee)\r\n    whenNotPaused()\r\n    {\r\n        //call _isWinnerOf with a 0 address to simply get the winner horse\r\n        bytes32 winner;\r\n        (,winner) = _isWinnerOf(raceAddress, address(0));\r\n        require(winner != bytes32(0),\"Winner is zero\");\r\n        require(can_claim(raceAddress, msg.sender),\"can_claim return false\");\r\n        //require(!exists(id)); should already be checked by mining function\r\n        uint256 id = _generate_special_horsey(raceAddress, msg.sender, winner);\r\n        emit Claimed(raceAddress, msg.sender, id);\r\n    }\r\n\r\n    /**\r\n        @dev Allows a user to give a horsey a name or rename it\r\n            This function is payable and its cost is renamingCostsPerChar * length(newname)\r\n            Cant be called while paused\r\n            If called with too low balance, the modifier will throw\r\n            If called with too much balance, we try to return the remaining funds back\r\n            Upon completion we update all ceos balances, maybe not very efficient?\r\n        @param tokenId ID of the horsey to rename\r\n        @param newName The name to give to the horsey\r\n    */\r\n    function renameHorsey(uint256 tokenId, string newName) external \r\n    whenNotPaused()\r\n    onlyOwnerOf(tokenId) \r\n    costs(renamingCostsPerChar * bytes(newName).length)\r\n    payable {\r\n        uint256 renamingFee = renamingCostsPerChar * bytes(newName).length;\r\n        //Return over paid amount to sender if necessary\r\n        if(msg.value > renamingFee) //overpaid\r\n        {\r\n            msg.sender.transfer(msg.value.sub(renamingFee));\r\n        }\r\n        //store the new name\r\n        stables.storeName(tokenId,newName);\r\n        emit HorseyRenamed(tokenId,newName);\r\n    }\r\n\r\n    /**\r\n        @dev Allows a user to burn a token he owns to get carrots\r\n            The mount of carrots given is equal to the horsey's feedingCounter upon burning\r\n            Cant be called on a horsey with a pending feeding\r\n            Cant be called while paused\r\n        @param tokenId ID of the token to burn\r\n    */\r\n    function freeForCarrots(uint256 tokenId) external \r\n    whenNotPaused()\r\n    onlyOwnerOf(tokenId) {\r\n        require(pendingFeedings[msg.sender].horsey != tokenId,\"\");\r\n        //credit carrots\r\n        uint8 feedingCounter;\r\n        (,,feedingCounter,) = stables.horseys(tokenId);\r\n        stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) + uint32(feedingCounter * carrotsMultiplier));\r\n        stables.unstoreHorsey(tokenId);\r\n        emit HorseyFreed(tokenId);\r\n    }\r\n\r\n    /**\r\n        @dev Returns the amount of carrots the user owns\r\n            We have a getter to hide the carrots amount from public view\r\n        @return The current amount of carrot credits the sender owns \r\n    */\r\n    function getCarrotCredits() external view returns (uint32) {\r\n        return stables.carrot_credits(msg.sender);\r\n    }\r\n\r\n    /**\r\n        @dev Returns horsey data of a given token\r\n        @param tokenId ID of the horsey to fetch\r\n        @return (race address, dna, feedingCounter, name)\r\n    */\r\n    function getHorsey(uint256 tokenId) public view returns (address, bytes32, uint8, string) {\r\n        RoyalStablesInterface.Horsey memory temp;\r\n        (temp.race,temp.dna,temp.feedingCounter,temp.tier) = stables.horseys(tokenId);\r\n        return (temp.race,temp.dna,temp.feedingCounter,stables.names(tokenId));\r\n    }\r\n\r\n    /**\r\n        @dev Allows to feed a horsey to increase its feedingCounter value\r\n            Gives a chance to get a rare trait\r\n            The amount of carrots required is the value of current feedingCounter\r\n            The carrots the user owns will be reduced accordingly upon success\r\n            Cant be called while paused\r\n        @param tokenId ID of the horsey to feed\r\n    */\r\n    function feed(uint256 tokenId) external \r\n    whenNotPaused()\r\n    onlyOwnerOf(tokenId) \r\n    carrotsMeetLevel(tokenId)\r\n    noFeedingInProgress()\r\n    {\r\n        pendingFeedings[msg.sender] = FeedingData(block.number,tokenId);\r\n        uint8 feedingCounter;\r\n        (,,feedingCounter,) = stables.horseys(tokenId);\r\n        stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter));\r\n        emit Feeding(tokenId);\r\n    }\r\n\r\n    /**\r\n        @dev Allows user to stop feeding a horsey\r\n            This will trigger a random rarity chance\r\n    */\r\n    function stopFeeding() external\r\n    feedingInProgress() returns (bool) {\r\n        uint256 blockNumber = pendingFeedings[msg.sender].blockNumber;\r\n        uint256 tokenId = pendingFeedings[msg.sender].horsey;\r\n        //you cant feed and stop feeding from the same block!\r\n        require(block.number - blockNumber >= 1,\"feeding and stop feeding are in same block\");\r\n\r\n        delete pendingFeedings[msg.sender];\r\n\r\n        //solidity only gives you access to the previous 256 blocks\r\n        //deny and remove this obsolete feeding if we cant fetch its blocks hash\r\n        if(block.number - blockNumber > 255) {\r\n            //the feeding is outdated = failed\r\n            //the user can feed again but he lost his carrots\r\n            emit FeedingFailed(tokenId);\r\n            return false; \r\n        }\r\n\r\n        //token could have been transfered in the meantime to someone else\r\n        if(stables.ownerOf(tokenId) != msg.sender) {\r\n            //the feeding is failed because the token no longer belongs to this user = failed\r\n            //the user has lost his carrots\r\n            emit FeedingFailed(tokenId);\r\n            return false; \r\n        }\r\n        \r\n        //call horsey generation with the claim block hash\r\n        _feed(tokenId, blockhash(blockNumber));\r\n        bytes32 dna;\r\n        (,dna,,) = stables.horseys(tokenId);\r\n        emit ReceivedCarrot(tokenId, dna);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Only ether sent explicitly through the donation() function is accepted\r\n    function() external payable {\r\n        revert(\"Not accepting donations\");\r\n    }\r\n\r\n    /**\r\n        @dev Internal function to increase a horsey's rarity\r\n            Uses a random value to assess if the feeding process increases rarity\r\n            The chances of having a rarity increase are based on the current feedingCounter\r\n        @param tokenId ID of the token to \"feed\"\r\n        @param blockHash Hash of the block where the feeding began\r\n    */\r\n    function _feed(uint256 tokenId, bytes32 blockHash) internal {\r\n        //Grab the upperbound for probability 100,100\r\n        uint8 tier;\r\n        uint8 feedingCounter;\r\n        (,,feedingCounter,tier) = stables.horseys(tokenId);\r\n        uint256 probabilityByRarity = 10 ** (uint256(tier).add(1));\r\n        uint256 randNum = uint256(keccak256(abi.encodePacked(tokenId, blockHash))) % probabilityByRarity;\r\n\r\n        //Scale probability based on horsey's level\r\n        if(randNum <= (feedingCounter * rarityMultiplier)){\r\n            _increaseRarity(tokenId, blockHash);\r\n        }\r\n\r\n        //Increment feedingCounter\r\n        //Maximum allowed is 255, which requires 32385 carrots, so we should never reach that\r\n        if(feedingCounter < 255) {\r\n            stables.modifyHorseyFeedingCounter(tokenId,feedingCounter+1);\r\n        }\r\n    }\r\n\r\n    /// @dev creates a special token id based on the race and the coin index\r\n    function _makeSpecialId(address race, address sender, bytes32 coinIndex) internal pure returns (uint256) {\r\n        return uint256(keccak256(abi.encodePacked(race, sender, coinIndex)));\r\n    }\r\n\r\n    /**\r\n        @dev Internal function to generate a SPECIAL horsey token\r\n            we then use the ERC721 inherited minting process\r\n            the dna is a bytes32 target for a keccak256. Not using blockhash\r\n            finaly, a bitmask zeros the first 2 bytes for rarity traits\r\n        @param race Address of the associated race\r\n        @param eth_address Address of the user to receive the token\r\n        @param coinIndex The index of the winning coin\r\n        @return ID of the token\r\n    */\r\n    function _generate_special_horsey(address race, address eth_address, bytes32 coinIndex) internal returns (uint256) {\r\n        uint256 id = _makeSpecialId(race, eth_address, coinIndex);\r\n        //generate dna\r\n        bytes32 dna = _shiftRight(keccak256(abi.encodePacked(race, coinIndex)),16);\r\n         //storeHorsey checks if the token exists before minting already, so we dont have to here\r\n        stables.storeHorsey(eth_address,id,race,dna,1,0);\r\n        return id;\r\n    }\r\n    \r\n    /**\r\n        @dev Internal function called to increase a horsey rarity\r\n            We generate a random zeros mask with a single 1 in the leading 16 bits\r\n        @param tokenId Id of the token to increase rarity of\r\n        @param blockHash hash of the block where the feeding began\r\n    */\r\n    function _increaseRarity(uint256 tokenId, bytes32 blockHash) private {\r\n        uint8 tier;\r\n        bytes32 dna;\r\n        (,dna,,tier) = stables.horseys(tokenId);\r\n        if(tier < 255)\r\n            stables.modifyHorseyTier(tokenId,tier+1);\r\n        uint256 random = uint256(keccak256(abi.encodePacked(tokenId, blockHash)));\r\n        //this creates a mask of 256 bits such as one of the first 16 bits will be 1\r\n        bytes32 rarityMask = _shiftLeft(bytes32(1), (random % 16 + 240));\r\n        bytes32 newdna = dna | rarityMask; //apply mask to add the random flag\r\n        stables.modifyHorseyDna(tokenId,newdna);\r\n    }\r\n\r\n    /// @dev shifts a bytes32 left by n positions\r\n    function _shiftLeft(bytes32 data, uint n) internal pure returns (bytes32) {\r\n        return bytes32(uint256(data)*(2 ** n));\r\n    }\r\n\r\n    /// @dev shifts a bytes32 right by n positions\r\n    function _shiftRight(bytes32 data, uint n) internal pure returns (bytes32) {\r\n        return bytes32(uint256(data)/(2 ** n));\r\n    }\r\n\r\n    /// @dev Modifier to ensure user can afford a rehorse\r\n    modifier carrotsMeetLevel(uint256 tokenId){\r\n        uint256 feedingCounter;\r\n        (,,feedingCounter,) = stables.horseys(tokenId);\r\n        require(feedingCounter <= stables.carrot_credits(msg.sender),\"Not enough carrots\");\r\n        _;\r\n    }\r\n\r\n    /// @dev insures the caller payed the required amount\r\n    modifier costs(uint256 amount) {\r\n        require(msg.value >= amount,\"Not enough funds\");\r\n        _;\r\n    }\r\n\r\n    /// @dev requires the address to be non null\r\n    modifier validAddress(address addr) {\r\n        require(addr != address(0),\"Address is zero\");\r\n        _;\r\n    }\r\n\r\n    /// @dev requires that the user isnt feeding a horsey already\r\n    modifier noFeedingInProgress() {\r\n        //if the key does not exit, then the default struct data is used where blockNumber is 0\r\n        require(pendingFeedings[msg.sender].blockNumber == 0,\"Already feeding\");\r\n        _;\r\n    }\r\n\r\n    /// @dev requires that the user isnt feeding a horsey already\r\n    modifier feedingInProgress() {\r\n        //if the key does not exit, then the default struct data is used where blockNumber is 0\r\n        require(pendingFeedings[msg.sender].blockNumber != 0,\"No pending feeding\");\r\n        _;\r\n    }\r\n\r\n    /// @dev requires that the user isnt feeding a horsey already\r\n    modifier onlyOwnerOf(uint256 tokenId) {\r\n        require(stables.ownerOf(tokenId) == msg.sender, \"Caller is not owner of this token\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts\\HorseyPilot.sol\r\n\r\n/**\r\n    @title Adds rank management utilities and voting behavior\r\n    @dev Handles equities distribution and levels of access\r\n\r\n    EXCHANGE FUNCTIONS IT CAN CALL\r\n\r\n    setClaimingFee OK 5\r\n    setMarketFees OK 1\r\n    withdraw\r\n\r\n    TOKEN FUNCTIONS IT CAN CALL\r\n\r\n    setRenamingCosts OK 0\r\n    addHorseIndex OK 3\r\n    setCarrotsMultiplier 8\r\n    setRarityMultiplier 9\r\n    addLegitDevAddress 2\r\n    withdraw\r\n\r\n    PAUSING OK 4\r\n*/\r\n\r\ncontract HorseyPilot {\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    /// @dev event that is fired when a new proposal is made\r\n    event NewProposal(uint8 methodId, uint parameter, address proposer);\r\n\r\n    /// @dev event that is fired when a proposal is accepted\r\n    event ProposalPassed(uint8 methodId, uint parameter, address proposer);\r\n\r\n    /// @dev minimum threshold that must be met in order to confirm\r\n    /// a contract update\r\n    uint8 constant votingThreshold = 2;\r\n\r\n    /// @dev minimum amount of time a proposal can live\r\n    /// after this time it can be forcefully invoked or killed by anyone\r\n    uint256 constant proposalLife = 7 days;\r\n\r\n    /// @dev amount of time until another proposal can be made\r\n    /// we use this to eliminate proposal spamming\r\n    uint256 constant proposalCooldown = 1 days;\r\n\r\n    /// @dev used to reference the exact time the last proposal vetoed\r\n    uint256 cooldownStart;\r\n\r\n    /// @dev The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public jokerAddress;\r\n    address public knightAddress;\r\n    address public paladinAddress;\r\n\r\n    /// @dev List of all addresses allowed to vote\r\n    address[3] public voters;\r\n\r\n    /// @dev joker is the pool and gets the rest\r\n    uint8 constant public knightEquity = 40;\r\n    uint8 constant public paladinEquity = 10;\r\n\r\n    /// @dev deployed exchange and token addresses\r\n    address public exchangeAddress;\r\n    address public tokenAddress;\r\n\r\n    /// @dev Mapping to keep track of pending balance of contract owners\r\n    mapping(address => uint) internal _cBalance;\r\n\r\n    /// @dev Encapsulates information about a proposed update\r\n    struct Proposal{\r\n        address proposer;           /// @dev address of the CEO at the origin of this proposal\r\n        uint256 timestamp;          /// @dev the time at which this propsal was made\r\n        uint256 parameter;          /// @dev parameters associated with proposed method invocation\r\n        uint8   methodId;           /// @dev id maps to function 0:rename horse, 1:change fees, 2:?    \r\n        address[] yay;              /// @dev list of all addresses who voted     \r\n        address[] nay;              /// @dev list of all addresses who voted against     \r\n    }\r\n\r\n    /// @dev the pending proposal\r\n    Proposal public currentProposal;\r\n\r\n    /// @dev true if the proposal is waiting for votes\r\n    bool public proposalInProgress = false;\r\n\r\n    /// @dev Value to keep track of avaible balance\r\n    uint256 public toBeDistributed;\r\n\r\n    /// @dev used to deploy contracts only once\r\n    bool deployed = false;\r\n\r\n    /**\r\n        @param _jokerAddress joker\r\n        @param _knightAddress knight\r\n        @param _paladinAddress paladin\r\n        @param _voters list of all allowed voting addresses\r\n    */\r\n    constructor(\r\n    address _jokerAddress,\r\n    address _knightAddress,\r\n    address _paladinAddress,\r\n    address[3] _voters\r\n    ) public {\r\n        jokerAddress = _jokerAddress;\r\n        knightAddress = _knightAddress;\r\n        paladinAddress = _paladinAddress;\r\n\r\n        for(uint i = 0; i < 3; i++) {\r\n            voters[i] = _voters[i];\r\n        }\r\n\r\n        //Set cooldown start to 1 day ago so that cooldown is irrelevant\r\n        cooldownStart = block.timestamp - proposalCooldown;\r\n    }\r\n\r\n    /**\r\n        @dev Used to deploy children contracts as a one shot call\r\n    */\r\n    function deployChildren(address stablesAddress) external {\r\n        require(!deployed,\"already deployed\");\r\n        // deploy token and exchange contracts\r\n        exchangeAddress = new HorseyExchange();\r\n        tokenAddress = new HorseyToken(stablesAddress);\r\n\r\n        // the exchange requires horsey token address\r\n        HorseyExchange(exchangeAddress).setStables(stablesAddress);\r\n\r\n        deployed = true;\r\n    }\r\n\r\n    /**\r\n        @dev Transfers joker ownership to a new address\r\n        @param newJoker the new address\r\n    */\r\n    function transferJokerOwnership(address newJoker) external \r\n    validAddress(newJoker) {\r\n        require(jokerAddress == msg.sender,\"Not right role\");\r\n        _moveBalance(newJoker);\r\n        jokerAddress = newJoker;\r\n    }\r\n\r\n    /**\r\n        @dev Transfers knight ownership to a new address\r\n        @param newKnight the new address\r\n    */\r\n    function transferKnightOwnership(address newKnight) external \r\n    validAddress(newKnight) {\r\n        require(knightAddress == msg.sender,\"Not right role\");\r\n        _moveBalance(newKnight);\r\n        knightAddress = newKnight;\r\n    }\r\n\r\n    /**\r\n        @dev Transfers paladin ownership to a new address\r\n        @param newPaladin the new address\r\n    */\r\n    function transferPaladinOwnership(address newPaladin) external \r\n    validAddress(newPaladin) {\r\n        require(paladinAddress == msg.sender,\"Not right role\");\r\n        _moveBalance(newPaladin);\r\n        paladinAddress = newPaladin;\r\n    }\r\n\r\n    /**\r\n        @dev Allow CEO to withdraw from pending value always checks to update redist\r\n            We ONLY redist when a user tries to withdraw so we are not redistributing\r\n            on every payment\r\n        @param destination The address to send the ether to\r\n    */\r\n    function withdrawCeo(address destination) external \r\n    onlyCLevelAccess()\r\n    validAddress(destination) {\r\n        //Check that pending balance can be redistributed - if so perform\r\n        //this procedure\r\n        if(toBeDistributed > 0){\r\n            _updateDistribution();\r\n        }\r\n        \r\n        //Grab the balance of this CEO \r\n        uint256 balance = _cBalance[msg.sender];\r\n        \r\n        //If we have non-zero balance, CEO may withdraw from pending amount\r\n        if(balance > 0 && (address(this).balance >= balance)) {\r\n            destination.transfer(balance); //throws on fail\r\n            _cBalance[msg.sender] = 0;\r\n        }\r\n    }\r\n\r\n    /// @dev acquire funds from owned contracts\r\n    function syncFunds() external {\r\n        uint256 prevBalance = address(this).balance;\r\n        HorseyToken(tokenAddress).withdraw();\r\n        HorseyExchange(exchangeAddress).withdraw();\r\n        uint256 newBalance = address(this).balance;\r\n        //add to\r\n        toBeDistributed = toBeDistributed.add(newBalance - prevBalance);\r\n    }\r\n\r\n    /// @dev allows a noble to access his holdings\r\n    function getNobleBalance() external view\r\n    onlyCLevelAccess() returns (uint256) {\r\n        return _cBalance[msg.sender];\r\n    }\r\n\r\n    /**\r\n        @dev Make a proposal and add to pending proposals\r\n        @param methodId a string representing the function ie. 'renameHorsey()'\r\n        @param parameter parameter to be used if invocation is approved\r\n    */\r\n    function makeProposal( uint8 methodId, uint256 parameter ) external\r\n    onlyCLevelAccess()\r\n    proposalAvailable()\r\n    cooledDown()\r\n    {\r\n        currentProposal.timestamp = block.timestamp;\r\n        currentProposal.parameter = parameter;\r\n        currentProposal.methodId = methodId;\r\n        currentProposal.proposer = msg.sender;\r\n        delete currentProposal.yay;\r\n        delete currentProposal.nay;\r\n        proposalInProgress = true;\r\n        \r\n        emit NewProposal(methodId,parameter,msg.sender);\r\n    }\r\n\r\n    /**\r\n        @dev Call to vote on a pending proposal\r\n    */\r\n    function voteOnProposal(bool voteFor) external \r\n    proposalPending()\r\n    onlyVoters()\r\n    notVoted() {\r\n        //cant vote on expired!\r\n        require((block.timestamp - currentProposal.timestamp) <= proposalLife);\r\n        if(voteFor)\r\n        {\r\n            currentProposal.yay.push(msg.sender);\r\n            //Proposal went through? invoke it\r\n            if( currentProposal.yay.length >= votingThreshold )\r\n            {\r\n                _doProposal();\r\n                proposalInProgress = false;\r\n                //no need to reset cooldown on successful proposal\r\n                return;\r\n            }\r\n\r\n        } else {\r\n            currentProposal.nay.push(msg.sender);\r\n            //Proposal failed?\r\n            if( currentProposal.nay.length >= votingThreshold )\r\n            {\r\n                proposalInProgress = false;\r\n                cooldownStart = block.timestamp;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @dev Helps moving pending balance from one role to another\r\n        @param newAddress the address to transfer the pending balance from the msg.sender account\r\n    */\r\n    function _moveBalance(address newAddress) internal\r\n    validAddress(newAddress) {\r\n        require(newAddress != msg.sender); /// @dev IMPORTANT or else the account balance gets reset here!\r\n        _cBalance[newAddress] = _cBalance[msg.sender];\r\n        _cBalance[msg.sender] = 0;\r\n    }\r\n\r\n    /**\r\n        @dev Called at the start of withdraw to distribute any pending balances that live in the contract\r\n            will only ever be called if balance is non-zero (funds should be distributed)\r\n    */\r\n    function _updateDistribution() internal {\r\n        require(toBeDistributed != 0,\"nothing to distribute\");\r\n        uint256 knightPayday = toBeDistributed.div(100).mul(knightEquity);\r\n        uint256 paladinPayday = toBeDistributed.div(100).mul(paladinEquity);\r\n\r\n        /// @dev due to the equities distribution, queen gets the remaining value\r\n        uint256 jokerPayday = toBeDistributed.sub(knightPayday).sub(paladinPayday);\r\n\r\n        _cBalance[jokerAddress] = _cBalance[jokerAddress].add(jokerPayday);\r\n        _cBalance[knightAddress] = _cBalance[knightAddress].add(knightPayday);\r\n        _cBalance[paladinAddress] = _cBalance[paladinAddress].add(paladinPayday);\r\n        //Reset balance to 0\r\n        toBeDistributed = 0;\r\n    }\r\n\r\n    /**\r\n        @dev Execute the proposal\r\n    */\r\n    function _doProposal() internal {\r\n        /// UPDATE the renaming cost\r\n        if( currentProposal.methodId == 0 ) HorseyToken(tokenAddress).setRenamingCosts(currentProposal.parameter);\r\n        \r\n        /// UPDATE the market fees\r\n        if( currentProposal.methodId == 1 ) HorseyExchange(exchangeAddress).setMarketFees(currentProposal.parameter);\r\n\r\n        /// UPDATE the legit dev addresses list\r\n        if( currentProposal.methodId == 2 ) HorseyToken(tokenAddress).addLegitDevAddress(address(currentProposal.parameter));\r\n\r\n        /// ADD a horse index to exchange\r\n        if( currentProposal.methodId == 3 ) HorseyToken(tokenAddress).addHorseIndex(bytes32(currentProposal.parameter));\r\n\r\n        /// PAUSE/UNPAUSE the dApp\r\n        if( currentProposal.methodId == 4 ) {\r\n            if(currentProposal.parameter == 0) {\r\n                HorseyExchange(exchangeAddress).unpause();\r\n                HorseyToken(tokenAddress).unpause();\r\n            } else {\r\n                HorseyExchange(exchangeAddress).pause();\r\n                HorseyToken(tokenAddress).pause();\r\n            }\r\n        }\r\n\r\n        /// UPDATE the claiming fees\r\n        if( currentProposal.methodId == 5 ) HorseyToken(tokenAddress).setClaimingCosts(currentProposal.parameter);\r\n\r\n        /// UPDATE carrots multiplier\r\n        if( currentProposal.methodId == 8 ){\r\n            HorseyToken(tokenAddress).setCarrotsMultiplier(uint8(currentProposal.parameter));\r\n        }\r\n\r\n        /// UPDATE rarity multiplier\r\n        if( currentProposal.methodId == 9 ){\r\n            HorseyToken(tokenAddress).setRarityMultiplier(uint8(currentProposal.parameter));\r\n        }\r\n\r\n        emit ProposalPassed(currentProposal.methodId,currentProposal.parameter,currentProposal.proposer);\r\n    }\r\n\r\n    /// @dev requires the address to be non null\r\n    modifier validAddress(address addr) {\r\n        require(addr != address(0),\"Address is zero\");\r\n        _;\r\n    }\r\n\r\n    /// @dev requires the sender to be on the contract owners list\r\n    modifier onlyCLevelAccess() {\r\n        require((jokerAddress == msg.sender) || (knightAddress == msg.sender) || (paladinAddress == msg.sender),\"not c level\");\r\n        _;\r\n    }\r\n\r\n    /// @dev requires that a proposal is not in process or has exceeded its lifetime, and has cooled down\r\n    /// after being vetoed\r\n    modifier proposalAvailable(){\r\n        require(((!proposalInProgress) || ((block.timestamp - currentProposal.timestamp) > proposalLife)),\"proposal already pending\");\r\n        _;\r\n    }\r\n\r\n    // @dev requries that if this proposer was the last proposer, that he or she has reached the \r\n    // cooldown limit\r\n    modifier cooledDown( ){\r\n        if(msg.sender == currentProposal.proposer && (block.timestamp - cooldownStart < 1 days)){\r\n            revert(\"Cool down period not passed yet\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev requires a proposal to be active\r\n    modifier proposalPending() {\r\n        require(proposalInProgress,\"no proposal pending\");\r\n        _;\r\n    }\r\n\r\n    /// @dev requires the voter to not have voted already\r\n    modifier notVoted() {\r\n        uint256 length = currentProposal.yay.length;\r\n        for(uint i = 0; i < length; i++) {\r\n            if(currentProposal.yay[i] == msg.sender) {\r\n                revert(\"Already voted\");\r\n            }\r\n        }\r\n\r\n        length = currentProposal.nay.length;\r\n        for(i = 0; i < length; i++) {\r\n            if(currentProposal.nay[i] == msg.sender) {\r\n                revert(\"Already voted\");\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev requires the voter to not have voted already\r\n    modifier onlyVoters() {\r\n        bool found = false;\r\n        uint256 length = voters.length;\r\n        for(uint i = 0; i < length; i++) {\r\n            if(voters[i] == msg.sender) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if(!found) {\r\n            revert(\"not a voter\");\r\n        }\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newHorse\",\"type\":\"bytes32\"}],\"name\":\"addHorseIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCarrotsMultiplier\",\"type\":\"uint8\"}],\"name\":\"setCarrotsMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"all_horses\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"raceAddress\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingFeedings\",\"outputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"horsey\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"renamingCostsPerChar\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newClaimingFee\",\"type\":\"uint256\"}],\"name\":\"setClaimingCosts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"renameHorsey\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getHorsey\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"raceAddress\",\"type\":\"address\"},{\"name\":\"eth_address\",\"type\":\"address\"}],\"name\":\"can_claim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"addLegitDevAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRarityMultiplier\",\"type\":\"uint8\"}],\"name\":\"setRarityMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rarityMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stables\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopFeeding\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"carrotsMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"freeForCarrots\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"eth_address\",\"type\":\"address\"}],\"name\":\"getOwnedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimingFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRenamingCost\",\"type\":\"uint256\"}],\"name\":\"setRenamingCosts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getall_horsesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"feed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCarrotCredits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"stablesAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"raceAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Feeding\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newDna\",\"type\":\"bytes32\"}],\"name\":\"ReceivedCarrot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"FeedingFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"HorseyRenamed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"HorseyFreed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"HorseyToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a4bef4c1cf2b6ffabc49d0737bf367d497d6defa","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://04cc59d5c2a5dd2e36eb79a77c47767d19bcdf217248fc8fc36bf1f9f56f74f6"}]