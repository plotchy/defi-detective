[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.15;\r\n\r\n/**\r\n * @title  SmartWalletInterface\r\n * @author 0age\r\n */\r\ninterface SmartWalletInterface {\r\n  event CallSuccess(\r\n    bool rolledBack,\r\n    address to,\r\n    uint256 value,\r\n    bytes data,\r\n    bytes returnData\r\n  );\r\n\r\n  event CallFailure(\r\n    address to,\r\n    uint256 value,\r\n    bytes data,\r\n    string revertReason\r\n  );\r\n\r\n  // Use an array of Calls for executing generic batch calls.\r\n  struct Call {\r\n    address to;\r\n    uint96 value;\r\n    bytes data;\r\n  }\r\n\r\n  // Use an array of CallReturns for handling generic batch calls.\r\n  struct CallReturn {\r\n    bool ok;\r\n    bytes returnData;\r\n  }\r\n\r\n  struct ValueReplacement {\r\n    uint24 returnDataOffset;\r\n    uint8 valueLength;\r\n    uint16 callIndex;\r\n  }\r\n\r\n  struct DataReplacement {\r\n    uint24 returnDataOffset;\r\n    uint24 dataLength;\r\n    uint16 callIndex;\r\n    uint24 callDataOffset;\r\n  }\r\n\r\n  struct AdvancedCall {\r\n    address to;\r\n    uint96 value;\r\n    bytes data;\r\n    ValueReplacement[] replaceValue;\r\n    DataReplacement[] replaceData;\r\n  }\r\n\r\n  struct AdvancedCallReturn {\r\n    bool ok;\r\n    bytes returnData;\r\n    uint96 callValue;\r\n    bytes callData;\r\n  }\r\n\r\n  receive() external payable;\r\n\r\n  function execute(\r\n    Call[] calldata calls\r\n  ) external returns (bool[] memory ok, bytes[] memory returnData);\r\n\r\n  function executeAdvanced(\r\n    AdvancedCall[] calldata calls\r\n  ) external returns (AdvancedCallReturn[] memory callResults);\r\n\r\n  function simulate(\r\n    Call[] calldata calls\r\n  ) external /* view */ returns (bool[] memory ok, bytes[] memory returnData);\r\n\r\n  function simulateAdvanced(\r\n    AdvancedCall[] calldata calls\r\n  ) external /* view */ returns (AdvancedCallReturn[] memory callResults);\r\n}\r\n\r\n\r\ninterface ERC721TokenReceiverInterface {\r\n  function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n\r\ninterface ERC1155TokenReceiverInterface {\r\n  function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes calldata data) external returns (bytes4);\r\n\r\n  function onERC1155BatchReceived(address operator, address from, uint256[] calldata ids, uint256[] calldata values, bytes calldata data) external returns (bytes4);       \r\n}\r\n\r\n\r\ninterface ERC1271Interface {\r\n  function isValidSignature(bytes32 digest, bytes memory signature) external view returns (bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @title   TwoStepOwnableInterface\r\n * @notice  TwoStepOwnableInterface contains all external function interfaces,\r\n *          events and errors for the TwoStepOwnable contract.\r\n */\r\ninterface TwoStepOwnableInterface {\r\n    /**\r\n     * @dev Emit an event whenever the contract owner registers a new potential\r\n     *      owner.\r\n     *\r\n     * @param newPotentialOwner The new potential owner of the contract.\r\n     */\r\n    event PotentialOwnerUpdated(address newPotentialOwner);\r\n\r\n    /**\r\n     * @dev Emit an event whenever contract ownership is transferred.\r\n     *\r\n     * @param previousOwner The previous owner of the contract.\r\n     * @param newOwner      The new owner of the contract.\r\n     */\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to set an initial owner when\r\n     *      one has already been set.\r\n     */\r\n    error OwnerAlreadySet(address currentOwner);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to call a function with the\r\n     *      onlyOwner modifier from an account other than that of the owner.\r\n     */\r\n    error CallerIsNotOwner();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to register an initial owner\r\n     *      and supplying the null address.\r\n     */\r\n    error InitialOwnerIsNullAddress();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to register a new potential\r\n     *      owner and supplying the null address.\r\n     */\r\n    error NewPotentialOwnerIsNullAddress();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to claim ownership of the\r\n     *      contract with a caller that is not the current potential owner.\r\n     */\r\n    error CallerIsNotNewPotentialOwner();\r\n\r\n    /**\r\n     * @notice Initiate ownership transfer by assigning a new potential owner\r\n     *         to this contract. Once set, the new potential owner may call\r\n     *         `acceptOwnership` to claim ownership. Only the owner may call\r\n     *         this function.\r\n     *\r\n     * @param newPotentialOwner The address for which to initiate ownership\r\n     *                          transfer to.\r\n     */\r\n    function transferOwnership(address newPotentialOwner) external;\r\n\r\n    /**\r\n     * @notice Clear the currently set potential owner, if any. Only the owner\r\n     *         of this contract may call this function.\r\n     */\r\n    function cancelOwnershipTransfer() external;\r\n\r\n    /**\r\n     * @notice Accept ownership of this contract. Only the account that the\r\n     *         current owner has set as the new potential owner may call this\r\n     *         function.\r\n     */\r\n    function acceptOwnership() external;\r\n\r\n    /**\r\n     * @notice An external view function that returns the potential owner.\r\n     *\r\n     * @return The address of the potential owner.\r\n     */\r\n    function potentialOwner() external view returns (address);\r\n\r\n    /**\r\n     * @notice An external view function that returns the owner.\r\n     *\r\n     * @return The address of the owner.\r\n     */\r\n    function owner() external view returns (address);\r\n}\r\n\r\n\r\n/**\r\n * @title   TwoStepOwnable\r\n * @notice  TwoStepOwnable provides access control for inheriting contracts,\r\n *          where the ownership of the contract can be exchanged via a two step\r\n *          process. A potential owner is set by the current owner by calling\r\n *          `transferOwnership`, then accepted by the new potential owner by\r\n *          calling `acceptOwnership`.\r\n */\r\nabstract contract TwoStepOwnable is TwoStepOwnableInterface {\r\n    // The address of the owner.\r\n    address private _owner;\r\n\r\n    // The address of the new potential owner.\r\n    address private _potentialOwner;\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        // Ensure that the caller is the owner.\r\n        if (msg.sender != _owner) {\r\n            revert CallerIsNotOwner();\r\n        }\r\n\r\n        // Continue with function execution.\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Initiate ownership transfer by assigning a new potential owner\r\n     *         to this contract. Once set, the new potential owner may call\r\n     *         `acceptOwnership` to claim ownership. Only the owner may call\r\n     *         this function.\r\n     *\r\n     * @param newPotentialOwner The address for which to initiate ownership\r\n     *                          transfer to.\r\n     */\r\n    function transferOwnership(address newPotentialOwner)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        // Ensure the new potential owner is not an invalid address.\r\n        if (newPotentialOwner == address(0)) {\r\n            revert NewPotentialOwnerIsNullAddress();\r\n        }\r\n\r\n        // Emit an event indicating that the potential owner has been updated.\r\n        emit PotentialOwnerUpdated(newPotentialOwner);\r\n\r\n        // Set the new potential owner as the potential owner.\r\n        _potentialOwner = newPotentialOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Clear the currently set potential owner, if any. Only the owner\r\n     *         of this contract may call this function.\r\n     */\r\n    function cancelOwnershipTransfer() external override onlyOwner {\r\n        // Emit an event indicating that the potential owner has been cleared.\r\n        emit PotentialOwnerUpdated(address(0));\r\n\r\n        // Clear the current new potential owner.\r\n        delete _potentialOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Accept ownership of this contract. Only the account that the\r\n     *         current owner has set as the new potential owner may call this\r\n     *         function.\r\n     */\r\n    function acceptOwnership() external override {\r\n        // Ensure the caller is the potential owner.\r\n        if (msg.sender != _potentialOwner) {\r\n            // Revert, indicating that caller is not current potential owner.\r\n            revert CallerIsNotNewPotentialOwner();\r\n        }\r\n\r\n        // Emit an event indicating that the potential owner has been cleared.\r\n        emit PotentialOwnerUpdated(address(0));\r\n\r\n        // Clear the current new potential owner.\r\n        delete _potentialOwner;\r\n\r\n        // Set the caller as the owner of this contract.\r\n        _setOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice An external view function that returns the potential owner.\r\n     *\r\n     * @return The address of the potential owner.\r\n     */\r\n    function potentialOwner() external view override returns (address) {\r\n        return _potentialOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice A public view function that returns the owner.\r\n     *\r\n     * @return The address of the owner.\r\n     */\r\n    function owner() public view override returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function that sets the inital owner.\r\n     *\r\n     * @param initialOwner The address to set for initial ownership.\r\n     */\r\n    function _setInitialOwner(address initialOwner) internal {\r\n        // Ensure that an initial owner has been supplied.\r\n        if (initialOwner == address(0)) {\r\n            revert InitialOwnerIsNullAddress();\r\n        }\r\n\r\n        // Set the initial owner.\r\n        _setOwner(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Private function that sets a new owner and emits a corresponding\r\n     *         event.\r\n     *\r\n     * @param newOwner The address to assign as the new owner.\r\n     */\r\n    function _setOwner(address newOwner) private {\r\n        // Emit an event indicating that the new owner has been set.\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n\r\n        // Set the new owner.\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n  function isContract(address account) internal view returns (bool) {\r\n    uint256 size;\r\n    assembly { size := extcodesize(account) }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    enum RecoverError {\r\n        NoError,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS,\r\n        InvalidSignatureV\r\n    }\r\n\r\n    function _throwError(RecoverError error) private pure {\r\n        if (error == RecoverError.NoError) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverError.InvalidSignature) {\r\n            revert(\"ECDSA: invalid signature\");\r\n        } else if (error == RecoverError.InvalidSignatureLength) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        } else if (error == RecoverError.InvalidSignatureS) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        } else if (error == RecoverError.InvalidSignatureV) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature` or error string. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     *\r\n     * Documentation for signature generation:\r\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\r\n        // Check the signature length\r\n        // - case 65: r,s,v signature (standard)\r\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return tryRecover(hash, v, r, s);\r\n        } else if (signature.length == 64) {\r\n            bytes32 r;\r\n            bytes32 vs;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                vs := mload(add(signature, 0x40))\r\n            }\r\n            return tryRecover(hash, r, vs);\r\n        } else {\r\n            return (address(0), RecoverError.InvalidSignatureLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\r\n     *\r\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address, RecoverError) {\r\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\r\n        return tryRecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address, RecoverError) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return (address(0), RecoverError.InvalidSignatureS);\r\n        }\r\n        if (v != 27 && v != 28) {\r\n            return (address(0), RecoverError.InvalidSignatureV);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverError.InvalidSignature);\r\n        }\r\n\r\n        return (signer, RecoverError.NoError);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title  SmartWallet\r\n * @author 0age\r\n */\r\ncontract SmartWallet is\r\n  TwoStepOwnable,\r\n  SmartWalletInterface,\r\n  ERC721TokenReceiverInterface,\r\n  ERC1155TokenReceiverInterface,\r\n  ERC1271Interface {\r\n  using Address for address;\r\n\r\n  bytes4 _selfCallContext;\r\n\r\n  constructor(address initialOwner) {\r\n    // Set the initial owner.\r\n    _setInitialOwner(initialOwner);\r\n  }\r\n\r\n  receive() external payable override {}\r\n\r\n  function execute(\r\n    Call[] calldata calls\r\n  ) external override onlyOwner() returns (\r\n    bool[] memory ok,\r\n    bytes[] memory returnData\r\n  ) {\r\n    // Ensure that each `to` address is a contract and is not this contract.\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      if (calls[i].value == 0) {\r\n        _ensureValidGenericCallTarget(calls[i].to);\r\n      }\r\n    }\r\n\r\n    // Note: from this point on, there are no reverts (apart from out-of-gas or\r\n    // call-depth-exceeded) originating from this contract. However, one of the\r\n    // calls may revert, in which case the function will return `false`, along\r\n    // with the revert reason encoded as bytes, and fire a CallFailure event.\r\n\r\n    // Specify length of returned values in order to work with them in memory.\r\n    ok = new bool[](calls.length);\r\n    returnData = new bytes[](calls.length);\r\n\r\n    // Set self-call context to call _execute.\r\n    _selfCallContext = this.execute.selector;\r\n\r\n    // Make the atomic self-call - if any call fails, calls that preceded it\r\n    // will be rolled back and calls that follow it will not be made.\r\n    (bool externalOk, bytes memory rawCallResults) = address(this).call(\r\n      abi.encodeWithSelector(\r\n        this._execute.selector, calls\r\n      )\r\n    );\r\n\r\n    // Ensure that self-call context has been cleared.\r\n    if (!externalOk) {\r\n      delete _selfCallContext;\r\n    }\r\n\r\n    // Parse data returned from self-call into each call result and store / log.\r\n    CallReturn[] memory callResults = abi.decode(rawCallResults, (CallReturn[]));\r\n    for (uint256 i = 0; i < callResults.length; i++) {\r\n      Call memory currentCall = calls[i];\r\n\r\n      // Set the status and the return data / revert reason from the call.\r\n      ok[i] = callResults[i].ok;\r\n      returnData[i] = callResults[i].returnData;\r\n\r\n      // Emit CallSuccess or CallFailure event based on the outcome of the call.\r\n      if (callResults[i].ok) {\r\n        // Note: while the call succeeded, the action may still have \"failed\".\r\n        emit CallSuccess(\r\n          !externalOk, // If another call failed this will have been rolled back\r\n          currentCall.to,\r\n          uint256(currentCall.value),\r\n          currentCall.data,\r\n          callResults[i].returnData\r\n        );\r\n      } else {\r\n        // Note: while the call failed, the nonce will still be incremented,\r\n        // which will invalidate all supplied signatures.\r\n        emit CallFailure(\r\n          currentCall.to,\r\n          uint256(currentCall.value),\r\n          currentCall.data,\r\n          _decodeRevertReason(callResults[i].returnData)\r\n        );\r\n\r\n        // exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function _execute(\r\n    Call[] calldata calls\r\n  ) external returns (CallReturn[] memory callResults) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.execute.selector);\r\n\r\n    bool rollBack = false;\r\n    callResults = new CallReturn[](calls.length);\r\n\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      // Perform low-level call and set return values using result.\r\n      (bool ok, bytes memory returnData) = calls[i].to.call{\r\n        value: uint256(calls[i].value)\r\n      }(calls[i].data);\r\n      callResults[i] = CallReturn({ok: ok, returnData: returnData});\r\n      if (!ok) {\r\n        // Exit early - any calls after the first failed call will not execute.\r\n        rollBack = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (rollBack) {\r\n      // Wrap in length encoding and revert (provide bytes instead of a string).\r\n      bytes memory callResultsBytes = abi.encode(callResults);\r\n      assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\r\n    }\r\n  }\r\n\r\n  function executeAdvanced(\r\n    AdvancedCall[] calldata calls\r\n  ) external override onlyOwner() returns (\r\n    AdvancedCallReturn[] memory callResults\r\n  ) {\r\n    // Ensure that each `to` address is a contract and is not this contract.\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      if (calls[i].value == 0) {\r\n        _ensureValidGenericCallTarget(calls[i].to);\r\n      }\r\n    }\r\n\r\n    // Note: from this point on, there are no reverts (apart from out-of-gas or\r\n    // call-depth-exceeded) originating from this contract. However, one of the\r\n    // calls may revert, in which case the function will return `false`, along\r\n    // with the revert reason encoded as bytes, and fire an CallFailure event.\r\n\r\n    // Specify length of returned values in order to work with them in memory.\r\n    callResults = new AdvancedCallReturn[](calls.length);\r\n\r\n    // Set self-call context to call _executeAdvanced.\r\n    _selfCallContext = this.executeAdvanced.selector;\r\n\r\n    // Make the atomic self-call - if any call fails, calls that preceded it\r\n    // will be rolled back and calls that follow it will not be made.\r\n    (bool externalOk, bytes memory rawCallResults) = address(this).call(\r\n      abi.encodeWithSelector(\r\n        this._executeAdvanced.selector, calls\r\n      )\r\n    );\r\n\r\n    // Note: there are more efficient ways to check for revert reasons.\r\n    if (\r\n      rawCallResults.length > 68 && // prefix (4) + position (32) + length (32)\r\n      rawCallResults[0] == bytes1(0x08) &&\r\n      rawCallResults[1] == bytes1(0xc3) &&\r\n      rawCallResults[2] == bytes1(0x79) &&\r\n      rawCallResults[3] == bytes1(0xa0)\r\n    ) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize())\r\n        revert(0, returndatasize())\r\n      }\r\n    }\r\n\r\n    // Ensure that self-call context has been cleared.\r\n    if (!externalOk) {\r\n      delete _selfCallContext;\r\n    }\r\n\r\n    // Parse data returned from self-call into each call result and store / log.\r\n    callResults = abi.decode(rawCallResults, (AdvancedCallReturn[]));\r\n    for (uint256 i = 0; i < callResults.length; i++) {\r\n      AdvancedCall memory currentCall = calls[i];\r\n\r\n      // Emit CallSuccess or CallFailure event based on the outcome of the call.\r\n      if (callResults[i].ok) {\r\n        // Note: while the call succeeded, the action may still have \"failed\".\r\n        emit CallSuccess(\r\n          !externalOk, // If another call failed this will have been rolled back\r\n          currentCall.to,\r\n          uint256(callResults[i].callValue),\r\n          callResults[i].callData,\r\n          callResults[i].returnData\r\n        );\r\n      } else {\r\n        // Note: while the call failed, the nonce will still be incremented,\r\n        // which will invalidate all supplied signatures.\r\n        emit CallFailure(\r\n          currentCall.to,\r\n          uint256(callResults[i].callValue),\r\n          callResults[i].callData,\r\n          _decodeRevertReason(callResults[i].returnData)\r\n        );\r\n\r\n        // exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function _executeAdvanced(\r\n    AdvancedCall[] memory calls\r\n  ) public returns (AdvancedCallReturn[] memory callResults) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.executeAdvanced.selector);\r\n\r\n    bool rollBack = false;\r\n    callResults = new AdvancedCallReturn[](calls.length);\r\n\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      AdvancedCall memory a = calls[i];\r\n      uint256 callValue = uint256(a.value);\r\n      bytes memory callData = a.data;\r\n      uint256 callIndex;\r\n\r\n      // Perform low-level call and set return values using result.\r\n      (bool ok, bytes memory returnData) = a.to.call{value: callValue}(callData);\r\n      callResults[i] = AdvancedCallReturn({\r\n          ok: ok,\r\n          returnData: returnData,\r\n          callValue: uint96(callValue),\r\n          callData: callData\r\n      });\r\n      if (!ok) {\r\n        // Exit early - any calls after the first failed call will not execute.\r\n        rollBack = true;\r\n        break;\r\n      }\r\n\r\n      for (uint256 j = 0; j < a.replaceValue.length; j++) {\r\n        callIndex = uint256(a.replaceValue[j].callIndex);\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (i >= callIndex) {\r\n          revert(\"Cannot replace value using call that has not yet been performed.\");\r\n        }\r\n\r\n        uint256 returnOffset = uint256(a.replaceValue[j].returnDataOffset);\r\n        uint256 valueLength = uint256(a.replaceValue[j].valueLength);\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (valueLength == 0 || valueLength > 32) {\r\n          revert(\"bad valueLength\");\r\n        }\r\n\r\n        if (returnData.length < returnOffset + valueLength) {\r\n          revert(\"Return values are too short to give back a value at supplied index.\");\r\n        }\r\n\r\n        AdvancedCall memory callTarget = calls[callIndex];\r\n        uint256 valueOffset = 32 - valueLength;\r\n        assembly {\r\n          returndatacopy(\r\n            add(add(callTarget, 32), valueOffset), returnOffset, valueLength\r\n          )\r\n        }\r\n      }\r\n\r\n      for (uint256 k = 0; k < a.replaceData.length; k++) {\r\n        callIndex = uint256(a.replaceData[k].callIndex);\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (i >= callIndex) {\r\n          revert(\"Cannot replace data using call that has not yet been performed.\");\r\n        }\r\n\r\n        uint256 callOffset = uint256(a.replaceData[k].callDataOffset);\r\n        uint256 returnOffset = uint256(a.replaceData[k].returnDataOffset);\r\n        uint256 dataLength = uint256(a.replaceData[k].dataLength);\r\n\r\n        if (returnData.length < returnOffset + dataLength) {\r\n          revert(\"Return values are too short to give back a value at supplied index.\");\r\n        }\r\n\r\n        bytes memory callTargetData = calls[callIndex].data;\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (callTargetData.length < callOffset + dataLength) {\r\n          revert(\"Calldata too short to insert returndata at supplied offset.\");\r\n        }\r\n\r\n        assembly {\r\n          returndatacopy(\r\n            add(callTargetData, add(32, callOffset)), returnOffset, dataLength\r\n          )\r\n        }\r\n      }\r\n    }\r\n\r\n    if (rollBack) {\r\n      // Wrap in length encoding and revert (provide bytes instead of a string).\r\n      bytes memory callResultsBytes = abi.encode(callResults);\r\n      assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\r\n    }\r\n  }\r\n\r\n  function simulate(\r\n    Call[] calldata calls\r\n  ) external /* view */ override returns (bool[] memory ok, bytes[] memory returnData) {\r\n    // Ensure that each `to` address is a contract and is not this contract.\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      if (calls[i].value == 0) {\r\n        _ensureValidGenericCallTarget(calls[i].to);\r\n      }\r\n    }\r\n\r\n    // Specify length of returned values in order to work with them in memory.\r\n    ok = new bool[](calls.length);\r\n    returnData = new bytes[](calls.length);\r\n\r\n    // Set self-call context to call _simulateActionWithAtomicBatchCallsAtomic.\r\n    _selfCallContext = this.simulate.selector;\r\n\r\n    // Make the atomic self-call - if any call fails, calls that preceded it\r\n    // will be rolled back and calls that follow it will not be made.\r\n    (bool mustBeFalse, bytes memory rawCallResults) = address(this).call(\r\n      abi.encodeWithSelector(\r\n        this._simulate.selector, calls\r\n      )\r\n    );\r\n\r\n    // Note: this should never be the case, but check just to be extra safe.\r\n    if (mustBeFalse) {\r\n      revert(\"Simulation code must revert!\");\r\n    }\r\n\r\n    // Ensure that self-call context has been cleared.\r\n    delete _selfCallContext;\r\n\r\n    // Parse data returned from self-call into each call result and store / log.\r\n    CallReturn[] memory callResults = abi.decode(rawCallResults, (CallReturn[]));\r\n    for (uint256 i = 0; i < callResults.length; i++) {\r\n      // Set the status and the return data / revert reason from the call.\r\n      ok[i] = callResults[i].ok;\r\n      returnData[i] = callResults[i].returnData;\r\n\r\n      if (!callResults[i].ok) {\r\n        // exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function _simulate(\r\n    Call[] calldata calls\r\n  ) external returns (CallReturn[] memory callResults) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.simulate.selector);\r\n\r\n    callResults = new CallReturn[](calls.length);\r\n\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      // Perform low-level call and set return values using result.\r\n      (bool ok, bytes memory returnData) = calls[i].to.call{\r\n        value: uint256(calls[i].value)\r\n      }(calls[i].data);\r\n      callResults[i] = CallReturn({ok: ok, returnData: returnData});\r\n      if (!ok) {\r\n        // Exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Wrap in length encoding and revert (provide bytes instead of a string).\r\n    bytes memory callResultsBytes = abi.encode(callResults);\r\n    assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\r\n  }\r\n\r\n  function simulateAdvanced(\r\n    AdvancedCall[] calldata calls\r\n  ) external /* view */ override returns (AdvancedCallReturn[] memory callResults) {\r\n    // Ensure that each `to` address is a contract and is not this contract.\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      if (calls[i].value == 0) {\r\n        _ensureValidGenericCallTarget(calls[i].to);\r\n      }\r\n    }\r\n\r\n    // Specify length of returned values in order to work with them in memory.\r\n    callResults = new AdvancedCallReturn[](calls.length);\r\n\r\n    // Set self-call context to call _simulateActionWithAtomicBatchCallsAtomic.\r\n    _selfCallContext = this.simulateAdvanced.selector;\r\n\r\n    // Make the atomic self-call - if any call fails, calls that preceded it\r\n    // will be rolled back and calls that follow it will not be made.\r\n    (bool mustBeFalse, bytes memory rawCallResults) = address(this).call(\r\n      abi.encodeWithSelector(\r\n        this._simulateAdvanced.selector, calls\r\n      )\r\n    );\r\n\r\n    // Note: this should never be the case, but check just to be extra safe.\r\n    if (mustBeFalse) {\r\n      revert(\"Simulation code must revert!\");\r\n    }\r\n\r\n    // Note: there are more efficient ways to check for revert reasons.\r\n    if (\r\n      rawCallResults.length > 68 && // prefix (4) + position (32) + length (32)\r\n      rawCallResults[0] == bytes1(0x08) &&\r\n      rawCallResults[1] == bytes1(0xc3) &&\r\n      rawCallResults[2] == bytes1(0x79) &&\r\n      rawCallResults[3] == bytes1(0xa0)\r\n    ) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize())\r\n        revert(0, returndatasize())\r\n      }\r\n    }\r\n\r\n    // Ensure that self-call context has been cleared.\r\n    delete _selfCallContext;\r\n\r\n    // Parse data returned from self-call into each call result and return.\r\n    callResults = abi.decode(rawCallResults, (AdvancedCallReturn[]));\r\n  }\r\n\r\n  function _simulateAdvanced(\r\n    AdvancedCall[] memory calls\r\n  ) public returns (AdvancedCallReturn[] memory callResults) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.simulateAdvanced.selector);\r\n\r\n    callResults = new AdvancedCallReturn[](calls.length);\r\n\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      AdvancedCall memory a = calls[i];\r\n      uint256 callValue = uint256(a.value);\r\n      bytes memory callData = a.data;\r\n      uint256 callIndex;\r\n\r\n      // Perform low-level call and set return values using result.\r\n      (bool ok, bytes memory returnData) = a.to.call{value: callValue}(callData);\r\n      callResults[i] = AdvancedCallReturn({\r\n          ok: ok,\r\n          returnData: returnData,\r\n          callValue: uint96(callValue),\r\n          callData: callData\r\n      });\r\n      if (!ok) {\r\n        // Exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n\r\n      for (uint256 j = 0; j < a.replaceValue.length; j++) {\r\n        callIndex = uint256(a.replaceValue[j].callIndex);\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (i >= callIndex) {\r\n          revert(\"Cannot replace value using call that has not yet been performed.\");\r\n        }\r\n\r\n        uint256 returnOffset = uint256(a.replaceValue[j].returnDataOffset);\r\n        uint256 valueLength = uint256(a.replaceValue[j].valueLength);\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (valueLength == 0 || valueLength > 32) {\r\n          revert(\"bad valueLength\");\r\n        }\r\n\r\n        if (returnData.length < returnOffset + valueLength) {\r\n          revert(\"Return values are too short to give back a value at supplied index.\");\r\n        }\r\n\r\n        AdvancedCall memory callTarget = calls[callIndex];\r\n        uint256 valueOffset = 32 - valueLength;\r\n        assembly {\r\n          returndatacopy(\r\n            add(add(callTarget, 32), valueOffset), returnOffset, valueLength\r\n          )\r\n        }\r\n      }\r\n\r\n      for (uint256 k = 0; k < a.replaceData.length; k++) {\r\n        callIndex = uint256(a.replaceData[k].callIndex);\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (i >= callIndex) {\r\n          revert(\"Cannot replace data using call that has not yet been performed.\");\r\n        }\r\n\r\n        uint256 callOffset = uint256(a.replaceData[k].callDataOffset);\r\n        uint256 returnOffset = uint256(a.replaceData[k].returnDataOffset);\r\n        uint256 dataLength = uint256(a.replaceData[k].dataLength);\r\n\r\n        if (returnData.length < returnOffset + dataLength) {\r\n          revert(\"Return values are too short to give back a value at supplied index.\");\r\n        }\r\n\r\n        bytes memory callTargetData = calls[callIndex].data;\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (callTargetData.length < callOffset + dataLength) {\r\n          revert(\"Calldata too short to insert returndata at supplied offset.\");\r\n        }\r\n\r\n        assembly {\r\n          returndatacopy(\r\n            add(callTargetData, add(32, callOffset)), returnOffset, dataLength\r\n          )\r\n        }\r\n      }\r\n    }\r\n\r\n    // Wrap in length encoding and revert (provide bytes instead of a string).\r\n    bytes memory callResultsBytes = abi.encode(callResults);\r\n    assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\r\n  }\r\n\r\n  function _enforceSelfCallFrom(bytes4 selfCallContext) internal {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    if (msg.sender != address(this) || _selfCallContext != selfCallContext) {\r\n      revert(\"External accounts or unapproved internal functions cannot call this.\");\r\n    }\r\n\r\n    // Clear the self-call context.\r\n    delete _selfCallContext;\r\n  }\r\n\r\n  function _ensureValidGenericCallTarget(address to) internal view {\r\n    if (!to.isContract()) {\r\n      revert(\"Invalid `to` parameter - must supply a contract address containing code.\");\r\n    }\r\n\r\n    if (to == address(this)) {\r\n      revert(\"Invalid `to` parameter - cannot supply the address of this contract.\");\r\n    }\r\n  }\r\n\r\n  function onERC721Received(\r\n    address operator,\r\n    address from,\r\n    uint256 tokenId,\r\n    bytes calldata data\r\n  ) external pure returns (bytes4) {\r\n    return this.onERC721Received.selector;\r\n  }\r\n\r\n  function onERC1155Received(\r\n    address operator,\r\n    address from,\r\n    uint256 id,\r\n    uint256 value,\r\n    bytes calldata data\r\n  ) external pure returns (bytes4) {\r\n    return this.onERC1155Received.selector;\r\n  }\r\n\r\n  function onERC1155BatchReceived(\r\n    address operator,\r\n    address from,\r\n    uint256[] calldata ids,\r\n    uint256[] calldata values,\r\n    bytes calldata data\r\n  ) external pure returns (bytes4) {\r\n    return this.onERC1155BatchReceived.selector;\r\n  }      \r\n\r\n  function isValidSignature(\r\n    bytes32 digest,\r\n    bytes memory signature\r\n  ) external view returns (bytes4) {\r\n    return ECDSA.recover(digest, signature) == owner()\r\n      ? this.isValidSignature.selector\r\n      : bytes4(0);\r\n  }\r\n\r\n  function _decodeRevertReason(\r\n    bytes memory revertData\r\n  ) internal pure returns (string memory revertReason) {\r\n    // Solidity prefixes revert reason with 0x08c379a0 -> Error(string) selector\r\n    if (\r\n      revertData.length > 68 && // prefix (4) + position (32) + length (32)\r\n      revertData[0] == bytes1(0x08) &&\r\n      revertData[1] == bytes1(0xc3) &&\r\n      revertData[2] == bytes1(0x79) &&\r\n      revertData[3] == bytes1(0xa0)\r\n    ) {\r\n      // Get the revert reason without the prefix from the revert data.\r\n      bytes memory revertReasonBytes = new bytes(revertData.length - 4);\r\n      for (uint256 i = 4; i < revertData.length; i++) {\r\n        revertReasonBytes[i - 4] = revertData[i];\r\n      }\r\n\r\n      // Decode the resultant revert reason as a string.\r\n      revertReason = abi.decode(revertReasonBytes, (string));\r\n    } else {\r\n      // Simply return the default, with no revert reason.\r\n      revertReason = \"(no revert reason)\";\r\n    }\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CallerIsNotNewPotentialOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitialOwnerIsNullAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewPotentialOwnerIsNullAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"OwnerAlreadySet\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"revertReason\",\"type\":\"string\"}],\"name\":\"CallFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"rolledBack\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"CallSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPotentialOwner\",\"type\":\"address\"}],\"name\":\"PotentialOwnerUpdated\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct SmartWalletInterface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"_execute\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"internalType\":\"struct SmartWalletInterface.CallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"valueLength\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct SmartWalletInterface.ValueReplacement[]\",\"name\":\"replaceValue\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"dataLength\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"callDataOffset\",\"type\":\"uint24\"}],\"internalType\":\"struct SmartWalletInterface.DataReplacement[]\",\"name\":\"replaceData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct SmartWalletInterface.AdvancedCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"_executeAdvanced\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"callValue\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct SmartWalletInterface.AdvancedCallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct SmartWalletInterface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"_simulate\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"internalType\":\"struct SmartWalletInterface.CallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"valueLength\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct SmartWalletInterface.ValueReplacement[]\",\"name\":\"replaceValue\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"dataLength\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"callDataOffset\",\"type\":\"uint24\"}],\"internalType\":\"struct SmartWalletInterface.DataReplacement[]\",\"name\":\"replaceData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct SmartWalletInterface.AdvancedCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"_simulateAdvanced\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"callValue\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct SmartWalletInterface.AdvancedCallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct SmartWalletInterface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"ok\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"returnData\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"valueLength\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct SmartWalletInterface.ValueReplacement[]\",\"name\":\"replaceValue\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"dataLength\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"callDataOffset\",\"type\":\"uint24\"}],\"internalType\":\"struct SmartWalletInterface.DataReplacement[]\",\"name\":\"replaceData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct SmartWalletInterface.AdvancedCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"executeAdvanced\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"callValue\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct SmartWalletInterface.AdvancedCallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"potentialOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct SmartWalletInterface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"simulate\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"ok\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"returnData\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"valueLength\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct SmartWalletInterface.ValueReplacement[]\",\"name\":\"replaceValue\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"dataLength\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"callDataOffset\",\"type\":\"uint24\"}],\"internalType\":\"struct SmartWalletInterface.DataReplacement[]\",\"name\":\"replaceData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct SmartWalletInterface.AdvancedCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"simulateAdvanced\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"callValue\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct SmartWalletInterface.AdvancedCallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPotentialOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SmartWallet","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"0000000000000000000000000734d56da60852a03e2aafae8a36ffd8c12b32f1","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://57cb1c032a4ba01ffe830c4577abbacbea5a0f9f4337786676f55d0b26e3bede"}]