[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/EthereumFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport { BaseFeeCollector } from \\\"./base/BaseFeeCollector.sol\\\";\\n\\nimport {\\n    EthereumFeeCollectorInterface,\\n    WETHInterface\\n} from \\\"./interfaces/EthereumFeeCollectorInterface.sol\\\";\\n\\n/**\\n * @title   EthereumFeeCollector\\n * @author  OpenSea Protocol Team\\n * @notice  EthereumFeeCollector is a contract that is used as an\\n *          implementation for a beacon proxy. It inherits the\\n *          BaseFeeCollector allowing for native token and ERC20\\n *          token withdrawals. In addition, allowing for unwrapping\\n *          and transferring WETH.\\n */\\ncontract EthereumFeeCollector is\\n    BaseFeeCollector,\\n    EthereumFeeCollectorInterface\\n{\\n    constructor() BaseFeeCollector() {}\\n\\n    /**\\n     * @notice Unwraps and withdraws the given amount of WETH tokens from the\\n     *         provided contract address. Requires the caller to have the\\n     *         operator role, and the withdrawal wallet to be in the\\n     *         allowlisted wallets.\\n     *\\n     * @param withdrawalWallet      The wallet to be used for withdrawal.\\n     * @param wrappedTokenContract  The token address to be unwrapped.\\n     * @param amount                The amount of tokens to be withdrawn.\\n     */\\n    function unwrapAndWithdraw(\\n        address withdrawalWallet,\\n        address wrappedTokenContract,\\n        uint256 amount\\n    ) external override isOperator {\\n        // Ensure the withdrawal wallet is in the withdrawal wallet mapping.\\n        if (_withdrawalWallets[withdrawalWallet] != true) {\\n            revert InvalidWithdrawalWallet(withdrawalWallet);\\n        }\\n\\n        // Make the withdraw call on the provided wrapped token.\\n        (bool result, bytes memory data) = wrappedTokenContract.call(\\n            abi.encodeWithSelector(WETHInterface.withdraw.selector, amount)\\n        );\\n\\n        // Revert if we have a false result.\\n        if (!result) {\\n            revert TokenTransferGenericFailure(\\n                wrappedTokenContract,\\n                withdrawalWallet,\\n                0,\\n                amount\\n            );\\n        }\\n\\n        // Revert if we have a bad return value.\\n        if (data.length != 0 && data.length >= 32) {\\n            if (!abi.decode(data, (bool))) {\\n                revert BadReturnValueFromERC20OnTransfer(\\n                    wrappedTokenContract,\\n                    withdrawalWallet,\\n                    amount\\n                );\\n            }\\n        }\\n\\n        // Transfer the now unwrapped tokens to the withdrawal address.\\n        payable(withdrawalWallet).transfer(amount);\\n    }\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return The name of this contract.\\n     */\\n    function name() external pure override returns (string memory) {\\n        // Return the name of the contract.\\n        return \\\"ethereum-fee-collector\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/BaseFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport { TwoStepOwnable } from \\\"../access/TwoStepOwnable.sol\\\";\\n\\nimport {\\n    ERC20Interface,\\n    BaseFeeCollectorInterface\\n} from \\\"../interfaces/BaseFeeCollectorInterface.sol\\\";\\n\\nimport {\\n    BaseFeeCollectorEventsAndErrors\\n} from \\\"../interfaces/BaseFeeCollectorEventsAndErrors.sol\\\";\\n\\n/**\\n * @title   BaseFeeCollector\\n * @author  OpenSea Protocol Team\\n * @notice  BaseFeeCollector is a contract that is used as an implementation\\n *          for a beacon proxy. Allows for withdrawal of the native token\\n *          and all ERC20 standard tokens from the proxy. The contract\\n *          inherits TwoStepOwnable to allow for ownership modifiers.\\n */\\ncontract BaseFeeCollector is\\n    TwoStepOwnable,\\n    BaseFeeCollectorInterface,\\n    BaseFeeCollectorEventsAndErrors\\n{\\n    // The operator address.\\n    address internal _operator;\\n\\n    // Mapping of valid withdrawal wallets.\\n    mapping(address => bool) internal _withdrawalWallets;\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner or\\n     *      operator.\\n     */\\n    modifier isOperator() {\\n        if (msg.sender != _operator && msg.sender != owner()) {\\n            revert InvalidOperator();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @notice Creates the implementation.\\n     */\\n    constructor() {\\n        // Ensure the origin is an approved deployer.\\n        require(\\n            (tx.origin == address(0x939C8d89EBC11fA45e576215E2353673AD0bA18A) ||\\n                tx.origin ==\\n                address(0xe80a65eB7a3018DedA407e621Ef5fb5B416678CA) ||\\n                tx.origin ==\\n                address(0x86D26897267711ea4b173C8C124a0A73612001da) ||\\n                tx.origin ==\\n                address(0x3B52ad533687Ce908bA0485ac177C5fb42972962)),\\n            \\\"Deployment must originate from an approved deployer.\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice External initialization called by the proxy to set the\\n     *         owner. During upgrading, do not modify the original\\n     *         variables that were set in previous implementations.\\n     *\\n     * @param ownerToSet The address to be set as the owner.\\n     */\\n    function initialize(address ownerToSet) external {\\n        // Ensure the origin is an approved deployer.\\n        require(\\n            (tx.origin == address(0x939C8d89EBC11fA45e576215E2353673AD0bA18A) ||\\n                tx.origin ==\\n                address(0xe80a65eB7a3018DedA407e621Ef5fb5B416678CA) ||\\n                tx.origin ==\\n                address(0x86D26897267711ea4b173C8C124a0A73612001da) ||\\n                tx.origin ==\\n                address(0x3B52ad533687Ce908bA0485ac177C5fb42972962)) &&\\n                owner() == address(0),\\n            \\\"Initialize must originate from an approved deployer, and the owner must not be set.\\\"\\n        );\\n\\n        // Call initialize.\\n        _initialize(ownerToSet);\\n    }\\n\\n    /**\\n     * @notice Internal initialization function to set the owner. During\\n     *         upgrading, do not modify the original variables that were set\\n     *         in the previous implementations. Requires this call to be inside\\n     *         the constructor.\\n     *\\n     * @param ownerToSet The address to be set as the owner.\\n     */\\n    function _initialize(address ownerToSet) internal {\\n        // Set the owner of the FeeCollector.\\n        _setInitialOwner(ownerToSet);\\n    }\\n\\n    /**\\n     * @notice Withdrawals the given amount of ERC20 tokens from the provided\\n     *         contract address. Requires the caller to have the operator role,\\n     *         and the withdrawal wallet to be in the allowlisted wallets.\\n     *\\n     * @param withdrawalWallet The wallet to be used for withdrawal.\\n     * @param tokenContract    The ERC20 token address to be withdrawn.\\n     * @param amount           The amount of ERC20 tokens to be withdrawn.\\n     */\\n    function withdrawERC20Tokens(\\n        address withdrawalWallet,\\n        address tokenContract,\\n        uint256 amount\\n    ) external override isOperator {\\n        // Ensure the withdrawal wallet is in the withdrawal wallet mapping.\\n        if (_withdrawalWallets[withdrawalWallet] != true) {\\n            revert InvalidWithdrawalWallet(withdrawalWallet);\\n        }\\n\\n        // Make the transfer call on the provided ERC20 token.\\n        (bool result, bytes memory data) = tokenContract.call(\\n            abi.encodeWithSelector(\\n                ERC20Interface.transfer.selector,\\n                withdrawalWallet,\\n                amount\\n            )\\n        );\\n\\n        // Revert if we have a false result.\\n        if (!result) {\\n            revert TokenTransferGenericFailure(\\n                tokenContract,\\n                withdrawalWallet,\\n                0,\\n                amount\\n            );\\n        }\\n\\n        // Revert if we have a bad return value.\\n        if (data.length != 0 && data.length >= 32) {\\n            if (!abi.decode(data, (bool))) {\\n                revert BadReturnValueFromERC20OnTransfer(\\n                    tokenContract,\\n                    withdrawalWallet,\\n                    amount\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Withdrawals the given amount of the native token from this\\n     *         contract to the withdrawal address. Requires the caller to\\n     *         have the operator role, and the withdrawal wallet to be in\\n     *         the allowlisted wallets.\\n     *\\n     * @param withdrawalWallet The wallet to be used for withdrawal.\\n     * @param amount           The amount of the native token to be withdrawn.\\n     */\\n    function withdraw(address withdrawalWallet, uint256 amount)\\n        external\\n        override\\n        isOperator\\n    {\\n        // Ensure the withdrawal wallet is in the withdrawal wallet mapping.\\n        if (_withdrawalWallets[withdrawalWallet] != true) {\\n            revert InvalidWithdrawalWallet(withdrawalWallet);\\n        }\\n\\n        // Ensure the amount to withdraw is valid.\\n        if (amount > address(this).balance) {\\n            revert InvalidNativeTokenAmount(amount);\\n        }\\n\\n        // Transfer the amount of the native token to the withdrawal address.\\n        payable(withdrawalWallet).transfer(amount);\\n    }\\n\\n    /**\\n     * @notice Adds a new withdrawal address to the mapping. Requires\\n     *         the caller to be the owner and the withdrawal\\n     *         wallet to not be the null address.\\n     *\\n     * @param newWithdrawalWallet  The new withdrawal address.\\n     */\\n    function addWithdrawAddress(address newWithdrawalWallet)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        // Ensure the new owner is not an invalid address.\\n        if (newWithdrawalWallet == address(0)) {\\n            revert NewWithdrawalWalletIsNullAddress();\\n        }\\n\\n        // Set the new wallet address mapping.\\n        _setWithdrawalWallet(newWithdrawalWallet, true);\\n    }\\n\\n    /**\\n     * @notice Removes the withdrawal address from the mapping. Requires\\n     *         the caller to be the owner.\\n     *\\n     * @param withdrawalWallet  The withdrawal address to\\n     *                             remove.\\n     */\\n    function removeWithdrawAddress(address withdrawalWallet)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        // Set the withdrawal wallet to false.\\n        _setWithdrawalWallet(withdrawalWallet, false);\\n    }\\n\\n    /**\\n     * @notice Assign the given address with the ability to operate the wallet.\\n     *         Requires caller to be the owner.\\n     *\\n     * @param operatorToAssign The address to assign the operator role.\\n     */\\n    function assignOperator(address operatorToAssign)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        // Ensure the operator to assign is not an invalid address.\\n        if (operatorToAssign == address(0)) {\\n            revert OperatorIsNullAddress();\\n        }\\n\\n        // Set the given account as the operator.\\n        _operator = operatorToAssign;\\n\\n        // Emit an event indicating the operator has been assigned.\\n        emit OperatorUpdated(_operator);\\n    }\\n\\n    /**\\n     * @notice An external view function that returns a boolean.\\n     *\\n     * @return A boolean that determines if the provided address is\\n     *         a valid withdrawal wallet.\\n     */\\n    function isWithdrawalWallet(address withdrawalWallet)\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        // Return if the wallet is in the allow list.\\n        return _withdrawalWallets[withdrawalWallet];\\n    }\\n\\n    /**\\n     * @notice Internal function to set the withdrawal wallet mapping.\\n     *\\n     * @param withdrawalAddress The address to be set as the withdrawal\\n     *                          wallet.\\n     * @param valueToSet        The boolean to set for the mapping.\\n     */\\n    function _setWithdrawalWallet(address withdrawalAddress, bool valueToSet)\\n        internal\\n    {\\n        // Set the withdrawal address mapping.\\n        _withdrawalWallets[withdrawalAddress] = valueToSet;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/EthereumFeeCollectorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface WETHInterface {\\n    function withdraw(uint256 wad) external;\\n}\\n\\n/**\\n * @title   EthereumFeeCollectorInterface\\n * @author  OpenSea Protocol Team\\n * @notice  EthereumFeeCollectorInterface contains all external function\\n *          interfaces for the fee collector implementation.\\n */\\ninterface EthereumFeeCollectorInterface {\\n    /**\\n     * @notice Unwraps and withdraws the given amount of WETH tokens from the\\n     *         provided contract address. Requires the caller to have the\\n     *         operator role, and the withdrawal wallet to be in the\\n     *         allowlisted wallets.\\n     *\\n     * @param withdrawalWallet The wallet to be used for withdrawal.\\n     * @param tokenContract    The WETH token address to be unwrapped.\\n     * @param amount           The amount of tokens to be withdrawn.\\n     */\\n    function unwrapAndWithdraw(\\n        address withdrawalWallet,\\n        address tokenContract,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return The name of this contract.\\n     */\\n    function name() external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/access/TwoStepOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"../interfaces/TwoStepOwnableInterface.sol\\\";\\n\\n/**\\n * @title   TwoStepOwnable\\n * @author  OpenSea Protocol Team\\n * @notice  TwoStepOwnable is a module which provides access control\\n *          where the ownership of a contract can be exchanged via a\\n *          two step process. A potential owner is set by the current\\n *          owner using transferOwnership, then accepted by the new\\n *          potential owner using acceptOwnership.\\n */\\ncontract TwoStepOwnable is TwoStepOwnableInterface {\\n    // The address of the owner.\\n    address private _owner;\\n\\n    // The address of the new potential owner.\\n    address private _potentialOwner;\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        // Ensure the caller is the owner.\\n        if (msg.sender != _owner) {\\n            revert CallerIsNotOwner();\\n        }\\n        // Continue with function execution.\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initiate ownership transfer by assigning a new potential owner\\n     *         to this contract. Once set, the new potential owner may call\\n     *         `acceptOwnership` to claim ownership. Only the owner may call\\n     *         this function.\\n     *\\n     * @param newPotentialOwner The address for which to initiate ownership\\n     *                          transfer to.\\n     */\\n    function transferOwnership(address newPotentialOwner)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        // Ensure the new potential owner is not an invalid address.\\n        if (newPotentialOwner == address(0)) {\\n            revert NewPotentialOwnerIsNullAddress();\\n        }\\n\\n        // Emit an event indicating that the potential owner has been updated.\\n        emit PotentialOwnerUpdated(newPotentialOwner);\\n\\n        // Set the new potential owner as the potential owner.\\n        _potentialOwner = newPotentialOwner;\\n    }\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any.\\n     *         Only the owner of this contract may call this function.\\n     */\\n    function cancelOwnershipTransfer() external override onlyOwner {\\n        // Emit an event indicating that the potential owner has been cleared.\\n        emit PotentialOwnerUpdated(address(0));\\n\\n        // Clear the current new potential owner.\\n        delete _potentialOwner;\\n    }\\n\\n    /**\\n     * @notice Accept ownership of this contract. Only the account that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     */\\n    function acceptOwnership() external override {\\n        // Ensure the caller is the potential owner.\\n        if (msg.sender != _potentialOwner) {\\n            // Revert, indicating that caller is not current potential owner.\\n            revert CallerIsNotNewPotentialOwner();\\n        }\\n\\n        // Emit an event indicating that the potential owner has been cleared.\\n        emit PotentialOwnerUpdated(address(0));\\n\\n        // Clear the current new potential owner.\\n        delete _potentialOwner;\\n\\n        // Emit an event indicating ownership has been transferred.\\n        emit OwnershipTransferred(_owner, msg.sender);\\n\\n        // Set the caller as the owner of this contract.\\n        _owner = msg.sender;\\n    }\\n\\n    /**\\n     * @notice An external view function that returns the potential owner.\\n     *\\n     * @return The address of the potential owner.\\n     */\\n    function potentialOwner() external view override returns (address) {\\n        return _potentialOwner;\\n    }\\n\\n    /**\\n     * @notice A public view function that returns the owner.\\n     *\\n     * @return The address of the owner.\\n     */\\n    function owner() public view override returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @notice Internal function that sets the inital owner of the\\n     *         base contract. The initial owner must not be set\\n     *         previously.\\n     *\\n     * @param initialOwner The address to set for initial ownership.\\n     */\\n    function _setInitialOwner(address initialOwner) internal {\\n        // Ensure the initial owner is not an invalid address.\\n        if (initialOwner == address(0)) {\\n            revert InitialOwnerIsNullAddress();\\n        }\\n\\n        // Ensure the owner has not already been set.\\n        if (_owner != address(0)) {\\n            revert OwnerAlreadySet(_owner);\\n        }\\n\\n        // Emit an event indicating ownership has been set.\\n        emit OwnershipTransferred(address(0), initialOwner);\\n\\n        // Set the initial owner.\\n        _owner = initialOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BaseFeeCollectorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface ERC20Interface {\\n    function transfer(address _to, uint256 _amount) external returns (bool);\\n}\\n\\n/**\\n * @title   BaseFeeCollectorInterface\\n * @author  OpenSea Protocol Team\\n * @notice  BaseFeeCollectorInterface contains all external function interfaces\\n *          for the fee collector implementation.\\n */\\ninterface BaseFeeCollectorInterface {\\n    /**\\n     * @notice Withdrawals the given amount of ERC20 tokens from the provided\\n     *         contract address\\n     *\\n     * @param withdrawalWallet The wallet to be used for withdrawal.\\n     * @param tokenContract    The ERC20 token address to be withdrawn.\\n     * @param amount           The amount of ERC20 tokens to be withdrawn.\\n     */\\n    function withdrawERC20Tokens(\\n        address withdrawalWallet,\\n        address tokenContract,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice Withdrawals the given amount of the native token from this\\n     *         contract to the withdrawal address. Requires the caller to\\n     *         have the operator role, and the withdrawal wallet to be in\\n     *         the allowlisted wallets.\\n     *\\n     * @param withdrawalWallet The wallet to be used for withdrawal.\\n     * @param amount           The amount of the native token to be withdrawn.\\n     */\\n    function withdraw(address withdrawalWallet, uint256 amount) external;\\n\\n    /**\\n     * @notice Adds a new withdrawal address to the mapping. Requires\\n     *         the caller to be the owner and the withdrawal\\n     *         wallet to not be the null address.\\n     *\\n     * @param newWithdrawalWallet  The new withdrawal address.\\n     */\\n    function addWithdrawAddress(address newWithdrawalWallet) external;\\n\\n    /**\\n     * @notice Removes the withdrawal address from the mapping. Requires\\n     *         the caller to be the owner.\\n     *\\n     * @param withdrawalWallet  The withdrawal address to\\n     *                             remove.\\n     */\\n    function removeWithdrawAddress(address withdrawalWallet) external;\\n\\n    /**\\n     * @notice Assign the given address with the ability to operate the wallet.\\n     *\\n     * @param operatorToAssign The address to assign the operator role.\\n     */\\n    function assignOperator(address operatorToAssign) external;\\n\\n    /**\\n     * @notice An external view function that returns a boolean.\\n     *\\n     * @return A boolean that determines if the provided address is\\n     *         a valid withdrawal wallet.\\n     */\\n    function isWithdrawalWallet(address withdrawalWallet)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BaseFeeCollectorEventsAndErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n * @notice BaseFeeCollectorEventsAndErrors contains errors and events\\n *         related to fee collector interaction.\\n */\\ninterface BaseFeeCollectorEventsAndErrors {\\n    /**\\n     * @dev Emit an event whenever the contract owner registers a\\n     *      new operator.\\n     *\\n     * @param newOperator The new operator of the contract.\\n     */\\n    event OperatorUpdated(address newOperator);\\n\\n    /**\\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\\n     *      value.\\n     *\\n     * @param token      The token for which the ERC20 transfer was attempted.\\n     * @param to         The recipient of the attempted ERC20 transfer.\\n     * @param amount     The amount for the attempted ERC20 transfer.\\n     */\\n    error BadReturnValueFromERC20OnTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when attempting to withdrawal\\n     *      an amount greater than the current balance.\\n     */\\n    error InvalidNativeTokenAmount(uint256 amount);\\n\\n    /**\\n     * @dev Revert with an error when attempting to initialize\\n     *      outside the constructor.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev Revert with an error when attempting to call an operation\\n     *      while the caller is not the owner of the wallet.\\n     */\\n    error InvalidOperator();\\n\\n    /**\\n     * @dev Revert with an error when attempting to call a withdrawal\\n     *      operation with an incorrect withdrawal wallet.\\n     */\\n    error InvalidWithdrawalWallet(address withdrawalWallet);\\n\\n    /**\\n     * @dev Revert with an error when attempting to set a\\n     *      new withdrawal wallet and supplying the null address.\\n     */\\n    error NewWithdrawalWalletIsNullAddress();\\n\\n    /**\\n     * @dev Revert with an error when attempting to set the\\n     *      new operator and supplying the null address.\\n     */\\n    error OperatorIsNullAddress();\\n\\n    /**\\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\\n     *      transfer reverts.\\n     *\\n     * @param token      The token for which the transfer was attempted.\\n     * @param to         The recipient of the attempted transfer.\\n     * @param identifier The identifier for the attempted transfer.\\n     * @param amount     The amount for the attempted transfer.\\n     */\\n    error TokenTransferGenericFailure(\\n        address token,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TwoStepOwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n * @title   TwoStepOwnableInterface\\n * @author  OpenSea Protocol Team\\n * @notice  TwoStepOwnableInterface contains all external function interfaces,\\n *          events and errors for the two step ownable access control module.\\n */\\ninterface TwoStepOwnableInterface {\\n    /**\\n     * @dev Emit an event whenever the contract owner registers a\\n     *      new potential owner.\\n     *\\n     * @param newPotentialOwner The new potential owner of the contract.\\n     */\\n    event PotentialOwnerUpdated(address newPotentialOwner);\\n\\n    /**\\n     * @dev Emit an event whenever contract ownership is transferred.\\n     *\\n     * @param previousOwner The previous owner of the contract.\\n     * @param newOwner      The new owner of the contract.\\n     */\\n    event OwnershipTransferred(address previousOwner, address newOwner);\\n\\n    /**\\n     * @dev Revert with an error when attempting to set an owner\\n     *      that is already set.\\n     */\\n    error OwnerAlreadySet(address currentOwner);\\n\\n    /**\\n     * @dev Revert with an error when attempting to set the initial\\n     *      owner and supplying the null address.\\n     */\\n    error InitialOwnerIsNullAddress();\\n\\n    /**\\n     * @dev Revert with an error when attempting to call an operation\\n     *      while the caller is not the owner.\\n     */\\n    error CallerIsNotOwner();\\n\\n    /**\\n     * @dev Revert with an error when attempting to register a new potential\\n     *      owner and supplying the null address.\\n     */\\n    error NewPotentialOwnerIsNullAddress();\\n\\n    /**\\n     * @dev Revert with an error when attempting to claim ownership of the\\n     *      contract with a caller that is not the current potential owner.\\n     */\\n    error CallerIsNotNewPotentialOwner();\\n\\n    /**\\n     * @notice Initiate ownership transfer by assigning a new potential owner\\n     *         to this contract. Once set, the new potential owner may call\\n     *         `acceptOwnership` to claim ownership. Only the owner may call\\n     *         this function.\\n     *\\n     * @param newPotentialOwner The address for which to initiate ownership\\n     *                          transfer to.\\n     */\\n    function transferOwnership(address newPotentialOwner) external;\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any.\\n     *         Only the owner of this contract may call this function.\\n     */\\n    function cancelOwnershipTransfer() external;\\n\\n    /**\\n     * @notice Accept ownership of this contract. Only the account that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     */\\n    function acceptOwnership() external;\\n\\n    /**\\n     * @notice An external view function that returns the potential owner.\\n     *\\n     * @return The address of the potential owner.\\n     */\\n    function potentialOwner() external view returns (address);\\n\\n    /**\\n     * @notice An external view function that returns the owner.\\n     *\\n     * @return The address of the owner.\\n     */\\n    function owner() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 19066\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BadReturnValueFromERC20OnTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotNewPotentialOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitialOwnerIsNullAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InvalidNativeTokenAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"withdrawalWallet\",\"type\":\"address\"}],\"name\":\"InvalidWithdrawalWallet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewPotentialOwnerIsNullAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewWithdrawalWalletIsNullAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperatorIsNullAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"OwnerAlreadySet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenTransferGenericFailure\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPotentialOwner\",\"type\":\"address\"}],\"name\":\"PotentialOwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWithdrawalWallet\",\"type\":\"address\"}],\"name\":\"addWithdrawAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operatorToAssign\",\"type\":\"address\"}],\"name\":\"assignOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerToSet\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"withdrawalWallet\",\"type\":\"address\"}],\"name\":\"isWithdrawalWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"potentialOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"withdrawalWallet\",\"type\":\"address\"}],\"name\":\"removeWithdrawAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPotentialOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"withdrawalWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedTokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unwrapAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"withdrawalWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"withdrawalWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EthereumFeeCollector","CompilerVersion":"v0.8.14+commit.80d49f37","OptimizationUsed":"1","Runs":"19066","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]