[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface tokenRecipient { \r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; \r\n}\r\n\r\ncontract ZFX {\r\n    string public name = 'ZFX';\r\n    string public symbol = 'ZFX';\r\n    uint8 public decimals = 18;\r\n    uint public totalSupply = 1000000 * 10 ** uint(decimals);\r\n    address public owner;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) revert();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor function\r\n     *\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n    constructor(address creator) public {\r\n        balanceOf[creator] = totalSupply;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != address(0x0));\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        // Subtract from the sender\r\n        balanceOf[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` on behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n    \r\n    function mint(address _to, uint _amount) external onlyOwner {\r\n        balanceOf[_to] += _amount;\r\n        totalSupply += _amount;\r\n        require(totalSupply >= _amount);\r\n        emit Transfer(address(0), address(this), _amount);\r\n        emit Transfer(address(this), _to, _amount);\r\n    }\r\n}\r\n\r\ncontract Token {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n    \r\n    uint8 public decimals;\r\n}\r\n\r\ncontract Exchange {\r\n    struct Order {\r\n        address creator;\r\n        address token;\r\n        bool buy;\r\n        uint price;\r\n        uint amount;\r\n    }\r\n    \r\n    address public owner;\r\n    uint public feeDeposit = 500;\r\n    \r\n    mapping (uint => Order) orders;\r\n    uint currentOrderId = 0;\r\n    \r\n    ZFX public ZFXToken;\r\n    \r\n    /* Token address (0x0 - Ether) => User address => balance */\r\n    mapping (address => mapping (address => uint)) public balanceOf;\r\n    \r\n    event FundTransfer(address backer, uint amount, bool isContribution);\r\n    \r\n    event PlaceSell(address indexed token, address indexed user, uint price, uint amount, uint id);\r\n    event PlaceBuy(address indexed token, address indexed user, uint price, uint amount, uint id);\r\n    event FillOrder(uint indexed id, address indexed user, uint amount);\r\n    event CancelOrder(uint indexed id);\r\n    event Deposit(address indexed token, address indexed user, uint amount);\r\n    event Withdraw(address indexed token, address indexed user, uint amount);\r\n    event BalanceChanged(address indexed token, address indexed user, uint value);\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) revert();\r\n        _;\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n        ZFXToken = new ZFX(msg.sender);\r\n    }\r\n    \r\n    function safeAdd(uint a, uint b) private pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    \r\n    function safeSub(uint a, uint b) private pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function safeMul(uint a, uint b) private pure returns (uint) {\r\n        if (a == 0) {\r\n          return 0;\r\n        }\r\n        \r\n        uint c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function decFeeDeposit(uint delta) external onlyOwner {\r\n        feeDeposit = safeSub(feeDeposit, delta);\r\n    }\r\n    \r\n    function calcAmountEther(address tokenAddr, uint price, uint amount) private view returns (uint) {\r\n        uint k = 10;\r\n        k = k ** Token(tokenAddr).decimals();\r\n        return safeMul(amount, price) / k;\r\n    }\r\n    \r\n    function balanceAdd(address tokenAddr, address user, uint amount) private {\r\n        balanceOf[tokenAddr][user] =\r\n            safeAdd(balanceOf[tokenAddr][user], amount);\r\n    }\r\n    \r\n    function balanceSub(address tokenAddr, address user, uint amount) private {\r\n        require(balanceOf[tokenAddr][user] >= amount);\r\n        balanceOf[tokenAddr][user] =\r\n            safeSub(balanceOf[tokenAddr][user], amount);\r\n    }\r\n    \r\n    function placeBuy(address tokenAddr, uint price, uint amount) external {\r\n        require(price > 0 && amount > 0);\r\n        uint amountEther = calcAmountEther(tokenAddr, price, amount);\r\n        require(amountEther > 0);\r\n        balanceSub(0x0, msg.sender, amountEther);\r\n        emit BalanceChanged(0x0, msg.sender, balanceOf[0x0][msg.sender]);\r\n        orders[currentOrderId] = Order({\r\n            creator: msg.sender,\r\n            token: tokenAddr,\r\n            buy: true,\r\n            price: price,\r\n            amount: amount\r\n        });\r\n        emit PlaceBuy(tokenAddr, msg.sender, price, amount, currentOrderId);\r\n        currentOrderId++;\r\n        \r\n        ZFXToken.mint(msg.sender, 1000000000000000000);\r\n    }\r\n    \r\n    function placeSell(address tokenAddr, uint price, uint amount) external {\r\n        require(price > 0 && amount > 0);\r\n        uint amountEther = calcAmountEther(tokenAddr, price, amount);\r\n        require(amountEther > 0);\r\n        balanceSub(tokenAddr, msg.sender, amount);\r\n        emit BalanceChanged(tokenAddr, msg.sender, balanceOf[tokenAddr][msg.sender]);\r\n        orders[currentOrderId] = Order({\r\n            creator: msg.sender,\r\n            token: tokenAddr,\r\n            buy: false,\r\n            price: price,\r\n            amount: amount\r\n        });\r\n        emit PlaceSell(tokenAddr, msg.sender, price, amount, currentOrderId);\r\n        currentOrderId++;\r\n        \r\n        ZFXToken.mint(msg.sender, 1000000000000000000);\r\n    }\r\n    \r\n    function fillOrder(uint id, uint amount) external {\r\n        require(id < currentOrderId);\r\n        require(amount > 0);\r\n        require(orders[id].creator != msg.sender);\r\n        require(orders[id].amount >= amount);\r\n        uint amountEther = calcAmountEther(orders[id].token, orders[id].price, amount);\r\n        if (orders[id].buy) {\r\n            /* send tokens from sender to creator */\r\n            // sub from sender\r\n            balanceSub(orders[id].token, msg.sender, amount);\r\n            emit BalanceChanged(\r\n                orders[id].token,\r\n                msg.sender,\r\n                balanceOf[orders[id].token][msg.sender]\r\n            );\r\n            \r\n            // add to creator\r\n            balanceAdd(orders[id].token, orders[id].creator, amount);\r\n            emit BalanceChanged(\r\n                orders[id].token,\r\n                orders[id].creator,\r\n                balanceOf[orders[id].token][orders[id].creator]\r\n            );\r\n            \r\n            /* send Ether to sender */\r\n            balanceAdd(0x0, msg.sender, amountEther);\r\n            emit BalanceChanged(\r\n                0x0,\r\n                msg.sender,\r\n                balanceOf[0x0][msg.sender]\r\n            );\r\n        } else {\r\n            /* send Ether from sender to creator */\r\n            // sub from sender\r\n            balanceSub(0x0, msg.sender, amountEther);\r\n            emit BalanceChanged(\r\n                0x0,\r\n                msg.sender,\r\n                balanceOf[0x0][msg.sender]\r\n            );\r\n            \r\n            // add to creator\r\n            balanceAdd(0x0, orders[id].creator, amountEther);\r\n            emit BalanceChanged(\r\n                0x0,\r\n                orders[id].creator,\r\n                balanceOf[0x0][orders[id].creator]\r\n            );\r\n            \r\n            /* send tokens to sender */\r\n            balanceAdd(orders[id].token, msg.sender, amount);\r\n            emit BalanceChanged(\r\n                orders[id].token,\r\n                msg.sender,\r\n                balanceOf[orders[id].token][msg.sender]\r\n            );\r\n        }\r\n        orders[id].amount -= amount;\r\n        emit FillOrder(id, msg.sender, orders[id].amount);\r\n        \r\n        ZFXToken.mint(msg.sender, 1000000000000000000);\r\n    }\r\n    \r\n    function cancelOrder(uint id) external {\r\n        require(id < currentOrderId);\r\n        require(orders[id].creator == msg.sender);\r\n        require(orders[id].amount > 0);\r\n        if (orders[id].buy) {\r\n            uint amountEther = calcAmountEther(orders[id].token, orders[id].price, orders[id].amount);\r\n            balanceAdd(0x0, msg.sender, amountEther);\r\n            emit BalanceChanged(0x0, msg.sender, balanceOf[0x0][msg.sender]);\r\n        } else {\r\n            balanceAdd(orders[id].token, msg.sender, orders[id].amount);\r\n            emit BalanceChanged(orders[id].token, msg.sender, balanceOf[orders[id].token][msg.sender]);\r\n        }\r\n        orders[id].amount = 0;\r\n        emit CancelOrder(id);\r\n    }\r\n    \r\n    function getFee(address user) public view returns (uint) {\r\n        uint fee = feeDeposit * ZFXToken.balanceOf(user) * 10 / ZFXToken.totalSupply();\r\n        return fee < feeDeposit ? feeDeposit - fee : 0;\r\n    }\r\n    \r\n    function () external payable {\r\n        require(msg.value > 0);\r\n        uint fee = msg.value * getFee(msg.sender) / 10000;\r\n        require(msg.value > fee);\r\n        balanceAdd(0x0, owner, fee);\r\n        \r\n        uint toAdd = msg.value - fee;\r\n        balanceAdd(0x0, msg.sender, toAdd);\r\n        \r\n        emit Deposit(0x0, msg.sender, toAdd);\r\n        emit BalanceChanged(0x0, msg.sender, balanceOf[0x0][msg.sender]);\r\n        \r\n        emit FundTransfer(msg.sender, toAdd, true);\r\n    }\r\n    \r\n    function depositToken(address tokenAddr, uint amount) external {\r\n        require(tokenAddr != 0x0);\r\n        require(amount > 0);\r\n        Token(tokenAddr).transferFrom(msg.sender, this, amount);\r\n        balanceAdd(tokenAddr, msg.sender, amount);\r\n        \r\n        emit Deposit(tokenAddr, msg.sender, amount);\r\n        emit BalanceChanged(tokenAddr, msg.sender, balanceOf[tokenAddr][msg.sender]);\r\n    }\r\n    \r\n    function withdrawEther(uint amount) external {\r\n        require(amount > 0);\r\n        balanceSub(0x0, msg.sender, amount);\r\n        msg.sender.transfer(amount);\r\n        \r\n        emit Withdraw(0x0, msg.sender, amount);\r\n        emit BalanceChanged(0x0, msg.sender, balanceOf[0x0][msg.sender]);\r\n        \r\n        emit FundTransfer(msg.sender, amount, false);\r\n    }\r\n    \r\n    function withdrawToken(address tokenAddr, uint amount) external {\r\n        require(tokenAddr != 0x0);\r\n        require(amount > 0);\r\n        balanceSub(tokenAddr, msg.sender, amount);\r\n        Token(tokenAddr).transfer(msg.sender, amount);\r\n        \r\n        emit Withdraw(tokenAddr, msg.sender, amount);\r\n        emit BalanceChanged(tokenAddr, msg.sender, balanceOf[tokenAddr][msg.sender]);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"placeSell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delta\",\"type\":\"uint256\"}],\"name\":\"decFeeDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"placeBuy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZFXToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fillOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isContribution\",\"type\":\"bool\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"PlaceSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"PlaceBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FillOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"CancelOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BalanceChanged\",\"type\":\"event\"}]","ContractName":"Exchange","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0ab7dd535cfe883971234c6b54288e056f4a7fbbb0255c97875ed95a71e10dbd"}]