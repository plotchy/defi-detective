[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/erc4626/vault/ZeroBTC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport \\\"./ZeroBTCConfig.sol\\\";\\nimport \\\"./ZeroBTCLoans.sol\\\";\\n\\ncontract ZeroBTC is ZeroBTCBase, ZeroBTCCache, ZeroBTCConfig, ZeroBTCLoans {\\n  constructor(\\n    IGatewayRegistry gatewayRegistry,\\n    IChainlinkOracle btcEthPriceOracle,\\n    IChainlinkOracle gasPriceOracle,\\n    IRenBtcEthConverter renBtcConverter,\\n    uint256 cacheTimeToLive,\\n    uint256 maxLoanDuration,\\n    uint256 targetEthReserve,\\n    uint256 maxGasProfitShareBips,\\n    address zeroFeeRecipient,\\n    address _asset,\\n    address _proxyContract\\n  )\\n    ZeroBTCBase(\\n      gatewayRegistry,\\n      btcEthPriceOracle,\\n      gasPriceOracle,\\n      renBtcConverter,\\n      cacheTimeToLive,\\n      maxLoanDuration,\\n      targetEthReserve,\\n      maxGasProfitShareBips,\\n      zeroFeeRecipient,\\n      _asset,\\n      _proxyContract\\n    )\\n  {}\\n\\n  function initialize(\\n    address initialGovernance,\\n    uint256 zeroBorrowFeeBips,\\n    uint256 renBorrowFeeBips,\\n    uint256 zeroBorrowFeeStatic,\\n    uint256 renBorrowFeeStatic,\\n    uint256 zeroFeeShareBips,\\n    address initialHarvester\\n  ) public payable virtual override {\\n    ZeroBTCBase.initialize(\\n      initialGovernance,\\n      zeroBorrowFeeBips,\\n      renBorrowFeeBips,\\n      zeroBorrowFeeStatic,\\n      renBorrowFeeStatic,\\n      zeroFeeShareBips,\\n      initialHarvester\\n    );\\n    _updateGlobalCache(_state);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/vault/ZeroBTCConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport \\\"./ZeroBTCCache.sol\\\";\\nimport \\\"../utils/Math.sol\\\";\\nimport { IStrategy } from \\\"../../interfaces/IStrategy.sol\\\";\\n\\nabstract contract ZeroBTCConfig is ZeroBTCCache {\\n  using ModuleStateCoder for ModuleState;\\n  using GlobalStateCoder for GlobalState;\\n  using LoanRecordCoder for LoanRecord;\\n  using Math for uint256;\\n\\n  /*//////////////////////////////////////////////////////////////\\n                         Governance Actions\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function setGlobalFees(\\n    uint256 zeroBorrowFeeBips,\\n    uint256 renBorrowFeeBips,\\n    uint256 zeroBorrowFeeStatic,\\n    uint256 renBorrowFeeStatic,\\n    uint256 zeroFeeShareBips\\n  ) external onlyGovernance nonReentrant {\\n    _setFees(zeroBorrowFeeBips, renBorrowFeeBips, zeroBorrowFeeStatic, renBorrowFeeStatic, zeroFeeShareBips);\\n  }\\n\\n  function setModuleGasFees(\\n    address module,\\n    uint256 loanGas,\\n    uint256 repayGas\\n  ) external onlyGovernance nonReentrant {\\n    (GlobalState state, ) = _getUpdatedGlobalState();\\n    ModuleState moduleState = _getExistingModuleState(module);\\n    // Divide loan and repay gas by 10000\\n    uint256 loanGasE4 = loanGas.uncheckedDivUpE4();\\n    uint256 repayGasE4 = repayGas.uncheckedDivUpE4();\\n    moduleState = moduleState.setGasParams(loanGasE4, repayGasE4);\\n    _updateModuleCache(state, moduleState, module);\\n  }\\n\\n  function addModule(\\n    address module,\\n    ModuleType moduleType,\\n    uint256 loanGas,\\n    uint256 repayGas\\n  ) external onlyGovernance nonReentrant {\\n    if (module != address(0)) {\\n      address moduleAsset = IZeroModule(module).asset();\\n      if (moduleAsset != asset) {\\n        revert ModuleAssetDoesNotMatch(moduleAsset);\\n      }\\n    }\\n\\n    if (loanGas == 0 || repayGas == 0) {\\n      revert InvalidNullValue();\\n    }\\n\\n    // Module type can not be null unless address is 0\\n    // If address is 0, module type must be null\\n    if ((moduleType == ModuleType.Null) != (module == address(0))) {\\n      revert InvalidModuleType();\\n    }\\n\\n    // Divide loan and repay gas by 10000\\n    uint256 loanGasE4 = loanGas.uncheckedDivUpE4();\\n    uint256 repayGasE4 = repayGas.uncheckedDivUpE4();\\n\\n    // Get updated global state, with cache refreshed if it had expired\\n    (GlobalState state, ) = _getUpdatedGlobalState();\\n\\n    // Calculate the new gas refunds for the module\\n    (\\n      uint256 ethRefundForLoanGas,\\n      uint256 ethRefundForRepayGas,\\n      uint256 btcFeeForLoanGas,\\n      uint256 btcFeeForRepayGas\\n    ) = _calculateModuleGasFees(state, loanGasE4, repayGasE4);\\n\\n    // Write the module data to storage\\n    _moduleFees[module] = ModuleStateCoder.encode(\\n      moduleType,\\n      loanGasE4,\\n      repayGasE4,\\n      ethRefundForLoanGas,\\n      ethRefundForRepayGas,\\n      btcFeeForLoanGas,\\n      btcFeeForRepayGas,\\n      block.timestamp\\n    );\\n\\n    // delegatecall initialize on the module\\n    (bool success, ) = module.delegatecall(abi.encodeWithSelector(IZeroModule.initialize.selector));\\n    require(success, \\\"module uninitialized\\\");\\n\\n    emit ModuleStateUpdated(module, moduleType, loanGasE4, repayGasE4);\\n  }\\n\\n  function removeModule(address module) external onlyGovernance nonReentrant {\\n    _moduleFees[module] = DefaultModuleState;\\n  }\\n\\n  function setHarvesters(address[] memory users) external onlyGovernance nonReentrant {\\n    for (uint256 i = 0; i < users.length; i++) _isHarvester[users[i]] = true;\\n  }\\n\\n  function removeHarvesters(address[] memory users) external onlyGovernance nonReentrant {\\n    for (uint256 i = 0; i < users.length; i++) _isHarvester[users[i]] = false;\\n  }\\n\\n  function setAuthorizedUsers(address[] memory users) external onlyGovernance nonReentrant {\\n    for (uint256 i = 0; i < users.length; i++) _authorized[users[i]] = true;\\n  }\\n\\n  function removeAuthorizedUsers(address[] memory users) external onlyGovernance nonReentrant {\\n    for (uint256 i = 0; i < users.length; i++) _authorized[users[i]] = false;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/vault/ZeroBTCLoans.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport \\\"./ZeroBTCCache.sol\\\";\\nimport { DefaultLoanRecord } from \\\"../utils/LoanRecordCoder.sol\\\";\\nimport { BaseModule } from \\\"../BaseModule.sol\\\";\\nimport \\\"../utils/FixedPointMathLib.sol\\\";\\n\\nuint256 constant ReceiveLoanError_selector = 0x83f44e2200000000000000000000000000000000000000000000000000000000;\\nuint256 constant RepayLoanError_selector = 0x0ccaea8800000000000000000000000000000000000000000000000000000000;\\nuint256 constant RepayLoan_selector = 0x2584dde800000000000000000000000000000000000000000000000000000000;\\nuint256 constant ReceiveLoan_selector = 0x332b578c00000000000000000000000000000000000000000000000000000000;\\n\\nuint256 constant ModuleCall_borrower_offset = 0x04;\\nuint256 constant ModuleCall_amount_offset = 0x24;\\nuint256 constant ModuleCall_loanId_offset = 0x44;\\nuint256 constant ModuleCall_data_head_offset = 0x64;\\nuint256 constant ModuleCall_data_length_offset = 0x84;\\nuint256 constant ModuleCall_data_offset = 0x80;\\nuint256 constant ModuleCall_calldata_baseLength = 0xa4;\\n\\nabstract contract ZeroBTCLoans is ZeroBTCCache {\\n  using ModuleStateCoder for ModuleState;\\n  using GlobalStateCoder for GlobalState;\\n  using LoanRecordCoder for LoanRecord;\\n  using SafeTransferLib for address;\\n  using FixedPointMathLib for uint256;\\n  using Math for uint256;\\n\\n  modifier onlyHarvester() {\\n    require(_isHarvester[msg.sender], \\\"cannot call unless harvester\\\");\\n    _;\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                             Constructor\\n  //////////////////////////////////////////////////////////////*/\\n\\n  constructor() {\\n    if (\\n      uint256(bytes32(IZeroModule.receiveLoan.selector)) != ReceiveLoan_selector ||\\n      uint256(bytes32(IZeroModule.repayLoan.selector)) != RepayLoan_selector ||\\n      uint256(bytes32(ReceiveLoanError.selector)) != ReceiveLoanError_selector ||\\n      uint256(bytes32(RepayLoanError.selector)) != RepayLoanError_selector\\n    ) {\\n      revert InvalidSelector();\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                        External Loan Actions\\n  //////////////////////////////////////////////////////////////*/\\n\\n  /**\\n   * @param module Module to use for conversion\\n   * @param borrower Account to receive loan\\n   * @param borrowAmount Amount of vault's underlying asset to borrow\\n   * @param nonce Nonce for the loan, provided by keeper\\n   * @param data User provided data\\n   */\\n  function loan(\\n    address module,\\n    address borrower,\\n    uint256 borrowAmount,\\n    uint256 nonce,\\n    bytes memory data\\n  ) external override nonReentrant {\\n    (GlobalState state, ModuleState moduleState) = _getUpdatedGlobalAndModuleState(module);\\n\\n    uint256 loanId = _deriveLoanId(msg.sender, _deriveLoanPHash(data));\\n\\n    (uint256 actualBorrowAmount, uint256 lenderDebt, uint256 btcFeeForLoanGas) = _calculateLoanFees(\\n      state,\\n      moduleState,\\n      borrowAmount\\n    );\\n\\n    // Store loan information and lock lender's shares\\n    _borrowFrom(uint256(loanId), msg.sender, borrower, actualBorrowAmount, lenderDebt, btcFeeForLoanGas);\\n\\n    if (uint256(moduleState.getModuleType()) > 0) {\\n      // Execute module interaction\\n      _executeReceiveLoan(module, borrower, loanId, actualBorrowAmount, data);\\n    } else {\\n      // If module does not override loan behavior,\\n      asset.safeTransfer(borrower, actualBorrowAmount);\\n    }\\n\\n    tx.origin.safeTransferETH(moduleState.getEthRefundForLoanGas());\\n  }\\n\\n  /**\\n   * @param module Module used for the loan\\n   * @param borrower Address of account that took out the loan\\n   * @param borrowAmount Original loan amount before fees\\n   * @param nonce Nonce for the loan\\n   * @param data Extra data used by module\\n   * @param lender Address of account that gave the loan\\n   * @param nHash Nonce hash from RenVM deposit\\n   * @param renSignature Signature from RenVM\\n   */\\n  function repay(\\n    address module,\\n    address borrower,\\n    uint256 borrowAmount,\\n    uint256 nonce,\\n    bytes memory data,\\n    address lender,\\n    bytes32 nHash,\\n    bytes memory renSignature\\n  ) external override nonReentrant {\\n    (GlobalState state, ModuleState moduleState) = _getUpdatedGlobalAndModuleState(module);\\n\\n    bytes32 pHash = _deriveLoanPHash(data);\\n    uint256 repaidAmount = _getGateway().mint(pHash, borrowAmount, nHash, renSignature);\\n\\n    uint256 loanId = _deriveLoanId(lender, pHash);\\n    if (moduleState.getModuleType() == ModuleType.LoanAndRepayOverride) {\\n      repaidAmount = _executeRepayLoan(module, borrower, loanId, repaidAmount, data);\\n    }\\n    LoanRecord loanRecord = _deleteLoan(loanId);\\n\\n    _repayTo(state, moduleState, loanRecord, lender, loanId, repaidAmount);\\n\\n    tx.origin.safeTransferETH(moduleState.getEthRefundForRepayGas());\\n  }\\n\\n  function closeExpiredLoan(\\n    address module,\\n    address borrower,\\n    uint256 borrowAmount,\\n    uint256 nonce,\\n    bytes memory data,\\n    address lender\\n  ) external override nonReentrant {\\n    uint256 loanId = _deriveLoanId(lender, _deriveLoanPHash(data));\\n    LoanRecord loanRecord = _deleteLoan(loanId);\\n    if (loanRecord.getExpiry() >= block.timestamp) {\\n      revert LoanNotExpired(loanId);\\n    }\\n    (GlobalState state, ModuleState moduleState) = _getUpdatedGlobalAndModuleState(module);\\n    ModuleType moduleType = moduleState.getModuleType();\\n    uint256 repaidAmount = 0;\\n    if (moduleType == ModuleType.LoanAndRepayOverride) {\\n      repaidAmount = _executeRepayLoan(module, borrower, loanId, repaidAmount, data);\\n    }\\n\\n    _repayTo(state, moduleState, loanRecord, lender, loanId, repaidAmount);\\n\\n    tx.origin.safeTransferETH(moduleState.getEthRefundForRepayGas());\\n  }\\n\\n  function earn() external override onlyHarvester nonReentrant {\\n    (GlobalState state, ) = _getUpdatedGlobalState();\\n    (uint256 unburnedGasReserveShares, uint256 unburnedZeroFeeShares) = state.getUnburnedShares();\\n    _state = state.setUnburnedShares(0, 0);\\n    uint256 totalFeeShares;\\n    uint256 totalFees;\\n    uint256 supply = _totalSupply;\\n    uint256 assets = totalAssets();\\n    unchecked {\\n      totalFeeShares = unburnedGasReserveShares + unburnedZeroFeeShares;\\n      totalFees = totalFeeShares.mulDivDown(assets, supply);\\n      _totalSupply = supply - totalFeeShares;\\n    }\\n    uint256 minimumEthOut = (_btcToEth(totalFees, state.getSatoshiPerEth()) * 98) / 100;\\n    asset.safeTransfer(address(_renBtcConverter), totalFees);\\n    uint256 actualEthOut = _renBtcConverter.convertToEth(minimumEthOut);\\n    uint256 ethForZero = unburnedZeroFeeShares.mulDivDown(actualEthOut, totalFeeShares);\\n    _zeroFeeRecipient.safeTransferETH(ethForZero);\\n    emit FeeSharesBurned(actualEthOut - ethForZero, unburnedGasReserveShares, ethForZero, unburnedZeroFeeShares);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                          External Getters\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function getOutstandingLoan(uint256 loanId)\\n    external\\n    view\\n    override\\n    returns (\\n      uint256 sharesLocked,\\n      uint256 actualBorrowAmount,\\n      uint256 lenderDebt,\\n      uint256 btcFeeForLoanGas,\\n      uint256 expiry\\n    )\\n  {\\n    return _outstandingLoans[loanId].decode();\\n  }\\n\\n  /**\\n   * @dev Derives a loan ID from the combination of the loan's\\n   * pHash, derived from the loan parameters (module, borrower,\\n   * borrowAmount, nonce, data), and the lender's address.\\n   */\\n  function calculateLoanId(\\n    address module,\\n    address borrower,\\n    uint256 borrowAmount,\\n    uint256 nonce,\\n    bytes memory data,\\n    address lender\\n  ) external view override returns (uint256) {\\n    return _deriveLoanId(lender, _deriveLoanPHash(data));\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                          Module Interactions\\n  //////////////////////////////////////////////////////////////*/\\n\\n  // function _prepareModuleCalldata(\\n  //   uint256 selector,\\n  //   address borrower,\\n  //   uint256 amount,\\n  //   uint256 loanId,\\n  //   bytes memory data\\n  // ) internal view {\\n  //   bytes32 startptr;\\n  //   bytes32 datalocation;\\n  //   console.log(amount);\\n  //   assembly {\\n  //     let startPtr := sub(data, ModuleCall_data_offset)\\n  //     startptr := startPtr\\n  //     // Write function selector\\n  //     mstore(startPtr, selector)\\n  //     // Write borrower\\n  //     mstore(add(startPtr, ModuleCall_borrower_offset), amount)\\n  //     datalocation := mload(add(startPtr, ModuleCall_amount_offset))\\n  //   }\\n  //   console.logBytes32(datalocation);\\n  //   assembly {\\n  //     let startPtr := sub(data, ModuleCall_data_offset)\\n  //     // Write borrowAmount or repaidAmount\\n  //     mstore(add(startPtr, ModuleCall_amount_offset), amount)\\n  //     // Write loanId\\n  //     mstore(add(startPtr, ModuleCall_loanId_offset), loanId)\\n  //     // Write data offset\\n  //     mstore(add(startPtr, ModuleCall_data_head_offset), ModuleCall_data_length_offset)\\n  //   }\\n  // }\\n\\n  function _executeReceiveLoan(\\n    address module,\\n    address borrower,\\n    uint256 loanId,\\n    uint256 borrowAmount,\\n    bytes memory data\\n  ) internal {\\n    // _prepareModuleCalldata(ReceiveLoan_selector, borrower, borrowAmount, loanId, data);\\n    (bool success, ) = module.delegatecall(\\n      abi.encodeWithSelector(bytes4(bytes32(ReceiveLoan_selector)), borrower, borrowAmount, loanId, data)\\n    );\\n    require(success, \\\"!module\\\");\\n    /* assembly {\\n      let startPtr := sub(data, ModuleCall_data_offset)\\n      // Size of data + (selector, borrower, borrowAmount, loanId, data_offset, data_length)\\n      let calldataLength := add(mload(data), ModuleCall_calldata_baseLength)\\n      // Delegatecall module\\n      let status := delegatecall(gas(), module, startPtr, calldataLength, 0, 0)\\n\\n      // Handle failures\\n      if iszero(status) {\\n        // If return data was provided, bubble up\\n        if returndatasize() {\\n          returndatacopy(0, 0, returndatasize())\\n          revert(0, returndatasize())\\n        }\\n        // If no return data was provided, throw generic error\\n        // Write ReceiveLoanError.selector\\n        mstore(sub(startPtr, 0x20), ReceiveLoanError_selector)\\n        // Write module to memory\\n        mstore(sub(startPtr, 0x1c), module)\\n        // Update data offset\\n        mstore(add(startPtr, 0x64), 0xa0)\\n        // Revert with ReceiveLoanError\\n        revert(sub(startPtr, 0x20), add(calldataLength, 0x20))\\n      }\\n    }*/\\n  }\\n\\n  function _executeRepayLoan(\\n    address module,\\n    address borrower,\\n    uint256 loanId,\\n    uint256 repaidAmount,\\n    bytes memory data\\n  ) internal returns (uint256 collateralToUnlock) {\\n    // _prepareModuleCalldata(RepayLoan_selector, borrower, repaidAmount, loanId, data);\\n    (bool success, bytes memory _data) = module.delegatecall(\\n      abi.encodeWithSelector(bytes4(bytes32(RepayLoan_selector)), borrower, repaidAmount, loanId, data)\\n    );\\n    require(success, \\\"!module\\\");\\n    (collateralToUnlock) = abi.decode(_data, (uint256));\\n    /* assembly {\\n      let startPtr := sub(data, ModuleCall_data_offset)\\n      // Size of data + (selector, borrower, borrowAmount, loanId, data_offset, data_length)\\n      let calldataLength := add(mload(data), ModuleCall_calldata_baseLength)\\n      // Delegatecall module\\n      let status := delegatecall(gas(), module, startPtr, calldataLength, 0, 0x20)\\n\\n      // Handle failures\\n      if iszero(status) {\\n        // If return data was provided, bubble up\\n        if returndatasize() {\\n          returndatacopy(0, 0, returndatasize())\\n          revert(0, returndatasize())\\n        }\\n        // If no return data was provided, throw generic error\\n        // Write RepayLoanError.selector\\n        mstore(sub(startPtr, 0x20), RepayLoanError_selector)\\n        // Write module to memory\\n        mstore(sub(startPtr, 0x1c), module)\\n        // Update data offset\\n        mstore(add(startPtr, 0x64), 0xa0)\\n        // Revert with RepayLoanError\\n        revert(sub(startPtr, 0x20), add(calldataLength, 0x20))\\n      }\\n      collateralToUnlock := mload(0)\\n    } */\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                       Internal Loan Handling\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function _deriveLoanPHash(bytes memory data)\\n    internal\\n    view\\n    RestoreFreeMemoryPointer\\n    RestoreZeroSlot\\n    RestoreFirstTwoUnreservedSlots\\n    returns (bytes32 pHash)\\n  {\\n    assembly {\\n      // Write data hash first, since its buffer will be overwritten by the following section\\n      mstore(0xa0, keccak256(add(data, 0x20), mload(data)))\\n      // Write vault address\\n      mstore(0, address())\\n      // Copy module, borrower, borrowAmount, nonce to hash buffer\\n      calldatacopy(0x20, 0x04, 0x80)\\n      pHash := keccak256(0, 0xc0)\\n    }\\n  }\\n\\n  function _deriveLoanId(address lender, bytes32 pHash) internal pure returns (uint256 loanId) {\\n    assembly {\\n      mstore(0, lender)\\n      mstore(0x20, pHash)\\n      loanId := keccak256(0, 0x40)\\n    }\\n  }\\n\\n  function _getAndSetLoan(uint256 loanId, LoanRecord newRecord) internal returns (LoanRecord oldRecord) {\\n    assembly {\\n      mstore(0, loanId)\\n      mstore(0x20, _outstandingLoans.slot)\\n      let loanSlot := keccak256(0, 0x40)\\n      oldRecord := sload(loanSlot)\\n      sstore(loanSlot, newRecord)\\n    }\\n  }\\n\\n  function _deleteLoan(uint256 loanId) internal returns (LoanRecord loanRecord) {\\n    loanRecord = _getAndSetLoan(loanId, DefaultLoanRecord);\\n\\n    // Ensure the loan exists\\n    if (loanRecord.isNull()) {\\n      revert LoanDoesNotExist(loanId);\\n    }\\n  }\\n\\n  /**\\n   * @notice Lock lender shares until they repay `borrowedAmount`.\\n   *\\n   * `lenderDebt` is higher than `borrowAmount`, the amount leaving\\n   * the contract, to account for gas fees paid to keepers in ETH\\n   * as well as protocol fees from Zero.\\n   *\\n   * The lender will have an amount of shares equivalent to `lenderDebt` locked,\\n   * and will have a fraction of those shares unlocked on repayment.\\n   *\\n   * @param loanId Identifier for the loan\\n   * @param lender Account lending assets\\n   * @param borrower Account borrowing assets\\n   * @param actualBorrowAmount Amount of `asset` sent to borrower\\n   * @param lenderDebt Amount of `asset` lender is responsible for repaying\\n   * @param vaultExpenseWithoutRepayFee Amount of `asset` vault is expecting back without\\n   * accounting for btc value of repay gas refund\\n   */\\n  function _borrowFrom(\\n    uint256 loanId,\\n    address lender,\\n    address borrower,\\n    uint256 actualBorrowAmount,\\n    uint256 lenderDebt,\\n    uint256 vaultExpenseWithoutRepayFee\\n  ) internal {\\n    // Calculate the amount of shares to lock\\n    uint256 shares = previewWithdraw(lenderDebt);\\n\\n    unchecked {\\n      GlobalState state = _state;\\n      uint256 totalBitcoinBorrowed = state.getTotalBitcoinBorrowed();\\n      _state = state.setTotalBitcoinBorrowed(totalBitcoinBorrowed + actualBorrowAmount);\\n    }\\n\\n    LoanRecord oldRecord = _getAndSetLoan(\\n      loanId,\\n      LoanRecordCoder.encode(\\n        shares,\\n        actualBorrowAmount,\\n        lenderDebt,\\n        vaultExpenseWithoutRepayFee,\\n        block.timestamp + _maxLoanDuration\\n      )\\n    );\\n\\n    if (!oldRecord.isNull()) {\\n      revert LoanIdNotUnique(loanId);\\n    }\\n    // Reduce lender's balance to lock shares for their debt\\n    _balanceOf[lender] -= shares;\\n\\n    // Emit transfer event so indexing services can correctly track the\\n    // lender's balance\\n    emit Transfer(lender, address(this), shares);\\n\\n    // Emit event for loan creation\\n    emit LoanCreated(lender, borrower, loanId, actualBorrowAmount, shares);\\n  }\\n\\n  /**\\n   * @notice Repay assets for a loan and unlock the shares of the lender\\n   * at the original price they were locked at. If less than the full\\n   * amount is repaid, the remainder of the shares are burned. This can\\n   * only be called once so full repayment will not eventually occur if\\n   * the loan is only partially repaid first.\\n   *\\n   * Note: amountRepaid MUST have already been received by the vault\\n   * before this function is called.\\n   *\\n   * @param state Global state\\n   * @param moduleState Module state\\n   * @param loanRecord Loan record\\n   * @param lender Account that gave the loan\\n   * @param loanId Identifier for the loan\\n   * @param repaidAmount Amount of underlying repaid\\n   */\\n  function _repayTo(\\n    GlobalState state,\\n    ModuleState moduleState,\\n    LoanRecord loanRecord,\\n    address lender,\\n    uint256 loanId,\\n    uint256 repaidAmount\\n  ) internal {\\n    // Unlock/burn shares for repaid amount\\n    (uint256 sharesUnlocked, uint256 sharesBurned) = _unlockSharesForLoan(loanRecord, lender, repaidAmount);\\n\\n    // Handle fees for gas reserves and ZeroDAO\\n    _state = _collectLoanFees(state, moduleState, loanRecord, repaidAmount, lender);\\n\\n    // Emit event for loan repayment\\n    emit LoanClosed(loanId, repaidAmount, sharesUnlocked, sharesBurned);\\n  }\\n\\n  function _unlockSharesForLoan(\\n    LoanRecord loanRecord,\\n    address lender,\\n    uint256 repaidAmount\\n  ) internal returns (uint256 sharesUnlocked, uint256 sharesBurned) {\\n    (uint256 sharesLocked, uint256 lenderDebt) = loanRecord.getSharesAndDebt();\\n\\n    sharesUnlocked = sharesLocked;\\n\\n    // If loan is less than fully repaid\\n    if (repaidAmount < lenderDebt) {\\n      // Unlock shares proportional to the fraction repaid\\n      sharesUnlocked = repaidAmount.mulDivDown(sharesLocked, lenderDebt);\\n      unchecked {\\n        // sharesUnlocked will always be less than sharesLocked\\n        sharesBurned = sharesLocked - sharesUnlocked;\\n        // The shares have already been subtracted from the lender's balance\\n        // so no balance update is needed.\\n        // totalSupply will always be greater than sharesBurned.\\n        _totalSupply -= sharesBurned;\\n      }\\n      // Emit transfer event so indexing services can correctly track the\\n      // totalSupply.\\n      emit Transfer(address(this), address(0), sharesBurned);\\n    }\\n\\n    // If any shares should be unlocked, add them back to the lender's balance\\n    if (sharesUnlocked > 0) {\\n      // Cannot overflow because the sum of all user balances\\n      // can't exceed the max uint256 value.\\n      unchecked {\\n        _balanceOf[lender] += sharesUnlocked;\\n      }\\n      // Emit transfer event so indexing services can correctly track the\\n      // lender's balance\\n      emit Transfer(address(this), lender, sharesUnlocked);\\n    }\\n  }\\n\\n  function _collectLoanFees(\\n    GlobalState state,\\n    ModuleState moduleState,\\n    LoanRecord loanRecord,\\n    uint256 repaidAmount,\\n    address lender\\n  ) internal returns (GlobalState) {\\n    (uint256 btcForGasReserve, uint256 ethForGasReserve) = _getEffectiveGasCosts(state, moduleState, loanRecord);\\n    uint256 newBalance = address(this).balance + ethForGasReserve;\\n    uint256 actualBorrowAmount = loanRecord.getActualBorrowAmount();\\n    unchecked {\\n      // `actualBorrowAmount` has already been added to `totalBitcoinBorrowed`\\n      uint256 totalBitcoinBorrowed = state.getTotalBitcoinBorrowed();\\n      state = state.setTotalBitcoinBorrowed(totalBitcoinBorrowed - actualBorrowAmount);\\n    }\\n\\n    uint256 profit = repaidAmount.subMinZero(actualBorrowAmount + btcForGasReserve);\\n    if (profit == 0) {\\n      return state;\\n    }\\n\\n    // If vault's gas reserves are below the target, reduce the profit shared\\n    // with ZeroDAO and vault LPs by up to `(profit * maxGasProfitShareBips) / 10000`\\n    if (newBalance < _targetEthReserve) {\\n      // Calculate amount of ETH needed to reach target gas reserves\\n      uint256 btcNeededForTarget = _ethToBtc(_targetEthReserve - newBalance, state.getSatoshiPerEth());\\n      // Calculate maximum amount of profit that can be used to meet reserves\\n      uint256 maxReservedBtcForGas = profit.uncheckedMulBipsUp(_maxGasProfitShareBips);\\n      // Take the minimum of the two values\\n      uint256 reservedProfit = Math.min(btcNeededForTarget, maxReservedBtcForGas);\\n      unchecked {\\n        // Reduce the profit that will be split between the vault's LPs and ZeroDAO\\n        profit -= reservedProfit;\\n        // Increase the BTC value that will be withheld for gas reserves\\n        btcForGasReserve += reservedProfit;\\n      }\\n    }\\n    return _mintFeeShares(state, profit, btcForGasReserve, lender);\\n  }\\n\\n  function _mintFeeShares(\\n    GlobalState state,\\n    uint256 profit,\\n    uint256 btcForGasReserve,\\n    address lender\\n  ) internal returns (GlobalState) {\\n    // @todo Clean up - nested scopes temporary to get around stack too deep\\n    uint256 newSupply;\\n    uint256 _totalAssets;\\n\\n    // Cache the total supply to avoid extra SLOADs\\n    uint256 supply = _totalSupply;\\n\\n    {\\n      uint256 gasReserveShares;\\n      uint256 zeroFeeShares;\\n      {\\n        // Calculate share of profits owed to ZeroDAO\\n        uint256 btcForZeroDAO = profit.uncheckedMulBipsUp(state.getZeroFeeShareBips());\\n\\n        // Keeper receives profits not allocated for gas reserves or ZeroDAO\\n        uint256 btcForKeeper = profit - btcForZeroDAO;\\n\\n        // Get the underlying assets held by the vault or in outstanding loans and subtract\\n        // the fees that will be charged in order to calculate the number of shares to mint\\n        // that will be worth the fees.\\n        _totalAssets =\\n          (ERC4626.totalAssets() + state.getTotalBitcoinBorrowed()) -\\n          (btcForGasReserve + btcForZeroDAO + btcForKeeper);\\n\\n        // Calculate shares to mint for the gas reserves and ZeroDAO fees\\n        gasReserveShares = btcForGasReserve.mulDivDown(supply, _totalAssets);\\n        zeroFeeShares = (btcForZeroDAO).mulDivDown(supply, _totalAssets);\\n        // Emit event for fee shares\\n        emit FeeSharesMinted(btcForGasReserve, gasReserveShares, btcForZeroDAO, zeroFeeShares);\\n      }\\n\\n      newSupply = supply + gasReserveShares + zeroFeeShares;\\n\\n      // Get the current fee share totals\\n      (uint256 unburnedGasReserveShares, uint256 unburnedZeroFeeShares) = state.getUnburnedShares();\\n\\n      // Write the new fee share totals to the global state on the stack\\n      state = state.setUnburnedShares(\\n        unburnedGasReserveShares + gasReserveShares,\\n        unburnedZeroFeeShares + zeroFeeShares\\n      );\\n    }\\n\\n    {\\n      uint256 keeperShares = profit.mulDivDown(supply, _totalAssets);\\n      // Emit transfer for mint of keeper shares\\n      emit Transfer(address(0), lender, keeperShares);\\n      newSupply += keeperShares;\\n\\n      // Add keeper shares to lender's balance\\n      unchecked {\\n        _balanceOf[lender] += keeperShares;\\n      }\\n    }\\n\\n    // Add the new shares to the total supply. They are not added to any balance but we track\\n    // them in the global state.\\n    _totalSupply = newSupply;\\n\\n    return state;\\n  }\\n\\n  function _getEffectiveGasCosts(\\n    GlobalState state,\\n    ModuleState moduleState,\\n    LoanRecord loanRecord\\n  ) internal pure returns (uint256 btcSpentOnGas, uint256 ethSpentOnGas) {\\n    uint256 satoshiPerEth = state.getSatoshiPerEth();\\n    uint256 btcForLoanGas = loanRecord.getBtcFeeForLoanGas();\\n    btcSpentOnGas = btcForLoanGas + moduleState.getBtcFeeForRepayGas();\\n    ethSpentOnGas = _btcToEth(btcForLoanGas, satoshiPerEth) + moduleState.getEthRefundForRepayGas();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/vault/ZeroBTCCache.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport \\\"./ZeroBTCBase.sol\\\";\\n\\nabstract contract ZeroBTCCache is ZeroBTCBase {\\n  using ModuleStateCoder for ModuleState;\\n  using GlobalStateCoder for GlobalState;\\n  using LoanRecordCoder for LoanRecord;\\n  using Math for uint256;\\n\\n  /*//////////////////////////////////////////////////////////////\\n                          External Updaters\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function pokeGlobalCache() external nonReentrant {\\n    _updateGlobalCache(_state);\\n  }\\n\\n  function pokeModuleCache(address module) external nonReentrant {\\n    _getUpdatedGlobalAndModuleState(module);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                  Internal Fee Getters and Updaters               \\n  //////////////////////////////////////////////////////////////*/\\n\\n  function _updateGlobalCache(GlobalState state) internal returns (GlobalState) {\\n    uint256 satoshiPerEth = _getSatoshiPerEth();\\n    uint256 gweiPerGas = _getGweiPerGas();\\n    state = state.setCached(satoshiPerEth, gweiPerGas, block.timestamp);\\n    _state = state;\\n    emit GlobalStateCacheUpdated(satoshiPerEth, gweiPerGas);\\n    return state;\\n  }\\n\\n  function _updateModuleCache(\\n    GlobalState state,\\n    ModuleState moduleState,\\n    address module\\n  ) internal returns (ModuleState) {\\n    // Read the gas parameters\\n    (uint256 loanGasE4, uint256 repayGasE4) = moduleState.getGasParams();\\n    // Calculate the new gas refunds for the module\\n    (\\n      uint256 ethRefundForLoanGas,\\n      uint256 ethRefundForRepayGas,\\n      uint256 btcFeeForLoanGas,\\n      uint256 btcFeeForRepayGas\\n    ) = _calculateModuleGasFees(state, loanGasE4, repayGasE4);\\n    // Update the module's cache and write it to storage\\n    moduleState = moduleState.setCached(\\n      ethRefundForLoanGas,\\n      ethRefundForRepayGas,\\n      btcFeeForLoanGas,\\n      btcFeeForRepayGas,\\n      block.timestamp\\n    );\\n    _moduleFees[module] = moduleState;\\n    return moduleState;\\n  }\\n\\n  function _getUpdatedGlobalState() internal returns (GlobalState state, uint256 lastUpdateTimestamp) {\\n    state = _state;\\n    lastUpdateTimestamp = state.getLastUpdateTimestamp();\\n    if (block.timestamp - lastUpdateTimestamp > _cacheTimeToLive) {\\n      state = _updateGlobalCache(state);\\n    }\\n  }\\n\\n  function _getUpdatedGlobalAndModuleState(address module)\\n    internal\\n    returns (GlobalState state, ModuleState moduleState)\\n  {\\n    // Get updated global state, with cache refreshed if it had expired\\n    uint256 lastGlobalUpdateTimestamp;\\n    (state, lastGlobalUpdateTimestamp) = _getUpdatedGlobalState();\\n    // Read module state from storage\\n    moduleState = _getExistingModuleState(module);\\n    // Check if module's cache is older than global cache\\n    if (moduleState.getLastUpdateTimestamp() < lastGlobalUpdateTimestamp) {\\n      moduleState = _updateModuleCache(state, moduleState, module);\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                      Internal Fee Calculators\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function _calculateModuleGasFees(\\n    GlobalState state,\\n    uint256 loanGasE4,\\n    uint256 repayGasE4\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint256 ethRefundForLoanGas,\\n      uint256 ethRefundForRepayGas,\\n      uint256 btcFeeForLoanGas,\\n      uint256 btcFeeForRepayGas\\n    )\\n  {\\n    (uint256 satoshiPerEth, uint256 gasPrice) = state.getParamsForModuleFees();\\n    // Unchecked because gasPrice can not exceed 60 bits,\\n    // refunds can not exceed 68 bits and the numerator for\\n    // borrowGasFeeBitcoin can not exceed 108 bits\\n    unchecked {\\n      // Multiply gasPrice (expressed in gwei) by 1e9 to convert to wei, and by 1e4 to convert\\n      // the gas values (expressed as gas * 1e-4) to ETH\\n      gasPrice *= 1e13;\\n      // Compute ETH cost of running loan function\\n      ethRefundForLoanGas = loanGasE4 * gasPrice;\\n      // Compute ETH cost of running repay function\\n      ethRefundForRepayGas = repayGasE4 * gasPrice;\\n      // Compute BTC value of `ethRefundForLoanGas`\\n      btcFeeForLoanGas = (satoshiPerEth * ethRefundForLoanGas) / OneEth;\\n      // Compute BTC value of `ethRefundForRepayGas`\\n      btcFeeForRepayGas = (satoshiPerEth * ethRefundForRepayGas) / OneEth;\\n    }\\n  }\\n\\n  function _calculateRenAndZeroFees(GlobalState state, uint256 borrowAmount)\\n    internal\\n    pure\\n    returns (uint256 renFees, uint256 zeroFees)\\n  {\\n    (\\n      uint256 zeroBorrowFeeBips,\\n      uint256 renBorrowFeeBips,\\n      uint256 zeroBorrowFeeStatic,\\n      uint256 renBorrowFeeStatic\\n    ) = state.getBorrowFees();\\n\\n    renFees = renBorrowFeeStatic + borrowAmount.uncheckedMulBipsUp(renBorrowFeeBips);\\n    zeroFees = zeroBorrowFeeStatic + borrowAmount.uncheckedMulBipsUp(zeroBorrowFeeBips);\\n  }\\n\\n  function _calculateLoanFees(\\n    GlobalState state,\\n    ModuleState moduleState,\\n    uint256 borrowAmount\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint256 actualBorrowAmount,\\n      uint256 lenderDebt,\\n      uint256 btcFeeForLoanGas\\n    )\\n  {\\n    (uint256 renFees, uint256 zeroFees) = _calculateRenAndZeroFees(state, borrowAmount);\\n    uint256 btcFeeForRepayGas;\\n    (btcFeeForLoanGas, btcFeeForRepayGas) = moduleState.getBitcoinGasFees();\\n\\n    // Lender is responsible for actualBorrowAmount, zeroFees and gas refunds.\\n    lenderDebt = borrowAmount - renFees;\\n\\n    // Subtract ren, zero and gas fees\\n    actualBorrowAmount = lenderDebt - (zeroFees + btcFeeForLoanGas + btcFeeForRepayGas);\\n  }\\n\\n  function _ethToBtc(uint256 ethAmount, uint256 satoshiPerEth) internal pure returns (uint256 btcAmount) {\\n    return (ethAmount * satoshiPerEth) / OneEth;\\n  }\\n\\n  function _btcToEth(uint256 btcAmount, uint256 satoshiPerEth) internal pure returns (uint256 ethAmount) {\\n    return (btcAmount * OneEth) / satoshiPerEth;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/utils/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\nimport \\\"./CoderConstants.sol\\\";\\n\\nuint256 constant TenThousand = 1e4;\\nuint256 constant OneGwei = 1e9;\\nuint256 constant OneEth = 1e18;\\n\\nlibrary Math {\\n  function avg(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = (a & b) + (a ^ b) / 2;\\n  }\\n\\n  function min(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = ternary(a < b, a, b);\\n  }\\n\\n  function max(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = ternary(a < b, b, a);\\n  }\\n\\n  function subMinZero(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    unchecked {\\n      c = ternary(a > b, a - b, 0);\\n    }\\n  }\\n\\n  function uncheckedMulBipsUp(uint256 x, uint256 bips) internal pure returns (uint256 y) {\\n    assembly {\\n      let numerator := mul(x, bips)\\n      y := mul(iszero(iszero(numerator)), add(div(sub(numerator, 1), TenThousand), 1))\\n    }\\n  }\\n\\n  function uncheckedMulBipsUpWithMultiplier(\\n    uint256 x,\\n    uint256 bips,\\n    uint8 multiplier\\n  ) internal pure returns (uint256) {\\n    return uncheckedMulBipsUp(x, (bips * multiplier) / 100);\\n  }\\n\\n  // Equivalent to ceil((x)e-4)\\n  function uncheckedDivUpE4(uint256 x) internal pure returns (uint256 y) {\\n    assembly {\\n      y := add(div(sub(x, 1), TenThousand), 1)\\n    }\\n  }\\n\\n  // Equivalent to ceil((x)e-9)\\n  function uncheckedDivUpE9(uint256 x) internal pure returns (uint256 y) {\\n    assembly {\\n      y := add(div(sub(x, 1), OneGwei), 1)\\n    }\\n  }\\n\\n  function mulBips(uint256 n, uint256 bips) internal pure returns (uint256 result) {\\n    result = (n * bips) / TenThousand;\\n  }\\n\\n  function ternary(\\n    bool condition,\\n    uint256 valueIfTrue,\\n    uint256 valueIfFalse\\n  ) internal pure returns (uint256 c) {\\n    assembly {\\n      c := add(valueIfFalse, mul(condition, sub(valueIfTrue, valueIfFalse)))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nimport { GlobalState } from \\\"../erc4626/storage/ZeroBTCStorage.sol\\\";\\n\\ninterface IStrategy {\\n  function manage(GlobalState old) external returns (GlobalState state);\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/utils/LoanRecordCoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport './CoderConstants.sol';\\n\\n// ============================== NOTICE ==============================\\n// This library was automatically generated with stackpacker.\\n// Be very careful about modifying it, as doing so incorrectly could\\n// result in corrupted reads/writes.\\n// ====================================================================\\n\\n// struct LoanRecord {\\n//   uint48 sharesLocked;\\n//   uint48 actualBorrowAmount;\\n//   uint48 lenderDebt;\\n//   uint48 btcFeeForLoanGas;\\n//   uint32 expiry;\\n// }\\ntype LoanRecord is uint256;\\n\\nLoanRecord constant DefaultLoanRecord = LoanRecord\\n  .wrap(0);\\n\\nlibrary LoanRecordCoder {\\n  /*//////////////////////////////////////////////////////////////\\n                           LoanRecord\\n//////////////////////////////////////////////////////////////*/\\n\\n  function decode(LoanRecord encoded)\\n    internal\\n    pure\\n    returns (\\n      uint256 sharesLocked,\\n      uint256 actualBorrowAmount,\\n      uint256 lenderDebt,\\n      uint256 btcFeeForLoanGas,\\n      uint256 expiry\\n    )\\n  {\\n    assembly {\\n      sharesLocked := shr(\\n        LoanRecord_sharesLocked_bitsAfter,\\n        encoded\\n      )\\n      actualBorrowAmount := and(\\n        MaxUint48,\\n        shr(\\n          LoanRecord_actualBorrowAmount_bitsAfter,\\n          encoded\\n        )\\n      )\\n      lenderDebt := and(\\n        MaxUint48,\\n        shr(\\n          LoanRecord_lenderDebt_bitsAfter,\\n          encoded\\n        )\\n      )\\n      btcFeeForLoanGas := and(\\n        MaxUint48,\\n        shr(\\n          LoanRecord_btcFeeForLoanGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n      expiry := and(\\n        MaxUint32,\\n        shr(LoanRecord_expiry_bitsAfter, encoded)\\n      )\\n    }\\n  }\\n\\n  function encode(\\n    uint256 sharesLocked,\\n    uint256 actualBorrowAmount,\\n    uint256 lenderDebt,\\n    uint256 btcFeeForLoanGas,\\n    uint256 expiry\\n  ) internal pure returns (LoanRecord encoded) {\\n    assembly {\\n      if or(\\n        gt(sharesLocked, MaxUint48),\\n        or(\\n          gt(actualBorrowAmount, MaxUint48),\\n          or(\\n            gt(lenderDebt, MaxUint48),\\n            or(\\n              gt(btcFeeForLoanGas, MaxUint48),\\n              gt(expiry, MaxUint32)\\n            )\\n          )\\n        )\\n      ) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      encoded := or(\\n        shl(\\n          LoanRecord_sharesLocked_bitsAfter,\\n          sharesLocked\\n        ),\\n        or(\\n          shl(\\n            LoanRecord_actualBorrowAmount_bitsAfter,\\n            actualBorrowAmount\\n          ),\\n          or(\\n            shl(\\n              LoanRecord_lenderDebt_bitsAfter,\\n              lenderDebt\\n            ),\\n            or(\\n              shl(\\n                LoanRecord_btcFeeForLoanGas_bitsAfter,\\n                btcFeeForLoanGas\\n              ),\\n              shl(\\n                LoanRecord_expiry_bitsAfter,\\n                expiry\\n              )\\n            )\\n          )\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                 LoanRecord SharesAndDebt coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getSharesAndDebt(LoanRecord encoded)\\n    internal\\n    pure\\n    returns (\\n      uint256 sharesLocked,\\n      uint256 lenderDebt\\n    )\\n  {\\n    assembly {\\n      sharesLocked := shr(\\n        LoanRecord_sharesLocked_bitsAfter,\\n        encoded\\n      )\\n      lenderDebt := and(\\n        MaxUint48,\\n        shr(\\n          LoanRecord_lenderDebt_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n              LoanRecord.actualBorrowAmount coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getActualBorrowAmount(\\n    LoanRecord encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 actualBorrowAmount)\\n  {\\n    assembly {\\n      actualBorrowAmount := and(\\n        MaxUint48,\\n        shr(\\n          LoanRecord_actualBorrowAmount_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n               LoanRecord.btcFeeForLoanGas coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getBtcFeeForLoanGas(LoanRecord encoded)\\n    internal\\n    pure\\n    returns (uint256 btcFeeForLoanGas)\\n  {\\n    assembly {\\n      btcFeeForLoanGas := and(\\n        MaxUint48,\\n        shr(\\n          LoanRecord_btcFeeForLoanGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                    LoanRecord.expiry coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getExpiry(LoanRecord encoded)\\n    internal\\n    pure\\n    returns (uint256 expiry)\\n  {\\n    assembly {\\n      expiry := and(\\n        MaxUint32,\\n        shr(LoanRecord_expiry_bitsAfter, encoded)\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                  LoanRecord comparison methods\\n//////////////////////////////////////////////////////////////*/\\n\\n  function equals(LoanRecord a, LoanRecord b)\\n    internal\\n    pure\\n    returns (bool _equals)\\n  {\\n    assembly {\\n      _equals := eq(a, b)\\n    }\\n  }\\n\\n  function isNull(LoanRecord a)\\n    internal\\n    pure\\n    returns (bool _isNull)\\n  {\\n    _isNull = equals(a, DefaultLoanRecord);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/BaseModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport { FixedPointMathLib } from \\\"./utils/FixedPointMathLib.sol\\\";\\nimport \\\"./utils/ModuleStateCoder.sol\\\";\\nimport { ZeroBTCStorage } from \\\"./storage/ZeroBTCStorage.sol\\\";\\n\\n/**\\n * @notice Base contract that must be inherited by all modules.\\n */\\nabstract contract BaseModule is ZeroBTCStorage {\\n  using ModuleStateCoder for ModuleState;\\n  using FixedPointMathLib for uint256;\\n\\n  /// @notice Base asset of the vault which is calling the module.\\n  /// This value is private because it is read only to the module.\\n  address public immutable asset;\\n\\n  /// @notice Isolated storage pointer for any data that the module must write\\n  /// Use like so:\\n  address internal immutable _moduleSlot;\\n\\n  constructor(address _asset) {\\n    asset = _asset;\\n    _moduleSlot = address(this);\\n  }\\n\\n  function initialize() external virtual {}\\n\\n  function _getModuleState() internal returns (ModuleState moduleState) {\\n    moduleState = _moduleFees[_moduleSlot];\\n  }\\n\\n  /**\\n   * @notice Repays a loan.\\n   *\\n   * This is always called in a delegatecall.\\n   *\\n   * `collateralToUnlock` should be equal to `repaidAmount` unless the vault\\n   * has less than 100% collateralization or the loan is underpaid.\\n   *\\n   * @param borrower Recipient of the loan\\n   * @param repaidAmount Amount of `asset` being repaid.\\n   * @param loanId Unique (per vault) identifier for a loan.\\n   * @param data Any additional data provided to the module.\\n   * @return collateralToUnlock Amount of collateral to unlock for the lender.\\n   */\\n  function repayLoan(\\n    address borrower,\\n    uint256 repaidAmount,\\n    uint256 loanId,\\n    bytes calldata data\\n  ) external virtual returns (uint256 collateralToUnlock) {\\n    // Handle loan using module's logic, reducing borrow amount by the value of gas used\\n    collateralToUnlock = _repayLoan(borrower, repaidAmount, loanId, data);\\n  }\\n\\n  /**\\n   * @notice Take out a loan.\\n   *\\n   * This is always called in a delegatecall.\\n   *\\n   * `collateralToLock` should be equal to `borrowAmount` unless the vault\\n   * has less than 100% collateralization.\\n   *\\n   * @param borrower Recipient of the loan\\n   * @param borrowAmount Amount of `asset` being borrowed.\\n   * @param loanId Unique (per vault) identifier for a loan.\\n   * @param data Any additional data provided to the module.\\n   * @return collateralToLock Amount of collateral to lock for the lender.\\n   */\\n  function receiveLoan(\\n    address borrower,\\n    uint256 borrowAmount,\\n    uint256 loanId,\\n    bytes calldata data\\n  ) external virtual returns (uint256 collateralToLock) {\\n    // Handle loan using module's logic, reducing borrow amount by the value of gas used\\n    collateralToLock = _receiveLoan(borrower, borrowAmount, loanId, data);\\n  }\\n\\n  struct ConvertLocals {\\n    address borrower;\\n    uint256 minOut;\\n    uint256 amount;\\n    uint256 nonce;\\n  }\\n\\n  /* ---- Override These In Child ---- */\\n  function swap(ConvertLocals memory) internal virtual returns (uint256 amountOut);\\n\\n  function swapBack(ConvertLocals memory) internal virtual returns (uint256 amountOut);\\n\\n  function transfer(address to, uint256 amount) internal virtual;\\n\\n  function _receiveLoan(\\n    address borrower,\\n    uint256 borrowAmount,\\n    uint256 loanId,\\n    bytes calldata data\\n  ) internal virtual returns (uint256 collateralToLock);\\n\\n  function _repayLoan(\\n    address borrower,\\n    uint256 repaidAmount,\\n    uint256 loanId,\\n    bytes calldata data\\n  ) internal virtual returns (uint256 collateralToUnlock);\\n\\n  /* ---- Leave Empty For Now ---- */\\n\\n  /// @notice Return recent average gas price in wei per unit of gas\\n  function getGasPrice() internal view virtual returns (uint256) {\\n    return 1;\\n  }\\n\\n  /// @notice Get current price of ETH in terms of `asset`\\n  function getEthPrice() internal view virtual returns (uint256) {\\n    return 1;\\n  }\\n}\\n\\ncontract ABC {\\n  function x(uint256 a) external pure {\\n    assembly {\\n      a := or(shr(96, a), or(shr(96, a), or(shr(96, a), or(shr(96, a), or(shr(96, a), shr(96, a))))))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n  /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n  function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n    return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n  }\\n\\n  function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n    return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n  }\\n\\n  function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n    return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n  }\\n\\n  function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n    return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  function mulDivDown(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator\\n  ) internal pure returns (uint256 z) {\\n    assembly {\\n      // Store x * y in z for now.\\n      z := mul(x, y)\\n\\n      // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n      if iszero(\\n        and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))\\n      ) {\\n        revert(0, 0)\\n      }\\n\\n      // Divide z by the denominator.\\n      z := div(z, denominator)\\n    }\\n  }\\n\\n  function mulDivUp(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator\\n  ) internal pure returns (uint256 z) {\\n    assembly {\\n      // Store x * y in z for now.\\n      z := mul(x, y)\\n\\n      // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n      if iszero(\\n        and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))\\n      ) {\\n        revert(0, 0)\\n      }\\n\\n      // First, divide z - 1 by the denominator and add 1.\\n      // We allow z - 1 to underflow if z is 0, because we multiply the\\n      // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n      z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n    }\\n  }\\n\\n  function divUp(uint256 numerator, uint256 denominator)\\n    internal\\n    pure\\n    returns (uint256 z)\\n  {\\n    assembly {\\n      // Equivalent to require(denominator != 0)\\n      if iszero(denominator) {\\n        revert(0, 0)\\n      }\\n\\n      // First, divide numerator - 1 by the denominator and add 1.\\n      // We allow z - 1 to underflow if z is 0, because we multiply the\\n      // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n      z := mul(\\n        iszero(iszero(numerator)),\\n        add(div(sub(numerator, 1), denominator), 1)\\n      )\\n    }\\n  }\\n\\n  function rpow(\\n    uint256 x,\\n    uint256 n,\\n    uint256 scalar\\n  ) internal pure returns (uint256 z) {\\n    assembly {\\n      switch x\\n      case 0 {\\n        switch n\\n        case 0 {\\n          // 0 ** 0 = 1\\n          z := scalar\\n        }\\n        default {\\n          // 0 ** n = 0\\n          z := 0\\n        }\\n      }\\n      default {\\n        switch mod(n, 2)\\n        case 0 {\\n          // If n is even, store scalar in z for now.\\n          z := scalar\\n        }\\n        default {\\n          // If n is odd, store x in z for now.\\n          z := x\\n        }\\n\\n        // Shifting right by 1 is like dividing by 2.\\n        let half := shr(1, scalar)\\n\\n        for {\\n          // Shift n right by 1 before looping to halve it.\\n          n := shr(1, n)\\n        } n {\\n          // Shift n right by 1 each iteration to halve it.\\n          n := shr(1, n)\\n        } {\\n          // Revert immediately if x ** 2 would overflow.\\n          // Equivalent to iszero(eq(div(xx, x), x)) here.\\n          if shr(128, x) {\\n            revert(0, 0)\\n          }\\n\\n          // Store x squared.\\n          let xx := mul(x, x)\\n\\n          // Round to the nearest number.\\n          let xxRound := add(xx, half)\\n\\n          // Revert if xx + half overflowed.\\n          if lt(xxRound, xx) {\\n            revert(0, 0)\\n          }\\n\\n          // Set x to scaled xxRound.\\n          x := div(xxRound, scalar)\\n\\n          // If n is even:\\n          if mod(n, 2) {\\n            // Compute z * x.\\n            let zx := mul(z, x)\\n\\n            // If z * x overflowed:\\n            if iszero(eq(div(zx, x), z)) {\\n              // Revert if x is non-zero.\\n              if iszero(iszero(x)) {\\n                revert(0, 0)\\n              }\\n            }\\n\\n            // Round to the nearest number.\\n            let zxRound := add(zx, half)\\n\\n            // Revert if zx + half overflowed.\\n            if lt(zxRound, zx) {\\n              revert(0, 0)\\n            }\\n\\n            // Return properly scaled zxRound.\\n            z := div(zxRound, scalar)\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n  function sqrt(uint256 x) internal pure returns (uint256 z) {\\n    assembly {\\n      // Start off with z at 1.\\n      z := 1\\n\\n      // Used below to help find a nearby power of 2.\\n      let y := x\\n\\n      // Find the lowest power of 2 that is at least sqrt(x).\\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n        y := shr(128, y) // Like dividing by 2 ** 128.\\n        z := shl(64, z) // Like multiplying by 2 ** 64.\\n      }\\n      if iszero(lt(y, 0x10000000000000000)) {\\n        y := shr(64, y) // Like dividing by 2 ** 64.\\n        z := shl(32, z) // Like multiplying by 2 ** 32.\\n      }\\n      if iszero(lt(y, 0x100000000)) {\\n        y := shr(32, y) // Like dividing by 2 ** 32.\\n        z := shl(16, z) // Like multiplying by 2 ** 16.\\n      }\\n      if iszero(lt(y, 0x10000)) {\\n        y := shr(16, y) // Like dividing by 2 ** 16.\\n        z := shl(8, z) // Like multiplying by 2 ** 8.\\n      }\\n      if iszero(lt(y, 0x100)) {\\n        y := shr(8, y) // Like dividing by 2 ** 8.\\n        z := shl(4, z) // Like multiplying by 2 ** 4.\\n      }\\n      if iszero(lt(y, 0x10)) {\\n        y := shr(4, y) // Like dividing by 2 ** 4.\\n        z := shl(2, z) // Like multiplying by 2 ** 2.\\n      }\\n      if iszero(lt(y, 0x8)) {\\n        // Equivalent to 2 ** z.\\n        z := shl(1, z)\\n      }\\n\\n      // Shifting right by 1 is like dividing by 2.\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n      z := shr(1, add(z, div(x, z)))\\n\\n      // Compute a rounded down version of z.\\n      let zRoundDown := div(x, z)\\n\\n      // If zRoundDown is smaller, use it.\\n      if lt(zRoundDown, z) {\\n        z := zRoundDown\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/vault/ZeroBTCBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.15;\\n\\nimport { ZeroBTCStorage, ModuleStateCoder, DefaultModuleState, ModuleType, ModuleState, GlobalStateCoder, GlobalState, LoanRecordCoder, LoanRecord } from \\\"../storage/ZeroBTCStorage.sol\\\";\\nimport { IGateway, IGatewayRegistry } from \\\"../../interfaces/IGatewayRegistry.sol\\\";\\nimport \\\"../token/ERC4626.sol\\\";\\nimport \\\"../utils/Governable.sol\\\";\\nimport \\\"../interfaces/IZeroModule.sol\\\";\\nimport \\\"../interfaces/IZeroBTC.sol\\\";\\nimport \\\"../interfaces/IRenBtcEthConverter.sol\\\";\\nimport { IGateway, IGatewayRegistry } from \\\"../../interfaces/IGatewayRegistry.sol\\\";\\nimport { IChainlinkOracle } from \\\"../../interfaces/IChainlinkOracle.sol\\\";\\nimport \\\"../utils/Math.sol\\\";\\n\\nuint256 constant OneBitcoin = 1e8;\\n\\n// Used to convert a price expressed as wei per btc to one expressed\\n// as satoshi per ETH\\nuint256 constant BtcEthPriceInversionNumerator = 1e26;\\n\\nabstract contract ZeroBTCBase is ZeroBTCStorage, ERC4626, Governable, IZeroBTC {\\n  using Math for uint256;\\n  using ModuleStateCoder for ModuleState;\\n  using GlobalStateCoder for GlobalState;\\n  using LoanRecordCoder for LoanRecord;\\n\\n  receive() external payable {}\\n\\n  /*//////////////////////////////////////////////////////////////\\n                          Immutables\\n  //////////////////////////////////////////////////////////////*/\\n\\n  // RenVM gateway registry\\n  IGatewayRegistry internal immutable _gatewayRegistry;\\n  // _btcEthPriceOracle MUST return prices expressed as wei per full bitcoin\\n  IChainlinkOracle internal immutable _btcEthPriceOracle;\\n  // _gasPriceOracle MUST return gas prices expressed as wei per unit of gas\\n  IChainlinkOracle internal immutable _gasPriceOracle;\\n  // Contract for swapping renBTC to ETH\\n  IRenBtcEthConverter internal immutable _renBtcConverter;\\n  // TTL for global cache\\n  uint256 internal immutable _cacheTimeToLive;\\n  // Maximum time a loan can remain outstanding\\n  uint256 internal immutable _maxLoanDuration;\\n  // Target ETH reserves for gas refunds\\n  uint256 internal immutable _targetEthReserve;\\n  // Target ETH reserves for gas refunds\\n  uint256 internal immutable _maxGasProfitShareBips;\\n  // Recipient of Zero DAO fees\\n  address internal immutable _zeroFeeRecipient;\\n\\n  constructor(\\n    IGatewayRegistry gatewayRegistry,\\n    IChainlinkOracle btcEthPriceOracle,\\n    IChainlinkOracle gasPriceOracle,\\n    IRenBtcEthConverter renBtcConverter,\\n    uint256 cacheTimeToLive,\\n    uint256 maxLoanDuration,\\n    uint256 targetEthReserve,\\n    uint256 maxGasProfitShareBips,\\n    address zeroFeeRecipient,\\n    address _asset,\\n    address _proxyContract\\n  ) ERC4626(_asset, \\\"ZeroBTC\\\", \\\"ZBTC\\\", 8, _proxyContract, \\\"v1\\\") {\\n    _gatewayRegistry = gatewayRegistry;\\n    _btcEthPriceOracle = btcEthPriceOracle;\\n    _gasPriceOracle = gasPriceOracle;\\n    _renBtcConverter = renBtcConverter;\\n    _cacheTimeToLive = cacheTimeToLive;\\n    _maxLoanDuration = maxLoanDuration;\\n    _targetEthReserve = targetEthReserve;\\n    _maxGasProfitShareBips = maxGasProfitShareBips;\\n    _zeroFeeRecipient = zeroFeeRecipient;\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                        State Initialization\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function initialize(\\n    address initialGovernance,\\n    uint256 zeroBorrowFeeBips,\\n    uint256 renBorrowFeeBips,\\n    uint256 zeroBorrowFeeStatic,\\n    uint256 renBorrowFeeStatic,\\n    uint256 zeroFeeShareBips,\\n    address initialHarvester\\n  ) public payable virtual override {\\n    if (_governance != address(0)) {\\n      revert AlreadyInitialized();\\n    }\\n    // Initialize governance address\\n    Governable._initialize(initialGovernance);\\n    _authorized[initialGovernance] = true;\\n    // Initialize UpgradeableEIP712 and ReentrancyGuard\\n    super._initialize();\\n\\n    // Set initial global state\\n    _setFees(zeroBorrowFeeBips, renBorrowFeeBips, zeroBorrowFeeStatic, renBorrowFeeStatic, zeroFeeShareBips);\\n\\n    // set harvester\\n    _isHarvester[initialHarvester] = true;\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                          External Getters\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function getConfig()\\n    external\\n    view\\n    virtual\\n    override\\n    returns (\\n      address gatewayRegistry,\\n      address btcEthPriceOracle,\\n      address gasPriceOracle,\\n      address renBtcConverter,\\n      uint256 cacheTimeToLive,\\n      uint256 maxLoanDuration,\\n      uint256 targetEthReserve,\\n      uint256 maxGasProfitShareBips,\\n      address zeroFeeRecipient\\n    )\\n  {\\n    gatewayRegistry = address(_gatewayRegistry);\\n    btcEthPriceOracle = address(_btcEthPriceOracle);\\n    gasPriceOracle = address(_gasPriceOracle);\\n    renBtcConverter = address(_renBtcConverter);\\n    cacheTimeToLive = _cacheTimeToLive;\\n    maxLoanDuration = _maxLoanDuration;\\n    targetEthReserve = _targetEthReserve;\\n    maxGasProfitShareBips = _maxGasProfitShareBips;\\n    zeroFeeRecipient = _zeroFeeRecipient;\\n  }\\n\\n  function getGlobalState()\\n    external\\n    view\\n    override\\n    returns (\\n      uint256 zeroBorrowFeeBips,\\n      uint256 renBorrowFeeBips,\\n      uint256 zeroFeeShareBips,\\n      uint256 zeroBorrowFeeStatic,\\n      uint256 renBorrowFeeStatic,\\n      uint256 satoshiPerEth,\\n      uint256 gweiPerGas,\\n      uint256 lastUpdateTimestamp,\\n      uint256 totalBitcoinBorrowed,\\n      uint256 unburnedGasReserveShares,\\n      uint256 unburnedZeroFeeShares\\n    )\\n  {\\n    return _state.decode();\\n  }\\n\\n  function getModuleState(address module)\\n    external\\n    view\\n    override\\n    returns (\\n      ModuleType moduleType,\\n      uint256 loanGasE4,\\n      uint256 repayGasE4,\\n      uint256 ethRefundForLoanGas,\\n      uint256 ethRefundForRepayGas,\\n      uint256 btcFeeForLoanGas,\\n      uint256 btcFeeForRepayGas,\\n      uint256 lastUpdateTimestamp\\n    )\\n  {\\n    return _getExistingModuleState(module).decode();\\n  }\\n\\n  function totalAssets() public view virtual override(ERC4626, IERC4626) returns (uint256) {\\n    return ERC4626.totalAssets() + _state.getTotalBitcoinBorrowed();\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                          Internal Getters\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function _getSatoshiPerEth() internal view returns (uint256) {\\n    uint256 ethPerBitcoin = _btcEthPriceOracle.latestAnswer();\\n    return BtcEthPriceInversionNumerator / ethPerBitcoin;\\n  }\\n\\n  function _getGweiPerGas() internal view returns (uint256) {\\n    uint256 gasPrice = _gasPriceOracle.latestAnswer();\\n    return gasPrice.uncheckedDivUpE9();\\n  }\\n\\n  function _getGateway() internal view returns (IGateway gateway) {\\n    gateway = IGateway(_gatewayRegistry.getGatewayByToken(asset));\\n  }\\n\\n  function _getExistingModuleState(address module) internal view returns (ModuleState moduleState) {\\n    moduleState = _moduleFees[module];\\n    if (moduleState.isNull()) {\\n      revert ModuleDoesNotExist();\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                          Internal Setters\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function _setFees(\\n    uint256 zeroBorrowFeeBips,\\n    uint256 renBorrowFeeBips,\\n    uint256 zeroBorrowFeeStatic,\\n    uint256 renBorrowFeeStatic,\\n    uint256 zeroFeeShareBips\\n  ) internal {\\n    if (\\n      (zeroBorrowFeeBips | renBorrowFeeBips) > 2000 ||\\n      (zeroFeeShareBips) > 8000 ||\\n      zeroBorrowFeeBips == 0 ||\\n      renBorrowFeeBips == 0 ||\\n      zeroFeeShareBips == 0\\n    ) {\\n      revert InvalidDynamicBorrowFee();\\n    }\\n    _state = _state.setFees(\\n      zeroBorrowFeeBips,\\n      renBorrowFeeBips,\\n      zeroBorrowFeeStatic,\\n      renBorrowFeeStatic,\\n      zeroFeeShareBips\\n    );\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                          External Setters\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function authorize(address user) external onlyGovernance {\\n    _authorized[user] = true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/utils/CoderConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n\\n// ============================== NOTICE ==============================\\n// This library was automatically generated with stackpacker.\\n// Be very careful about modifying it, as doing so incorrectly could\\n// result in corrupted reads/writes.\\n// ====================================================================\\n\\nuint256 constant GlobalState_BorrowFees_maskOut = 0x000003ffe000000000007fffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant GlobalState_Cached_maskOut = 0xffffffffffffffffffff80000000000000000001ffffffffffffffffffffffff;\\nuint256 constant GlobalState_Fees_maskOut = 0x000000000000000000007fffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant GlobalState_LoanInfo_maskOut = 0xfffffffffffffffffffffffffffffffffffffffe0000000001ffffffffffffff;\\nuint256 constant GlobalState_ParamsForModuleFees_maskOut = 0xffffffffffffffffffff800000000001ffffffffffffffffffffffffffffffff;\\nuint256 constant GlobalState_UnburnedShares_maskOut = 0xfffffffffffffffffffffffffffffffffffffffffffffffffe00000000000001;\\nuint256 constant GlobalState_gweiPerGas_bitsAfter = 0x81;\\nuint256 constant GlobalState_gweiPerGas_maskOut = 0xfffffffffffffffffffffffffffe0001ffffffffffffffffffffffffffffffff;\\nuint256 constant GlobalState_lastUpdateTimestamp_bitsAfter = 0x61;\\nuint256 constant GlobalState_lastUpdateTimestamp_maskOut = 0xfffffffffffffffffffffffffffffffe00000001ffffffffffffffffffffffff;\\nuint256 constant GlobalState_renBorrowFeeBips_bitsAfter = 0xea;\\nuint256 constant GlobalState_renBorrowFeeBips_maskOut = 0xffe003ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant GlobalState_renBorrowFeeStatic_bitsAfter = 0xaf;\\nuint256 constant GlobalState_renBorrowFeeStatic_maskOut = 0xffffffffffffffc000007fffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant GlobalState_satoshiPerEth_bitsAfter = 0x91;\\nuint256 constant GlobalState_satoshiPerEth_maskOut = 0xffffffffffffffffffff80000001ffffffffffffffffffffffffffffffffffff;\\nuint256 constant GlobalState_totalBitcoinBorrowed_bitsAfter = 0x39;\\nuint256 constant GlobalState_totalBitcoinBorrowed_maskOut = 0xfffffffffffffffffffffffffffffffffffffffe0000000001ffffffffffffff;\\nuint256 constant GlobalState_unburnedGasReserveShares_bitsAfter = 0x1d;\\nuint256 constant GlobalState_unburnedGasReserveShares_maskOut = 0xfffffffffffffffffffffffffffffffffffffffffffffffffe0000001fffffff;\\nuint256 constant GlobalState_unburnedZeroFeeShares_bitsAfter = 0x01;\\nuint256 constant GlobalState_unburnedZeroFeeShares_maskOut = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0000001;\\nuint256 constant GlobalState_zeroBorrowFeeBips_bitsAfter = 0xf5;\\nuint256 constant GlobalState_zeroBorrowFeeBips_maskOut = 0x001fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant GlobalState_zeroBorrowFeeStatic_bitsAfter = 0xc6;\\nuint256 constant GlobalState_zeroBorrowFeeStatic_maskOut = 0xffffffffe000003fffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant GlobalState_zeroFeeShareBips_bitsAfter = 0xdd;\\nuint256 constant GlobalState_zeroFeeShareBips_maskOut = 0xfffffc001fffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant LoanRecord_SharesAndDebt_maskOut = 0x000000000000ffffffffffff000000000000ffffffffffffffffffffffffffff;\\nuint256 constant LoanRecord_actualBorrowAmount_bitsAfter = 0xa0;\\nuint256 constant LoanRecord_actualBorrowAmount_maskOut = 0xffffffffffff000000000000ffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant LoanRecord_btcFeeForLoanGas_bitsAfter = 0x40;\\nuint256 constant LoanRecord_btcFeeForLoanGas_maskOut = 0xffffffffffffffffffffffffffffffffffff000000000000ffffffffffffffff;\\nuint256 constant LoanRecord_expiry_bitsAfter = 0x20;\\nuint256 constant LoanRecord_expiry_maskOut = 0xffffffffffffffffffffffffffffffffffffffffffffffff00000000ffffffff;\\nuint256 constant LoanRecord_lenderDebt_bitsAfter = 0x70;\\nuint256 constant LoanRecord_lenderDebt_maskOut = 0xffffffffffffffffffffffff000000000000ffffffffffffffffffffffffffff;\\nuint256 constant LoanRecord_sharesLocked_bitsAfter = 0xd0;\\nuint256 constant LoanRecord_sharesLocked_maskOut = 0x000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant MaxUint11 = 0x07ff;\\nuint256 constant MaxUint13 = 0x1fff;\\nuint256 constant MaxUint16 = 0xffff;\\nuint256 constant MaxUint2 = 0x03;\\nuint256 constant MaxUint23 = 0x7fffff;\\nuint256 constant MaxUint24 = 0xffffff;\\nuint256 constant MaxUint28 = 0x0fffffff;\\nuint256 constant MaxUint30 = 0x3fffffff;\\nuint256 constant MaxUint32 = 0xffffffff;\\nuint256 constant MaxUint40 = 0xffffffffff;\\nuint256 constant MaxUint48 = 0xffffffffffff;\\nuint256 constant MaxUint64 = 0xffffffffffffffff;\\nuint256 constant MaxUint8 = 0xff;\\nuint256 constant ModuleState_BitcoinGasFees_maskOut = 0xffffffffffffffffffffffffffffffffffffc000000000003fffffffffffffff;\\nuint256 constant ModuleState_Cached_maskOut = 0xffffc0000000000000000000000000000000000000000000000000003fffffff;\\nuint256 constant ModuleState_GasParams_maskOut = 0xc0003fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant ModuleState_LoanParams_maskOut = 0x3fffc0000000000000003fffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant ModuleState_RepayParams_maskOut = 0x3fffffffffffffffffffc0000000000000003fffffc000003fffffffffffffff;\\nuint256 constant ModuleState_btcFeeForLoanGas_bitsAfter = 0x56;\\nuint256 constant ModuleState_btcFeeForLoanGas_maskOut = 0xffffffffffffffffffffffffffffffffffffc000003fffffffffffffffffffff;\\nuint256 constant ModuleState_btcFeeForRepayGas_bitsAfter = 0x3e;\\nuint256 constant ModuleState_btcFeeForRepayGas_maskOut = 0xffffffffffffffffffffffffffffffffffffffffffc000003fffffffffffffff;\\nuint256 constant ModuleState_ethRefundForLoanGas_bitsAfter = 0xae;\\nuint256 constant ModuleState_ethRefundForLoanGas_maskOut = 0xffffc0000000000000003fffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant ModuleState_ethRefundForRepayGas_bitsAfter = 0x6e;\\nuint256 constant ModuleState_ethRefundForRepayGas_maskOut = 0xffffffffffffffffffffc0000000000000003fffffffffffffffffffffffffff;\\nuint256 constant ModuleState_lastUpdateTimestamp_bitsAfter = 0x1e;\\nuint256 constant ModuleState_lastUpdateTimestamp_maskOut = 0xffffffffffffffffffffffffffffffffffffffffffffffffc00000003fffffff;\\nuint256 constant ModuleState_loanGasE4_bitsAfter = 0xf6;\\nuint256 constant ModuleState_loanGasE4_maskOut = 0xc03fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant ModuleState_moduleType_bitsAfter = 0xfe;\\nuint256 constant ModuleState_moduleType_maskOut = 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant ModuleState_repayGasE4_bitsAfter = 0xee;\\nuint256 constant ModuleState_repayGasE4_maskOut = 0xffc03fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint256 constant Panic_arithmetic = 0x11;\\nuint256 constant Panic_error_length = 0x24;\\nuint256 constant Panic_error_offset = 0x04;\\nuint256 constant Panic_error_signature = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\"\r\n    },\r\n    \"contracts/erc4626/storage/ZeroBTCStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport \\\"./ERC4626Storage.sol\\\";\\nimport \\\"./GovernableStorage.sol\\\";\\nimport \\\"../utils/ModuleStateCoder.sol\\\";\\nimport \\\"../utils/GlobalStateCoder.sol\\\";\\nimport \\\"../utils/LoanRecordCoder.sol\\\";\\n\\ncontract ZeroBTCStorage is ERC4626Storage, GovernableStorage {\\n  GlobalState internal _state;\\n\\n  mapping(address => ModuleState) internal _moduleFees;\\n\\n  // Maps loanId => LoanRecord\\n  mapping(uint256 => LoanRecord) internal _outstandingLoans;\\n\\n  // maps wallets => whether they can call earn\\n  mapping(address => bool) internal _isHarvester;\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/utils/ModuleStateCoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport './CoderConstants.sol';\\n\\n// ============================== NOTICE ==============================\\n// This library was automatically generated with stackpacker.\\n// Be very careful about modifying it, as doing so incorrectly could\\n// result in corrupted reads/writes.\\n// ====================================================================\\n\\n// struct ModuleState {\\n//   ModuleType moduleType;\\n//   uint8 loanGasE4;\\n//   uint8 repayGasE4;\\n//   uint64 ethRefundForLoanGas;\\n//   uint64 ethRefundForRepayGas;\\n//   uint24 btcFeeForLoanGas;\\n//   uint24 btcFeeForRepayGas;\\n//   uint32 lastUpdateTimestamp;\\n// }\\ntype ModuleState is uint256;\\n\\nModuleState constant DefaultModuleState = ModuleState\\n  .wrap(0);\\n\\nlibrary ModuleStateCoder {\\n  /*//////////////////////////////////////////////////////////////\\n                           ModuleState\\n//////////////////////////////////////////////////////////////*/\\n\\n  function decode(ModuleState encoded)\\n    internal\\n    pure\\n    returns (\\n      ModuleType moduleType,\\n      uint256 loanGasE4,\\n      uint256 repayGasE4,\\n      uint256 ethRefundForLoanGas,\\n      uint256 ethRefundForRepayGas,\\n      uint256 btcFeeForLoanGas,\\n      uint256 btcFeeForRepayGas,\\n      uint256 lastUpdateTimestamp\\n    )\\n  {\\n    assembly {\\n      moduleType := shr(\\n        ModuleState_moduleType_bitsAfter,\\n        encoded\\n      )\\n      loanGasE4 := and(\\n        MaxUint8,\\n        shr(\\n          ModuleState_loanGasE4_bitsAfter,\\n          encoded\\n        )\\n      )\\n      repayGasE4 := and(\\n        MaxUint8,\\n        shr(\\n          ModuleState_repayGasE4_bitsAfter,\\n          encoded\\n        )\\n      )\\n      ethRefundForLoanGas := and(\\n        MaxUint64,\\n        shr(\\n          ModuleState_ethRefundForLoanGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n      ethRefundForRepayGas := and(\\n        MaxUint64,\\n        shr(\\n          ModuleState_ethRefundForRepayGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n      btcFeeForLoanGas := and(\\n        MaxUint24,\\n        shr(\\n          ModuleState_btcFeeForLoanGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n      btcFeeForRepayGas := and(\\n        MaxUint24,\\n        shr(\\n          ModuleState_btcFeeForRepayGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n      lastUpdateTimestamp := and(\\n        MaxUint32,\\n        shr(\\n          ModuleState_lastUpdateTimestamp_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function encode(\\n    ModuleType moduleType,\\n    uint256 loanGasE4,\\n    uint256 repayGasE4,\\n    uint256 ethRefundForLoanGas,\\n    uint256 ethRefundForRepayGas,\\n    uint256 btcFeeForLoanGas,\\n    uint256 btcFeeForRepayGas,\\n    uint256 lastUpdateTimestamp\\n  ) internal pure returns (ModuleState encoded) {\\n    assembly {\\n      if or(\\n        gt(loanGasE4, MaxUint8),\\n        or(\\n          gt(repayGasE4, MaxUint8),\\n          or(\\n            gt(ethRefundForLoanGas, MaxUint64),\\n            or(\\n              gt(ethRefundForRepayGas, MaxUint64),\\n              or(\\n                gt(btcFeeForLoanGas, MaxUint24),\\n                or(\\n                  gt(\\n                    btcFeeForRepayGas,\\n                    MaxUint24\\n                  ),\\n                  gt(\\n                    lastUpdateTimestamp,\\n                    MaxUint32\\n                  )\\n                )\\n              )\\n            )\\n          )\\n        )\\n      ) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      encoded := or(\\n        shl(\\n          ModuleState_moduleType_bitsAfter,\\n          moduleType\\n        ),\\n        or(\\n          shl(\\n            ModuleState_loanGasE4_bitsAfter,\\n            loanGasE4\\n          ),\\n          or(\\n            shl(\\n              ModuleState_repayGasE4_bitsAfter,\\n              repayGasE4\\n            ),\\n            or(\\n              shl(\\n                ModuleState_ethRefundForLoanGas_bitsAfter,\\n                ethRefundForLoanGas\\n              ),\\n              or(\\n                shl(\\n                  ModuleState_ethRefundForRepayGas_bitsAfter,\\n                  ethRefundForRepayGas\\n                ),\\n                or(\\n                  shl(\\n                    ModuleState_btcFeeForLoanGas_bitsAfter,\\n                    btcFeeForLoanGas\\n                  ),\\n                  or(\\n                    shl(\\n                      ModuleState_btcFeeForRepayGas_bitsAfter,\\n                      btcFeeForRepayGas\\n                    ),\\n                    shl(\\n                      ModuleState_lastUpdateTimestamp_bitsAfter,\\n                      lastUpdateTimestamp\\n                    )\\n                  )\\n                )\\n              )\\n            )\\n          )\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                  ModuleState LoanParams coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getLoanParams(ModuleState encoded)\\n    internal\\n    pure\\n    returns (\\n      ModuleType moduleType,\\n      uint256 ethRefundForLoanGas\\n    )\\n  {\\n    assembly {\\n      moduleType := shr(\\n        ModuleState_moduleType_bitsAfter,\\n        encoded\\n      )\\n      ethRefundForLoanGas := and(\\n        MaxUint64,\\n        shr(\\n          ModuleState_ethRefundForLoanGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                ModuleState BitcoinGasFees coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getBitcoinGasFees(ModuleState encoded)\\n    internal\\n    pure\\n    returns (\\n      uint256 btcFeeForLoanGas,\\n      uint256 btcFeeForRepayGas\\n    )\\n  {\\n    assembly {\\n      btcFeeForLoanGas := and(\\n        MaxUint24,\\n        shr(\\n          ModuleState_btcFeeForLoanGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n      btcFeeForRepayGas := and(\\n        MaxUint24,\\n        shr(\\n          ModuleState_btcFeeForRepayGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                 ModuleState RepayParams coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function setRepayParams(\\n    ModuleState old,\\n    ModuleType moduleType,\\n    uint256 ethRefundForRepayGas,\\n    uint256 btcFeeForRepayGas\\n  ) internal pure returns (ModuleState updated) {\\n    assembly {\\n      if or(\\n        gt(ethRefundForRepayGas, MaxUint64),\\n        gt(btcFeeForRepayGas, MaxUint24)\\n      ) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(old, ModuleState_RepayParams_maskOut),\\n        or(\\n          shl(\\n            ModuleState_moduleType_bitsAfter,\\n            moduleType\\n          ),\\n          or(\\n            shl(\\n              ModuleState_ethRefundForRepayGas_bitsAfter,\\n              ethRefundForRepayGas\\n            ),\\n            shl(\\n              ModuleState_btcFeeForRepayGas_bitsAfter,\\n              btcFeeForRepayGas\\n            )\\n          )\\n        )\\n      )\\n    }\\n  }\\n\\n  function getRepayParams(ModuleState encoded)\\n    internal\\n    pure\\n    returns (\\n      ModuleType moduleType,\\n      uint256 ethRefundForRepayGas,\\n      uint256 btcFeeForRepayGas\\n    )\\n  {\\n    assembly {\\n      moduleType := shr(\\n        ModuleState_moduleType_bitsAfter,\\n        encoded\\n      )\\n      ethRefundForRepayGas := and(\\n        MaxUint64,\\n        shr(\\n          ModuleState_ethRefundForRepayGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n      btcFeeForRepayGas := and(\\n        MaxUint24,\\n        shr(\\n          ModuleState_btcFeeForRepayGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                    ModuleState Cached coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function setCached(\\n    ModuleState old,\\n    uint256 ethRefundForLoanGas,\\n    uint256 ethRefundForRepayGas,\\n    uint256 btcFeeForLoanGas,\\n    uint256 btcFeeForRepayGas,\\n    uint256 lastUpdateTimestamp\\n  ) internal pure returns (ModuleState updated) {\\n    assembly {\\n      if or(\\n        gt(ethRefundForLoanGas, MaxUint64),\\n        or(\\n          gt(ethRefundForRepayGas, MaxUint64),\\n          or(\\n            gt(btcFeeForLoanGas, MaxUint24),\\n            or(\\n              gt(btcFeeForRepayGas, MaxUint24),\\n              gt(lastUpdateTimestamp, MaxUint32)\\n            )\\n          )\\n        )\\n      ) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(old, ModuleState_Cached_maskOut),\\n        or(\\n          shl(\\n            ModuleState_ethRefundForLoanGas_bitsAfter,\\n            ethRefundForLoanGas\\n          ),\\n          or(\\n            shl(\\n              ModuleState_ethRefundForRepayGas_bitsAfter,\\n              ethRefundForRepayGas\\n            ),\\n            or(\\n              shl(\\n                ModuleState_btcFeeForLoanGas_bitsAfter,\\n                btcFeeForLoanGas\\n              ),\\n              or(\\n                shl(\\n                  ModuleState_btcFeeForRepayGas_bitsAfter,\\n                  btcFeeForRepayGas\\n                ),\\n                shl(\\n                  ModuleState_lastUpdateTimestamp_bitsAfter,\\n                  lastUpdateTimestamp\\n                )\\n              )\\n            )\\n          )\\n        )\\n      )\\n    }\\n  }\\n\\n  function getCached(ModuleState encoded)\\n    internal\\n    pure\\n    returns (\\n      uint256 ethRefundForLoanGas,\\n      uint256 ethRefundForRepayGas,\\n      uint256 btcFeeForLoanGas,\\n      uint256 btcFeeForRepayGas,\\n      uint256 lastUpdateTimestamp\\n    )\\n  {\\n    assembly {\\n      ethRefundForLoanGas := and(\\n        MaxUint64,\\n        shr(\\n          ModuleState_ethRefundForLoanGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n      ethRefundForRepayGas := and(\\n        MaxUint64,\\n        shr(\\n          ModuleState_ethRefundForRepayGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n      btcFeeForLoanGas := and(\\n        MaxUint24,\\n        shr(\\n          ModuleState_btcFeeForLoanGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n      btcFeeForRepayGas := and(\\n        MaxUint24,\\n        shr(\\n          ModuleState_btcFeeForRepayGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n      lastUpdateTimestamp := and(\\n        MaxUint32,\\n        shr(\\n          ModuleState_lastUpdateTimestamp_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                  ModuleState GasParams coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function setGasParams(\\n    ModuleState old,\\n    uint256 loanGasE4,\\n    uint256 repayGasE4\\n  ) internal pure returns (ModuleState updated) {\\n    assembly {\\n      if or(\\n        gt(loanGasE4, MaxUint8),\\n        gt(repayGasE4, MaxUint8)\\n      ) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(old, ModuleState_GasParams_maskOut),\\n        or(\\n          shl(\\n            ModuleState_loanGasE4_bitsAfter,\\n            loanGasE4\\n          ),\\n          shl(\\n            ModuleState_repayGasE4_bitsAfter,\\n            repayGasE4\\n          )\\n        )\\n      )\\n    }\\n  }\\n\\n  function getGasParams(ModuleState encoded)\\n    internal\\n    pure\\n    returns (\\n      uint256 loanGasE4,\\n      uint256 repayGasE4\\n    )\\n  {\\n    assembly {\\n      loanGasE4 := and(\\n        MaxUint8,\\n        shr(\\n          ModuleState_loanGasE4_bitsAfter,\\n          encoded\\n        )\\n      )\\n      repayGasE4 := and(\\n        MaxUint8,\\n        shr(\\n          ModuleState_repayGasE4_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                  ModuleState.moduleType coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getModuleType(ModuleState encoded)\\n    internal\\n    pure\\n    returns (ModuleType moduleType)\\n  {\\n    assembly {\\n      moduleType := shr(\\n        ModuleState_moduleType_bitsAfter,\\n        encoded\\n      )\\n    }\\n  }\\n\\n  function setModuleType(\\n    ModuleState old,\\n    ModuleType moduleType\\n  ) internal pure returns (ModuleState updated) {\\n    assembly {\\n      updated := or(\\n        and(old, ModuleState_moduleType_maskOut),\\n        shl(\\n          ModuleState_moduleType_bitsAfter,\\n          moduleType\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                  ModuleState.loanGasE4 coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getLoanGasE4(ModuleState encoded)\\n    internal\\n    pure\\n    returns (uint256 loanGasE4)\\n  {\\n    assembly {\\n      loanGasE4 := and(\\n        MaxUint8,\\n        shr(\\n          ModuleState_loanGasE4_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setLoanGasE4(\\n    ModuleState old,\\n    uint256 loanGasE4\\n  ) internal pure returns (ModuleState updated) {\\n    assembly {\\n      if gt(loanGasE4, MaxUint8) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(old, ModuleState_loanGasE4_maskOut),\\n        shl(\\n          ModuleState_loanGasE4_bitsAfter,\\n          loanGasE4\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                  ModuleState.repayGasE4 coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getRepayGasE4(ModuleState encoded)\\n    internal\\n    pure\\n    returns (uint256 repayGasE4)\\n  {\\n    assembly {\\n      repayGasE4 := and(\\n        MaxUint8,\\n        shr(\\n          ModuleState_repayGasE4_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setRepayGasE4(\\n    ModuleState old,\\n    uint256 repayGasE4\\n  ) internal pure returns (ModuleState updated) {\\n    assembly {\\n      if gt(repayGasE4, MaxUint8) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(old, ModuleState_repayGasE4_maskOut),\\n        shl(\\n          ModuleState_repayGasE4_bitsAfter,\\n          repayGasE4\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n             ModuleState.ethRefundForLoanGas coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getEthRefundForLoanGas(\\n    ModuleState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 ethRefundForLoanGas)\\n  {\\n    assembly {\\n      ethRefundForLoanGas := and(\\n        MaxUint64,\\n        shr(\\n          ModuleState_ethRefundForLoanGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setEthRefundForLoanGas(\\n    ModuleState old,\\n    uint256 ethRefundForLoanGas\\n  ) internal pure returns (ModuleState updated) {\\n    assembly {\\n      if gt(ethRefundForLoanGas, MaxUint64) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(\\n          old,\\n          ModuleState_ethRefundForLoanGas_maskOut\\n        ),\\n        shl(\\n          ModuleState_ethRefundForLoanGas_bitsAfter,\\n          ethRefundForLoanGas\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n             ModuleState.ethRefundForRepayGas coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getEthRefundForRepayGas(\\n    ModuleState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 ethRefundForRepayGas)\\n  {\\n    assembly {\\n      ethRefundForRepayGas := and(\\n        MaxUint64,\\n        shr(\\n          ModuleState_ethRefundForRepayGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setEthRefundForRepayGas(\\n    ModuleState old,\\n    uint256 ethRefundForRepayGas\\n  ) internal pure returns (ModuleState updated) {\\n    assembly {\\n      if gt(ethRefundForRepayGas, MaxUint64) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(\\n          old,\\n          ModuleState_ethRefundForRepayGas_maskOut\\n        ),\\n        shl(\\n          ModuleState_ethRefundForRepayGas_bitsAfter,\\n          ethRefundForRepayGas\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n               ModuleState.btcFeeForLoanGas coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getBtcFeeForLoanGas(\\n    ModuleState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 btcFeeForLoanGas)\\n  {\\n    assembly {\\n      btcFeeForLoanGas := and(\\n        MaxUint24,\\n        shr(\\n          ModuleState_btcFeeForLoanGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setBtcFeeForLoanGas(\\n    ModuleState old,\\n    uint256 btcFeeForLoanGas\\n  ) internal pure returns (ModuleState updated) {\\n    assembly {\\n      if gt(btcFeeForLoanGas, MaxUint24) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(\\n          old,\\n          ModuleState_btcFeeForLoanGas_maskOut\\n        ),\\n        shl(\\n          ModuleState_btcFeeForLoanGas_bitsAfter,\\n          btcFeeForLoanGas\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n              ModuleState.btcFeeForRepayGas coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getBtcFeeForRepayGas(\\n    ModuleState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 btcFeeForRepayGas)\\n  {\\n    assembly {\\n      btcFeeForRepayGas := and(\\n        MaxUint24,\\n        shr(\\n          ModuleState_btcFeeForRepayGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setBtcFeeForRepayGas(\\n    ModuleState old,\\n    uint256 btcFeeForRepayGas\\n  ) internal pure returns (ModuleState updated) {\\n    assembly {\\n      if gt(btcFeeForRepayGas, MaxUint24) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(\\n          old,\\n          ModuleState_btcFeeForRepayGas_maskOut\\n        ),\\n        shl(\\n          ModuleState_btcFeeForRepayGas_bitsAfter,\\n          btcFeeForRepayGas\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n             ModuleState.lastUpdateTimestamp coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getLastUpdateTimestamp(\\n    ModuleState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 lastUpdateTimestamp)\\n  {\\n    assembly {\\n      lastUpdateTimestamp := and(\\n        MaxUint32,\\n        shr(\\n          ModuleState_lastUpdateTimestamp_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setLastUpdateTimestamp(\\n    ModuleState old,\\n    uint256 lastUpdateTimestamp\\n  ) internal pure returns (ModuleState updated) {\\n    assembly {\\n      if gt(lastUpdateTimestamp, MaxUint32) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(\\n          old,\\n          ModuleState_lastUpdateTimestamp_maskOut\\n        ),\\n        shl(\\n          ModuleState_lastUpdateTimestamp_bitsAfter,\\n          lastUpdateTimestamp\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                 ModuleState comparison methods\\n//////////////////////////////////////////////////////////////*/\\n\\n  function equals(ModuleState a, ModuleState b)\\n    internal\\n    pure\\n    returns (bool _equals)\\n  {\\n    assembly {\\n      _equals := eq(a, b)\\n    }\\n  }\\n\\n  function isNull(ModuleState a)\\n    internal\\n    pure\\n    returns (bool _isNull)\\n  {\\n    _isNull = equals(a, DefaultModuleState);\\n  }\\n}\\n\\nenum ModuleType {\\n  Null,\\n  LoanOverride,\\n  LoanAndRepayOverride\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGatewayRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\n\\nimport \\\"./IGateway.sol\\\";\\n\\n/// @notice GatewayRegistry is a mapping from assets to their associated\\n/// RenERC20 and Gateway contracts.\\ninterface IGatewayRegistry {\\n  /// @dev The symbol is included twice because strings have to be hashed\\n  /// first in order to be used as a log index/topic.\\n  event LogGatewayRegistered(\\n    string _symbol,\\n    string indexed _indexedSymbol,\\n    address indexed _tokenAddress,\\n    address indexed _gatewayAddress\\n  );\\n  event LogGatewayDeregistered(\\n    string _symbol,\\n    string indexed _indexedSymbol,\\n    address indexed _tokenAddress,\\n    address indexed _gatewayAddress\\n  );\\n  event LogGatewayUpdated(\\n    address indexed _tokenAddress,\\n    address indexed _currentGatewayAddress,\\n    address indexed _newGatewayAddress\\n  );\\n\\n  /// @dev To get all the registered gateways use count = 0.\\n  function getGateways(address _start, uint256 _count)\\n    external\\n    view\\n    returns (address[] memory);\\n\\n  /// @dev To get all the registered RenERC20s use count = 0.\\n  function getRenTokens(address _start, uint256 _count)\\n    external\\n    view\\n    returns (address[] memory);\\n\\n  /// @notice Returns the Gateway contract for the given RenERC20\\n  ///         address.\\n  ///\\n  /// @param _tokenAddress The address of the RenERC20 contract.\\n  function getGatewayByToken(address _tokenAddress)\\n    external\\n    view\\n    returns (IGateway);\\n\\n  /// @notice Returns the Gateway contract for the given RenERC20\\n  ///         symbol.\\n  ///\\n  /// @param _tokenSymbol The symbol of the RenERC20 contract.\\n  function getGatewayBySymbol(string calldata _tokenSymbol)\\n    external\\n    view\\n    returns (IGateway);\\n\\n  /// @notice Returns the RenERC20 address for the given token symbol.\\n  ///\\n  /// @param _tokenSymbol The symbol of the RenERC20 contract to\\n  ///        lookup.\\n  function getTokenBySymbol(string calldata _tokenSymbol)\\n    external\\n    view\\n    returns (IERC20);\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/token/ERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport { FixedPointMathLib } from \\\"../utils/FixedPointMathLib.sol\\\";\\nimport { SafeTransferLib } from \\\"../utils/SafeTransferLib.sol\\\";\\nimport { ReentrancyGuard } from \\\"../utils/ReentrancyGuard.sol\\\";\\nimport { ERC2612, UpgradeableEIP712 } from \\\"./ERC2612.sol\\\";\\nimport { ERC4626Storage } from \\\"../storage/ERC4626Storage.sol\\\";\\nimport \\\"../interfaces/IERC4626.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author ZeroDAO\\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\\n/// All functions which can affect the ratio of shares to underlying assets must be nonreentrant\\ncontract ERC4626 is ERC4626Storage, ERC2612, ReentrancyGuard, IERC4626 {\\n  using SafeTransferLib for address;\\n  using FixedPointMathLib for uint256;\\n\\n  /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n  address public immutable override asset;\\n\\n  constructor(\\n    address _asset,\\n    string memory _name,\\n    string memory _symbol,\\n    uint8 _decimals,\\n    address _proxyContract,\\n    string memory _version\\n  ) ERC2612(_proxyContract, _name, _symbol, _decimals, _version) {\\n    asset = _asset;\\n  }\\n\\n  modifier onlyAuthorized() {\\n    require(_authorized[msg.sender], \\\"unauthorized\\\");\\n    _;\\n  }\\n\\n  function _initialize() internal virtual override(UpgradeableEIP712, ReentrancyGuard) {\\n    UpgradeableEIP712._initialize();\\n    ReentrancyGuard._initialize();\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  function deposit(uint256 assets, address receiver)\\n    public\\n    virtual\\n    override\\n    onlyAuthorized\\n    nonReentrant\\n    returns (uint256 shares)\\n  {\\n    // Check for rounding error since we round down in previewDeposit.\\n    if ((shares = previewDeposit(assets)) == 0) {\\n      revert ZeroShares();\\n    }\\n\\n    // Need to transfer before minting or ERC777s could reenter.\\n    asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n    _mint(receiver, shares);\\n\\n    emit Deposit(msg.sender, receiver, assets, shares);\\n\\n    afterDeposit(assets, shares);\\n  }\\n\\n  function mint(uint256 shares, address receiver) public virtual override nonReentrant returns (uint256 assets) {\\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n    // Need to transfer before minting or ERC777s could reenter.\\n    asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n    _mint(receiver, shares);\\n\\n    emit Deposit(msg.sender, receiver, assets, shares);\\n\\n    afterDeposit(assets, shares);\\n  }\\n\\n  function withdraw(\\n    uint256 assets,\\n    address receiver,\\n    address owner\\n  ) public virtual override nonReentrant returns (uint256 shares) {\\n    shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n    if (msg.sender != owner) {\\n      uint256 allowed = _allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n      if (allowed != type(uint256).max) _allowance[owner][msg.sender] = allowed - shares;\\n    }\\n\\n    beforeWithdraw(assets, shares);\\n\\n    _burn(owner, shares);\\n\\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n    asset.safeTransfer(receiver, assets);\\n  }\\n\\n  function redeem(\\n    uint256 shares,\\n    address receiver,\\n    address owner\\n  ) public virtual override nonReentrant returns (uint256 assets) {\\n    if (msg.sender != owner) {\\n      uint256 allowed = _allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n      if (allowed != type(uint256).max) {\\n        _allowance[owner][msg.sender] = allowed - shares;\\n      }\\n    }\\n\\n    // Check for rounding error since we round down in previewRedeem.\\n    if ((assets = previewRedeem(shares)) == 0) {\\n      revert ZeroShares();\\n    }\\n\\n    beforeWithdraw(assets, shares);\\n\\n    _burn(owner, shares);\\n\\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n    asset.safeTransfer(receiver, assets);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  function totalAssets() public view virtual override returns (uint256) {\\n    return IERC20(asset).balanceOf(address(this));\\n  }\\n\\n  function convertToShares(uint256 assets) public view virtual override returns (uint256) {\\n    uint256 supply = _totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n  }\\n\\n  function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\\n    uint256 supply = _totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n    return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n  }\\n\\n  function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\\n    return convertToShares(assets);\\n  }\\n\\n  function previewMint(uint256 shares) public view virtual override returns (uint256) {\\n    uint256 supply = _totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n    return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n  }\\n\\n  function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\\n    uint256 supply = _totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n    return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n  }\\n\\n  function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\\n    return convertToAssets(shares);\\n  }\\n\\n  function previewWithdrawForCheckpoint(\\n    uint256 assets,\\n    uint256 checkpointSupply,\\n    uint256 checkpointTotalAssets\\n  ) internal pure virtual returns (uint256) {\\n    return checkpointSupply == 0 ? assets : assets.mulDivUp(checkpointSupply, checkpointTotalAssets);\\n  }\\n\\n  function checkpointWithdrawParams() internal view returns (uint256 checkpointSupply, uint256 checkpointTotalAssets) {\\n    checkpointSupply = _totalSupply;\\n    checkpointTotalAssets = totalAssets();\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  function maxDeposit(address) public view virtual override returns (uint256) {\\n    return type(uint256).max;\\n  }\\n\\n  function maxMint(address) public view virtual override returns (uint256) {\\n    return type(uint256).max;\\n  }\\n\\n  function maxWithdraw(address owner) public view virtual override returns (uint256) {\\n    return convertToAssets(_balanceOf[owner]);\\n  }\\n\\n  function maxRedeem(address owner) public view virtual override returns (uint256) {\\n    return _balanceOf[owner];\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n  function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/utils/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"../storage/GovernableStorage.sol\\\";\\nimport \\\"../interfaces/IGovernable.sol\\\";\\n\\ncontract Governable is GovernableStorage, IGovernable {\\n  function _initialize(address initialGovernance) internal virtual {\\n    _governance = initialGovernance;\\n  }\\n\\n  function governance() external view override returns (address) {\\n    return _governance;\\n  }\\n\\n  modifier onlyGovernance() {\\n    if (msg.sender != _governance) {\\n      revert NotGovernance();\\n    }\\n    _;\\n  }\\n\\n  function setGovernance(address newGovernance) public onlyGovernance {\\n    emit GovernanceTransferred(_governance, newGovernance);\\n    _governance = newGovernance;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/interfaces/IZeroModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\ninterface IZeroModule {\\n  function initialize() external;\\n\\n  function asset() external view returns (address);\\n\\n  function repayLoan(\\n    address borrower,\\n    uint256 repaidAmount,\\n    uint256 loanId,\\n    bytes calldata data\\n  ) external;\\n\\n  function receiveLoan(\\n    address borrower,\\n    uint256 borrowAmount,\\n    uint256 loanId,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/interfaces/IZeroBTC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { ModuleType } from \\\"../utils/ModuleStateCoder.sol\\\";\\nimport { IERC4626 } from \\\"./IERC4626.sol\\\";\\nimport \\\"./IGovernable.sol\\\";\\nimport \\\"./InitializationErrors.sol\\\";\\n\\ninterface IZeroBTC is IERC4626, IGovernable, InitializationErrors {\\n  /*//////////////////////////////////////////////////////////////\\n                               Actions\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function loan(\\n    address module,\\n    address borrower,\\n    uint256 borrowAmount,\\n    uint256 nonce,\\n    bytes memory data\\n  ) external;\\n\\n  function repay(\\n    address module,\\n    address borrower,\\n    uint256 borrowAmount,\\n    uint256 nonce,\\n    bytes memory data,\\n    address lender,\\n    bytes32 nHash,\\n    bytes memory renSignature\\n  ) external;\\n\\n  function closeExpiredLoan(\\n    address module,\\n    address borrower,\\n    uint256 borrowAmount,\\n    uint256 nonce,\\n    bytes memory data,\\n    address lender\\n  ) external;\\n\\n  function earn() external;\\n\\n  function setGlobalFees(\\n    uint256 zeroBorrowFeeBips,\\n    uint256 renBorrowFeeBips,\\n    uint256 zeroBorrowFeeStatic,\\n    uint256 renBorrowFeeStatic,\\n    uint256 zeroFeeShareBips\\n  ) external;\\n\\n  function setModuleGasFees(\\n    address module,\\n    uint256 loanGas,\\n    uint256 repayGas\\n  ) external;\\n\\n  function addModule(\\n    address module,\\n    ModuleType moduleType,\\n    uint256 loanGas,\\n    uint256 repayGas\\n  ) external;\\n\\n  function removeModule(address module) external;\\n\\n  function pokeGlobalCache() external;\\n\\n  function pokeModuleCache(address module) external;\\n\\n  function initialize(\\n    address initialGovernance,\\n    uint256 zeroBorrowFeeBips,\\n    uint256 renBorrowFeeBips,\\n    uint256 zeroBorrowFeeStatic,\\n    uint256 renBorrowFeeStatic,\\n    uint256 zeroFeeShareBips,\\n    address initialHarvester\\n  ) external payable;\\n\\n  /*//////////////////////////////////////////////////////////////\\n                               Getters\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function getConfig()\\n    external\\n    view\\n    returns (\\n      address gatewayRegistry,\\n      address btcEthPriceOracle,\\n      address gasPriceOracle,\\n      address renBtcConverter,\\n      uint256 cacheTimeToLive,\\n      uint256 maxLoanDuration,\\n      uint256 targetEthReserve,\\n      uint256 maxGasProfitShareBips,\\n      address zeroFeeRecipient\\n    );\\n\\n  function getGlobalState()\\n    external\\n    view\\n    returns (\\n      uint256 zeroBorrowFeeBips,\\n      uint256 renBorrowFeeBips,\\n      uint256 zeroFeeShareBips,\\n      uint256 zeroBorrowFeeStatic,\\n      uint256 renBorrowFeeStatic,\\n      uint256 satoshiPerEth,\\n      uint256 gweiPerGas,\\n      uint256 lastUpdateTimestamp,\\n      uint256 totalBitcoinBorrowed,\\n      uint256 unburnedGasReserveShares,\\n      uint256 unburnedZeroFeeShares\\n    );\\n\\n  function getModuleState(address module)\\n    external\\n    view\\n    returns (\\n      ModuleType moduleType,\\n      uint256 loanGasE4,\\n      uint256 repayGasE4,\\n      uint256 ethRefundForLoanGas,\\n      uint256 ethRefundForRepayGas,\\n      uint256 btcFeeForLoanGas,\\n      uint256 btcFeeForRepayGas,\\n      uint256 lastUpdateTimestamp\\n    );\\n\\n  function getOutstandingLoan(uint256 loanId)\\n    external\\n    view\\n    returns (\\n      uint256 sharesLocked,\\n      uint256 actualBorrowAmount,\\n      uint256 lenderDebt,\\n      uint256 vaultExpenseWithoutRepayFee,\\n      uint256 expiry\\n    );\\n\\n  function calculateLoanId(\\n    address module,\\n    address borrower,\\n    uint256 borrowAmount,\\n    uint256 nonce,\\n    bytes memory data,\\n    address lender\\n  ) external view returns (uint256);\\n\\n  /*//////////////////////////////////////////////////////////////\\n                               Errors\\n  //////////////////////////////////////////////////////////////*/\\n\\n  error ModuleDoesNotExist();\\n\\n  error ReceiveLoanError(address module, address borrower, uint256 borrowAmount, uint256 loanId, bytes data);\\n\\n  error RepayLoanError(address module, address borrower, uint256 repaidAmount, uint256 loanId, bytes data);\\n\\n  error ModuleAssetDoesNotMatch(address moduleAsset);\\n\\n  error InvalidModuleType();\\n\\n  error InvalidDynamicBorrowFee();\\n\\n  error LoanDoesNotExist(uint256 loanId);\\n\\n  error LoanIdNotUnique(uint256 loanId);\\n\\n  error InvalidNullValue();\\n\\n  error InvalidSelector();\\n\\n  error LoanNotExpired(uint256 loanId);\\n\\n  /*//////////////////////////////////////////////////////////////\\n                                Events\\n  //////////////////////////////////////////////////////////////*/\\n\\n  event LoanCreated(address lender, address borrower, uint256 loanId, uint256 assetsBorrowed, uint256 sharesLocked);\\n\\n  event LoanClosed(uint256 loanId, uint256 assetsRepaid, uint256 sharesUnlocked, uint256 sharesBurned);\\n\\n  event ModuleStateUpdated(address module, ModuleType moduleType, uint256 loanGasE4, uint256 repayGasE4);\\n\\n  event GlobalStateConfigUpdated(uint256 dynamicBorrowFee, uint256 staticBorrowFee);\\n\\n  event GlobalStateCacheUpdated(uint256 satoshiPerEth, uint256 getGweiPerGas);\\n\\n  event FeeSharesMinted(uint256 gasReserveFees, uint256 gasReserveShares, uint256 zeroFees, uint256 zeroFeeShares);\\n\\n  event FeeSharesBurned(uint256 gasReserveFees, uint256 gasReserveShares, uint256 zeroFees, uint256 zeroFeeShares);\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/interfaces/IRenBtcEthConverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\ninterface IRenBtcEthConverter {\\n  function convertToEth(uint256 minimumEthOut)\\n    external\\n    returns (uint256 actualEthOut);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChainlinkOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\ninterface IChainlinkOracle {\\n  function latestAnswer() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/storage/ERC4626Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport \\\"./ERC2612Storage.sol\\\";\\nimport \\\"./ReentrancyGuardStorage.sol\\\";\\n\\ncontract ERC4626Storage is ERC2612Storage, ReentrancyGuardStorage {\\n  // maps user => authorized\\n  mapping(address => bool) internal _authorized;\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/storage/GovernableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\ncontract GovernableStorage {\\n  address internal _governance;\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/utils/GlobalStateCoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport './CoderConstants.sol';\\n\\n// ============================== NOTICE ==============================\\n// This library was automatically generated with stackpacker.\\n// Be very careful about modifying it, as doing so incorrectly could\\n// result in corrupted reads/writes.\\n// ====================================================================\\n\\n// struct GlobalState {\\n//   uint11 zeroBorrowFeeBips;\\n//   uint11 renBorrowFeeBips;\\n//   uint13 zeroFeeShareBips;\\n//   uint23 zeroBorrowFeeStatic;\\n//   uint23 renBorrowFeeStatic;\\n//   uint30 satoshiPerEth;\\n//   uint16 gweiPerGas;\\n//   uint32 lastUpdateTimestamp;\\n//   uint40 totalBitcoinBorrowed;\\n//   uint28 unburnedGasReserveShares;\\n//   uint28 unburnedZeroFeeShares;\\n// }\\ntype GlobalState is uint256;\\n\\nGlobalState constant DefaultGlobalState = GlobalState\\n  .wrap(0);\\n\\nlibrary GlobalStateCoder {\\n  /*//////////////////////////////////////////////////////////////\\n                           GlobalState\\n//////////////////////////////////////////////////////////////*/\\n\\n  function decode(GlobalState encoded)\\n    internal\\n    pure\\n    returns (\\n      uint256 zeroBorrowFeeBips,\\n      uint256 renBorrowFeeBips,\\n      uint256 zeroFeeShareBips,\\n      uint256 zeroBorrowFeeStatic,\\n      uint256 renBorrowFeeStatic,\\n      uint256 satoshiPerEth,\\n      uint256 gweiPerGas,\\n      uint256 lastUpdateTimestamp,\\n      uint256 totalBitcoinBorrowed,\\n      uint256 unburnedGasReserveShares,\\n      uint256 unburnedZeroFeeShares\\n    )\\n  {\\n    assembly {\\n      zeroBorrowFeeBips := shr(\\n        GlobalState_zeroBorrowFeeBips_bitsAfter,\\n        encoded\\n      )\\n      renBorrowFeeBips := and(\\n        MaxUint11,\\n        shr(\\n          GlobalState_renBorrowFeeBips_bitsAfter,\\n          encoded\\n        )\\n      )\\n      zeroFeeShareBips := and(\\n        MaxUint13,\\n        shr(\\n          GlobalState_zeroFeeShareBips_bitsAfter,\\n          encoded\\n        )\\n      )\\n      zeroBorrowFeeStatic := and(\\n        MaxUint23,\\n        shr(\\n          GlobalState_zeroBorrowFeeStatic_bitsAfter,\\n          encoded\\n        )\\n      )\\n      renBorrowFeeStatic := and(\\n        MaxUint23,\\n        shr(\\n          GlobalState_renBorrowFeeStatic_bitsAfter,\\n          encoded\\n        )\\n      )\\n      satoshiPerEth := and(\\n        MaxUint30,\\n        shr(\\n          GlobalState_satoshiPerEth_bitsAfter,\\n          encoded\\n        )\\n      )\\n      gweiPerGas := and(\\n        MaxUint16,\\n        shr(\\n          GlobalState_gweiPerGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n      lastUpdateTimestamp := and(\\n        MaxUint32,\\n        shr(\\n          GlobalState_lastUpdateTimestamp_bitsAfter,\\n          encoded\\n        )\\n      )\\n      totalBitcoinBorrowed := and(\\n        MaxUint40,\\n        shr(\\n          GlobalState_totalBitcoinBorrowed_bitsAfter,\\n          encoded\\n        )\\n      )\\n      unburnedGasReserveShares := and(\\n        MaxUint28,\\n        shr(\\n          GlobalState_unburnedGasReserveShares_bitsAfter,\\n          encoded\\n        )\\n      )\\n      unburnedZeroFeeShares := and(\\n        MaxUint28,\\n        shr(\\n          GlobalState_unburnedZeroFeeShares_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function encode(\\n    uint256 zeroBorrowFeeBips,\\n    uint256 renBorrowFeeBips,\\n    uint256 zeroFeeShareBips,\\n    uint256 zeroBorrowFeeStatic,\\n    uint256 renBorrowFeeStatic,\\n    uint256 satoshiPerEth,\\n    uint256 gweiPerGas,\\n    uint256 lastUpdateTimestamp,\\n    uint256 totalBitcoinBorrowed,\\n    uint256 unburnedGasReserveShares,\\n    uint256 unburnedZeroFeeShares\\n  ) internal pure returns (GlobalState encoded) {\\n    assembly {\\n      if or(\\n        gt(zeroBorrowFeeStatic, MaxUint23),\\n        or(\\n          gt(renBorrowFeeStatic, MaxUint23),\\n          or(\\n            gt(satoshiPerEth, MaxUint30),\\n            or(\\n              gt(gweiPerGas, MaxUint16),\\n              or(\\n                gt(\\n                  lastUpdateTimestamp,\\n                  MaxUint32\\n                ),\\n                or(\\n                  gt(\\n                    totalBitcoinBorrowed,\\n                    MaxUint40\\n                  ),\\n                  or(\\n                    gt(\\n                      unburnedGasReserveShares,\\n                      MaxUint28\\n                    ),\\n                    gt(\\n                      unburnedZeroFeeShares,\\n                      MaxUint28\\n                    )\\n                  )\\n                )\\n              )\\n            )\\n          )\\n        )\\n      ) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      encoded := or(\\n        shl(\\n          GlobalState_zeroBorrowFeeBips_bitsAfter,\\n          zeroBorrowFeeBips\\n        ),\\n        or(\\n          shl(\\n            GlobalState_renBorrowFeeBips_bitsAfter,\\n            renBorrowFeeBips\\n          ),\\n          or(\\n            shl(\\n              GlobalState_zeroFeeShareBips_bitsAfter,\\n              zeroFeeShareBips\\n            ),\\n            or(\\n              shl(\\n                GlobalState_zeroBorrowFeeStatic_bitsAfter,\\n                zeroBorrowFeeStatic\\n              ),\\n              or(\\n                shl(\\n                  GlobalState_renBorrowFeeStatic_bitsAfter,\\n                  renBorrowFeeStatic\\n                ),\\n                or(\\n                  shl(\\n                    GlobalState_satoshiPerEth_bitsAfter,\\n                    satoshiPerEth\\n                  ),\\n                  or(\\n                    shl(\\n                      GlobalState_gweiPerGas_bitsAfter,\\n                      gweiPerGas\\n                    ),\\n                    or(\\n                      shl(\\n                        GlobalState_lastUpdateTimestamp_bitsAfter,\\n                        lastUpdateTimestamp\\n                      ),\\n                      or(\\n                        shl(\\n                          GlobalState_totalBitcoinBorrowed_bitsAfter,\\n                          totalBitcoinBorrowed\\n                        ),\\n                        or(\\n                          shl(\\n                            GlobalState_unburnedGasReserveShares_bitsAfter,\\n                            unburnedGasReserveShares\\n                          ),\\n                          shl(\\n                            GlobalState_unburnedZeroFeeShares_bitsAfter,\\n                            unburnedZeroFeeShares\\n                          )\\n                        )\\n                      )\\n                    )\\n                  )\\n                )\\n              )\\n            )\\n          )\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                   GlobalState LoanInfo coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function setLoanInfo(\\n    GlobalState old,\\n    uint256 totalBitcoinBorrowed\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      if gt(totalBitcoinBorrowed, MaxUint40) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(old, GlobalState_LoanInfo_maskOut),\\n        shl(\\n          GlobalState_totalBitcoinBorrowed_bitsAfter,\\n          totalBitcoinBorrowed\\n        )\\n      )\\n    }\\n  }\\n\\n  function getLoanInfo(GlobalState encoded)\\n    internal\\n    pure\\n    returns (uint256 totalBitcoinBorrowed)\\n  {\\n    assembly {\\n      totalBitcoinBorrowed := and(\\n        MaxUint40,\\n        shr(\\n          GlobalState_totalBitcoinBorrowed_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                     GlobalState Fees coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function setFees(\\n    GlobalState old,\\n    uint256 zeroBorrowFeeBips,\\n    uint256 renBorrowFeeBips,\\n    uint256 zeroBorrowFeeStatic,\\n    uint256 renBorrowFeeStatic,\\n    uint256 zeroFeeShareBips\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      if or(\\n        gt(zeroBorrowFeeBips, MaxUint11),\\n        or(\\n          gt(renBorrowFeeBips, MaxUint11),\\n          or(\\n            gt(zeroBorrowFeeStatic, MaxUint23),\\n            or(\\n              gt(renBorrowFeeStatic, MaxUint23),\\n              gt(zeroFeeShareBips, MaxUint13)\\n            )\\n          )\\n        )\\n      ) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(old, GlobalState_Fees_maskOut),\\n        or(\\n          shl(\\n            GlobalState_zeroBorrowFeeBips_bitsAfter,\\n            zeroBorrowFeeBips\\n          ),\\n          or(\\n            shl(\\n              GlobalState_renBorrowFeeBips_bitsAfter,\\n              renBorrowFeeBips\\n            ),\\n            or(\\n              shl(\\n                GlobalState_zeroBorrowFeeStatic_bitsAfter,\\n                zeroBorrowFeeStatic\\n              ),\\n              or(\\n                shl(\\n                  GlobalState_renBorrowFeeStatic_bitsAfter,\\n                  renBorrowFeeStatic\\n                ),\\n                shl(\\n                  GlobalState_zeroFeeShareBips_bitsAfter,\\n                  zeroFeeShareBips\\n                )\\n              )\\n            )\\n          )\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                  GlobalState BorrowFees coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getBorrowFees(GlobalState encoded)\\n    internal\\n    pure\\n    returns (\\n      uint256 zeroBorrowFeeBips,\\n      uint256 renBorrowFeeBips,\\n      uint256 zeroBorrowFeeStatic,\\n      uint256 renBorrowFeeStatic\\n    )\\n  {\\n    assembly {\\n      zeroBorrowFeeBips := shr(\\n        GlobalState_zeroBorrowFeeBips_bitsAfter,\\n        encoded\\n      )\\n      renBorrowFeeBips := and(\\n        MaxUint11,\\n        shr(\\n          GlobalState_renBorrowFeeBips_bitsAfter,\\n          encoded\\n        )\\n      )\\n      zeroBorrowFeeStatic := and(\\n        MaxUint23,\\n        shr(\\n          GlobalState_zeroBorrowFeeStatic_bitsAfter,\\n          encoded\\n        )\\n      )\\n      renBorrowFeeStatic := and(\\n        MaxUint23,\\n        shr(\\n          GlobalState_renBorrowFeeStatic_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                    GlobalState Cached coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function setCached(\\n    GlobalState old,\\n    uint256 satoshiPerEth,\\n    uint256 gweiPerGas,\\n    uint256 lastUpdateTimestamp\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      if or(\\n        gt(satoshiPerEth, MaxUint30),\\n        or(\\n          gt(gweiPerGas, MaxUint16),\\n          gt(lastUpdateTimestamp, MaxUint32)\\n        )\\n      ) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(old, GlobalState_Cached_maskOut),\\n        or(\\n          shl(\\n            GlobalState_satoshiPerEth_bitsAfter,\\n            satoshiPerEth\\n          ),\\n          or(\\n            shl(\\n              GlobalState_gweiPerGas_bitsAfter,\\n              gweiPerGas\\n            ),\\n            shl(\\n              GlobalState_lastUpdateTimestamp_bitsAfter,\\n              lastUpdateTimestamp\\n            )\\n          )\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n             GlobalState ParamsForModuleFees coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function setParamsForModuleFees(\\n    GlobalState old,\\n    uint256 satoshiPerEth,\\n    uint256 gweiPerGas\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      if or(\\n        gt(satoshiPerEth, MaxUint30),\\n        gt(gweiPerGas, MaxUint16)\\n      ) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(\\n          old,\\n          GlobalState_ParamsForModuleFees_maskOut\\n        ),\\n        or(\\n          shl(\\n            GlobalState_satoshiPerEth_bitsAfter,\\n            satoshiPerEth\\n          ),\\n          shl(\\n            GlobalState_gweiPerGas_bitsAfter,\\n            gweiPerGas\\n          )\\n        )\\n      )\\n    }\\n  }\\n\\n  function getParamsForModuleFees(\\n    GlobalState encoded\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint256 satoshiPerEth,\\n      uint256 gweiPerGas\\n    )\\n  {\\n    assembly {\\n      satoshiPerEth := and(\\n        MaxUint30,\\n        shr(\\n          GlobalState_satoshiPerEth_bitsAfter,\\n          encoded\\n        )\\n      )\\n      gweiPerGas := and(\\n        MaxUint16,\\n        shr(\\n          GlobalState_gweiPerGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                GlobalState UnburnedShares coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function setUnburnedShares(\\n    GlobalState old,\\n    uint256 unburnedGasReserveShares,\\n    uint256 unburnedZeroFeeShares\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      if or(\\n        gt(unburnedGasReserveShares, MaxUint28),\\n        gt(unburnedZeroFeeShares, MaxUint28)\\n      ) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(\\n          old,\\n          GlobalState_UnburnedShares_maskOut\\n        ),\\n        or(\\n          shl(\\n            GlobalState_unburnedGasReserveShares_bitsAfter,\\n            unburnedGasReserveShares\\n          ),\\n          shl(\\n            GlobalState_unburnedZeroFeeShares_bitsAfter,\\n            unburnedZeroFeeShares\\n          )\\n        )\\n      )\\n    }\\n  }\\n\\n  function getUnburnedShares(GlobalState encoded)\\n    internal\\n    pure\\n    returns (\\n      uint256 unburnedGasReserveShares,\\n      uint256 unburnedZeroFeeShares\\n    )\\n  {\\n    assembly {\\n      unburnedGasReserveShares := and(\\n        MaxUint28,\\n        shr(\\n          GlobalState_unburnedGasReserveShares_bitsAfter,\\n          encoded\\n        )\\n      )\\n      unburnedZeroFeeShares := and(\\n        MaxUint28,\\n        shr(\\n          GlobalState_unburnedZeroFeeShares_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n              GlobalState.zeroBorrowFeeBips coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getZeroBorrowFeeBips(\\n    GlobalState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 zeroBorrowFeeBips)\\n  {\\n    assembly {\\n      zeroBorrowFeeBips := shr(\\n        GlobalState_zeroBorrowFeeBips_bitsAfter,\\n        encoded\\n      )\\n    }\\n  }\\n\\n  function setZeroBorrowFeeBips(\\n    GlobalState old,\\n    uint256 zeroBorrowFeeBips\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      updated := or(\\n        and(\\n          old,\\n          GlobalState_zeroBorrowFeeBips_maskOut\\n        ),\\n        shl(\\n          GlobalState_zeroBorrowFeeBips_bitsAfter,\\n          zeroBorrowFeeBips\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n               GlobalState.renBorrowFeeBips coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getRenBorrowFeeBips(\\n    GlobalState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 renBorrowFeeBips)\\n  {\\n    assembly {\\n      renBorrowFeeBips := and(\\n        MaxUint11,\\n        shr(\\n          GlobalState_renBorrowFeeBips_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setRenBorrowFeeBips(\\n    GlobalState old,\\n    uint256 renBorrowFeeBips\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      updated := or(\\n        and(\\n          old,\\n          GlobalState_renBorrowFeeBips_maskOut\\n        ),\\n        shl(\\n          GlobalState_renBorrowFeeBips_bitsAfter,\\n          renBorrowFeeBips\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n               GlobalState.zeroFeeShareBips coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getZeroFeeShareBips(\\n    GlobalState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 zeroFeeShareBips)\\n  {\\n    assembly {\\n      zeroFeeShareBips := and(\\n        MaxUint13,\\n        shr(\\n          GlobalState_zeroFeeShareBips_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setZeroFeeShareBips(\\n    GlobalState old,\\n    uint256 zeroFeeShareBips\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      updated := or(\\n        and(\\n          old,\\n          GlobalState_zeroFeeShareBips_maskOut\\n        ),\\n        shl(\\n          GlobalState_zeroFeeShareBips_bitsAfter,\\n          zeroFeeShareBips\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n             GlobalState.zeroBorrowFeeStatic coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getZeroBorrowFeeStatic(\\n    GlobalState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 zeroBorrowFeeStatic)\\n  {\\n    assembly {\\n      zeroBorrowFeeStatic := and(\\n        MaxUint23,\\n        shr(\\n          GlobalState_zeroBorrowFeeStatic_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setZeroBorrowFeeStatic(\\n    GlobalState old,\\n    uint256 zeroBorrowFeeStatic\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      if gt(zeroBorrowFeeStatic, MaxUint23) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(\\n          old,\\n          GlobalState_zeroBorrowFeeStatic_maskOut\\n        ),\\n        shl(\\n          GlobalState_zeroBorrowFeeStatic_bitsAfter,\\n          zeroBorrowFeeStatic\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n              GlobalState.renBorrowFeeStatic coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getRenBorrowFeeStatic(\\n    GlobalState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 renBorrowFeeStatic)\\n  {\\n    assembly {\\n      renBorrowFeeStatic := and(\\n        MaxUint23,\\n        shr(\\n          GlobalState_renBorrowFeeStatic_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setRenBorrowFeeStatic(\\n    GlobalState old,\\n    uint256 renBorrowFeeStatic\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      if gt(renBorrowFeeStatic, MaxUint23) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(\\n          old,\\n          GlobalState_renBorrowFeeStatic_maskOut\\n        ),\\n        shl(\\n          GlobalState_renBorrowFeeStatic_bitsAfter,\\n          renBorrowFeeStatic\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                GlobalState.satoshiPerEth coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getSatoshiPerEth(GlobalState encoded)\\n    internal\\n    pure\\n    returns (uint256 satoshiPerEth)\\n  {\\n    assembly {\\n      satoshiPerEth := and(\\n        MaxUint30,\\n        shr(\\n          GlobalState_satoshiPerEth_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                  GlobalState.gweiPerGas coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getGweiPerGas(GlobalState encoded)\\n    internal\\n    pure\\n    returns (uint256 gweiPerGas)\\n  {\\n    assembly {\\n      gweiPerGas := and(\\n        MaxUint16,\\n        shr(\\n          GlobalState_gweiPerGas_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n             GlobalState.lastUpdateTimestamp coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getLastUpdateTimestamp(\\n    GlobalState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 lastUpdateTimestamp)\\n  {\\n    assembly {\\n      lastUpdateTimestamp := and(\\n        MaxUint32,\\n        shr(\\n          GlobalState_lastUpdateTimestamp_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n             GlobalState.totalBitcoinBorrowed coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getTotalBitcoinBorrowed(\\n    GlobalState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 totalBitcoinBorrowed)\\n  {\\n    assembly {\\n      totalBitcoinBorrowed := and(\\n        MaxUint40,\\n        shr(\\n          GlobalState_totalBitcoinBorrowed_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setTotalBitcoinBorrowed(\\n    GlobalState old,\\n    uint256 totalBitcoinBorrowed\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      if gt(totalBitcoinBorrowed, MaxUint40) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(\\n          old,\\n          GlobalState_totalBitcoinBorrowed_maskOut\\n        ),\\n        shl(\\n          GlobalState_totalBitcoinBorrowed_bitsAfter,\\n          totalBitcoinBorrowed\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n           GlobalState.unburnedGasReserveShares coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getUnburnedGasReserveShares(\\n    GlobalState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 unburnedGasReserveShares)\\n  {\\n    assembly {\\n      unburnedGasReserveShares := and(\\n        MaxUint28,\\n        shr(\\n          GlobalState_unburnedGasReserveShares_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setUnburnedGasReserveShares(\\n    GlobalState old,\\n    uint256 unburnedGasReserveShares\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      if gt(unburnedGasReserveShares, MaxUint28) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(\\n          old,\\n          GlobalState_unburnedGasReserveShares_maskOut\\n        ),\\n        shl(\\n          GlobalState_unburnedGasReserveShares_bitsAfter,\\n          unburnedGasReserveShares\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n            GlobalState.unburnedZeroFeeShares coders\\n//////////////////////////////////////////////////////////////*/\\n\\n  function getUnburnedZeroFeeShares(\\n    GlobalState encoded\\n  )\\n    internal\\n    pure\\n    returns (uint256 unburnedZeroFeeShares)\\n  {\\n    assembly {\\n      unburnedZeroFeeShares := and(\\n        MaxUint28,\\n        shr(\\n          GlobalState_unburnedZeroFeeShares_bitsAfter,\\n          encoded\\n        )\\n      )\\n    }\\n  }\\n\\n  function setUnburnedZeroFeeShares(\\n    GlobalState old,\\n    uint256 unburnedZeroFeeShares\\n  ) internal pure returns (GlobalState updated) {\\n    assembly {\\n      if gt(unburnedZeroFeeShares, MaxUint28) {\\n        mstore(0, Panic_error_signature)\\n        mstore(\\n          Panic_error_offset,\\n          Panic_arithmetic\\n        )\\n        revert(0, Panic_error_length)\\n      }\\n      updated := or(\\n        and(\\n          old,\\n          GlobalState_unburnedZeroFeeShares_maskOut\\n        ),\\n        shl(\\n          GlobalState_unburnedZeroFeeShares_bitsAfter,\\n          unburnedZeroFeeShares\\n        )\\n      )\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                 GlobalState comparison methods\\n//////////////////////////////////////////////////////////////*/\\n\\n  function equals(GlobalState a, GlobalState b)\\n    internal\\n    pure\\n    returns (bool _equals)\\n  {\\n    assembly {\\n      _equals := eq(a, b)\\n    }\\n  }\\n\\n  function isNull(GlobalState a)\\n    internal\\n    pure\\n    returns (bool _isNull)\\n  {\\n    _isNull = equals(a, DefaultGlobalState);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface IMintGateway {\\n  function mint(\\n    bytes32 _pHash,\\n    uint256 _amount,\\n    bytes32 _nHash,\\n    bytes calldata _sig\\n  ) external returns (uint256);\\n\\n  function mintFee() external view returns (uint256);\\n}\\n\\ninterface IBurnGateway {\\n  function burn(bytes memory _to, uint256 _amountScaled)\\n    external\\n    returns (uint256);\\n\\n  function burnFee() external view returns (uint256);\\n}\\n\\ninterface IGateway is IMintGateway, IBurnGateway {\\n\\n}\\n\\n/*\\ninterface IGateway is IMintGateway, IBurnGateway {\\n    function mint(\\n        bytes32 _pHash,\\n        uint256 _amount,\\n        bytes32 _nHash,\\n        bytes calldata _sig\\n    ) external returns (uint256);\\n\\n    function mintFee() external view returns (uint256);\\n\\n    function burn(bytes calldata _to, uint256 _amountScaled)\\n        external\\n        returns (uint256);\\n\\n    function burnFee() external view returns (uint256);\\n}\\n*/\\n\"\r\n    },\r\n    \"contracts/erc4626/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author ZeroDAO\\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n  /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  function safeTransferETH(address to, uint256 amount) internal {\\n    bool success;\\n\\n    assembly {\\n      // Transfer the ETH and store if it succeeded or not.\\n      success := call(gas(), to, amount, 0, 0, 0, 0)\\n    }\\n\\n    require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  function safeTransferFrom(\\n    address token,\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal {\\n    bool success;\\n\\n    assembly {\\n      // Get a pointer to some free memory.\\n      let freeMemoryPointer := mload(0x40)\\n\\n      // Write the abi-encoded calldata into memory, beginning with the function selector.\\n      mstore(\\n        freeMemoryPointer,\\n        0x23b872dd00000000000000000000000000000000000000000000000000000000\\n      )\\n      mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n      mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n      mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n      success := and(\\n        // Set success to whether the call reverted, if not we check it either\\n        // returned exactly 1 (can't just be non-zero data), or had no return data.\\n        or(\\n          and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n          iszero(returndatasize())\\n        ),\\n        // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n        // Counterintuitively, this call must be positioned second to the or() call in the\\n        // surrounding and() call or else returndatasize() will be zero during the computation.\\n        call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n      )\\n    }\\n\\n    require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n  }\\n\\n  function safeTransfer(\\n    address token,\\n    address to,\\n    uint256 amount\\n  ) internal {\\n    bool success;\\n\\n    assembly {\\n      // Get a pointer to some free memory.\\n      let freeMemoryPointer := mload(0x40)\\n\\n      // Write the abi-encoded calldata into memory, beginning with the function selector.\\n      mstore(\\n        freeMemoryPointer,\\n        0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n      )\\n      mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n      mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n      success := and(\\n        // Set success to whether the call reverted, if not we check it either\\n        // returned exactly 1 (can't just be non-zero data), or had no return data.\\n        or(\\n          and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n          iszero(returndatasize())\\n        ),\\n        // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n        // Counterintuitively, this call must be positioned second to the or() call in the\\n        // surrounding and() call or else returndatasize() will be zero during the computation.\\n        call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n      )\\n    }\\n\\n    require(success, \\\"TRANSFER_FAILED\\\");\\n  }\\n\\n  function safeApprove(\\n    address token,\\n    address to,\\n    uint256 amount\\n  ) internal {\\n    bool success;\\n\\n    assembly {\\n      // Get a pointer to some free memory.\\n      let freeMemoryPointer := mload(0x40)\\n\\n      // Write the abi-encoded calldata into memory, beginning with the function selector.\\n      mstore(\\n        freeMemoryPointer,\\n        0x095ea7b300000000000000000000000000000000000000000000000000000000\\n      )\\n      mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n      mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n      success := and(\\n        // Set success to whether the call reverted, if not we check it either\\n        // returned exactly 1 (can't just be non-zero data), or had no return data.\\n        or(\\n          and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n          iszero(returndatasize())\\n        ),\\n        // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n        // Counterintuitively, this call must be positioned second to the or() call in the\\n        // surrounding and() call or else returndatasize() will be zero during the computation.\\n        call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n      )\\n    }\\n\\n    require(success, \\\"APPROVE_FAILED\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\nimport \\\"../interfaces/ReentrancyErrors.sol\\\";\\nimport \\\"../storage/ReentrancyGuardStorage.sol\\\";\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard is ReentrancyGuardStorage, ReentrancyErrors {\\n  function _initialize() internal virtual {\\n    locked = 1;\\n  }\\n\\n  modifier nonReentrant() virtual {\\n    if (locked != 1) {\\n      revert Reentrancy();\\n    }\\n\\n    locked = 2;\\n    _;\\n    locked = 1;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/token/ERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport \\\"../storage/ERC2612Storage.sol\\\";\\nimport \\\"../utils/SignatureVerification.sol\\\";\\nimport \\\"../interfaces/IERC2612.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\ncontract ERC2612 is ERC2612Storage, ERC20, SignatureVerification, IERC2612 {\\n  /*//////////////////////////////////////////////////////////////\\n                             Constructor\\n  //////////////////////////////////////////////////////////////*/\\n\\n  constructor(\\n    address _proxyContract,\\n    string memory _name,\\n    string memory _symbol,\\n    uint8 _decimals,\\n    string memory _version\\n  )\\n    ERC20(_name, _symbol, _decimals)\\n    SignatureVerification(_proxyContract, _name, _version)\\n  {}\\n\\n  /*//////////////////////////////////////////////////////////////\\n                               Queries\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n    return getDomainSeparator();\\n  }\\n\\n  function nonces(address account) external view override returns (uint256) {\\n    return _nonces[account];\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                               Actions\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8,\\n    bytes32,\\n    bytes32\\n  ) external virtual override {\\n    if (deadline < block.timestamp) {\\n      revert PermitDeadlineExpired(deadline, block.timestamp);\\n    }\\n    _verifyPermitSignature(owner, _nonces[owner]++, deadline);\\n\\n    // Unchecked because the only math done is incrementing\\n    // the owner's nonce which cannot realistically overflow.\\n    unchecked {\\n      _allowance[owner][spender] = value;\\n    }\\n\\n    emit Approval(owner, spender, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/interfaces/IERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"./IERC2612.sol\\\";\\nimport \\\"./ReentrancyErrors.sol\\\";\\n\\ninterface IERC4626 is IERC2612, ReentrancyErrors {\\n  function asset() external view returns (address);\\n\\n  function deposit(uint256 assets, address receiver)\\n    external\\n    returns (uint256 shares);\\n\\n  function mint(uint256 shares, address receiver)\\n    external\\n    returns (uint256 assets);\\n\\n  function withdraw(\\n    uint256 assets,\\n    address receiver,\\n    address owner\\n  ) external returns (uint256 shares);\\n\\n  function redeem(\\n    uint256 shares,\\n    address receiver,\\n    address owner\\n  ) external returns (uint256 assets);\\n\\n  function totalAssets() external view returns (uint256);\\n\\n  function convertToShares(uint256 assets) external view returns (uint256);\\n\\n  function convertToAssets(uint256 shares) external view returns (uint256);\\n\\n  function previewDeposit(uint256 assets) external view returns (uint256);\\n\\n  function previewMint(uint256 shares) external view returns (uint256);\\n\\n  function previewWithdraw(uint256 assets) external view returns (uint256);\\n\\n  function previewRedeem(uint256 shares) external view returns (uint256);\\n\\n  function maxDeposit(address) external view returns (uint256);\\n\\n  function maxMint(address) external view returns (uint256);\\n\\n  function maxWithdraw(address owner) external view returns (uint256);\\n\\n  function maxRedeem(address owner) external view returns (uint256);\\n\\n  /*//////////////////////////////////////////////////////////////\\n                                ERRORS\\n  //////////////////////////////////////////////////////////////*/\\n\\n  error ZeroShares();\\n\\n  /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  event Deposit(\\n    address indexed caller,\\n    address indexed owner,\\n    uint256 assets,\\n    uint256 shares\\n  );\\n\\n  event Withdraw(\\n    address indexed caller,\\n    address indexed receiver,\\n    address indexed owner,\\n    uint256 assets,\\n    uint256 shares\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/interfaces/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\ninterface IGovernable {\\n  function setGovernance(address _governance) external;\\n\\n  function governance() external view returns (address);\\n\\n  /*//////////////////////////////////////////////////////////////\\n                            Errors\\n    //////////////////////////////////////////////////////////////*/\\n\\n  error NotGovernance();\\n\\n  /*//////////////////////////////////////////////////////////////\\n                            Events\\n    //////////////////////////////////////////////////////////////*/\\n\\n  event GovernanceTransferred(\\n    address indexed oldGovernance,\\n    address indexed newGovernance\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/interfaces/InitializationErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\ninterface InitializationErrors {\\n  error AlreadyInitialized();\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/storage/ERC2612Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport \\\"./ERC20Storage.sol\\\";\\n\\ncontract ERC2612Storage is ERC20Storage {\\n  mapping(address => uint256) internal _nonces;\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/storage/ReentrancyGuardStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\ncontract ReentrancyGuardStorage {\\n  uint256 internal locked;\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/interfaces/ReentrancyErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\ninterface ReentrancyErrors {\\n  error Reentrancy();\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/utils/SignatureVerification.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"../EIP712/UpgradeableEIP712.sol\\\";\\nimport { ECDSA } from \\\"oz460/utils/cryptography/ECDSA.sol\\\";\\n\\nbytes constant Permit_typeString = \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\";\\nbytes32 constant Permit_typeHash = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\nuint256 constant Permit_typeHash_ptr = 0x0;\\nuint256 constant Permit_owner_ptr = 0x20;\\nuint256 constant Permit_nonce_ptr = 0x80;\\nuint256 constant Permit_deadline_ptr = 0xa0;\\nuint256 constant Permit_owner_cdPtr = 0x04;\\nuint256 constant Permit_v_cdPtr = 0x84;\\nuint256 constant Permit_signature_length = 0x60;\\nuint256 constant Permit_calldata_params_length = 0x60;\\nuint256 constant Permit_length = 0xc0;\\n\\nuint256 constant ECRecover_precompile = 0x01;\\nuint256 constant ECRecover_digest_ptr = 0x0;\\nuint256 constant ECRecover_v_ptr = 0x20;\\nuint256 constant ECRecover_calldata_length = 0x80;\\n\\ncontract SignatureVerification is UpgradeableEIP712 {\\n  /*//////////////////////////////////////////////////////////////\\n                             Constructor\\n  //////////////////////////////////////////////////////////////*/\\n\\n  constructor(\\n    address _proxyContract,\\n    string memory _name,\\n    string memory _version\\n  ) UpgradeableEIP712(_proxyContract, _name, _version) {\\n    if (Permit_typeHash != keccak256(Permit_typeString)) {\\n      revert InvalidTypeHash();\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                               Permit\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function _digestPermit(uint256 nonce, uint256 deadline) internal view returns (bytes32 digest) {\\n    bytes32 domainSeparator = getDomainSeparator();\\n    assembly {\\n      mstore(Permit_typeHash_ptr, Permit_typeHash)\\n      calldatacopy(Permit_owner_ptr, Permit_owner_cdPtr, Permit_calldata_params_length)\\n      mstore(Permit_nonce_ptr, nonce)\\n      mstore(Permit_deadline_ptr, deadline)\\n      let permitHash := keccak256(Permit_typeHash_ptr, Permit_length)\\n      mstore(0, EIP712Signature_prefix)\\n      mstore(EIP712Signature_domainSeparator_ptr, domainSeparator)\\n      mstore(EIP712Signature_digest_ptr, permitHash)\\n      digest := keccak256(0, EIP712Signature_length)\\n    }\\n  }\\n\\n  function _verifyPermitSignature(\\n    address owner,\\n    uint256 nonce,\\n    uint256 deadline\\n  ) internal view RestoreFirstTwoUnreservedSlots RestoreFreeMemoryPointer RestoreZeroSlot {\\n    bytes32 digest = _digestPermit(nonce, deadline);\\n    bool validSignature;\\n    assembly {\\n      mstore(ECRecover_digest_ptr, digest)\\n      // Copy v, r, s from calldata\\n      calldatacopy(ECRecover_v_ptr, Permit_v_cdPtr, Permit_signature_length)\\n      // Call ecrecover precompile to validate signature\\n      let success := staticcall(\\n        gas(),\\n        ECRecover_precompile, // ecrecover precompile\\n        ECRecover_digest_ptr,\\n        ECRecover_calldata_length,\\n        0x0,\\n        0x20\\n      )\\n      validSignature := and(\\n        success, // call succeeded\\n        and(\\n          gt(owner, 0), // owner != 0\\n          eq(owner, mload(0)) // owner == recoveredAddress\\n        )\\n      )\\n    }\\n    if (!validSignature) {\\n      revert InvalidSigner();\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/interfaces/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC2612 is IERC20 {\\n  error PermitDeadlineExpired(uint256 deadline, uint256 timestamp);\\n\\n  /**\\n   * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n   * given `owner`'s signed approval.\\n   *\\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n   * ordering also apply here.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `owner` cannot be the zero address.\\n   * - `deadline` must be a timestamp in the future.\\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n   * over the EIP712-formatted function arguments.\\n   * - the signature must use ``owner``'s current nonce (see {nonces}).\\n   *\\n   * For more information on the signature format, see the\\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n   * section].\\n   */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n   * included whenever a signature is generated for {permit}.\\n   *\\n   * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n   * prevents a signature from being used multiple times.\\n   */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/token/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport \\\"../utils/CompactStrings.sol\\\";\\nimport \\\"../storage/ERC20Storage.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Zero Protocol\\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\ncontract ERC20 is ERC20Storage, CompactStrings, IERC20 {\\n  /*//////////////////////////////////////////////////////////////\\n                             Immutables\\n  //////////////////////////////////////////////////////////////*/\\n\\n  bytes32 private immutable _packedName;\\n\\n  bytes32 private immutable _packedSymbol;\\n\\n  uint8 public immutable override decimals;\\n\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    uint8 _decimals\\n  ) {\\n    _packedName = packString(_name);\\n    _packedSymbol = packString(_symbol);\\n    decimals = _decimals;\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                               Queries\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function name() external view override returns (string memory) {\\n    return unpackString(_packedName);\\n  }\\n\\n  function symbol() external view override returns (string memory) {\\n    return unpackString(_packedSymbol);\\n  }\\n\\n  function totalSupply() external view override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return _allowance[owner][spender];\\n  }\\n\\n  function balanceOf(address account) external view override returns (uint256) {\\n    return _balanceOf[account];\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                               Actions\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function approve(address spender, uint256 amount)\\n    external\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    _allowance[msg.sender][spender] = amount;\\n\\n    emit Approval(msg.sender, spender, amount);\\n\\n    return true;\\n  }\\n\\n  function transfer(address to, uint256 amount)\\n    external\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    _balanceOf[msg.sender] -= amount;\\n\\n    // Cannot overflow because the sum of all user\\n    // balances can't exceed the max uint256 value.\\n    unchecked {\\n      _balanceOf[to] += amount;\\n    }\\n\\n    emit Transfer(msg.sender, to, amount);\\n\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external virtual override returns (bool) {\\n    uint256 allowed = _allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n    if (allowed != type(uint256).max) {\\n      _allowance[from][msg.sender] = allowed - amount;\\n    }\\n\\n    _balanceOf[from] -= amount;\\n\\n    // Cannot overflow because the sum of all user\\n    // balances can't exceed the max uint256 value.\\n    unchecked {\\n      _balanceOf[to] += amount;\\n    }\\n\\n    emit Transfer(from, to, amount);\\n\\n    return true;\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                       Internal State Handlers\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function _mint(address to, uint256 amount) internal virtual {\\n    _totalSupply += amount;\\n\\n    // Cannot overflow because the sum of all user\\n    // balances can't exceed the max uint256 value.\\n    unchecked {\\n      _balanceOf[to] += amount;\\n    }\\n\\n    emit Transfer(address(0), to, amount);\\n  }\\n\\n  function _burn(address from, uint256 amount) internal virtual {\\n    _balanceOf[from] -= amount;\\n\\n    // Cannot underflow because a user's balance\\n    // will never be larger than the total supply.\\n    unchecked {\\n      _totalSupply -= amount;\\n    }\\n\\n    emit Transfer(from, address(0), amount);\\n  }\\n\\n  function _transfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual {\\n    _balanceOf[from] -= amount;\\n\\n    // Cannot overflow because the sum of all user\\n    // balances can't exceed the max uint256 value.\\n    unchecked {\\n      _balanceOf[to] += amount;\\n    }\\n\\n    emit Transfer(from, to, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/storage/ERC20Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\ncontract ERC20Storage {\\n  uint256 internal _totalSupply;\\n\\n  mapping(address => uint256) internal _balanceOf;\\n\\n  mapping(address => mapping(address => uint256)) internal _allowance;\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/EIP712/UpgradeableEIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport \\\"./AbstractEIP712.sol\\\";\\n\\n// @todo Rename UpgradeableEIP712 to UpgradeableSingletonEIP712\\n/**\\n * @dev ProxyImmutable is used to set `proxyContract` in UpgradeableEIP712\\n * before the constructor of AbstractEIP712 runs, giving it access to the\\n * `verifyingContract` function. The address of the proxy contract must be\\n * known when the implementation is deployed.\\n */\\ncontract ProxyImmutable {\\n  address internal immutable proxyContract;\\n\\n  constructor(address _proxyContract) {\\n    proxyContract = _proxyContract;\\n  }\\n}\\n\\ncontract UpgradeableEIP712 is ProxyImmutable, AbstractEIP712 {\\n  constructor(\\n    address _proxyContract,\\n    string memory _name,\\n    string memory _version\\n  ) ProxyImmutable(_proxyContract) AbstractEIP712(_name, _version) {}\\n\\n  function _initialize() internal virtual {\\n    if (address(this) != _verifyingContract()) {\\n      revert InvalidVerifyingContract();\\n    }\\n  }\\n\\n  function _verifyingContract()\\n    internal\\n    view\\n    virtual\\n    override\\n    returns (address)\\n  {\\n    return proxyContract;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/oz460/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/utils/CompactStrings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"../interfaces/CompactStringErrors.sol\\\";\\n\\ncontract CompactStrings is CompactStringErrors {\\n  function packString(string memory unpackedString)\\n    internal\\n    pure\\n    returns (bytes32 packedString)\\n  {\\n    if (bytes(unpackedString).length > 31) {\\n      revert InvalidCompactString();\\n    }\\n    assembly {\\n      packedString := mload(add(unpackedString, 31))\\n    }\\n  }\\n\\n  function unpackString(bytes32 packedString)\\n    internal\\n    pure\\n    returns (string memory unpackedString)\\n  {\\n    assembly {\\n      // Get free memory pointer\\n      let freeMemPtr := mload(0x40)\\n      // Increase free memory pointer by 64 bytes\\n      mstore(0x40, add(freeMemPtr, 0x40))\\n      // Set pointer to string\\n      unpackedString := freeMemPtr\\n      // Overwrite buffer with zeroes in case it has already been used\\n      mstore(freeMemPtr, 0)\\n      mstore(add(freeMemPtr, 0x20), 0)\\n      // Write length and name to string\\n      mstore(add(freeMemPtr, 0x1f), packedString)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/EIP712/AbstractEIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\nimport \\\"../utils/MemoryRestoration.sol\\\";\\nimport \\\"../interfaces/EIP712Errors.sol\\\";\\n\\nbytes constant EIP712Domain_typeString = \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\";\\nbytes32 constant EIP712Domain_typeHash = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\nuint256 constant EIP712Signature_prefix = 0x1901000000000000000000000000000000000000000000000000000000000000;\\nuint256 constant EIP712Signature_domainSeparator_ptr = 0x2;\\nuint256 constant EIP712Signature_digest_ptr = 0x22;\\nuint256 constant EIP712Signature_length = 0x42;\\n\\nuint256 constant DomainSeparator_nameHash_offset = 0x20;\\nuint256 constant DomainSeparator_versionHash_offset = 0x40;\\nuint256 constant DomainSeparator_chainId_offset = 0x60;\\nuint256 constant DomainSeparator_verifyingContract_offset = 0x80;\\nuint256 constant DomainSeparator_length = 0xa0;\\n\\nabstract contract AbstractEIP712 is MemoryRestoration, EIP712Errors {\\n  uint256 private immutable _CHAIN_ID;\\n  bytes32 private immutable _DOMAIN_SEPARATOR;\\n  bytes32 private immutable _NAME_HASH;\\n  bytes32 private immutable _VERSION_HASH;\\n\\n  constructor(string memory _name, string memory _version) {\\n    _CHAIN_ID = block.chainid;\\n    _NAME_HASH = keccak256(bytes(_name));\\n    _VERSION_HASH = keccak256(bytes(_version));\\n    _DOMAIN_SEPARATOR = _computeDomainSeparator();\\n    if (EIP712Domain_typeHash != keccak256(EIP712Domain_typeString)) {\\n      revert InvalidTypeHash();\\n    }\\n  }\\n\\n  function _computeDomainSeparator() internal view returns (bytes32 separator) {\\n    address verifyingContract = _verifyingContract();\\n    bytes32 nameHash = _NAME_HASH;\\n    bytes32 versionHash = _VERSION_HASH;\\n    assembly {\\n      let ptr := mload(0x40)\\n      mstore(ptr, EIP712Domain_typeHash)\\n      mstore(add(ptr, DomainSeparator_nameHash_offset), nameHash)\\n      mstore(add(ptr, DomainSeparator_versionHash_offset), versionHash)\\n      mstore(add(ptr, DomainSeparator_chainId_offset), chainid())\\n      mstore(\\n        add(ptr, DomainSeparator_verifyingContract_offset),\\n        verifyingContract\\n      )\\n      separator := keccak256(ptr, DomainSeparator_length)\\n    }\\n  }\\n\\n  function getDomainSeparator() internal view virtual returns (bytes32) {\\n    return\\n      block.chainid == _CHAIN_ID\\n        ? _DOMAIN_SEPARATOR\\n        : _computeDomainSeparator();\\n  }\\n\\n  function _verifyingContract() internal view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/oz460/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/interfaces/CompactStringErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\ninterface CompactStringErrors {\\n  error InvalidCompactString();\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/utils/MemoryRestoration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.13;\\n\\ncontract MemoryRestoration {\\n  modifier RestoreOneWord(uint256 slot1) {\\n    uint256 cachedValue;\\n    assembly {\\n      cachedValue := mload(slot1)\\n    }\\n    _;\\n    assembly {\\n      mstore(slot1, cachedValue)\\n    }\\n  }\\n\\n  modifier RestoreTwoWords(uint256 slot1, uint256 slot2) {\\n    uint256 cachedValue1;\\n    uint256 cachedValue2;\\n    assembly {\\n      cachedValue1 := mload(slot1)\\n      cachedValue2 := mload(slot2)\\n    }\\n    _;\\n    assembly {\\n      mstore(slot1, cachedValue1)\\n      mstore(slot2, cachedValue2)\\n    }\\n  }\\n\\n  modifier RestoreThreeWords(\\n    uint256 slot1,\\n    uint256 slot2,\\n    uint256 slot3\\n  ) {\\n    uint256 cachedValue1;\\n    uint256 cachedValue2;\\n    uint256 cachedValue3;\\n    assembly {\\n      cachedValue1 := mload(slot1)\\n      cachedValue2 := mload(slot2)\\n      cachedValue3 := mload(slot3)\\n    }\\n    _;\\n    assembly {\\n      mstore(slot1, cachedValue1)\\n      mstore(slot2, cachedValue2)\\n      mstore(slot3, cachedValue3)\\n    }\\n  }\\n\\n  modifier RestoreFourWords(\\n    uint256 slot1,\\n    uint256 slot2,\\n    uint256 slot3,\\n    uint256 slot4\\n  ) {\\n    uint256 cachedValue1;\\n    uint256 cachedValue2;\\n    uint256 cachedValue3;\\n    uint256 cachedValue4;\\n    assembly {\\n      cachedValue1 := mload(slot1)\\n      cachedValue2 := mload(slot2)\\n      cachedValue3 := mload(slot3)\\n      cachedValue4 := mload(slot4)\\n    }\\n    _;\\n    assembly {\\n      mstore(slot1, cachedValue1)\\n      mstore(slot2, cachedValue2)\\n      mstore(slot3, cachedValue3)\\n      mstore(slot4, cachedValue4)\\n    }\\n  }\\n\\n  modifier RestoreFourWordsBefore(bytes memory data) {\\n    uint256 cachedValue1;\\n    uint256 cachedValue2;\\n    uint256 cachedValue3;\\n    uint256 cachedValue4;\\n    assembly {\\n      cachedValue1 := mload(sub(data, 0x20))\\n      cachedValue2 := mload(sub(data, 0x40))\\n      cachedValue3 := mload(sub(data, 0x60))\\n      cachedValue4 := mload(sub(data, 0x80))\\n    }\\n    _;\\n    assembly {\\n      mstore(sub(data, 0x20), cachedValue1)\\n      mstore(sub(data, 0x40), cachedValue2)\\n      mstore(sub(data, 0x60), cachedValue3)\\n      mstore(sub(data, 0x80), cachedValue4)\\n    }\\n  }\\n\\n  modifier RestoreFirstTwoUnreservedSlots() {\\n    uint256 cachedValue1;\\n    uint256 cachedValue2;\\n    assembly {\\n      cachedValue1 := mload(0x80)\\n      cachedValue2 := mload(0xa0)\\n    }\\n    _;\\n    assembly {\\n      mstore(0x80, cachedValue1)\\n      mstore(0xa0, cachedValue2)\\n    }\\n  }\\n\\n  modifier RestoreFreeMemoryPointer() {\\n    uint256 freeMemoryPointer;\\n    assembly {\\n      freeMemoryPointer := mload(0x40)\\n    }\\n    _;\\n    assembly {\\n      mstore(0x40, freeMemoryPointer)\\n    }\\n  }\\n\\n  modifier RestoreZeroSlot() {\\n    _;\\n    assembly {\\n      mstore(0x60, 0)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc4626/interfaces/EIP712Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\ninterface EIP712Errors {\\n  error InvalidTypeHash();\\n\\n  error InvalidSigner();\\n\\n  error InvalidVerifyingContract();\\n}\\n\"\r\n    },\r\n    \"lib/oz460/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-new/=lib/@openzeppelin/contracts-new/\",\r\n      \"@openzeppelin/contracts/=lib/@openzeppelin/contracts/\",\r\n      \"@rari-capital/=lib/@rari-capital/solmate/src/\",\r\n      \"@rari-capital/solmate/=lib/@rari-capital/solmate/src/\",\r\n      \"@uniswap/=lib/@uniswap/\",\r\n      \"@uniswap/v3-periphery/=lib/@uniswap/v3-periphery/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"oz410/=lib/oz410/\",\r\n      \"oz410/=lib/oz410/contracts/\",\r\n      \"oz460/=lib/oz460/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IGatewayRegistry\",\"name\":\"gatewayRegistry\",\"type\":\"address\"},{\"internalType\":\"contract IChainlinkOracle\",\"name\":\"btcEthPriceOracle\",\"type\":\"address\"},{\"internalType\":\"contract IChainlinkOracle\",\"name\":\"gasPriceOracle\",\"type\":\"address\"},{\"internalType\":\"contract IRenBtcEthConverter\",\"name\":\"renBtcConverter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cacheTimeToLive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoanDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetEthReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxGasProfitShareBips\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"zeroFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proxyContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCompactString\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDynamicBorrowFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidModuleType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNullValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSelector\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTypeHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidVerifyingContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"LoanDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"LoanIdNotUnique\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"LoanNotExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"moduleAsset\",\"type\":\"address\"}],\"name\":\"ModuleAssetDoesNotMatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ModuleDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotGovernance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PermitDeadlineExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ReceiveLoanError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repaidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"RepayLoanError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroShares\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasReserveFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasReserveShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"zeroFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"zeroFeeShares\",\"type\":\"uint256\"}],\"name\":\"FeeSharesBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasReserveFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasReserveShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"zeroFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"zeroFeeShares\",\"type\":\"uint256\"}],\"name\":\"FeeSharesMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"satoshiPerEth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getGweiPerGas\",\"type\":\"uint256\"}],\"name\":\"GlobalStateCacheUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dynamicBorrowFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"staticBorrowFee\",\"type\":\"uint256\"}],\"name\":\"GlobalStateConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldGovernance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetsRepaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesUnlocked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesBurned\",\"type\":\"uint256\"}],\"name\":\"LoanClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetsBorrowed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesLocked\",\"type\":\"uint256\"}],\"name\":\"LoanCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum ModuleType\",\"name\":\"moduleType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanGasE4\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayGasE4\",\"type\":\"uint256\"}],\"name\":\"ModuleStateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"enum ModuleType\",\"name\":\"moduleType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"loanGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repayGas\",\"type\":\"uint256\"}],\"name\":\"addModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"}],\"name\":\"calculateLoanId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"}],\"name\":\"closeExpiredLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"convertToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"convertToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"gatewayRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"btcEthPriceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gasPriceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"renBtcConverter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cacheTimeToLive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoanDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetEthReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxGasProfitShareBips\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"zeroFeeRecipient\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"zeroBorrowFeeBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"renBorrowFeeBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zeroFeeShareBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zeroBorrowFeeStatic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"renBorrowFeeStatic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"satoshiPerEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gweiPerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBitcoinBorrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unburnedGasReserveShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unburnedZeroFeeShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"getModuleState\",\"outputs\":[{\"internalType\":\"enum ModuleType\",\"name\":\"moduleType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"loanGasE4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repayGasE4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethRefundForLoanGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethRefundForRepayGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"btcFeeForLoanGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"btcFeeForRepayGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"getOutstandingLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualBorrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lenderDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"btcFeeForLoanGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialGovernance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"zeroBorrowFeeBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"renBorrowFeeBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zeroBorrowFeeStatic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"renBorrowFeeStatic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zeroFeeShareBips\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"initialHarvester\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"loan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pokeGlobalCache\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"pokeModuleCache\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"removeAuthorizedUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"removeHarvesters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"removeModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"renSignature\",\"type\":\"bytes\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"setAuthorizedUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"zeroBorrowFeeBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"renBorrowFeeBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zeroBorrowFeeStatic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"renBorrowFeeStatic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zeroFeeShareBips\",\"type\":\"uint256\"}],\"name\":\"setGlobalFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"setHarvesters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loanGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repayGas\",\"type\":\"uint256\"}],\"name\":\"setModuleGasFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ZeroBTC","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000f36666c230fa12333579b9bd6196cb634d6bc506000000000000000000000000deb288f737066589598e9214e782fa5a8ed689e8000000000000000000000000169e633a2d1e6c10dd91238ba11c4a708dfef37c00000000000000000000000060a81a16ef01cc887f0a447f338fd664fc7ad8b80000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000003e80000000000000000000000005b73c5498c1e3b4dba84de0f1833c4a029d90519000000000000000000000000eb4c2781e4eba804ce9a9803c67d0893436bb27d00000000000000000000000011dbf784098e296471a08251178f757156651085","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]