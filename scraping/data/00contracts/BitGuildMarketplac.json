[{"SourceCode":"pragma solidity ^0.4.22;\r\n\r\n\r\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\r\n\r\ncontract BitGuildToken {\r\n    // Public variables of the token\r\n    string public name = \"BitGuild PLAT\";\r\n    string public symbol = \"PLAT\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 10000000000 * 10 ** uint256(decimals); // 10 billion tokens;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    /**\r\n     * Constructor function\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n    function BitGuildToken() public {\r\n        balanceOf[msg.sender] = totalSupply;\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        // Subtract from the sender\r\n        balanceOf[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` on behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title BitGuildAccessAdmin\r\n * @dev Allow two roles: 'owner' or 'operator'\r\n *      - owner: admin/superuser (e.g. with financial rights)\r\n *      - operator: can update configurations\r\n */\r\ncontract BitGuildAccessAdmin {\r\n    address public owner;\r\n    address[] public operators;\r\n\r\n    uint public MAX_OPS = 20; // Default maximum number of operators allowed\r\n\r\n    mapping(address => bool) public isOperator;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    event OperatorAdded(address operator);\r\n    event OperatorRemoved(address operator);\r\n\r\n    // @dev The BitGuildAccessAdmin constructor: sets owner to the sender account\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // @dev Throws if called by any non-operator account. Owner has all ops rights.\r\n    modifier onlyOperator() {\r\n        require(\r\n            isOperator[msg.sender] || msg.sender == owner,\r\n            \"Permission denied. Must be an operator or the owner.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(\r\n            _newOwner != address(0),\r\n            \"Invalid new owner address.\"\r\n        );\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner or operators to add operators\r\n     * @param _newOperator New operator address\r\n     */\r\n    function addOperator(address _newOperator) public onlyOwner {\r\n        require(\r\n            _newOperator != address(0),\r\n            \"Invalid new operator address.\"\r\n        );\r\n\r\n        // Make sure no dups\r\n        require(\r\n            !isOperator[_newOperator],\r\n            \"New operator exists.\"\r\n        );\r\n\r\n        // Only allow so many ops\r\n        require(\r\n            operators.length < MAX_OPS,\r\n            \"Overflow.\"\r\n        );\r\n\r\n        operators.push(_newOperator);\r\n        isOperator[_newOperator] = true;\r\n\r\n        emit OperatorAdded(_newOperator);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner or operators to remove operator\r\n     * @param _operator Address of the operator to be removed\r\n     */\r\n    function removeOperator(address _operator) public onlyOwner {\r\n        // Make sure operators array is not empty\r\n        require(\r\n            operators.length > 0,\r\n            \"No operator.\"\r\n        );\r\n\r\n        // Make sure the operator exists\r\n        require(\r\n            isOperator[_operator],\r\n            \"Not an operator.\"\r\n        );\r\n\r\n        // Manual array manipulation:\r\n        // - replace the _operator with last operator in array\r\n        // - remove the last item from array\r\n        address lastOperator = operators[operators.length - 1];\r\n        for (uint i = 0; i < operators.length; i++) {\r\n            if (operators[i] == _operator) {\r\n                operators[i] = lastOperator;\r\n            }\r\n        }\r\n        operators.length -= 1; // remove the last element\r\n\r\n        isOperator[_operator] = false;\r\n        emit OperatorRemoved(_operator);\r\n    }\r\n\r\n    // @dev Remove ALL operators\r\n    function removeAllOps() public onlyOwner {\r\n        for (uint i = 0; i < operators.length; i++) {\r\n            isOperator[operators[i]] = false;\r\n        }\r\n        operators.length = 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title BitGuildWhitelist\r\n * @dev A small smart contract to provide whitelist functionality and storage\r\n */\r\ncontract BitGuildWhitelist is BitGuildAccessAdmin {\r\n    uint public total = 0;\r\n    mapping (address => bool) public isWhitelisted;\r\n\r\n    event AddressWhitelisted(address indexed addr, address operator);\r\n    event AddressRemovedFromWhitelist(address indexed addr, address operator);\r\n\r\n    // @dev Throws if _address is not in whitelist.\r\n    modifier onlyWhitelisted(address _address) {\r\n        require(\r\n            isWhitelisted[_address],\r\n            \"Address is not on the whitelist.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // Doesn't accept eth\r\n    function () external payable {\r\n        revert();\r\n    }\r\n\r\n    /**\r\n     * @dev Allow operators to add whitelisted contracts\r\n     * @param _newAddr New whitelisted contract address\r\n     */\r\n    function addToWhitelist(address _newAddr) public onlyOperator {\r\n        require(\r\n            _newAddr != address(0),\r\n            \"Invalid new address.\"\r\n        );\r\n\r\n        // Make sure no dups\r\n        require(\r\n            !isWhitelisted[_newAddr],\r\n            \"Address is already whitelisted.\"\r\n        );\r\n\r\n        isWhitelisted[_newAddr] = true;\r\n        total++;\r\n        emit AddressWhitelisted(_newAddr, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Allow operators to remove a contract from the whitelist\r\n     * @param _addr Contract address to be removed\r\n     */\r\n    function removeFromWhitelist(address _addr) public onlyOperator {\r\n        require(\r\n            _addr != address(0),\r\n            \"Invalid address.\"\r\n        );\r\n\r\n        // Make sure the address is in whitelist\r\n        require(\r\n            isWhitelisted[_addr],\r\n            \"Address not in whitelist.\"\r\n        );\r\n\r\n        isWhitelisted[_addr] = false;\r\n        if (total > 0) {\r\n            total--;\r\n        }\r\n        emit AddressRemovedFromWhitelist(_addr, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Allow operators to update whitelist contracts in bulk\r\n     * @param _addresses Array of addresses to be processed\r\n     * @param _whitelisted Boolean value -- to add or remove from whitelist\r\n     */\r\n    function whitelistAddresses(address[] _addresses, bool _whitelisted) public onlyOperator {\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            address addr = _addresses[i];\r\n            if (isWhitelisted[addr] == _whitelisted) continue;\r\n            if (_whitelisted) {\r\n                addToWhitelist(addr);\r\n            } else {\r\n                removeFromWhitelist(addr);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title BitGuildFeeProvider\r\n * @dev Fee definition, supports custom fees by seller or buyer or token combinations\r\n */\r\ncontract BitGuildFeeProvider is BitGuildAccessAdmin {\r\n    // @dev Since default uint value is zero, need to distinguish Default vs No Fee\r\n    uint constant NO_FEE = 10000;\r\n\r\n    // @dev default % fee. Fixed is not supported. use percent * 100 to include 2 decimals\r\n    uint defaultPercentFee = 500; // default fee: 5%\r\n\r\n    mapping(bytes32 => uint) public customFee;  // Allow buyer or seller or game discounts\r\n\r\n    event LogFeeChanged(uint newPercentFee, uint oldPercentFee, address operator);\r\n    event LogCustomFeeChanged(uint newPercentFee, uint oldPercentFee, address buyer, address seller, address token, address operator);\r\n\r\n    // Default\r\n    function () external payable {\r\n        revert();\r\n    }\r\n\r\n    /**\r\n     * @dev Allow operators to update the fee for a custom combo\r\n     * @param _newFee New fee in percent x 100 (to support decimals)\r\n     */\r\n    function updateFee(uint _newFee) public onlyOperator {\r\n        require(_newFee >= 0 && _newFee <= 10000, \"Invalid percent fee.\");\r\n\r\n        uint oldPercentFee = defaultPercentFee;\r\n        defaultPercentFee = _newFee;\r\n\r\n        emit LogFeeChanged(_newFee, oldPercentFee, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Allow operators to update the fee for a custom combo\r\n     * @param _newFee New fee in percent x 100 (to support decimals)\r\n     *                enter zero for default, 10000 for No Fee\r\n     */\r\n    function updateCustomFee(uint _newFee, address _currency, address _buyer, address _seller, address _token) public onlyOperator {\r\n        require(_newFee >= 0 && _newFee <= 10000, \"Invalid percent fee.\");\r\n\r\n        bytes32 key = _getHash(_currency, _buyer, _seller, _token);\r\n        uint oldPercentFee = customFee[key];\r\n        customFee[key] = _newFee;\r\n\r\n        emit LogCustomFeeChanged(_newFee, oldPercentFee, _buyer, _seller, _token, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the custom fee based on buyer, seller, game token or combo of these\r\n     */\r\n    function getFee(uint _price, address _currency, address _buyer, address _seller, address _token) public view returns(uint percent, uint fee) {\r\n        bytes32 key = _getHash(_currency, _buyer, _seller, _token);\r\n        uint customPercentFee = customFee[key];\r\n        (percent, fee) = _getFee(_price, customPercentFee);\r\n    }\r\n\r\n    function _getFee(uint _price, uint _percentFee) internal view returns(uint percent, uint fee) {\r\n        require(_price >= 0, \"Invalid price.\");\r\n\r\n        percent = _percentFee;\r\n\r\n        // No data, set it to default\r\n        if (_percentFee == 0) {\r\n            percent = defaultPercentFee;\r\n        }\r\n\r\n        // Special value to set it to zero\r\n        if (_percentFee == NO_FEE) {\r\n            percent = 0;\r\n            fee = 0;\r\n        } else {\r\n            fee = _safeMul(_price, percent) / 10000; // adjust for percent and decimal. division always truncate\r\n        }\r\n    }\r\n\r\n    // get custom fee hash\r\n    function _getHash(address _currency, address _buyer, address _seller, address _token) internal pure returns(bytes32 key) {\r\n        key = keccak256(abi.encodePacked(_currency, _buyer, _seller, _token));\r\n    }\r\n\r\n    // safe multiplication\r\n    function _safeMul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n}\r\n\r\npragma solidity ^0.4.24;\r\n\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n// @title ERC-721 Non-Fungible Token Standard\r\n// @dev Include interface for both new and old functions\r\ninterface ERC721TokenReceiver {\r\n\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\r\n\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes data) external returns(bytes4);\r\n}\r\n\r\n/*\r\n * @title BitGuildMarketplace\r\n * @dev: Marketplace smart contract for BitGuild.com\r\n */\r\ncontract BitGuildMarketplace is BitGuildAccessAdmin {\r\n    // Callback values from zepellin ERC721Receiver.sol\r\n    // Old ver: bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\")) = 0xf0b9e5ba;\r\n    bytes4 constant ERC721_RECEIVED_OLD = 0xf0b9e5ba;\r\n    // New ver w/ operator: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")) = 0xf0b9e5ba;\r\n    bytes4 constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // BitGuild Contracts\r\n    BitGuildToken public PLAT = BitGuildToken(0x7E43581b19ab509BCF9397a2eFd1ab10233f27dE); // Main Net\r\n    BitGuildWhitelist public Whitelist = BitGuildWhitelist(0xA8CedD578fed14f07C3737bF42AD6f04FAAE3978); // Main Net\r\n    BitGuildFeeProvider public FeeProvider = BitGuildFeeProvider(0x58D36571250D91eF5CE90869E66Cd553785364a2); // Main Net\r\n    // BitGuildToken public PLAT = BitGuildToken(0x0F2698b7605fE937933538387b3d6Fec9211477d); // Rinkeby\r\n    // BitGuildWhitelist public Whitelist = BitGuildWhitelist(0x72b93A4943eF4f658648e27D64e9e3B8cDF520a6); // Rinkeby\r\n    // BitGuildFeeProvider public FeeProvider = BitGuildFeeProvider(0xf7AB04A47AA9F3c8Cb7FDD701CF6DC6F2eB330E2); // Rinkeby\r\n\r\n    uint public defaultExpiry = 7 days;  // default expiry is 7 days\r\n\r\n    enum Currency { PLAT, ETH }\r\n    struct Listing {\r\n        Currency currency;      // ETH or PLAT\r\n        address seller;         // seller address\r\n        address token;          // token contract\r\n        uint tokenId;           // token id\r\n        uint price;             // Big number in ETH or PLAT\r\n        uint createdAt;         // timestamp\r\n        uint expiry;            // createdAt + defaultExpiry\r\n    }\r\n\r\n    mapping(bytes32 => Listing) public listings;\r\n\r\n    event LogListingCreated(address _seller, address _contract, uint _tokenId, uint _createdAt, uint _expiry);\r\n    event LogListingExtended(address _seller, address _contract, uint _tokenId, uint _createdAt, uint _expiry);\r\n    event LogItemSold(address _buyer, address _seller, address _contract, uint _tokenId, uint _price, Currency _currency, uint _soldAt);\r\n    event LogItemWithdrawn(address _seller, address _contract, uint _tokenId, uint _withdrawnAt);\r\n    event LogItemExtended(address _contract, uint _tokenId, uint _modifiedAt, uint _expiry);\r\n\r\n    modifier onlyWhitelisted(address _contract) {\r\n        require(Whitelist.isWhitelisted(_contract), \"Contract not in whitelist.\");\r\n        _;\r\n    }\r\n\r\n    // @dev fall back function\r\n    function () external payable {\r\n        revert();\r\n    }\r\n\r\n    // @dev Retrieve hashkey to view listing\r\n    function getHashKey(address _contract, uint _tokenId) public pure returns(bytes32 key) {\r\n        key = _getHashKey(_contract, _tokenId);\r\n    }\r\n\r\n    // ===========================================\r\n    // Fee functions (from fee provider contract)\r\n    // ===========================================\r\n    // @dev get fees\r\n    function getFee(uint _price, address _currency, address _buyer, address _seller, address _token) public view returns(uint percent, uint fee) {\r\n        (percent, fee) = FeeProvider.getFee(_price, _currency, _buyer, _seller, _token);\r\n    }\r\n\r\n    // ===========================================\r\n    // Seller Functions\r\n    // ===========================================\r\n    // Deposit Item\r\n    // @dev deprecated callback (did not handle operator). added to support older contracts\r\n    function onERC721Received(address _from, uint _tokenId, bytes _extraData) external returns(bytes4) {\r\n        _deposit(_from, msg.sender, _tokenId, _extraData);\r\n        return ERC721_RECEIVED_OLD;\r\n    }\r\n\r\n    // @dev expected callback (include operator)\r\n    function onERC721Received(address _operator, address _from, uint _tokenId, bytes _extraData) external returns(bytes4) {\r\n        _deposit(_from, msg.sender, _tokenId, _extraData);\r\n        return ERC721_RECEIVED;\r\n    }\r\n\r\n    // @dev Extend item listing: new expiry = current expiry + defaultExpiry\r\n    // @param _contract whitelisted contract\r\n    // @param _tokenId  tokenId\r\n    function extendItem(address _contract, uint _tokenId) public onlyWhitelisted(_contract) returns(bool) {\r\n        bytes32 key = _getHashKey(_contract, _tokenId);\r\n        address seller = listings[key].seller;\r\n\r\n        require(seller == msg.sender, \"Only seller can extend listing.\");\r\n        require(listings[key].expiry > 0, \"Item not listed.\");\r\n\r\n        listings[key].expiry = now + defaultExpiry;\r\n\r\n        emit LogListingExtended(seller, _contract, _tokenId, listings[key].createdAt, listings[key].expiry);\r\n\r\n        return true;\r\n    }\r\n\r\n    // @dev Withdraw item from marketplace back to seller\r\n    // @param _contract whitelisted contract\r\n    // @param _tokenId  tokenId\r\n    function withdrawItem(address _contract, uint _tokenId) public onlyWhitelisted(_contract) {\r\n        bytes32 key = _getHashKey(_contract, _tokenId);\r\n        address seller = listings[key].seller;\r\n\r\n        require(seller == msg.sender, \"Only seller can withdraw listing.\");\r\n\r\n        // Transfer item back to the seller\r\n        ERC721 gameToken = ERC721(_contract);\r\n        gameToken.safeTransferFrom(this, seller, _tokenId);\r\n\r\n        emit LogItemWithdrawn(seller, _contract, _tokenId, now);\r\n\r\n        // remove listing\r\n        delete(listings[key]);\r\n    }\r\n\r\n    // ===========================================\r\n    // Purchase Item\r\n    // ===========================================\r\n    // @dev Buy item with ETH. Take ETH from buyer, transfer token, transfer payment minus fee to seller\r\n    // @param _token  Token contract\r\n    // @param _tokenId   Token Id\r\n    function buyWithETH(address _token, uint _tokenId) public onlyWhitelisted(_token) payable {\r\n        _buy(_token, _tokenId, Currency.ETH, msg.value, msg.sender);\r\n    }\r\n\r\n    // Buy with PLAT requires calling BitGuildToken contract, this is the callback\r\n    // call to approve already verified the token ownership, no checks required\r\n    // @param _buyer     buyer\r\n    // @param _value     PLAT amount (big number)\r\n    // @param _PLAT      BitGuild token address\r\n    // @param _extraData address _gameContract, uint _tokenId\r\n    function receiveApproval(address _buyer, uint _value, BitGuildToken _PLAT, bytes _extraData) public {\r\n        require(_extraData.length > 0, \"No extraData provided.\");\r\n        // We check msg.sender with our known PLAT address instead of the _PLAT param\r\n        require(msg.sender == address(PLAT), \"Unauthorized PLAT contract address.\");\r\n\r\n        address token;\r\n        uint tokenId;\r\n        (token, tokenId) = _decodeBuyData(_extraData);\r\n\r\n        _buy(token, tokenId, Currency.PLAT, _value, _buyer);\r\n    }\r\n\r\n    // ===========================================\r\n    // Admin Functions\r\n    // ===========================================\r\n    // @dev Update fee provider contract\r\n    function updateFeeProvider(address _newAddr) public onlyOperator {\r\n        require(_newAddr != address(0), \"Invalid contract address.\");\r\n        FeeProvider = BitGuildFeeProvider(_newAddr);\r\n    }\r\n\r\n    // @dev Update whitelist contract\r\n    function updateWhitelist(address _newAddr) public onlyOperator {\r\n        require(_newAddr != address(0), \"Invalid contract address.\");\r\n        Whitelist = BitGuildWhitelist(_newAddr);\r\n    }\r\n\r\n    // @dev Update expiry date\r\n    function updateExpiry(uint _days) public onlyOperator {\r\n        require(_days > 0, \"Invalid number of days.\");\r\n        defaultExpiry = _days * 1 days;\r\n    }\r\n\r\n    // @dev Admin function: withdraw ETH balance\r\n    function withdrawETH() public onlyOwner payable {\r\n        msg.sender.transfer(msg.value);\r\n    }\r\n\r\n    // @dev Admin function: withdraw PLAT balance\r\n    function withdrawPLAT() public onlyOwner payable {\r\n        uint balance = PLAT.balanceOf(this);\r\n        PLAT.transfer(msg.sender, balance);\r\n    }\r\n\r\n    // ===========================================\r\n    // Internal Functions\r\n    // ===========================================\r\n    function _getHashKey(address _contract, uint _tokenId) internal pure returns(bytes32 key) {\r\n        key = keccak256(abi.encodePacked(_contract, _tokenId));\r\n    }\r\n\r\n    // @dev create new listing data\r\n    function _newListing(address _seller, address _contract, uint _tokenId, uint _price, Currency _currency) internal {\r\n        bytes32 key = _getHashKey(_contract, _tokenId);\r\n        uint createdAt = now;\r\n        uint expiry = now + defaultExpiry;\r\n        listings[key].currency = _currency;\r\n        listings[key].seller = _seller;\r\n        listings[key].token = _contract;\r\n        listings[key].tokenId = _tokenId;\r\n        listings[key].price = _price;\r\n        listings[key].createdAt = createdAt;\r\n        listings[key].expiry = expiry;\r\n\r\n        emit LogListingCreated(_seller, _contract, _tokenId, createdAt, expiry);\r\n    }\r\n\r\n    // @dev deposit unpacks _extraData and log listing info\r\n    // @param _extraData packed bytes of (uint _price, uint _currency)\r\n    function _deposit(address _seller, address _contract, uint _tokenId, bytes _extraData) internal onlyWhitelisted(_contract) {\r\n        uint price;\r\n        uint currencyUint;\r\n        (currencyUint, price) = _decodePriceData(_extraData);\r\n        Currency currency = Currency(currencyUint);\r\n\r\n        require(price > 0, \"Invalid price.\");\r\n\r\n        _newListing(_seller, _contract, _tokenId, price, currency);\r\n    }\r\n\r\n    // @dev handles purchase logic for both PLAT and ETH\r\n    function _buy(address _token, uint _tokenId, Currency _currency, uint _price, address _buyer) internal {\r\n        bytes32 key = _getHashKey(_token, _tokenId);\r\n        Currency currency = listings[key].currency;\r\n        address seller = listings[key].seller;\r\n\r\n        address currencyAddress = _currency == Currency.PLAT ? address(PLAT) : address(0);\r\n\r\n        require(currency == _currency, \"Wrong currency.\");\r\n        require(_price > 0 && _price == listings[key].price, \"Invalid price.\");\r\n        require(listings[key].expiry > now, \"Item expired.\");\r\n\r\n        ERC721 gameToken = ERC721(_token);\r\n        require(gameToken.ownerOf(_tokenId) == address(this), \"Item is not available.\");\r\n\r\n        if (_currency == Currency.PLAT) {\r\n            // Transfer PLAT to marketplace contract\r\n            require(PLAT.transferFrom(_buyer, address(this), _price), \"PLAT payment transfer failed.\");\r\n        }\r\n\r\n        // Transfer item token to buyer\r\n        gameToken.safeTransferFrom(this, _buyer, _tokenId);\r\n\r\n        uint fee;\r\n        (,fee) = getFee(_price, currencyAddress, _buyer, seller, _token); // getFee returns percentFee and fee, we only need fee\r\n\r\n        if (_currency == Currency.PLAT) {\r\n            PLAT.transfer(seller, _price - fee);\r\n        } else {\r\n            require(seller.send(_price - fee) == true, \"Transfer to seller failed.\");\r\n        }\r\n\r\n        // Emit event\r\n        emit LogItemSold(_buyer, seller, _token, _tokenId, _price, currency, now);\r\n\r\n        // delist item\r\n        delete(listings[key]);\r\n    }\r\n\r\n    function _decodePriceData(bytes _extraData) internal pure returns(uint _currency, uint _price) {\r\n        // Deserialize _extraData\r\n        uint256 offset = 64;\r\n        _price = _bytesToUint256(offset, _extraData);\r\n        offset -= 32;\r\n        _currency = _bytesToUint256(offset, _extraData);\r\n    }\r\n\r\n    function _decodeBuyData(bytes _extraData) internal pure returns(address _contract, uint _tokenId) {\r\n        // Deserialize _extraData\r\n        uint256 offset = 64;\r\n        _tokenId = _bytesToUint256(offset, _extraData);\r\n        offset -= 32;\r\n        _contract = _bytesToAddress(offset, _extraData);\r\n    }\r\n\r\n    // @dev Decoding helper function from Seriality\r\n    function _bytesToUint256(uint _offst, bytes memory _input) internal pure returns (uint256 _output) {\r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    // @dev Decoding helper functions from Seriality\r\n    function _bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address _output) {\r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddr\",\"type\":\"address\"}],\"name\":\"updateFeeProvider\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PLAT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddr\",\"type\":\"address\"}],\"name\":\"updateWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawItem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"extendItem\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPLAT\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OPS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getHashKey\",\"outputs\":[{\"name\":\"key\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultExpiry\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_PLAT\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FeeProvider\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"buyWithETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeAllOps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"listings\",\"outputs\":[{\"name\":\"currency\",\"type\":\"uint8\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"updateExpiry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_currency\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getFee\",\"outputs\":[{\"name\":\"percent\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operators\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_createdAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"LogListingCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_createdAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"LogListingExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_currency\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_soldAt\",\"type\":\"uint256\"}],\"name\":\"LogItemSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_withdrawnAt\",\"type\":\"uint256\"}],\"name\":\"LogItemWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_modifiedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"LogItemExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"}]","ContractName":"BitGuildMarketplace","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9aa0941aa9dded0ae2f0c8b01661618c079871b593d1031ed1c7bd83cce7d671"}]