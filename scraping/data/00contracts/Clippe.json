[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n/// clip.sol -- Dai auction module 2.0\r\n\r\n// Copyright (C) 2020-2021 Maker Ecosystem Growth Holdings, INC.\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published\r\n// by the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.6.12;\r\n\r\ninterface VatLike {\r\n    function move(address,address,uint256) external;\r\n    function flux(bytes32,address,address,uint256) external;\r\n    function ilks(bytes32) external returns (uint256, uint256, uint256, uint256, uint256);\r\n    function suck(address,address,uint256) external;\r\n}\r\n\r\ninterface PipLike {\r\n    function peek() external returns (bytes32, bool);\r\n}\r\n\r\ninterface SpotterLike {\r\n    function par() external returns (uint256);\r\n    function ilks(bytes32) external returns (PipLike, uint256);\r\n}\r\n\r\ninterface DogLike {\r\n    function chop(bytes32) external returns (uint256);\r\n    function digs(bytes32, uint256) external;\r\n}\r\n\r\ninterface ClipperCallee {\r\n    function clipperCall(address, uint256, uint256, bytes calldata) external;\r\n}\r\n\r\ninterface AbacusLike {\r\n    function price(uint256, uint256) external view returns (uint256);\r\n}\r\n\r\ncontract Clipper {\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\r\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Clipper/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    bytes32  immutable public ilk;   // Collateral type of this Clipper\r\n    VatLike  immutable public vat;   // Core CDP Engine\r\n\r\n    DogLike     public dog;      // Liquidation module\r\n    address     public vow;      // Recipient of dai raised in auctions\r\n    SpotterLike public spotter;  // Collateral price module\r\n    AbacusLike  public calc;     // Current price calculator\r\n\r\n    uint256 public buf;    // Multiplicative factor to increase starting price                  [ray]\r\n    uint256 public tail;   // Time elapsed before auction reset                                 [seconds]\r\n    uint256 public cusp;   // Percentage drop before auction reset                              [ray]\r\n    uint64  public chip;   // Percentage of tab to suck from vow to incentivize keepers         [wad]\r\n    uint192 public tip;    // Flat fee to suck from vow to incentivize keepers                  [rad]\r\n    uint256 public chost;  // Cache the ilk dust times the ilk chop to prevent excessive SLOADs [rad]\r\n\r\n    uint256   public kicks;   // Total auctions\r\n    uint256[] public active;  // Array of active auction ids\r\n\r\n    struct Sale {\r\n        uint256 pos;  // Index in active array\r\n        uint256 tab;  // Dai to raise       [rad]\r\n        uint256 lot;  // collateral to sell [wad]\r\n        address usr;  // Liquidated CDP\r\n        uint96  tic;  // Auction start time\r\n        uint256 top;  // Starting price     [ray]\r\n    }\r\n    mapping(uint256 => Sale) public sales;\r\n\r\n    uint256 internal locked;\r\n\r\n    // Levels for circuit breaker\r\n    // 0: no breaker\r\n    // 1: no new kick()\r\n    // 2: no new kick() or redo()\r\n    // 3: no new kick(), redo(), or take()\r\n    uint256 public stopped = 0;\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n\r\n    event File(bytes32 indexed what, uint256 data);\r\n    event File(bytes32 indexed what, address data);\r\n\r\n    event Kick(\r\n        uint256 indexed id,\r\n        uint256 top,\r\n        uint256 tab,\r\n        uint256 lot,\r\n        address indexed usr,\r\n        address indexed kpr,\r\n        uint256 coin\r\n    );\r\n    event Take(\r\n        uint256 indexed id,\r\n        uint256 max,\r\n        uint256 price,\r\n        uint256 owe,\r\n        uint256 tab,\r\n        uint256 lot,\r\n        address indexed usr\r\n    );\r\n    event Redo(\r\n        uint256 indexed id,\r\n        uint256 top,\r\n        uint256 tab,\r\n        uint256 lot,\r\n        address indexed usr,\r\n        address indexed kpr,\r\n        uint256 coin\r\n    );\r\n\r\n    event Yank(uint256 id);\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, address spotter_, address dog_, bytes32 ilk_) public {\r\n        vat     = VatLike(vat_);\r\n        spotter = SpotterLike(spotter_);\r\n        dog     = DogLike(dog_);\r\n        ilk     = ilk_;\r\n        buf     = RAY;\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n    }\r\n\r\n    // --- Synchronization ---\r\n    modifier lock {\r\n        require(locked == 0, \"Clipper/system-locked\");\r\n        locked = 1;\r\n        _;\r\n        locked = 0;\r\n    }\r\n\r\n    modifier isStopped(uint256 level) {\r\n        require(stopped < level, \"Clipper/stopped-incorrect\");\r\n        _;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, uint256 data) external auth lock {\r\n        if      (what == \"buf\")         buf = data;\r\n        else if (what == \"tail\")       tail = data;           // Time elapsed before auction reset\r\n        else if (what == \"cusp\")       cusp = data;           // Percentage drop before auction reset\r\n        else if (what == \"chip\")       chip = uint64(data);   // Percentage of tab to incentivize (max: 2^64 - 1 => 18.xxx WAD = 18xx%)\r\n        else if (what == \"tip\")         tip = uint192(data);  // Flat fee to incentivize keepers (max: 2^192 - 1 => 6.277T RAD)\r\n        else if (what == \"stopped\") stopped = data;           // Set breaker (0, 1, 2, or 3)\r\n        else revert(\"Clipper/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n    function file(bytes32 what, address data) external auth lock {\r\n        if (what == \"spotter\") spotter = SpotterLike(data);\r\n        else if (what == \"dog\")    dog = DogLike(data);\r\n        else if (what == \"vow\")    vow = data;\r\n        else if (what == \"calc\")  calc = AbacusLike(data);\r\n        else revert(\"Clipper/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant BLN = 10 **  9;\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAY = 10 ** 27;\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x <= y ? x : y;\r\n    }\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = mul(x, y) / WAD;\r\n    }\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = mul(x, y) / RAY;\r\n    }\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = mul(x, RAY) / y;\r\n    }\r\n\r\n    // --- Auction ---\r\n\r\n    // get the price directly from the OSM\r\n    // Could get this from rmul(Vat.ilks(ilk).spot, Spotter.mat()) instead, but\r\n    // if mat has changed since the last poke, the resulting value will be\r\n    // incorrect.\r\n    function getFeedPrice() internal returns (uint256 feedPrice) {\r\n        (PipLike pip, ) = spotter.ilks(ilk);\r\n        (bytes32 val, bool has) = pip.peek();\r\n        require(has, \"Clipper/invalid-price\");\r\n        feedPrice = rdiv(mul(uint256(val), BLN), spotter.par());\r\n    }\r\n\r\n    // start an auction\r\n    // note: trusts the caller to transfer collateral to the contract\r\n    // The starting price `top` is obtained as follows:\r\n    //\r\n    //     top = val * buf / par\r\n    //\r\n    // Where `val` is the collateral's unitary value in USD, `buf` is a\r\n    // multiplicative factor to increase the starting price, and `par` is a\r\n    // reference per DAI.\r\n    function kick(\r\n        uint256 tab,  // Debt                   [rad]\r\n        uint256 lot,  // Collateral             [wad]\r\n        address usr,  // Address that will receive any leftover collateral\r\n        address kpr   // Address that will receive incentives\r\n    ) external auth lock isStopped(1) returns (uint256 id) {\r\n        // Input validation\r\n        require(tab  >          0, \"Clipper/zero-tab\");\r\n        require(lot  >          0, \"Clipper/zero-lot\");\r\n        require(usr != address(0), \"Clipper/zero-usr\");\r\n        id = ++kicks;\r\n        require(id   >          0, \"Clipper/overflow\");\r\n\r\n        active.push(id);\r\n\r\n        sales[id].pos = active.length - 1;\r\n\r\n        sales[id].tab = tab;\r\n        sales[id].lot = lot;\r\n        sales[id].usr = usr;\r\n        sales[id].tic = uint96(block.timestamp);\r\n\r\n        uint256 top;\r\n        top = rmul(getFeedPrice(), buf);\r\n        require(top > 0, \"Clipper/zero-top-price\");\r\n        sales[id].top = top;\r\n\r\n        // incentive to kick auction\r\n        uint256 _tip  = tip;\r\n        uint256 _chip = chip;\r\n        uint256 coin;\r\n        if (_tip > 0 || _chip > 0) {\r\n            coin = add(_tip, wmul(tab, _chip));\r\n            vat.suck(vow, kpr, coin);\r\n        }\r\n\r\n        emit Kick(id, top, tab, lot, usr, kpr, coin);\r\n    }\r\n\r\n    // Reset an auction\r\n    // See `kick` above for an explanation of the computation of `top`.\r\n    function redo(\r\n        uint256 id,  // id of the auction to reset\r\n        address kpr  // Address that will receive incentives\r\n    ) external lock isStopped(2) {\r\n        // Read auction data\r\n        address usr = sales[id].usr;\r\n        uint96  tic = sales[id].tic;\r\n        uint256 top = sales[id].top;\r\n\r\n        require(usr != address(0), \"Clipper/not-running-auction\");\r\n\r\n        // Check that auction needs reset\r\n        // and compute current price [ray]\r\n        (bool done,) = status(tic, top);\r\n        require(done, \"Clipper/cannot-reset\");\r\n\r\n        uint256 tab   = sales[id].tab;\r\n        uint256 lot   = sales[id].lot;\r\n        sales[id].tic = uint96(block.timestamp);\r\n\r\n        uint256 feedPrice = getFeedPrice();\r\n        top = rmul(feedPrice, buf);\r\n        require(top > 0, \"Clipper/zero-top-price\");\r\n        sales[id].top = top;\r\n\r\n        // incentive to redo auction\r\n        uint256 _tip  = tip;\r\n        uint256 _chip = chip;\r\n        uint256 coin;\r\n        if (_tip > 0 || _chip > 0) {\r\n            uint256 _chost = chost;\r\n            if (tab >= _chost && mul(lot, feedPrice) >= _chost) {\r\n                coin = add(_tip, wmul(tab, _chip));\r\n                vat.suck(vow, kpr, coin);\r\n            }\r\n        }\r\n\r\n        emit Redo(id, top, tab, lot, usr, kpr, coin);\r\n    }\r\n\r\n    // Buy up to `amt` of collateral from the auction indexed by `id`.\r\n    // \r\n    // Auctions will not collect more DAI than their assigned DAI target,`tab`;\r\n    // thus, if `amt` would cost more DAI than `tab` at the current price, the\r\n    // amount of collateral purchased will instead be just enough to collect `tab` DAI.\r\n    //\r\n    // To avoid partial purchases resulting in very small leftover auctions that will\r\n    // never be cleared, any partial purchase must leave at least `Clipper.chost`\r\n    // remaining DAI target. `chost` is an asynchronously updated value equal to\r\n    // (Vat.dust * Dog.chop(ilk) / WAD) where the values are understood to be determined\r\n    // by whatever they were when Clipper.upchost() was last called. Purchase amounts\r\n    // will be minimally decreased when necessary to respect this limit; i.e., if the\r\n    // specified `amt` would leave `tab < chost` but `tab > 0`, the amount actually\r\n    // purchased will be such that `tab == chost`.\r\n    //\r\n    // If `tab <= chost`, partial purchases are no longer possible; that is, the remaining\r\n    // collateral can only be purchased entirely, or not at all.\r\n    function take(\r\n        uint256 id,           // Auction id\r\n        uint256 amt,          // Upper limit on amount of collateral to buy  [wad]\r\n        uint256 max,          // Maximum acceptable price (DAI / collateral) [ray]\r\n        address who,          // Receiver of collateral and external call address\r\n        bytes calldata data   // Data to pass in external call; if length 0, no call is done\r\n    ) external lock isStopped(3) {\r\n\r\n        address usr = sales[id].usr;\r\n        uint96  tic = sales[id].tic;\r\n\r\n        require(usr != address(0), \"Clipper/not-running-auction\");\r\n\r\n        uint256 price;\r\n        {\r\n            bool done;\r\n            (done, price) = status(tic, sales[id].top);\r\n\r\n            // Check that auction doesn't need reset\r\n            require(!done, \"Clipper/needs-reset\");\r\n        }\r\n\r\n        // Ensure price is acceptable to buyer\r\n        require(max >= price, \"Clipper/too-expensive\");\r\n\r\n        uint256 lot = sales[id].lot;\r\n        uint256 tab = sales[id].tab;\r\n        uint256 owe;\r\n\r\n        {\r\n            // Purchase as much as possible, up to amt\r\n            uint256 slice = min(lot, amt);  // slice <= lot\r\n\r\n            // DAI needed to buy a slice of this sale\r\n            owe = mul(slice, price);\r\n\r\n            // Don't collect more than tab of DAI\r\n            if (owe > tab) {\r\n                // Total debt will be paid\r\n                owe = tab;                  // owe' <= owe\r\n                // Adjust slice\r\n                slice = owe / price;        // slice' = owe' / price <= owe / price == slice <= lot\r\n            } else if (owe < tab && slice < lot) {\r\n                // If slice == lot => auction completed => dust doesn't matter\r\n                uint256 _chost = chost;\r\n                if (tab - owe < _chost) {    // safe as owe < tab\r\n                    // If tab <= chost, buyers have to take the entire lot.\r\n                    require(tab > _chost, \"Clipper/no-partial-purchase\");\r\n                    // Adjust amount to pay\r\n                    owe = tab - _chost;      // owe' <= owe\r\n                    // Adjust slice\r\n                    slice = owe / price;     // slice' = owe' / price < owe / price == slice < lot\r\n                }\r\n            }\r\n\r\n            // Calculate remaining tab after operation\r\n            tab = tab - owe;  // safe since owe <= tab\r\n            // Calculate remaining lot after operation\r\n            lot = lot - slice;\r\n\r\n            // Send collateral to who\r\n            vat.flux(ilk, address(this), who, slice);\r\n\r\n            // Do external call (if data is defined) but to be\r\n            // extremely careful we don't allow to do it to the two\r\n            // contracts which the Clipper needs to be authorized\r\n            DogLike dog_ = dog;\r\n            if (data.length > 0 && who != address(vat) && who != address(dog_)) {\r\n                ClipperCallee(who).clipperCall(msg.sender, owe, slice, data);\r\n            }\r\n\r\n            // Get DAI from caller\r\n            vat.move(msg.sender, vow, owe);\r\n\r\n            // Removes Dai out for liquidation from accumulator\r\n            dog_.digs(ilk, lot == 0 ? tab + owe : owe);\r\n        }\r\n\r\n        if (lot == 0) {\r\n            _remove(id);\r\n        } else if (tab == 0) {\r\n            vat.flux(ilk, address(this), usr, lot);\r\n            _remove(id);\r\n        } else {\r\n            sales[id].tab = tab;\r\n            sales[id].lot = lot;\r\n        }\r\n\r\n        emit Take(id, max, price, owe, tab, lot, usr);\r\n    }\r\n\r\n    function _remove(uint256 id) internal {\r\n        uint256 _move    = active[active.length - 1];\r\n        if (id != _move) {\r\n            uint256 _index   = sales[id].pos;\r\n            active[_index]   = _move;\r\n            sales[_move].pos = _index;\r\n        }\r\n        active.pop();\r\n        delete sales[id];\r\n    }\r\n\r\n    // The number of active auctions\r\n    function count() external view returns (uint256) {\r\n        return active.length;\r\n    }\r\n\r\n    // Return the entire array of active auctions\r\n    function list() external view returns (uint256[] memory) {\r\n        return active;\r\n    }\r\n\r\n    // Externally returns boolean for if an auction needs a redo and also the current price\r\n    function getStatus(uint256 id) external view returns (bool needsRedo, uint256 price, uint256 lot, uint256 tab) {\r\n        // Read auction data\r\n        address usr = sales[id].usr;\r\n        uint96  tic = sales[id].tic;\r\n\r\n        bool done;\r\n        (done, price) = status(tic, sales[id].top);\r\n\r\n        needsRedo = usr != address(0) && done;\r\n        lot = sales[id].lot;\r\n        tab = sales[id].tab;\r\n    }\r\n\r\n    // Internally returns boolean for if an auction needs a redo\r\n    function status(uint96 tic, uint256 top) internal view returns (bool done, uint256 price) {\r\n        price = calc.price(top, sub(block.timestamp, tic));\r\n        done  = (sub(block.timestamp, tic) > tail || rdiv(price, top) < cusp);\r\n    }\r\n\r\n    // Public function to update the cached dust*chop value.\r\n    function upchost() external {\r\n        (,,,, uint256 _dust) = VatLike(vat).ilks(ilk);\r\n        chost = wmul(_dust, dog.chop(ilk));\r\n    }\r\n\r\n    // Cancel an auction during ES or via governance action.\r\n    function yank(uint256 id) external auth lock {\r\n        require(sales[id].usr != address(0), \"Clipper/not-running-auction\");\r\n        dog.digs(ilk, sales[id].tab);\r\n        vat.flux(ilk, address(this), msg.sender, sales[id].lot);\r\n        _remove(id);\r\n        emit Yank(id);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vat_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spotter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dog_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ilk_\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"top\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tab\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lot\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"kpr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coin\",\"type\":\"uint256\"}],\"name\":\"Kick\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"top\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tab\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lot\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"kpr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coin\",\"type\":\"uint256\"}],\"name\":\"Redo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"owe\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tab\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lot\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Take\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Yank\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"active\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calc\",\"outputs\":[{\"internalType\":\"contract AbacusLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chip\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cusp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dog\",\"outputs\":[{\"internalType\":\"contract DogLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"file\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"file\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"needsRedo\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tab\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ilk\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tab\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lot\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"kpr\",\"type\":\"address\"}],\"name\":\"kick\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kicks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"list\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"kpr\",\"type\":\"address\"}],\"name\":\"redo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tab\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lot\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"tic\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"top\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spotter\",\"outputs\":[{\"internalType\":\"contract SpotterLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tail\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"take\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tip\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upchost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract VatLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"yank\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Clipper","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000035D1b3F3D7966A1DFe207aa4514C12a259A0492B00000000000000000000000065C79fcB50Ca1594B025960e539eD7A9a6D434A3000000000000000000000000135954d155898D42C90D2a57824C690e0c7BEf1B4b4e432d41000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2308b84e56a54cac65688adc6c5c48e47623dd66554942603cbe3515cdbe1587"}]