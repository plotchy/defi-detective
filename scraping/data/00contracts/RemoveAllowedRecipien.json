[{"SourceCode":"// SPDX-License-Identifier: MIT & GPL-3.0\r\n// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @author psirex\r\n/// @notice A helper contract contains logic to validate that only a trusted caller has access to certain methods.\r\n/// @dev Trusted caller set once on deployment and can't be changed.\r\ncontract TrustedCaller {\r\n    string private constant ERROR_TRUSTED_CALLER_IS_ZERO_ADDRESS = \"TRUSTED_CALLER_IS_ZERO_ADDRESS\";\r\n    string private constant ERROR_CALLER_IS_FORBIDDEN = \"CALLER_IS_FORBIDDEN\";\r\n\r\n    address public immutable trustedCaller;\r\n\r\n    constructor(address _trustedCaller) {\r\n        require(_trustedCaller != address(0), ERROR_TRUSTED_CALLER_IS_ZERO_ADDRESS);\r\n        trustedCaller = _trustedCaller;\r\n    }\r\n\r\n    modifier onlyTrustedCaller(address _caller) {\r\n        require(_caller == trustedCaller, ERROR_CALLER_IS_FORBIDDEN);\r\n        _;\r\n    }\r\n}\r\n// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\r\n\r\n\r\n\r\n\r\n/// @author psirex\r\n/// @notice Contains methods for convenient creation\r\n/// of EVMScripts in EVMScript factories contracts\r\nlibrary EVMScriptCreator {\r\n    // Id of default CallsScript Aragon's executor.\r\n    bytes4 private constant SPEC_ID = hex\"00000001\";\r\n\r\n    /// @notice Encodes one method call as EVMScript\r\n    function createEVMScript(\r\n        address _to,\r\n        bytes4 _methodId,\r\n        bytes memory _evmScriptCallData\r\n    ) internal pure returns (bytes memory _commands) {\r\n        return\r\n            abi.encodePacked(\r\n                SPEC_ID,\r\n                _to,\r\n                uint32(_evmScriptCallData.length) + 4,\r\n                _methodId,\r\n                _evmScriptCallData\r\n            );\r\n    }\r\n\r\n    /// @notice Encodes multiple calls of the same method on one contract as EVMScript\r\n    function createEVMScript(\r\n        address _to,\r\n        bytes4 _methodId,\r\n        bytes[] memory _evmScriptCallData\r\n    ) internal pure returns (bytes memory _evmScript) {\r\n        for (uint256 i = 0; i < _evmScriptCallData.length; ++i) {\r\n            _evmScript = bytes.concat(\r\n                _evmScript,\r\n                abi.encodePacked(\r\n                    _to,\r\n                    uint32(_evmScriptCallData[i].length) + 4,\r\n                    _methodId,\r\n                    _evmScriptCallData[i]\r\n                )\r\n            );\r\n        }\r\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\r\n    }\r\n\r\n    /// @notice Encodes multiple calls to different methods within the same contract as EVMScript\r\n    function createEVMScript(\r\n        address _to,\r\n        bytes4[] memory _methodIds,\r\n        bytes[] memory _evmScriptCallData\r\n    ) internal pure returns (bytes memory _evmScript) {\r\n        require(_methodIds.length == _evmScriptCallData.length, \"LENGTH_MISMATCH\");\r\n\r\n        for (uint256 i = 0; i < _methodIds.length; ++i) {\r\n            _evmScript = bytes.concat(\r\n                _evmScript,\r\n                abi.encodePacked(\r\n                    _to,\r\n                    uint32(_evmScriptCallData[i].length) + 4,\r\n                    _methodIds[i],\r\n                    _evmScriptCallData[i]\r\n                )\r\n            );\r\n        }\r\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\r\n    }\r\n\r\n    /// @notice Encodes multiple calls to different contracts as EVMScript\r\n    function createEVMScript(\r\n        address[] memory _to,\r\n        bytes4[] memory _methodIds,\r\n        bytes[] memory _evmScriptCallData\r\n    ) internal pure returns (bytes memory _evmScript) {\r\n        require(_to.length == _methodIds.length, \"LENGTH_MISMATCH\");\r\n        require(_to.length == _evmScriptCallData.length, \"LENGTH_MISMATCH\");\r\n\r\n        for (uint256 i = 0; i < _to.length; ++i) {\r\n            _evmScript = bytes.concat(\r\n                _evmScript,\r\n                abi.encodePacked(\r\n                    _to[i],\r\n                    uint32(_evmScriptCallData[i].length) + 4,\r\n                    _methodIds[i],\r\n                    _evmScriptCallData[i]\r\n                )\r\n            );\r\n        }\r\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\r\n    }\r\n}\r\n// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\r\n\r\n\r\n\r\n\r\n/// @author zuzueeka\r\n/// @notice Interface of methods from BokkyPooBahsDateTimeContract to deal with dates\r\ninterface IBokkyPooBahsDateTimeContract {\r\n    function timestampToDate(uint256 timestamp)\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 year,\r\n            uint256 month,\r\n            uint256 day\r\n        );\r\n\r\n    function timestampFromDate(\r\n        uint256 year,\r\n        uint256 month,\r\n        uint256 day\r\n    ) external pure returns (uint256 timestamp);\r\n\r\n    function addMonths(uint256 timestamp, uint256 _months)\r\n        external\r\n        pure\r\n        returns (uint256 newTimestamp);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n    struct RoleData {\r\n        mapping(address => bool) members;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping(bytes32 => RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    /**\r\n     * @dev Modifier that checks that an account has a specific role. Reverts\r\n     * with a standardized message including the required role.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     *\r\n     * _Available since v4.1._\r\n     */\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role, _msgSender());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\r\n        return _roles[role].members[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `account` is missing `role`.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     */\r\n    function _checkRole(bytes32 role, address account) internal view {\r\n        if (!hasRole(role, account)) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"AccessControl: account \",\r\n                        Strings.toHexString(uint160(account), 20),\r\n                        \" is missing role \",\r\n                        Strings.toHexString(uint256(role), 32)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) public virtual override {\r\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event. Note that unlike {grantRole}, this function doesn't perform any\r\n     * checks on the calling account.\r\n     *\r\n     * [WARNING]\r\n     * ====\r\n     * This function should only be called from the constructor when setting\r\n     * up the initial roles for the system.\r\n     *\r\n     * Using this function in any other way is effectively circumventing the admin\r\n     * system imposed by {AccessControl}.\r\n     * ====\r\n     */\r\n    function _setupRole(bytes32 role, address account) internal virtual {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `adminRole` as ``role``'s admin role.\r\n     *\r\n     * Emits a {RoleAdminChanged} event.\r\n     */\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        _roles[role].adminRole = adminRole;\r\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n\r\n    function _grantRole(bytes32 role, address account) private {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].members[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n        }\r\n    }\r\n\r\n    function _revokeRole(bytes32 role, address account) private {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].members[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n        }\r\n    }\r\n}\r\n// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @author zuzueeka\r\n/// @notice Stores limits params and provides limit-enforcement logic\r\n///\r\n/// ▲ spendableBalance = limit-spentAmount\r\n/// |\r\n/// │             |................              |..               limit-spentAmount = limit-0 = limit\r\n/// │.....        |                ...           |\r\n/// │     ........|                   ......     |  ..............\r\n///               |                         .....|\r\n/// │─────────────────────────────────────────────────────────────> Time\r\n/// |     ^       |                ^  ^     ^    |  ^              (^ - Motion enactment)\r\n/// │             |currentPeriodEndTimestamp     |currentPeriodEndTimestamp\r\n/// |             |spentAmount=0                 |spentAmount=0\r\n///\r\n/// currentPeriodEndTimestamp is calculated as a calendar date of the beginning of\r\n/// a next month, bi-months, quarter, half year, or year period.\r\n/// If, for example, periodDurationMonths = 3, then it is considered that the date changes once a quarter.\r\n/// And currentPeriodEndTimestamp can take values 1 Apr, 1 Jul, 1 Oct, 1 Jan.\r\n/// If periodDurationMonths = 1, then shift of currentPeriodEndTimestamp occurs once a month\r\n/// and currentPeriodEndTimestamp can take values 1 Feb, 1 Mar, 1 Apr, etc\r\n///\r\ncontract LimitsChecker is AccessControl {\r\n    // -------------\r\n    // EVENTS\r\n    // -------------\r\n    event LimitsParametersChanged(uint256 _limit, uint256 _periodDurationMonths);\r\n    event SpendableAmountChanged(\r\n        uint256 _alreadySpentAmount,\r\n        uint256 _spendableBalance,\r\n        uint256 indexed _periodStartTimestamp,\r\n        uint256 _periodEndTimestamp\r\n    );\r\n    event CurrentPeriodAdvanced(uint256 indexed _periodStartTimestamp);\r\n    event BokkyPooBahsDateTimeContractChanged(address indexed _newAddress);\r\n    event SpentAmountChanged(uint256 _newSpentAmount);\r\n\r\n    // -------------\r\n    // ERRORS\r\n    // -------------\r\n    string private constant ERROR_INVALID_PERIOD_DURATION = \"INVALID_PERIOD_DURATION\";\r\n    string private constant ERROR_SUM_EXCEEDS_SPENDABLE_BALANCE = \"SUM_EXCEEDS_SPENDABLE_BALANCE\";\r\n    string private constant ERROR_TOO_LARGE_LIMIT = \"TOO_LARGE_LIMIT\";\r\n    string private constant ERROR_SAME_DATE_TIME_CONTRACT_ADDRESS =\r\n        \"SAME_DATE_TIME_CONTRACT_ADDRESS\";\r\n    string private constant ERROR_SPENT_AMOUNT_EXCEEDS_LIMIT = \"ERROR_SPENT_AMOUNT_EXCEEDS_LIMIT\";\r\n\r\n    // -------------\r\n    // ROLES\r\n    // -------------\r\n    bytes32 public constant SET_PARAMETERS_ROLE = keccak256(\"SET_PARAMETERS_ROLE\");\r\n    bytes32 public constant UPDATE_SPENT_AMOUNT_ROLE = keccak256(\"UPDATE_SPENT_AMOUNT_ROLE\");\r\n\r\n    // -------------\r\n    // CONSTANTS\r\n    // -------------\r\n\r\n    // ------------\r\n    // STORAGE VARIABLES\r\n    // ------------\r\n\r\n    /// @notice Address of BokkyPooBahsDateTimeContract\r\n    IBokkyPooBahsDateTimeContract public bokkyPooBahsDateTimeContract;\r\n\r\n    /// @notice Length of period in months\r\n    uint64 internal periodDurationMonths;\r\n\r\n    /// @notice End of the current period\r\n    uint128 internal currentPeriodEndTimestamp;\r\n\r\n    /// @notice The maximum that can be spent in a period\r\n    uint128 internal limit;\r\n\r\n    /// @notice Amount already spent in the period\r\n    uint128 internal spentAmount;\r\n\r\n    // ------------\r\n    // CONSTRUCTOR\r\n    // ------------\r\n    /// @param _setParametersRoleHolders List of addresses which will\r\n    ///     be granted with role SET_PARAMETERS_ROLE\r\n    /// @param _updateSpentAmountRoleHolders List of addresses which will\r\n    ///     be granted with role UPDATE_SPENT_AMOUNT_ROLE\r\n    /// @param _bokkyPooBahsDateTimeContract Address of bokkyPooBahs DateTime Contract\r\n    constructor(\r\n        address[] memory _setParametersRoleHolders,\r\n        address[] memory _updateSpentAmountRoleHolders,\r\n        IBokkyPooBahsDateTimeContract _bokkyPooBahsDateTimeContract\r\n    ) {\r\n        for (uint256 i = 0; i < _setParametersRoleHolders.length; i++) {\r\n            _setupRole(SET_PARAMETERS_ROLE, _setParametersRoleHolders[i]);\r\n        }\r\n        for (uint256 i = 0; i < _updateSpentAmountRoleHolders.length; i++) {\r\n            _setupRole(UPDATE_SPENT_AMOUNT_ROLE, _updateSpentAmountRoleHolders[i]);\r\n        }\r\n        bokkyPooBahsDateTimeContract = _bokkyPooBahsDateTimeContract;\r\n    }\r\n\r\n    // -------------\r\n    // EXTERNAL METHODS\r\n    // -------------\r\n\r\n    /// @notice Checks if _payoutAmount is less or equal than the may be spent\r\n    /// @param _payoutAmount Motion total amount\r\n    /// @param _motionDuration Motion duration - minimal time required to pass before enacting of motion\r\n    /// @return True if _payoutAmount is less or equal than may be spent\r\n    /// @dev note that upfront check is used to compare _paymentSum with total limit in case\r\n    /// when motion is started in one period and will be probably enacted in the next.\r\n    function isUnderSpendableBalance(uint256 _payoutAmount, uint256 _motionDuration)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (block.timestamp + _motionDuration >= currentPeriodEndTimestamp) {\r\n            return _payoutAmount <= limit;\r\n        } else {\r\n            return _payoutAmount <= _spendableBalance(limit, spentAmount);\r\n        }\r\n    }\r\n\r\n    /// @notice Checks if _payoutAmount may be spent and increases spentAmount by _payoutAmount.\r\n    /// @notice Also updates the period boundaries if necessary.\r\n    function updateSpentAmount(uint256 _payoutAmount) external onlyRole(UPDATE_SPENT_AMOUNT_ROLE) {\r\n        uint256 spentAmountLocal = spentAmount;\r\n        uint256 limitLocal = limit;\r\n        uint256 currentPeriodEndTimestampLocal = currentPeriodEndTimestamp;\r\n\r\n        /// When it is necessary to shift the currentPeriodEndTimestamp it takes on a new value.\r\n        /// And also spent is set to zero. Thus begins a new period.\r\n        if (block.timestamp >= currentPeriodEndTimestampLocal) {\r\n            currentPeriodEndTimestampLocal = _getPeriodEndFromTimestamp(block.timestamp);\r\n            spentAmountLocal = 0;\r\n            emit CurrentPeriodAdvanced(\r\n                _getPeriodStartFromTimestamp(currentPeriodEndTimestampLocal - 1)\r\n            );\r\n            currentPeriodEndTimestamp = uint128(currentPeriodEndTimestampLocal);\r\n        }\r\n\r\n        require(\r\n            _payoutAmount <= _spendableBalance(limitLocal, spentAmountLocal),\r\n            ERROR_SUM_EXCEEDS_SPENDABLE_BALANCE\r\n        );\r\n        spentAmountLocal += _payoutAmount;\r\n        spentAmount = uint128(spentAmountLocal);\r\n\r\n        (\r\n            uint256 alreadySpentAmount,\r\n            uint256 spendableBalanceInPeriod,\r\n            uint256 periodStartTimestamp,\r\n            uint256 periodEndTimestamp\r\n        ) = _getCurrentPeriodState(limitLocal, spentAmountLocal, currentPeriodEndTimestampLocal);\r\n\r\n        emit SpendableAmountChanged(\r\n            alreadySpentAmount,\r\n            spendableBalanceInPeriod,\r\n            periodStartTimestamp,\r\n            periodEndTimestamp\r\n        );\r\n    }\r\n\r\n    /// @notice Returns balance that can be spent in the current period\r\n    /// @notice If period advanced and no call to updateSpentAmount or setLimitParameters made,\r\n    /// @notice then the method will return spendable balance corresponding to the previous period.\r\n    /// @return Balance that can be spent in the current period\r\n    function spendableBalance() external view returns (uint256) {\r\n        return _spendableBalance(limit, spentAmount);\r\n    }\r\n\r\n    /// @notice Sets periodDurationMonths and limit\r\n    /// @notice Calculates currentPeriodEndTimestamp as a calendar date of the beginning of next period.\r\n    /// @param _limit Limit to set\r\n    /// @param _periodDurationMonths Length of period in months. Must be 1, 2, 3, 6 or 12.\r\n    function setLimitParameters(uint256 _limit, uint256 _periodDurationMonths)\r\n        external\r\n        onlyRole(SET_PARAMETERS_ROLE)\r\n    {\r\n        require(_limit <= type(uint128).max, ERROR_TOO_LARGE_LIMIT);\r\n\r\n        _validatePeriodDurationMonths(_periodDurationMonths);\r\n        periodDurationMonths = uint64(_periodDurationMonths);\r\n        uint256 currentPeriodEndTimestampLocal = _getPeriodEndFromTimestamp(block.timestamp);\r\n        emit CurrentPeriodAdvanced(\r\n            _getPeriodStartFromTimestamp(currentPeriodEndTimestampLocal - 1)\r\n        );\r\n        currentPeriodEndTimestamp = uint128(currentPeriodEndTimestampLocal);\r\n        limit = uint128(_limit);\r\n\r\n        emit LimitsParametersChanged(_limit, _periodDurationMonths);\r\n    }\r\n\r\n    /// @notice Returns limit and periodDurationMonths\r\n    /// @return limit - the maximum that can be spent in a period\r\n    /// @return periodDurationMonths - length of period in months\r\n    function getLimitParameters() external view returns (uint256, uint256) {\r\n        return (limit, periodDurationMonths);\r\n    }\r\n\r\n    /// @notice Returns state of the current period: amount spent, balance available for spending,\r\n    /// @notice start date of the current period and end date of the current period\r\n    /// @notice If period advanced and the period was not shifted,\r\n    /// @notice then the method will return spendable balance corresponding to the previous period.\r\n    /// @return _alreadySpentAmount - amount already spent in the current period\r\n    /// @return _spendableBalanceInPeriod - balance available for spending in the current period\r\n    /// @return _periodStartTimestamp - start date of the current period\r\n    /// @return _periodEndTimestamp - end date of the current period\r\n    function getPeriodState()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _alreadySpentAmount,\r\n            uint256 _spendableBalanceInPeriod,\r\n            uint256 _periodStartTimestamp,\r\n            uint256 _periodEndTimestamp\r\n        )\r\n    {\r\n        return _getCurrentPeriodState(limit, spentAmount, currentPeriodEndTimestamp);\r\n    }\r\n\r\n    /// @notice Sets address of BokkyPooBahsDateTime contract\r\n    /// @dev Need this to be able to replace the contract in case of a bug in it\r\n    /// @param _bokkyPooBahsDateTimeContract New address of the BokkyPooBahsDateTime library\r\n    function setBokkyPooBahsDateTimeContract(address _bokkyPooBahsDateTimeContract)\r\n        external\r\n        onlyRole(SET_PARAMETERS_ROLE)\r\n    {\r\n        require(\r\n            _bokkyPooBahsDateTimeContract != address(bokkyPooBahsDateTimeContract),\r\n            ERROR_SAME_DATE_TIME_CONTRACT_ADDRESS\r\n        );\r\n\r\n        bokkyPooBahsDateTimeContract = IBokkyPooBahsDateTimeContract(_bokkyPooBahsDateTimeContract);\r\n        emit BokkyPooBahsDateTimeContractChanged(_bokkyPooBahsDateTimeContract);\r\n    }\r\n\r\n    /// @notice Allows setting the amount of spent tokens in the current period manually\r\n    /// @param _newSpentAmount New value for the amount of spent tokens in the current period\r\n    function unsafeSetSpentAmount(uint256 _newSpentAmount) external onlyRole(SET_PARAMETERS_ROLE) {\r\n        require(_newSpentAmount <= limit, ERROR_SPENT_AMOUNT_EXCEEDS_LIMIT);\r\n\r\n        if (spentAmount != _newSpentAmount) {\r\n            spentAmount = uint128(_newSpentAmount);\r\n            emit SpentAmountChanged(_newSpentAmount);\r\n        }\r\n    }\r\n\r\n    // ------------------\r\n    // PRIVATE METHODS\r\n    // ------------------\r\n    function _getCurrentPeriodState(\r\n        uint256 _limit,\r\n        uint256 _spentAmount,\r\n        uint256 _currentPeriodEndTimestamp\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 _alreadySpentAmount,\r\n            uint256 _spendableBalanceInPeriod,\r\n            uint256 _periodStartTimestamp,\r\n            uint256 _periodEndTimestamp\r\n        )\r\n    {\r\n        return (\r\n            _spentAmount,\r\n            _spendableBalance(_limit, _spentAmount),\r\n            _getPeriodStartFromTimestamp(_currentPeriodEndTimestamp - 1),\r\n            _currentPeriodEndTimestamp\r\n        );\r\n    }\r\n\r\n    function _spendableBalance(uint256 _limit, uint256 _spentAmount)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return _spentAmount < _limit ? _limit - _spentAmount : 0;\r\n    }\r\n\r\n    function _validatePeriodDurationMonths(uint256 _periodDurationMonths) internal pure {\r\n        require(\r\n            _periodDurationMonths == 1 ||\r\n                _periodDurationMonths == 2 ||\r\n                _periodDurationMonths == 3 ||\r\n                _periodDurationMonths == 6 ||\r\n                _periodDurationMonths == 12,\r\n            ERROR_INVALID_PERIOD_DURATION\r\n        );\r\n    }\r\n\r\n    function _getPeriodStartFromTimestamp(uint256 _timestamp) internal view returns (uint256) {\r\n        // Get year and number of month of the timestamp:\r\n        (uint256 year, uint256 month, ) = bokkyPooBahsDateTimeContract.timestampToDate(_timestamp);\r\n        // We assume that the year will remain the same,\r\n        // because the beginning of the current calendar period will necessarily be in the same year.\r\n        uint256 periodStartYear = year;\r\n        // Get the number of the start date month:\r\n        uint256 periodStartMonth = _getFirstMonthInPeriodFromMonth(month, periodDurationMonths);\r\n        // The beginning of the period always matches the calendar date of the beginning of the month.\r\n        uint256 periodStartDay = 1;\r\n        return\r\n            bokkyPooBahsDateTimeContract.timestampFromDate(\r\n                periodStartYear,\r\n                periodStartMonth,\r\n                periodStartDay\r\n            );\r\n    }\r\n\r\n    function _getFirstMonthInPeriodFromMonth(uint256 _month, uint256 _periodDurationMonths)\r\n        internal\r\n        pure\r\n        returns (uint256 _firstMonthInPeriod)\r\n    {\r\n        require(_periodDurationMonths != 0, ERROR_INVALID_PERIOD_DURATION);\r\n\r\n        // To get the number of the first month in the period:\r\n        //   1. get the number of the period within the current year, starting from its beginning:\r\n        uint256 periodNumber = (_month - 1) / _periodDurationMonths;\r\n        //   2. and then the number of the first month in this period:\r\n        _firstMonthInPeriod = periodNumber * _periodDurationMonths + 1;\r\n        // The shift by - 1 and then by + 1 happens because the months in the calendar start from 1 and not from 0.\r\n    }\r\n\r\n    function _getPeriodEndFromTimestamp(uint256 _timestamp) internal view returns (uint256) {\r\n        uint256 periodStart = _getPeriodStartFromTimestamp(_timestamp);\r\n        return bokkyPooBahsDateTimeContract.addMonths(periodStart, periodDurationMonths);\r\n    }\r\n}\r\n// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @author psirex, zuzueeka\r\n/// @title Registry of allowed addresses for payouts\r\n/// @notice Stores list of allowed addresses\r\ncontract AllowedRecipientsRegistry is LimitsChecker {\r\n    // -------------\r\n    // EVENTS\r\n    // -------------\r\n    event RecipientAdded(address indexed _recipient, string _title);\r\n    event RecipientRemoved(address indexed _recipient);\r\n\r\n    // -------------\r\n    // ROLES\r\n    // -------------\r\n    bytes32 public constant ADD_RECIPIENT_TO_ALLOWED_LIST_ROLE =\r\n        keccak256(\"ADD_RECIPIENT_TO_ALLOWED_LIST_ROLE\");\r\n    bytes32 public constant REMOVE_RECIPIENT_FROM_ALLOWED_LIST_ROLE =\r\n        keccak256(\"REMOVE_RECIPIENT_FROM_ALLOWED_LIST_ROLE\");\r\n\r\n    // -------------\r\n    // ERRORS\r\n    // -------------\r\n    string private constant ERROR_RECIPIENT_ALREADY_ADDED_TO_ALLOWED_LIST =\r\n        \"RECIPIENT_ALREADY_ADDED_TO_ALLOWED_LIST\";\r\n    string private constant ERROR_RECIPIENT_NOT_FOUND_IN_ALLOWED_LIST =\r\n        \"RECIPIENT_NOT_FOUND_IN_ALLOWED_LIST\";\r\n\r\n    // -------------\r\n    // VARIABLES\r\n    // -------------\r\n\r\n    /// @dev List of allowed addresses for payouts\r\n    address[] public allowedRecipients;\r\n\r\n    // Position of the address in the `allowedRecipients` array,\r\n    // plus 1 because index 0 means a value is not in the set.\r\n    mapping(address => uint256) private allowedRecipientIndices;\r\n\r\n    // -------------\r\n    // CONSTRUCTOR\r\n    // -------------\r\n\r\n    /// @param _admin Address which will be granted with role DEFAULT_ADMIN_ROLE\r\n    /// @param _addRecipientToAllowedListRoleHolders List of addresses which will be\r\n    ///     granted with role ADD_RECIPIENT_TO_ALLOWED_LIST_ROLE\r\n    /// @param _removeRecipientFromAllowedListRoleHolders List of addresses which will\r\n    ///     be granted with role REMOVE_RECIPIENT_FROM_ALLOWED_LIST_ROLE\r\n    /// @param _setParametersRoleHolders List of addresses which will\r\n    ///     be granted with role SET_PARAMETERS_ROLE\r\n    /// @param _updateSpentAmountRoleHolders List of addresses which will\r\n    ///     be granted with role UPDATE_SPENT_AMOUNT_ROLE\r\n    /// @param _bokkyPooBahsDateTimeContract Address of bokkyPooBahs DateTime Contract\r\n    constructor(\r\n        address _admin,\r\n        address[] memory _addRecipientToAllowedListRoleHolders,\r\n        address[] memory _removeRecipientFromAllowedListRoleHolders,\r\n        address[] memory _setParametersRoleHolders,\r\n        address[] memory _updateSpentAmountRoleHolders,\r\n        IBokkyPooBahsDateTimeContract _bokkyPooBahsDateTimeContract\r\n    )\r\n        LimitsChecker(\r\n            _setParametersRoleHolders,\r\n            _updateSpentAmountRoleHolders,\r\n            _bokkyPooBahsDateTimeContract\r\n        )\r\n    {\r\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\r\n        for (uint256 i = 0; i < _addRecipientToAllowedListRoleHolders.length; i++) {\r\n            _setupRole(\r\n                ADD_RECIPIENT_TO_ALLOWED_LIST_ROLE,\r\n                _addRecipientToAllowedListRoleHolders[i]\r\n            );\r\n        }\r\n        for (uint256 i = 0; i < _removeRecipientFromAllowedListRoleHolders.length; i++) {\r\n            _setupRole(\r\n                REMOVE_RECIPIENT_FROM_ALLOWED_LIST_ROLE,\r\n                _removeRecipientFromAllowedListRoleHolders[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    // -------------\r\n    // EXTERNAL METHODS\r\n    // -------------\r\n\r\n    /// @notice Adds address to list of allowed addresses for payouts\r\n    function addRecipient(address _recipient, string memory _title)\r\n        external\r\n        onlyRole(ADD_RECIPIENT_TO_ALLOWED_LIST_ROLE)\r\n    {\r\n        require(\r\n            allowedRecipientIndices[_recipient] == 0,\r\n            ERROR_RECIPIENT_ALREADY_ADDED_TO_ALLOWED_LIST\r\n        );\r\n\r\n        allowedRecipients.push(_recipient);\r\n        allowedRecipientIndices[_recipient] = allowedRecipients.length;\r\n        emit RecipientAdded(_recipient, _title);\r\n    }\r\n\r\n    /// @notice Removes address from list of allowed addresses for payouts\r\n    /// @dev To delete an allowed address from the allowedRecipients array in O(1),\r\n    /// we swap the element to delete with the last one in the array,\r\n    /// and then remove the last element (sometimes called as 'swap and pop').\r\n    function removeRecipient(address _recipient)\r\n        external\r\n        onlyRole(REMOVE_RECIPIENT_FROM_ALLOWED_LIST_ROLE)\r\n    {\r\n        uint256 index = _getAllowedRecipientIndex(_recipient);\r\n        uint256 lastIndex = allowedRecipients.length - 1;\r\n\r\n        if (index != lastIndex) {\r\n            address lastAllowedRecipient = allowedRecipients[lastIndex];\r\n            allowedRecipients[index] = lastAllowedRecipient;\r\n            allowedRecipientIndices[lastAllowedRecipient] = index + 1;\r\n        }\r\n\r\n        allowedRecipients.pop();\r\n        delete allowedRecipientIndices[_recipient];\r\n        emit RecipientRemoved(_recipient);\r\n    }\r\n\r\n    /// @notice Returns if passed address is listed as allowed recipient in the registry\r\n    function isRecipientAllowed(address _recipient) external view returns (bool) {\r\n        return allowedRecipientIndices[_recipient] > 0;\r\n    }\r\n\r\n    /// @notice Returns current list of allowed recipients\r\n    function getAllowedRecipients() external view returns (address[] memory) {\r\n        return allowedRecipients;\r\n    }\r\n\r\n    // ------------------\r\n    // PRIVATE METHODS\r\n    // ------------------\r\n\r\n    function _getAllowedRecipientIndex(address _recipient) private view returns (uint256 _index) {\r\n        _index = allowedRecipientIndices[_recipient];\r\n        require(_index > 0, ERROR_RECIPIENT_NOT_FOUND_IN_ALLOWED_LIST);\r\n        _index -= 1;\r\n    }\r\n}\r\n// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\r\n\r\n\r\n\r\n\r\n/// @author psirex\r\n/// @notice Interface which every EVMScript factory used in EasyTrack contract has to implement\r\ninterface IEVMScriptFactory {\r\n    function createEVMScript(address _creator, bytes memory _evmScriptCallData)\r\n        external\r\n        returns (bytes memory);\r\n}\r\n// SPDX-FileCopyrightText: 2022 Lido <info@lido.fi>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @author psirex, zuzueeka\r\n/// @notice Creates EVMScript to remove allowed recipient address from AllowedRecipientsRegistry\r\ncontract RemoveAllowedRecipient is TrustedCaller, IEVMScriptFactory {\r\n    // -------------\r\n    // ERRORS\r\n    // -------------\r\n    string private constant ERROR_ALLOWED_RECIPIENT_NOT_FOUND = \"ALLOWED_RECIPIENT_NOT_FOUND\";\r\n\r\n    // -------------\r\n    // VARIABLES\r\n    // -------------\r\n\r\n    /// @notice Address of AllowedRecipientsRegistry\r\n    AllowedRecipientsRegistry public allowedRecipientsRegistry;\r\n\r\n    // -------------\r\n    // CONSTRUCTOR\r\n    // -------------\r\n\r\n    constructor(address _trustedCaller, address _allowedRecipientsRegistry)\r\n        TrustedCaller(_trustedCaller)\r\n    {\r\n        allowedRecipientsRegistry = AllowedRecipientsRegistry(_allowedRecipientsRegistry);\r\n    }\r\n\r\n    // -------------\r\n    // EXTERNAL METHODS\r\n    // -------------\r\n\r\n    /// @notice Creates EVMScript to remove allowed recipient address from allowedRecipientsRegistry\r\n    /// @param _creator Address who creates EVMScript\r\n    /// @param _evmScriptCallData Encoded tuple: (address recipientAddress)\r\n    function createEVMScript(address _creator, bytes memory _evmScriptCallData)\r\n        external\r\n        view\r\n        override\r\n        onlyTrustedCaller(_creator)\r\n        returns (bytes memory)\r\n    {\r\n        require(\r\n            allowedRecipientsRegistry.isRecipientAllowed(\r\n                _decodeEVMScriptCallData(_evmScriptCallData)\r\n            ),\r\n            ERROR_ALLOWED_RECIPIENT_NOT_FOUND\r\n        );\r\n        return\r\n            EVMScriptCreator.createEVMScript(\r\n                address(allowedRecipientsRegistry),\r\n                allowedRecipientsRegistry.removeRecipient.selector,\r\n                _evmScriptCallData\r\n            );\r\n    }\r\n\r\n    /// @notice Decodes call data used by createEVMScript method\r\n    /// @param _evmScriptCallData Encoded tuple: (address recipientAddress)\r\n    /// @return recipientAddress Address to remove\r\n    function decodeEVMScriptCallData(bytes memory _evmScriptCallData)\r\n        external\r\n        pure\r\n        returns (address recipientAddress)\r\n    {\r\n        return _decodeEVMScriptCallData(_evmScriptCallData);\r\n    }\r\n\r\n    // ------------------\r\n    // PRIVATE METHODS\r\n    // ------------------\r\n\r\n    function _decodeEVMScriptCallData(bytes memory _evmScriptCallData)\r\n        private\r\n        pure\r\n        returns (address)\r\n    {\r\n        return abi.decode(_evmScriptCallData, (address));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedCaller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_allowedRecipientsRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"allowedRecipientsRegistry\",\"outputs\":[{\"internalType\":\"contract AllowedRecipientsRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_evmScriptCallData\",\"type\":\"bytes\"}],\"name\":\"createEVMScript\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_evmScriptCallData\",\"type\":\"bytes\"}],\"name\":\"decodeEVMScriptCallData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedCaller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RemoveAllowedRecipient","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000087d93d9b2c672bf9c9642d853a8682546a5012b5000000000000000000000000aa47c268e6b2d4ac7d7f7ffb28a39484f5212c2a","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://91ae64d6081097c8d289dbe4c9f35a19e87065afa67ab13b76007619c4d55463"}]