[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/external/actions/nTokenMintAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../internal/nTokenHandler.sol\\\";\\nimport \\\"../../internal/markets/Market.sol\\\";\\nimport \\\"../../internal/markets/CashGroup.sol\\\";\\nimport \\\"../../internal/markets/AssetRate.sol\\\";\\nimport \\\"../../internal/balances/BalanceHandler.sol\\\";\\nimport \\\"../../internal/portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary nTokenMintAction {\\n    using SafeInt256 for int256;\\n    using BalanceHandler for BalanceState;\\n    using CashGroup for CashGroupParameters;\\n    using Market for MarketParameters;\\n    using nTokenHandler for nTokenPortfolio;\\n    using PortfolioHandler for PortfolioState;\\n    using AssetRate for AssetRateParameters;\\n    using SafeMath for uint256;\\n    using nTokenHandler for nTokenPortfolio;\\n\\n    /// @notice Converts the given amount of cash to nTokens in the same currency.\\n    /// @param currencyId the currency associated the nToken\\n    /// @param amountToDepositInternal the amount of asset tokens to deposit denominated in internal decimals\\n    /// @return nTokens minted by this action\\n    function nTokenMint(uint16 currencyId, int256 amountToDepositInternal)\\n        external\\n        returns (int256)\\n    {\\n        uint256 blockTime = block.timestamp;\\n        nTokenPortfolio memory nToken;\\n        nToken.loadNTokenPortfolioStateful(currencyId);\\n\\n        int256 tokensToMint = calculateTokensToMint(nToken, amountToDepositInternal, blockTime);\\n        require(tokensToMint >= 0, \\\"Invalid token amount\\\");\\n\\n        if (nToken.portfolioState.storedAssets.length == 0) {\\n            // If the token does not have any assets, then the markets must be initialized first.\\n            nToken.cashBalance = nToken.cashBalance.add(amountToDepositInternal);\\n            BalanceHandler.setBalanceStorageForNToken(\\n                nToken.tokenAddress,\\n                currencyId,\\n                nToken.cashBalance\\n            );\\n        } else {\\n            _depositIntoPortfolio(nToken, amountToDepositInternal, blockTime);\\n        }\\n\\n        // NOTE: token supply does not change here, it will change after incentives have been claimed\\n        // during BalanceHandler.finalize\\n        return tokensToMint;\\n    }\\n\\n    /// @notice Calculates the tokens to mint to the account as a ratio of the nToken\\n    /// present value denominated in asset cash terms.\\n    /// @return the amount of tokens to mint, the ifCash bitmap\\n    function calculateTokensToMint(\\n        nTokenPortfolio memory nToken,\\n        int256 amountToDepositInternal,\\n        uint256 blockTime\\n    ) internal view returns (int256) {\\n        require(amountToDepositInternal >= 0); // dev: deposit amount negative\\n        if (amountToDepositInternal == 0) return 0;\\n\\n        if (nToken.lastInitializedTime != 0) {\\n            // For the sake of simplicity, nTokens cannot be minted if they have assets\\n            // that need to be settled. This is only done during market initialization.\\n            uint256 nextSettleTime = nToken.getNextSettleTime();\\n            // If next settle time <= blockTime then the token can be settled\\n            require(nextSettleTime > blockTime, \\\"Requires settlement\\\");\\n        }\\n\\n        int256 assetCashPV = nToken.getNTokenAssetPV(blockTime);\\n        // Defensive check to ensure PV remains positive\\n        require(assetCashPV >= 0);\\n\\n        // Allow for the first deposit\\n        if (nToken.totalSupply == 0) {\\n            return amountToDepositInternal;\\n        } else {\\n            // assetCashPVPost = assetCashPV + amountToDeposit\\n            // (tokenSupply + tokensToMint) / tokenSupply == (assetCashPV + amountToDeposit) / assetCashPV\\n            // (tokenSupply + tokensToMint) == (assetCashPV + amountToDeposit) * tokenSupply / assetCashPV\\n            // (tokenSupply + tokensToMint) == tokenSupply + (amountToDeposit * tokenSupply) / assetCashPV\\n            // tokensToMint == (amountToDeposit * tokenSupply) / assetCashPV\\n            return amountToDepositInternal.mul(nToken.totalSupply).div(assetCashPV);\\n        }\\n    }\\n\\n    /// @notice Portions out assetCashDeposit into amounts to deposit into individual markets. When\\n    /// entering this method we know that assetCashDeposit is positive and the nToken has been\\n    /// initialized to have liquidity tokens.\\n    function _depositIntoPortfolio(\\n        nTokenPortfolio memory nToken,\\n        int256 assetCashDeposit,\\n        uint256 blockTime\\n    ) private {\\n        (int256[] memory depositShares, int256[] memory leverageThresholds) =\\n            nTokenHandler.getDepositParameters(\\n                nToken.cashGroup.currencyId,\\n                nToken.cashGroup.maxMarketIndex\\n            );\\n\\n        // Loop backwards from the last market to the first market, the reasoning is a little complicated:\\n        // If we have to deleverage the markets (i.e. lend instead of provide liquidity) it's quite gas inefficient\\n        // to calculate the cash amount to lend. We do know that longer term maturities will have more\\n        // slippage and therefore the residual from the perMarketDeposit will be lower as the maturities get\\n        // closer to the current block time. Any residual cash from lending will be rolled into shorter\\n        // markets as this loop progresses.\\n        int256 residualCash;\\n        MarketParameters memory market;\\n        for (uint256 marketIndex = nToken.cashGroup.maxMarketIndex; marketIndex > 0; marketIndex--) {\\n            int256 fCashAmount;\\n            // Loads values into the market memory slot\\n            nToken.cashGroup.loadMarket(\\n                market,\\n                marketIndex,\\n                true, // Needs liquidity to true\\n                blockTime\\n            );\\n            // If market has not been initialized, continue. This can occur when cash groups extend maxMarketIndex\\n            // before initializing\\n            if (market.totalLiquidity == 0) continue;\\n\\n            // Checked that assetCashDeposit must be positive before entering\\n            int256 perMarketDeposit =\\n                assetCashDeposit\\n                    .mul(depositShares[marketIndex - 1])\\n                    .div(Constants.DEPOSIT_PERCENT_BASIS)\\n                    .add(residualCash);\\n\\n            (fCashAmount, residualCash) = _lendOrAddLiquidity(\\n                nToken,\\n                market,\\n                perMarketDeposit,\\n                leverageThresholds[marketIndex - 1],\\n                marketIndex,\\n                blockTime\\n            );\\n\\n            if (fCashAmount != 0) {\\n                BitmapAssetsHandler.addifCashAsset(\\n                    nToken.tokenAddress,\\n                    nToken.cashGroup.currencyId,\\n                    market.maturity,\\n                    nToken.lastInitializedTime,\\n                    fCashAmount\\n                );\\n            }\\n        }\\n\\n        // nToken is allowed to store assets directly without updating account context.\\n        nToken.portfolioState.storeAssets(nToken.tokenAddress);\\n\\n        // Defensive check to ensure that we do not somehow accrue negative residual cash.\\n        require(residualCash >= 0, \\\"Negative residual cash\\\");\\n        // This will occur if the three month market is over levered and we cannot lend into it\\n        if (residualCash > 0) {\\n            // Any remaining residual cash will be put into the nToken balance and added as liquidity on the\\n            // next market initialization\\n            nToken.cashBalance = nToken.cashBalance.add(residualCash);\\n            BalanceHandler.setBalanceStorageForNToken(\\n                nToken.tokenAddress,\\n                nToken.cashGroup.currencyId,\\n                nToken.cashBalance\\n            );\\n        }\\n    }\\n\\n    /// @notice For a given amount of cash to deposit, decides how much to lend or provide\\n    /// given the market conditions.\\n    function _lendOrAddLiquidity(\\n        nTokenPortfolio memory nToken,\\n        MarketParameters memory market,\\n        int256 perMarketDeposit,\\n        int256 leverageThreshold,\\n        uint256 marketIndex,\\n        uint256 blockTime\\n    ) private returns (int256 fCashAmount, int256 residualCash) {\\n        // We start off with the entire per market deposit as residuals\\n        residualCash = perMarketDeposit;\\n\\n        // If the market is over leveraged then we will lend to it instead of providing liquidity\\n        if (_isMarketOverLeveraged(nToken.cashGroup, market, leverageThreshold)) {\\n            (residualCash, fCashAmount) = _deleverageMarket(\\n                nToken.cashGroup,\\n                market,\\n                perMarketDeposit,\\n                blockTime,\\n                marketIndex\\n            );\\n\\n            // Recalculate this after lending into the market, if it is still over leveraged then\\n            // we will not add liquidity and just exit.\\n            if (_isMarketOverLeveraged(nToken.cashGroup, market, leverageThreshold)) {\\n                // Returns the residual cash amount\\n                return (fCashAmount, residualCash);\\n            }\\n        }\\n\\n        // Add liquidity to the market only if we have successfully delevered.\\n        // (marketIndex - 1) is the index of the nToken portfolio array where the asset is stored\\n        // If deleveraged, residualCash is what remains\\n        // If not deleveraged, residual cash is per market deposit\\n        fCashAmount = fCashAmount.add(\\n            _addLiquidityToMarket(nToken, market, marketIndex - 1, residualCash)\\n        );\\n        // No residual cash if we're adding liquidity\\n        return (fCashAmount, 0);\\n    }\\n\\n    /// @notice Markets are over levered when their proportion is greater than a governance set\\n    /// threshold. At this point, providing liquidity will incur too much negative fCash on the nToken\\n    /// account for the given amount of cash deposited, putting the nToken account at risk of liquidation.\\n    /// If the market is over leveraged, we call `deleverageMarket` to lend to the market instead.\\n    function _isMarketOverLeveraged(\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        int256 leverageThreshold\\n    ) private pure returns (bool) {\\n        int256 totalCashUnderlying = cashGroup.assetRate.convertToUnderlying(market.totalAssetCash);\\n        // Comparison we want to do:\\n        // (totalfCash) / (totalfCash + totalCashUnderlying) > leverageThreshold\\n        // However, the division will introduce rounding errors so we change this to:\\n        // totalfCash * RATE_PRECISION > leverageThreshold * (totalfCash + totalCashUnderlying)\\n        // Leverage threshold is denominated in rate precision.\\n        return (\\n            market.totalfCash.mul(Constants.RATE_PRECISION) >\\n            leverageThreshold.mul(market.totalfCash.add(totalCashUnderlying))\\n        );\\n    }\\n\\n    function _addLiquidityToMarket(\\n        nTokenPortfolio memory nToken,\\n        MarketParameters memory market,\\n        uint256 index,\\n        int256 perMarketDeposit\\n    ) private returns (int256) {\\n        // Add liquidity to the market\\n        PortfolioAsset memory asset = nToken.portfolioState.storedAssets[index];\\n        // We expect that all the liquidity tokens are in the portfolio in order.\\n        require(\\n            asset.maturity == market.maturity &&\\n            // Ensures that the asset type references the proper liquidity token\\n            asset.assetType == index + Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\\n            // Ensures that the storage state will not be overwritten\\n            asset.storageState == AssetStorageState.NoChange,\\n            \\\"PT: invalid liquidity token\\\"\\n        );\\n\\n        // This will update the market state as well, fCashAmount returned here is negative\\n        (int256 liquidityTokens, int256 fCashAmount) = market.addLiquidity(perMarketDeposit);\\n        asset.notional = asset.notional.add(liquidityTokens);\\n        asset.storageState = AssetStorageState.Update;\\n\\n        return fCashAmount;\\n    }\\n\\n    /// @notice Lends into the market to reduce the leverage that the nToken will add liquidity at. May fail due\\n    /// to slippage or result in some amount of residual cash.\\n    function _deleverageMarket(\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        int256 perMarketDeposit,\\n        uint256 blockTime,\\n        uint256 marketIndex\\n    ) private returns (int256, int256) {\\n        uint256 timeToMaturity = market.maturity.sub(blockTime);\\n\\n        // Shift the last implied rate by some buffer and calculate the exchange rate to fCash. Hope that this\\n        // is sufficient to cover all potential slippage. We don't use the `getfCashGivenCashAmount` method here\\n        // because it is very gas inefficient.\\n        int256 assumedExchangeRate;\\n        if (market.lastImpliedRate < Constants.DELEVERAGE_BUFFER) {\\n            // Floor the exchange rate at zero interest rate\\n            assumedExchangeRate = Constants.RATE_PRECISION;\\n        } else {\\n            assumedExchangeRate = Market.getExchangeRateFromImpliedRate(\\n                market.lastImpliedRate.sub(Constants.DELEVERAGE_BUFFER),\\n                timeToMaturity\\n            );\\n        }\\n\\n        int256 fCashAmount;\\n        {\\n            int256 perMarketDepositUnderlying =\\n                cashGroup.assetRate.convertToUnderlying(perMarketDeposit);\\n            // NOTE: cash * exchangeRate = fCash\\n            fCashAmount = perMarketDepositUnderlying.mulInRatePrecision(assumedExchangeRate);\\n        }\\n        int256 netAssetCash = market.executeTrade(cashGroup, fCashAmount, timeToMaturity, marketIndex);\\n\\n        // This means that the trade failed\\n        if (netAssetCash == 0) {\\n            return (perMarketDeposit, 0);\\n        } else {\\n            // Ensure that net the per market deposit figure does not drop below zero, this should not be possible\\n            // given how we've calculated the exchange rate but extra caution here\\n            int256 residual = perMarketDeposit.add(netAssetCash);\\n            require(residual >= 0); // dev: insufficient cash\\n            return (residual, fCashAmount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/global/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\n/// @title All shared constants for the Notional system should be declared here.\\nlibrary Constants {\\n    // Return code for cTokens that represents no error\\n    uint256 internal constant COMPOUND_RETURN_CODE_NO_ERROR = 0;\\n    uint8 internal constant CETH_DECIMAL_PLACES = 8;\\n\\n    // Token precision used for all internal balances, TokenHandler library ensures that we\\n    // limit the dust amount caused by precision mismatches\\n    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\\n\\n    // ETH will be initialized as the first currency\\n    uint256 internal constant ETH_CURRENCY_ID = 1;\\n    uint8 internal constant ETH_DECIMAL_PLACES = 18;\\n    int256 internal constant ETH_DECIMALS = 1e18;\\n    // Used to prevent overflow when converting decimal places to decimal precision values via\\n    // 10**decimalPlaces. This is a safe value for int256 and uint256 variables. We apply this\\n    // constraint when storing decimal places in governance.\\n    uint256 internal constant MAX_DECIMAL_PLACES = 36;\\n\\n    // Address of the reserve account\\n    address internal constant RESERVE = address(0);\\n    // NOTE: this address is hardcoded in the library, must update this on deployment\\n    address constant NOTE_TOKEN_ADDRESS = 0xCFEAead4947f0705A14ec42aC3D44129E1Ef3eD5;\\n\\n    // Most significant bit\\n    bytes32 internal constant MSB =\\n        0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n    // Basis for percentages\\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\\n    // Max number of traded markets, also used as the maximum number of assets in a portfolio array\\n    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;\\n    // Max number of fCash assets in a bitmap, this is based on the gas costs of calculating free collateral\\n    // for a bitmap portfolio\\n    uint256 internal constant MAX_BITMAP_ASSETS = 20;\\n    uint256 internal constant FIVE_MINUTES = 300;\\n\\n    // Internal date representations, note we use a 6/30/360 week/month/year convention here\\n    uint256 internal constant DAY = 86400;\\n    // We use six day weeks to ensure that all time references divide evenly\\n    uint256 internal constant WEEK = DAY * 6;\\n    uint256 internal constant MONTH = WEEK * 5;\\n    uint256 internal constant QUARTER = MONTH * 3;\\n    uint256 internal constant YEAR = QUARTER * 4;\\n    \\n    // These constants are used in DateTime.sol\\n    uint256 internal constant DAYS_IN_WEEK = 6;\\n    uint256 internal constant DAYS_IN_MONTH = 30;\\n    uint256 internal constant DAYS_IN_QUARTER = 90;\\n\\n    // Offsets for each time chunk denominated in days\\n    uint256 internal constant MAX_DAY_OFFSET = 90;\\n    uint256 internal constant MAX_WEEK_OFFSET = 360;\\n    uint256 internal constant MAX_MONTH_OFFSET = 2160;\\n    uint256 internal constant MAX_QUARTER_OFFSET = 7650;\\n\\n    // Offsets for each time chunk denominated in bits\\n    uint256 internal constant WEEK_BIT_OFFSET = 90;\\n    uint256 internal constant MONTH_BIT_OFFSET = 135;\\n    uint256 internal constant QUARTER_BIT_OFFSET = 195;\\n\\n    // This is a constant that represents the time period that all rates are normalized by, 360 days\\n    uint256 internal constant IMPLIED_RATE_TIME = 360 * DAY;\\n    // Number of decimal places that rates are stored in, equals 100%\\n    int256 internal constant RATE_PRECISION = 1e9;\\n    // One basis point in RATE_PRECISION terms\\n    uint256 internal constant BASIS_POINT = uint256(RATE_PRECISION / 10000);\\n    // Used to when calculating the amount to deleverage of a market when minting nTokens\\n    uint256 internal constant DELEVERAGE_BUFFER = 300 * BASIS_POINT;\\n    // Used for scaling cash group factors\\n    uint256 internal constant FIVE_BASIS_POINTS = 5 * BASIS_POINT;\\n    // Used for residual purchase incentive and cash withholding buffer\\n    uint256 internal constant TEN_BASIS_POINTS = 10 * BASIS_POINT;\\n\\n    // This is the ABDK64x64 representation of RATE_PRECISION\\n    // RATE_PRECISION_64x64 = ABDKMath64x64.fromUint(RATE_PRECISION)\\n    int128 internal constant RATE_PRECISION_64x64 = 0x3b9aca000000000000000000;\\n    int128 internal constant LOG_RATE_PRECISION_64x64 = 382276781265598821176;\\n    // Limit the market proportion so that borrowing cannot hit extremely high interest rates\\n    int256 internal constant MAX_MARKET_PROPORTION = RATE_PRECISION * 96 / 100;\\n\\n    uint8 internal constant FCASH_ASSET_TYPE = 1;\\n    // Liquidity token asset types are 1 + marketIndex (where marketIndex is 1-indexed)\\n    uint8 internal constant MIN_LIQUIDITY_TOKEN_INDEX = 2;\\n    uint8 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;\\n\\n    // Used for converting bool to bytes1, solidity does not have a native conversion\\n    // method for this\\n    bytes1 internal constant BOOL_FALSE = 0x00;\\n    bytes1 internal constant BOOL_TRUE = 0x01;\\n\\n    // Account context flags\\n    bytes1 internal constant HAS_ASSET_DEBT = 0x01;\\n    bytes1 internal constant HAS_CASH_DEBT = 0x02;\\n    bytes2 internal constant ACTIVE_IN_PORTFOLIO = 0x8000;\\n    bytes2 internal constant ACTIVE_IN_BALANCES = 0x4000;\\n    bytes2 internal constant UNMASK_FLAGS = 0x3FFF;\\n    uint16 internal constant MAX_CURRENCIES = uint16(UNMASK_FLAGS);\\n\\n    // Equal to 100% of all deposit amounts for nToken liquidity across fCash markets.\\n    int256 internal constant DEPOSIT_PERCENT_BASIS = 1e8;\\n\\n    // nToken Parameters: there are offsets in the nTokenParameters bytes6 variable returned\\n    // in nTokenHandler. Each constant represents a position in the byte array.\\n    uint8 internal constant LIQUIDATION_HAIRCUT_PERCENTAGE = 0;\\n    uint8 internal constant CASH_WITHHOLDING_BUFFER = 1;\\n    uint8 internal constant RESIDUAL_PURCHASE_TIME_BUFFER = 2;\\n    uint8 internal constant PV_HAIRCUT_PERCENTAGE = 3;\\n    uint8 internal constant RESIDUAL_PURCHASE_INCENTIVE = 4;\\n\\n    // Liquidation parameters\\n    // Default percentage of collateral that a liquidator is allowed to liquidate, will be higher if the account\\n    // requires more collateral to be liquidated\\n    int256 internal constant DEFAULT_LIQUIDATION_PORTION = 40;\\n    // Percentage of local liquidity token cash claim delivered to the liquidator for liquidating liquidity tokens\\n    int256 internal constant TOKEN_REPO_INCENTIVE_PERCENT = 30;\\n\\n    // Pause Router liquidation enabled states\\n    bytes1 internal constant LOCAL_CURRENCY_ENABLED = 0x01;\\n    bytes1 internal constant COLLATERAL_CURRENCY_ENABLED = 0x02;\\n    bytes1 internal constant LOCAL_FCASH_ENABLED = 0x04;\\n    bytes1 internal constant CROSS_CURRENCY_FCASH_ENABLED = 0x08;\\n}\\n\"\r\n    },\r\n    \"contracts/internal/nTokenHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../global/LibStorage.sol\\\";\\nimport \\\"./markets/CashGroup.sol\\\";\\nimport \\\"./markets/AssetRate.sol\\\";\\nimport \\\"./valuation/AssetHandler.sol\\\";\\nimport \\\"./portfolio/BitmapAssetsHandler.sol\\\";\\nimport \\\"./portfolio/PortfolioHandler.sol\\\";\\nimport \\\"./balances/BalanceHandler.sol\\\";\\nimport \\\"../math/SafeInt256.sol\\\";\\n\\nlibrary nTokenHandler {\\n    using AssetRate for AssetRateParameters;\\n    using SafeInt256 for int256;\\n\\n    /// @dev Mirror of the value in LibStorage\\n    uint256 private constant NUM_NTOKEN_MARKET_FACTORS = 14;\\n\\n    /// @notice Returns an account context object that is specific to nTokens.\\n    function getNTokenContext(address tokenAddress)\\n        internal\\n        view\\n        returns (\\n            uint16 currencyId,\\n            uint256 incentiveAnnualEmissionRate,\\n            uint256 lastInitializedTime,\\n            uint8 assetArrayLength,\\n            bytes5 parameters\\n        )\\n    {\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n\\n        // TODO: how many storage reads is this?\\n        currencyId = context.currencyId;\\n        incentiveAnnualEmissionRate = context.incentiveAnnualEmissionRate;\\n        lastInitializedTime = context.lastInitializedTime;\\n        assetArrayLength = context.assetArrayLength;\\n        parameters = context.nTokenParameters;\\n    }\\n\\n    /// @notice Returns the nToken token address for a given currency\\n    function nTokenAddress(uint256 currencyId) internal view returns (address tokenAddress) {\\n        mapping(uint256 => address) storage store = LibStorage.getNTokenAddressStorage();\\n        return store[currencyId];\\n    }\\n\\n    /// @notice Called by governance to set the nToken token address and its reverse lookup. Cannot be\\n    /// reset once this is set.\\n    function setNTokenAddress(uint16 currencyId, address tokenAddress) internal {\\n        mapping(uint256 => address) storage addressStore = LibStorage.getNTokenAddressStorage();\\n        require(addressStore[currencyId] == address(0), \\\"PT: token address exists\\\");\\n\\n        mapping(address => nTokenContext) storage contextStore = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = contextStore[tokenAddress];\\n        require(context.currencyId == 0, \\\"PT: currency exists\\\");\\n\\n        // This will initialize all other context slots to zero\\n        context.currencyId = currencyId;\\n        addressStore[currencyId] = tokenAddress;\\n    }\\n\\n    /// @notice Set nToken token collateral parameters\\n    function setNTokenCollateralParameters(\\n        address tokenAddress,\\n        uint8 residualPurchaseIncentive10BPS,\\n        uint8 pvHaircutPercentage,\\n        uint8 residualPurchaseTimeBufferHours,\\n        uint8 cashWithholdingBuffer10BPS,\\n        uint8 liquidationHaircutPercentage\\n    ) internal {\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n\\n        require(liquidationHaircutPercentage <= Constants.PERCENTAGE_DECIMALS, \\\"Invalid haircut\\\");\\n        // The pv haircut percentage must be less than the liquidation percentage or else liquidators will not\\n        // get profit for liquidating nToken.\\n        require(pvHaircutPercentage < liquidationHaircutPercentage, \\\"Invalid pv haircut\\\");\\n        // Ensure that the cash withholding buffer is greater than the residual purchase incentive or\\n        // the nToken may not have enough cash to pay accounts to buy its negative ifCash\\n        require(residualPurchaseIncentive10BPS <= cashWithholdingBuffer10BPS, \\\"Invalid discounts\\\");\\n\\n        bytes5 parameters =\\n            (bytes5(uint40(residualPurchaseIncentive10BPS)) |\\n            (bytes5(uint40(pvHaircutPercentage)) << 8) |\\n            (bytes5(uint40(residualPurchaseTimeBufferHours)) << 16) |\\n            (bytes5(uint40(cashWithholdingBuffer10BPS)) << 24) |\\n            (bytes5(uint40(liquidationHaircutPercentage)) << 32));\\n\\n        // Set the parameters\\n        context.nTokenParameters = parameters;\\n    }\\n\\n    /// @notice Retrieves the nToken supply factors without any updates or calculations\\n    function getStoredNTokenSupplyFactors(address tokenAddress)\\n        internal\\n        view\\n        returns (\\n            uint256 totalSupply,\\n            uint256 integralTotalSupply,\\n            uint256 lastSupplyChangeTime\\n        )\\n    {\\n        mapping(address => nTokenTotalSupplyStorage) storage store = LibStorage.getNTokenTotalSupplyStorage();\\n        nTokenTotalSupplyStorage storage nTokenStorage = store[tokenAddress];\\n        totalSupply = nTokenStorage.totalSupply;\\n        // NOTE: DO NOT USE THIS RETURNED VALUE FOR CALCULATING INCENTIVES. The integral total supply\\n        // must be updated given the block time. Use `calculateIntegralTotalSupply` instead\\n        integralTotalSupply = nTokenStorage.integralTotalSupply;\\n        lastSupplyChangeTime = nTokenStorage.lastSupplyChangeTime;\\n    }\\n\\n    /// @notice Retrieves stored total supply factors and \\n    function calculateIntegralTotalSupply(address tokenAddress, uint256 blockTime) \\n        internal\\n        view \\n        returns (\\n            uint256 totalSupply,\\n            uint256 integralTotalSupply,\\n            uint256 lastSupplyChangeTime\\n        )\\n    {\\n        (\\n            totalSupply,\\n            integralTotalSupply,\\n            lastSupplyChangeTime\\n        ) = getStoredNTokenSupplyFactors(tokenAddress);\\n\\n        // Initialize last supply change time if it has not been set.\\n        if (lastSupplyChangeTime == 0) lastSupplyChangeTime = blockTime;\\n\\n        require(blockTime >= lastSupplyChangeTime); // dev: invalid block time\\n\\n        // Add to the integral total supply the total supply of tokens multiplied by the time that the total supply\\n        // has been the value. This will part of the numerator for the average total supply calculation during\\n        // minting incentives.\\n        integralTotalSupply = uint256(int256(integralTotalSupply).add(\\n            int256(totalSupply).mul(int256(blockTime - lastSupplyChangeTime))\\n        ));\\n\\n        require(integralTotalSupply >= 0 && integralTotalSupply < type(uint128).max); // dev: integral total supply overflow\\n        require(blockTime < type(uint32).max); // dev: last supply change supply overflow\\n    }\\n\\n\\n    /// @notice Updates the nToken token supply amount when minting or redeeming.\\n    function changeNTokenSupply(\\n        address tokenAddress,\\n        int256 netChange,\\n        uint256 blockTime\\n    ) internal returns (uint256) {\\n        (\\n            uint256 totalSupply,\\n            uint256 integralTotalSupply,\\n            /* uint256 lastSupplyChangeTime */\\n        ) = calculateIntegralTotalSupply(tokenAddress, blockTime);\\n\\n        if (netChange != 0) {\\n            // If the totalSupply will change then we store the new total supply, the integral total supply and the\\n            // current block time. We know that this int256 conversion will not overflow because totalSupply is stored\\n            // as a uint96 and checked in the next line.\\n            int256 newTotalSupply = int256(totalSupply).add(netChange);\\n            require(newTotalSupply >= 0 && uint256(newTotalSupply) < type(uint96).max); // dev: nToken supply overflow\\n\\n            mapping(address => nTokenTotalSupplyStorage) storage store = LibStorage.getNTokenTotalSupplyStorage();\\n            nTokenTotalSupplyStorage storage nTokenStorage = store[tokenAddress];\\n\\n            nTokenStorage.totalSupply = uint96(newTotalSupply);\\n            // NOTE: overflows checked in calculateIntegralTotalSupply\\n            nTokenStorage.integralTotalSupply = uint128(integralTotalSupply);\\n            nTokenStorage.lastSupplyChangeTime = uint32(blockTime);\\n        }\\n\\n        return integralTotalSupply;\\n    }\\n\\n    function setIncentiveEmissionRate(address tokenAddress, uint32 newEmissionsRate) internal {\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n        context.incentiveAnnualEmissionRate = newEmissionsRate;\\n    }\\n\\n    function setArrayLengthAndInitializedTime(\\n        address tokenAddress,\\n        uint8 arrayLength,\\n        uint256 lastInitializedTime\\n    ) internal {\\n        require(lastInitializedTime >= 0 && uint256(lastInitializedTime) < type(uint32).max); // dev: next settle time overflow\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n        context.lastInitializedTime = uint32(lastInitializedTime);\\n        context.assetArrayLength = arrayLength;\\n    }\\n\\n    /// @notice Returns the array of deposit shares and leverage thresholds for nTokens\\n    function getDepositParameters(uint256 currencyId, uint256 maxMarketIndex)\\n        internal\\n        view\\n        returns (int256[] memory depositShares, int256[] memory leverageThresholds)\\n    {\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenDepositStorage();\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage depositParameters = store[currencyId];\\n        (depositShares, leverageThresholds) = _getParameters(depositParameters, maxMarketIndex, false);\\n    }\\n\\n    /// @notice Sets the deposit parameters\\n    /// @dev We pack the values in alternating between the two parameters into either one or two\\n    // storage slots depending on the number of markets. This is to save storage reads when we use the parameters.\\n    function setDepositParameters(\\n        uint256 currencyId,\\n        uint32[] calldata depositShares,\\n        uint32[] calldata leverageThresholds\\n    ) internal {\\n        require(\\n            depositShares.length <= Constants.MAX_TRADED_MARKET_INDEX,\\n            \\\"PT: deposit share length\\\"\\n        );\\n        require(depositShares.length == leverageThresholds.length, \\\"PT: leverage share length\\\");\\n\\n        uint256 shareSum;\\n        for (uint256 i; i < depositShares.length; i++) {\\n            // This cannot overflow in uint 256 with 9 max slots\\n            shareSum = shareSum + depositShares[i];\\n            require(\\n                leverageThresholds[i] > 0 && leverageThresholds[i] < Constants.RATE_PRECISION,\\n                \\\"PT: leverage threshold\\\"\\n            );\\n        }\\n\\n        // Total deposit share must add up to 100%\\n        require(shareSum == uint256(Constants.DEPOSIT_PERCENT_BASIS), \\\"PT: deposit shares sum\\\");\\n\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenDepositStorage();\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage depositParameters = store[currencyId];\\n        _setParameters(depositParameters, depositShares, leverageThresholds);\\n    }\\n\\n    /// @notice Sets the initialization parameters for the markets, these are read only when markets\\n    /// are initialized\\n    function setInitializationParameters(\\n        uint256 currencyId,\\n        uint32[] calldata annualizedAnchorRates,\\n        uint32[] calldata proportions\\n    ) internal {\\n        require(annualizedAnchorRates.length <= Constants.MAX_TRADED_MARKET_INDEX, \\\"PT: annualized anchor rates length\\\");\\n        require(proportions.length == annualizedAnchorRates.length, \\\"PT: proportions length\\\");\\n\\n        for (uint256 i; i < proportions.length; i++) {\\n            // Proportions must be between zero and the rate precision\\n            require(annualizedAnchorRates[i] > 0, \\\"NT: anchor rate zero\\\");\\n            require(\\n                proportions[i] > 0 && proportions[i] < Constants.RATE_PRECISION,\\n                \\\"PT: invalid proportion\\\"\\n            );\\n        }\\n\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenInitStorage();\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage initParameters = store[currencyId];\\n        _setParameters(initParameters, annualizedAnchorRates, proportions);\\n    }\\n\\n    /// @notice Returns the array of initialization parameters for a given currency.\\n    function getInitializationParameters(uint256 currencyId, uint256 maxMarketIndex)\\n        internal\\n        view\\n        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions)\\n    {\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenInitStorage();\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage initParameters = store[currencyId];\\n        (annualizedAnchorRates, proportions) = _getParameters(initParameters, maxMarketIndex, true);\\n    }\\n\\n    function _getParameters(\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage slot,\\n        uint256 maxMarketIndex,\\n        bool noUnset\\n    ) private view returns (int256[] memory, int256[] memory) {\\n        uint256 index = 0;\\n        int256[] memory array1 = new int256[](maxMarketIndex);\\n        int256[] memory array2 = new int256[](maxMarketIndex);\\n        for (uint256 i; i < maxMarketIndex; i++) {\\n            array1[i] = slot[index];\\n            index++;\\n            array2[i] = slot[index];\\n            index++;\\n\\n            if (noUnset) {\\n                require(array1[i] > 0 && array2[i] > 0, \\\"PT: init value zero\\\");\\n            }\\n        }\\n\\n        return (array1, array2);\\n    }\\n\\n    function _setParameters(\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage slot,\\n        uint32[] calldata array1,\\n        uint32[] calldata array2\\n    ) private {\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < array1.length; i++) {\\n            slot[index] = array1[i];\\n            index++;\\n\\n            slot[index] = array2[i];\\n            index++;\\n        }\\n    }\\n\\n    function loadNTokenPortfolioNoCashGroup(nTokenPortfolio memory nToken, uint16 currencyId)\\n        internal\\n        view\\n    {\\n        nToken.tokenAddress = nTokenAddress(currencyId);\\n        // prettier-ignore\\n        (\\n            /* currencyId */,\\n            /* incentiveRate */,\\n            uint256 lastInitializedTime,\\n            uint8 assetArrayLength,\\n            bytes5 parameters\\n        ) = getNTokenContext(nToken.tokenAddress);\\n\\n        // prettier-ignore\\n        (\\n            uint256 totalSupply,\\n            /* integralTotalSupply */,\\n            /* lastSupplyChangeTime */\\n        ) = getStoredNTokenSupplyFactors(nToken.tokenAddress);\\n\\n        nToken.lastInitializedTime = lastInitializedTime;\\n        nToken.totalSupply = int256(totalSupply);\\n        nToken.parameters = parameters;\\n\\n        nToken.portfolioState = PortfolioHandler.buildPortfolioState(\\n            nToken.tokenAddress,\\n            assetArrayLength,\\n            0\\n        );\\n\\n        // prettier-ignore\\n        (\\n            nToken.cashBalance,\\n            /* nTokenBalance */,\\n            /* lastClaimTime */,\\n            /* lastClaimIntegralSupply */\\n        ) = BalanceHandler.getBalanceStorage(nToken.tokenAddress, currencyId);\\n    }\\n\\n    /// @notice Uses buildCashGroupStateful\\n    function loadNTokenPortfolioStateful(nTokenPortfolio memory nToken, uint16 currencyId)\\n        internal\\n    {\\n        loadNTokenPortfolioNoCashGroup(nToken, currencyId);\\n        nToken.cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\n    }\\n\\n    /// @notice Uses buildCashGroupView\\n    function loadNTokenPortfolioView(nTokenPortfolio memory nToken, uint16 currencyId)\\n        internal\\n        view\\n    {\\n        loadNTokenPortfolioNoCashGroup(nToken, currencyId);\\n        nToken.cashGroup = CashGroup.buildCashGroupView(currencyId);\\n    }\\n\\n    /// @notice Returns the next settle time for the nToken which is 1 quarter away\\n    function getNextSettleTime(nTokenPortfolio memory nToken) internal pure returns (uint256) {\\n        if (nToken.lastInitializedTime == 0) return 0;\\n        return DateTime.getReferenceTime(nToken.lastInitializedTime) + Constants.QUARTER;\\n    }\\n\\n    /// @notice Returns the nToken present value denominated in asset terms.\\n    function getNTokenAssetPV(nTokenPortfolio memory nToken, uint256 blockTime)\\n        internal\\n        view\\n        returns (int256)\\n    {\\n        int256 totalAssetPV;\\n        int256 totalUnderlyingPV;\\n\\n        {\\n            uint256 nextSettleTime = getNextSettleTime(nToken);\\n            // If the first asset maturity has passed (the 3 month), this means that all the LTs must\\n            // be settled except the 6 month (which is now the 3 month). We don't settle LTs except in\\n            // initialize markets so we calculate the cash value of the portfolio here.\\n            if (nextSettleTime <= blockTime) {\\n                // NOTE: this condition should only be present for a very short amount of time, which is the window between\\n                // when the markets are no longer tradable at quarter end and when the new markets have been initialized.\\n                // We time travel back to one second before maturity to value the liquidity tokens. Although this value is\\n                // not strictly correct the different should be quite slight. We do this to ensure that free collateral checks\\n                // for withdraws and liquidations can still be processed. If this condition persists for a long period of time then\\n                // the entire protocol will have serious problems as markets will not be tradable.\\n                blockTime = nextSettleTime - 1;\\n            }\\n        }\\n\\n        // Since we are not doing a risk adjusted valuation here we do not need to net off residual fCash\\n        // balances in the future before discounting to present. If we did, then the ifCash assets would\\n        // have to be in the portfolio array first. PV here is denominated in asset cash terms, not in\\n        // underlying terms.\\n        {\\n            MarketParameters memory market;\\n            for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) {\\n                // NOTE: getLiquidityTokenValue can rewrite fCash values in memory, however, that does not\\n                // happen in this call because there are no fCash values in the nToken portfolio.\\n                (int256 assetCashClaim, int256 pv) =\\n                    AssetHandler.getLiquidityTokenValue(\\n                        i,\\n                        nToken.cashGroup,\\n                        market,\\n                        nToken.portfolioState.storedAssets,\\n                        blockTime,\\n                        false\\n                    );\\n\\n                totalAssetPV = totalAssetPV.add(assetCashClaim);\\n                totalUnderlyingPV = totalUnderlyingPV.add(pv);\\n            }\\n        }\\n\\n        // Then iterate over bitmapped assets and get present value\\n        // prettier-ignore\\n        (\\n            int256 bitmapPv, \\n            /* hasDebt */\\n        ) = BitmapAssetsHandler.getifCashNetPresentValue(\\n            nToken.tokenAddress,\\n            nToken.cashGroup.currencyId,\\n            nToken.lastInitializedTime,\\n            blockTime,\\n            nToken.cashGroup,\\n            false\\n        );\\n        totalUnderlyingPV = totalUnderlyingPV.add(bitmapPv);\\n\\n        // Return the total present value denominated in asset terms\\n        totalAssetPV = totalAssetPV\\n            .add(nToken.cashGroup.assetRate.convertFromUnderlying(totalUnderlyingPV))\\n            .add(nToken.cashBalance);\\n\\n        return totalAssetPV;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/markets/Market.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./AssetRate.sol\\\";\\nimport \\\"./CashGroup.sol\\\";\\nimport \\\"./DateTime.sol\\\";\\nimport \\\"../balances/BalanceHandler.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../math/ABDKMath64x64.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary Market {\\n    using SafeMath for uint256;\\n    using SafeInt256 for int256;\\n    using CashGroup for CashGroupParameters;\\n    using AssetRate for AssetRateParameters;\\n\\n    // Max positive value for a ABDK64x64 integer\\n    int256 private constant MAX64 = 0x7FFFFFFFFFFFFFFF;\\n\\n    /// @notice Add liquidity to a market, assuming that it is initialized. If not then\\n    /// this method will revert and the market must be initialized first.\\n    /// Return liquidityTokens and negative fCash to the portfolio\\n    function addLiquidity(MarketParameters memory market, int256 assetCash)\\n        internal\\n        returns (int256 liquidityTokens, int256 fCash)\\n    {\\n        require(market.totalLiquidity > 0, \\\"M: zero liquidity\\\");\\n        if (assetCash == 0) return (0, 0);\\n        require(assetCash > 0); // dev: negative asset cash\\n\\n        liquidityTokens = market.totalLiquidity.mul(assetCash).div(market.totalAssetCash);\\n        // No need to convert this to underlying, assetCash / totalAssetCash is a unitless proportion.\\n        fCash = market.totalfCash.mul(assetCash).div(market.totalAssetCash);\\n\\n        market.totalLiquidity = market.totalLiquidity.add(liquidityTokens);\\n        market.totalfCash = market.totalfCash.add(fCash);\\n        market.totalAssetCash = market.totalAssetCash.add(assetCash);\\n        _setMarketStorageForLiquidity(market);\\n        // Flip the sign to represent the LP's net position\\n        fCash = fCash.neg();\\n    }\\n\\n    /// @notice Remove liquidity from a market, assuming that it is initialized.\\n    /// Return assetCash and positive fCash to the portfolio\\n    function removeLiquidity(MarketParameters memory market, int256 tokensToRemove)\\n        internal\\n        returns (int256 assetCash, int256 fCash)\\n    {\\n        if (tokensToRemove == 0) return (0, 0);\\n        require(tokensToRemove > 0); // dev: negative tokens to remove\\n\\n        assetCash = market.totalAssetCash.mul(tokensToRemove).div(market.totalLiquidity);\\n        fCash = market.totalfCash.mul(tokensToRemove).div(market.totalLiquidity);\\n\\n        market.totalLiquidity = market.totalLiquidity.subNoNeg(tokensToRemove);\\n        market.totalfCash = market.totalfCash.subNoNeg(fCash);\\n        market.totalAssetCash = market.totalAssetCash.subNoNeg(assetCash);\\n\\n        _setMarketStorageForLiquidity(market);\\n    }\\n\\n    function executeTrade(\\n        MarketParameters memory market,\\n        CashGroupParameters memory cashGroup,\\n        int256 fCashToAccount,\\n        uint256 timeToMaturity,\\n        uint256 marketIndex\\n    ) internal returns (int256 netAssetCash) {\\n        int256 netAssetCashToReserve;\\n        (netAssetCash, netAssetCashToReserve) = calculateTrade(\\n            market,\\n            cashGroup,\\n            fCashToAccount,\\n            timeToMaturity,\\n            marketIndex\\n        );\\n\\n        MarketStorage storage marketStorage = _getMarketStoragePointer(market);\\n        _setMarketStorage(\\n            marketStorage,\\n            market.totalfCash,\\n            market.totalAssetCash,\\n            market.lastImpliedRate,\\n            market.oracleRate,\\n            market.previousTradeTime\\n        );\\n        BalanceHandler.incrementFeeToReserve(cashGroup.currencyId, netAssetCashToReserve);\\n    }\\n\\n    /// @notice Calculates the asset cash amount the results from trading fCashToAccount with the market. A positive\\n    /// fCashToAccount is equivalent of lending, a negative is borrowing. Updates the market state in memory.\\n    /// @param market the current market state\\n    /// @param cashGroup cash group configuration parameters\\n    /// @param fCashToAccount the fCash amount that will be deposited into the user's portfolio. The net change\\n    /// to the market is in the opposite direction.\\n    /// @param timeToMaturity number of seconds until maturity\\n    /// @return netAssetCash, netAssetCashToReserve\\n    function calculateTrade(\\n        MarketParameters memory market,\\n        CashGroupParameters memory cashGroup,\\n        int256 fCashToAccount,\\n        uint256 timeToMaturity,\\n        uint256 marketIndex\\n    ) internal view returns (int256, int256) {\\n        // We return false if there is not enough fCash to support this trade.\\n        // if fCashToAccount > 0 and totalfCash - fCashToAccount <= 0 then the trade will fail\\n        // if fCashToAccount < 0 and totalfCash > 0 then this will always pass\\n        if (market.totalfCash <= fCashToAccount) return (0, 0);\\n\\n        // Calculates initial rate factors for the trade\\n        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =\\n            getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);\\n\\n        // Calculates the exchange rate from cash to fCash before any liquidity fees\\n        // are applied\\n        int256 preFeeExchangeRate;\\n        {\\n            bool success;\\n            (preFeeExchangeRate, success) = _getExchangeRate(\\n                market.totalfCash,\\n                totalCashUnderlying,\\n                rateScalar,\\n                rateAnchor,\\n                fCashToAccount\\n            );\\n            if (!success) return (0, 0);\\n        }\\n\\n        // Given the exchange rate, returns the net cash amounts to apply to each of the\\n        // three relevant balances.\\n        (int256 netCashToAccount, int256 netCashToMarket, int256 netCashToReserve) =\\n            _getNetCashAmountsUnderlying(\\n                cashGroup,\\n                preFeeExchangeRate,\\n                fCashToAccount,\\n                timeToMaturity\\n            );\\n        // Signifies a failed net cash amount calculation\\n        if (netCashToAccount == 0) return (0, 0);\\n\\n        {\\n            // Set the new implied interest rate after the trade has taken effect, this\\n            // will be used to calculate the next trader's interest rate.\\n            market.totalfCash = market.totalfCash.subNoNeg(fCashToAccount);\\n            market.lastImpliedRate = getImpliedRate(\\n                market.totalfCash,\\n                totalCashUnderlying.add(netCashToMarket),\\n                rateScalar,\\n                rateAnchor,\\n                timeToMaturity\\n            );\\n\\n            // It's technically possible that the implied rate is actually exactly zero (or\\n            // more accurately the natural log rounds down to zero) but we will still fail\\n            // in this case. If this does happen we may assume that markets are not initialized.\\n            if (market.lastImpliedRate == 0) return (0, 0);\\n        }\\n\\n        return\\n            _setNewMarketState(\\n                market,\\n                cashGroup.assetRate,\\n                netCashToAccount,\\n                netCashToMarket,\\n                netCashToReserve\\n            );\\n    }\\n\\n    /// @notice Returns factors for calculating exchange rates\\n    /// @return\\n    ///    rateScalar: a scalar value in rate precision that defines the slope of the line\\n    ///    totalCashUnderlying: the converted asset cash to underlying cash for calculating\\n    ///    the exchange rates for the trade\\n    ///    rateAnchor: an offset from the x axis to maintain interest rate continuity over time\\n    function getExchangeRateFactors(\\n        MarketParameters memory market,\\n        CashGroupParameters memory cashGroup,\\n        uint256 timeToMaturity,\\n        uint256 marketIndex\\n    )\\n        internal\\n        pure\\n        returns (\\n            int256,\\n            int256,\\n            int256\\n        )\\n    {\\n        int256 rateScalar = cashGroup.getRateScalar(marketIndex, timeToMaturity);\\n        int256 totalCashUnderlying = cashGroup.assetRate.convertToUnderlying(market.totalAssetCash);\\n\\n        // This would result in a divide by zero\\n        if (market.totalfCash == 0 || totalCashUnderlying == 0) return (0, 0, 0);\\n\\n        // Get the rate anchor given the market state, this will establish the baseline for where\\n        // the exchange rate is set.\\n        int256 rateAnchor;\\n        {\\n            bool success;\\n            (rateAnchor, success) = _getRateAnchor(\\n                market.totalfCash,\\n                market.lastImpliedRate,\\n                totalCashUnderlying,\\n                rateScalar,\\n                timeToMaturity\\n            );\\n            if (!success) return (0, 0, 0);\\n        }\\n\\n        return (rateScalar, totalCashUnderlying, rateAnchor);\\n    }\\n\\n    /// @dev Returns net asset cash amounts to the account, the market and the reserve\\n    /// @return\\n    ///     netCashToAccount: this is a positive or negative amount of cash change to the account\\n    ///     netCashToMarket: this is a positive or negative amount of cash change in the market\\n    //      netCashToReserve: this is always a positive amount of cash accrued to the reserve\\n    function _getNetCashAmountsUnderlying(\\n        CashGroupParameters memory cashGroup,\\n        int256 preFeeExchangeRate,\\n        int256 fCashToAccount,\\n        uint256 timeToMaturity\\n    )\\n        private\\n        pure\\n        returns (\\n            int256,\\n            int256,\\n            int256\\n        )\\n    {\\n        // Fees are specified in basis points which is an rate precision denomination. We convert this to\\n        // an exchange rate denomination for the given time to maturity. (i.e. get e^(fee * t) and multiply\\n        // or divide depending on the side of the trade).\\n        // tradeExchangeRate = exp((tradeInterestRateNoFee +/- fee) * timeToMaturity)\\n        // tradeExchangeRate = tradeExchangeRateNoFee (* or /) exp(fee * timeToMaturity)\\n        // cash = fCash / exchangeRate, exchangeRate > 1\\n        int256 preFeeCashToAccount =\\n            fCashToAccount.divInRatePrecision(preFeeExchangeRate).neg();\\n        int256 fee = getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);\\n\\n        if (fCashToAccount > 0) {\\n            // Lending\\n            // Dividing reduces exchange rate, lending should receive less fCash for cash\\n            int256 postFeeExchangeRate = preFeeExchangeRate.divInRatePrecision(fee);\\n            // It's possible that the fee pushes exchange rates into negative territory. This is not possible\\n            // when borrowing. If this happens then the trade has failed.\\n            if (postFeeExchangeRate < Constants.RATE_PRECISION) return (0, 0, 0);\\n\\n            // cashToAccount = -(fCashToAccount / exchangeRate)\\n            // postFeeExchangeRate = preFeeExchangeRate / feeExchangeRate\\n            // preFeeCashToAccount = -(fCashToAccount / preFeeExchangeRate)\\n            // postFeeCashToAccount = -(fCashToAccount / postFeeExchangeRate)\\n            // netFee = preFeeCashToAccount - postFeeCashToAccount\\n            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\\n            // netFee = ((fCashToAccount * feeExchangeRate) / preFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\\n            // netFee = (fCashToAccount / preFeeExchangeRate) * (feeExchangeRate - 1)\\n            // netFee = -(preFeeCashToAccount) * (feeExchangeRate - 1)\\n            // netFee = preFeeCashToAccount * (1 - feeExchangeRate)\\n            // RATE_PRECISION - fee will be negative here, preFeeCashToAccount < 0, fee > 0\\n            fee = preFeeCashToAccount.mulInRatePrecision(Constants.RATE_PRECISION.sub(fee));\\n        } else {\\n            // Borrowing\\n            // cashToAccount = -(fCashToAccount / exchangeRate)\\n            // postFeeExchangeRate = preFeeExchangeRate * feeExchangeRate\\n\\n            // netFee = preFeeCashToAccount - postFeeCashToAccount\\n            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\\n            // netFee = ((fCashToAccount / (feeExchangeRate * preFeeExchangeRate)) - (fCashToAccount / preFeeExchangeRate)\\n            // netFee = (fCashToAccount / preFeeExchangeRate) * (1 / feeExchangeRate - 1)\\n            // netFee = preFeeCashToAccount * ((1 - feeExchangeRate) / feeExchangeRate)\\n            // NOTE: preFeeCashToAccount is negative in this branch so we negate it to ensure that fee is a positive number\\n            // preFee * (1 - fee) / fee will be negative, use neg() to flip to positive\\n            // RATE_PRECISION - fee will be negative\\n            fee = preFeeCashToAccount.mul(Constants.RATE_PRECISION.sub(fee)).div(fee).neg();\\n        }\\n\\n        int256 cashToReserve =\\n            fee.mul(cashGroup.getReserveFeeShare()).div(Constants.PERCENTAGE_DECIMALS);\\n\\n        return (\\n            // postFeeCashToAccount = preFeeCashToAccount - fee\\n            preFeeCashToAccount.sub(fee),\\n            // netCashToMarket = -(preFeeCashToAccount - fee + cashToReserve)\\n            (preFeeCashToAccount.sub(fee).add(cashToReserve)).neg(),\\n            cashToReserve\\n        );\\n    }\\n\\n    /// @notice Sets the new market state\\n    /// @return\\n    ///     netAssetCashToAccount: the positive or negative change in asset cash to the account\\n    ///     assetCashToReserve: the positive amount of cash that accrues to the reserve\\n    function _setNewMarketState(\\n        MarketParameters memory market,\\n        AssetRateParameters memory assetRate,\\n        int256 netCashToAccount,\\n        int256 netCashToMarket,\\n        int256 netCashToReserve\\n    ) private view returns (int256, int256) {\\n        int256 netAssetCashToMarket = assetRate.convertFromUnderlying(netCashToMarket);\\n        // Set storage checks that total asset cash is above zero\\n        market.totalAssetCash = market.totalAssetCash.add(netAssetCashToMarket);\\n\\n        // Sets the trade time for the next oracle update\\n        market.previousTradeTime = block.timestamp;\\n        int256 assetCashToReserve = assetRate.convertFromUnderlying(netCashToReserve);\\n        int256 netAssetCashToAccount = assetRate.convertFromUnderlying(netCashToAccount);\\n        return (netAssetCashToAccount, assetCashToReserve);\\n    }\\n\\n    /// @notice Rate anchors update as the market gets closer to maturity. Rate anchors are not comparable\\n    /// across time or markets but implied rates are. The goal here is to ensure that the implied rate\\n    /// before and after the rate anchor update is the same. Therefore, the market will trade at the same implied\\n    /// rate that it last traded at. If these anchors do not update then it opens up the opportunity for arbitrage\\n    /// which will hurt the liquidity providers.\\n    ///\\n    /// The rate anchor will update as the market rolls down to maturity. The calculation is:\\n    /// newExchangeRate = e^(lastImpliedRate * timeToMaturity / Constants.IMPLIED_RATE_TIME)\\n    /// newAnchor = newExchangeRate - ln((proportion / (1 - proportion)) / rateScalar\\n    ///\\n    /// where:\\n    /// lastImpliedRate = ln(exchangeRate') * (Constants.IMPLIED_RATE_TIME / timeToMaturity')\\n    ///      (calculated when the last trade in the market was made)\\n    /// @return the new rate anchor and a boolean that signifies success\\n    function _getRateAnchor(\\n        int256 totalfCash,\\n        uint256 lastImpliedRate,\\n        int256 totalCashUnderlying,\\n        int256 rateScalar,\\n        uint256 timeToMaturity\\n    ) internal pure returns (int256, bool) {\\n        // This is the exchange rate at the new time to maturity\\n        int256 newExchangeRate = getExchangeRateFromImpliedRate(lastImpliedRate, timeToMaturity);\\n        if (newExchangeRate < Constants.RATE_PRECISION) return (0, false);\\n\\n        int256 rateAnchor;\\n        {\\n            // totalfCash / (totalfCash + totalCashUnderlying)\\n            int256 proportion =\\n                totalfCash.divInRatePrecision(totalfCash.add(totalCashUnderlying));\\n\\n            (int256 lnProportion, bool success) = _logProportion(proportion);\\n            if (!success) return (0, false);\\n\\n            // newExchangeRate - ln(proportion / (1 - proportion)) / rateScalar\\n            rateAnchor = newExchangeRate.sub(lnProportion.divInRatePrecision(rateScalar));\\n        }\\n\\n        return (rateAnchor, true);\\n    }\\n\\n    /// @notice Calculates the current market implied rate.\\n    /// @return the implied rate and a bool that is true on success\\n    function getImpliedRate(\\n        int256 totalfCash,\\n        int256 totalCashUnderlying,\\n        int256 rateScalar,\\n        int256 rateAnchor,\\n        uint256 timeToMaturity\\n    ) internal pure returns (uint256) {\\n        // This will check for exchange rates < Constants.RATE_PRECISION\\n        (int256 exchangeRate, bool success) =\\n            _getExchangeRate(totalfCash, totalCashUnderlying, rateScalar, rateAnchor, 0);\\n        if (!success) return 0;\\n\\n        // Uses continuous compounding to calculate the implied rate:\\n        // ln(exchangeRate) * Constants.IMPLIED_RATE_TIME / timeToMaturity\\n        int128 rate = ABDKMath64x64.fromInt(exchangeRate);\\n        // Scales down to a floating point for LN\\n        int128 rateScaled = ABDKMath64x64.div(rate, Constants.RATE_PRECISION_64x64);\\n        // We will not have a negative log here because we check that exchangeRate > Constants.RATE_PRECISION\\n        // inside getExchangeRate\\n        int128 lnRateScaled = ABDKMath64x64.ln(rateScaled);\\n        // Scales up to a fixed point\\n        uint256 lnRate =\\n            ABDKMath64x64.toUInt(ABDKMath64x64.mul(lnRateScaled, Constants.RATE_PRECISION_64x64));\\n\\n        // lnRate * IMPLIED_RATE_TIME / ttm\\n        uint256 impliedRate = lnRate.mul(Constants.IMPLIED_RATE_TIME).div(timeToMaturity);\\n\\n        // Implied rates over 429% will overflow, this seems like a safe assumption\\n        if (impliedRate > type(uint32).max) return 0;\\n\\n        return impliedRate;\\n    }\\n\\n    /// @notice Converts an implied rate to an exchange rate given a time to maturity. The\\n    /// formula is E = e^rt\\n    function getExchangeRateFromImpliedRate(uint256 impliedRate, uint256 timeToMaturity)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        int128 expValue =\\n            ABDKMath64x64.fromUInt(\\n                impliedRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME)\\n            );\\n        int128 expValueScaled = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\\n        int128 expResult = ABDKMath64x64.exp(expValueScaled);\\n        int128 expResultScaled = ABDKMath64x64.mul(expResult, Constants.RATE_PRECISION_64x64);\\n\\n        return ABDKMath64x64.toInt(expResultScaled);\\n    }\\n\\n    /// @notice Returns the exchange rate between fCash and cash for the given market\\n    /// Calculates the following exchange rate:\\n    ///     (1 / rateScalar) * ln(proportion / (1 - proportion)) + rateAnchor\\n    /// where:\\n    ///     proportion = totalfCash / (totalfCash + totalUnderlyingCash)\\n    /// @dev has an underscore to denote as private but is marked internal for the mock\\n    function _getExchangeRate(\\n        int256 totalfCash,\\n        int256 totalCashUnderlying,\\n        int256 rateScalar,\\n        int256 rateAnchor,\\n        int256 fCashToAccount\\n    ) internal pure returns (int256, bool) {\\n        int256 numerator = totalfCash.subNoNeg(fCashToAccount);\\n\\n        // This is the proportion scaled by Constants.RATE_PRECISION\\n        // (totalfCash + fCash) / (totalfCash + totalCashUnderlying)\\n        int256 proportion =\\n            numerator.divInRatePrecision(totalfCash.add(totalCashUnderlying));\\n\\n        // This limit is here to prevent the market from reaching extremely high interest rates via an\\n        // excessively large proportion (high amounts of fCash relative to cash).\\n        // Market proportion can only increase via borrowing (fCash is added to the market and cash is\\n        // removed). Over time, the returns from asset cash will slightly decrease the proportion (the\\n        // value of cash underlying in the market must be monotonically increasing). Therefore it is not\\n        // possible for the proportion to go over max market proportion unless borrowing occurs.\\n        if (proportion > Constants.MAX_MARKET_PROPORTION) return (0, false);\\n\\n        (int256 lnProportion, bool success) = _logProportion(proportion);\\n        if (!success) return (0, false);\\n\\n        // lnProportion / rateScalar + rateAnchor\\n        int256 rate = lnProportion.divInRatePrecision(rateScalar).add(rateAnchor);\\n        // Do not succeed if interest rates fall below 1\\n        if (rate < Constants.RATE_PRECISION) {\\n            return (0, false);\\n        } else {\\n            return (rate, true);\\n        }\\n    }\\n\\n    /// @dev This method calculates the log of the proportion inside the logit function which is\\n    /// defined as ln(proportion / (1 - proportion)). Special handling here is required to deal with\\n    /// fixed point precision and the ABDK library.\\n    function _logProportion(int256 proportion) internal pure returns (int256, bool) {\\n        // This will result in divide by zero, short circuit\\n        if (proportion == Constants.RATE_PRECISION) return (0, false);\\n\\n        // Convert proportion to what is used inside the logit function (p / (1-p))\\n        int256 logitP = proportion.divInRatePrecision(Constants.RATE_PRECISION.sub(proportion));\\n\\n        // ABDK does not handle log of numbers that are less than 1, in order to get the right value\\n        // scaled by RATE_PRECISION we use the log identity:\\n        // (ln(logitP / RATE_PRECISION)) * RATE_PRECISION = (ln(logitP) - ln(RATE_PRECISION)) * RATE_PRECISION\\n        int128 abdkProportion = ABDKMath64x64.fromInt(logitP);\\n        // Here, abdk will revert due to negative log so abort\\n        if (abdkProportion <= 0) return (0, false);\\n        int256 result =\\n            ABDKMath64x64.toInt(\\n                ABDKMath64x64.mul(\\n                    ABDKMath64x64.sub(\\n                        ABDKMath64x64.ln(abdkProportion),\\n                        Constants.LOG_RATE_PRECISION_64x64\\n                    ),\\n                    Constants.RATE_PRECISION_64x64\\n                )\\n            );\\n\\n        return (result, true);\\n    }\\n\\n    /// @notice Oracle rate protects against short term price manipulation. Time window will be set to a value\\n    /// on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example,\\n    /// a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates.\\n    /// Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then\\n    /// be liquidated.\\n    ///\\n    /// Oracle rates are calculated when the market is loaded from storage.\\n    ///\\n    /// The oracle rate is a lagged weighted average over a short term price window. If we are past\\n    /// the short term window then we just set the rate to the lastImpliedRate, otherwise we take the\\n    /// weighted average:\\n    ///     lastImpliedRatePreTrade * (currentTs - previousTs) / timeWindow +\\n    ///         oracleRatePrevious * (1 - (currentTs - previousTs) / timeWindow)\\n    function _updateRateOracle(\\n        uint256 previousTradeTime,\\n        uint256 lastImpliedRate,\\n        uint256 oracleRate,\\n        uint256 rateOracleTimeWindow,\\n        uint256 blockTime\\n    ) private pure returns (uint256) {\\n        require(rateOracleTimeWindow > 0); // dev: update rate oracle, time window zero\\n\\n        // This can occur when using a view function get to a market state in the past\\n        if (previousTradeTime > blockTime) return lastImpliedRate;\\n\\n        uint256 timeDiff = blockTime.sub(previousTradeTime);\\n        if (timeDiff > rateOracleTimeWindow) {\\n            // If past the time window just return the lastImpliedRate\\n            return lastImpliedRate;\\n        }\\n\\n        // (currentTs - previousTs) / timeWindow\\n        uint256 lastTradeWeight =\\n            timeDiff.mul(uint256(Constants.RATE_PRECISION)).div(rateOracleTimeWindow);\\n\\n        // 1 - (currentTs - previousTs) / timeWindow\\n        uint256 oracleWeight = uint256(Constants.RATE_PRECISION).sub(lastTradeWeight);\\n\\n        uint256 newOracleRate =\\n            (lastImpliedRate.mul(lastTradeWeight).add(oracleRate.mul(oracleWeight))).div(\\n                uint256(Constants.RATE_PRECISION)\\n            );\\n\\n        return newOracleRate;\\n    }\\n\\n    function getOracleRate(\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 rateOracleTimeWindow,\\n        uint256 blockTime\\n    ) internal view returns (uint256) {\\n        mapping(uint256 => mapping(uint256 => \\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\\n        MarketStorage storage marketStorage = store[currencyId][maturity][settlementDate];\\n\\n        uint256 lastImpliedRate = marketStorage.lastImpliedRate;\\n        uint256 oracleRate = marketStorage.oracleRate;\\n        uint256 previousTradeTime = marketStorage.previousTradeTime;\\n\\n        // If the oracle rate is set to zero this can only be because the markets have past their settlement\\n        // date but the new set of markets has not yet been initialized. This means that accounts cannot be liquidated\\n        // during this time, but market initialization can be called by anyone so the actual time that this condition\\n        // exists for should be quite short.\\n        require(oracleRate > 0, \\\"Market not initialized\\\");\\n\\n        return\\n            _updateRateOracle(\\n                previousTradeTime,\\n                lastImpliedRate,\\n                oracleRate,\\n                rateOracleTimeWindow,\\n                blockTime\\n            );\\n    }\\n\\n    /// @notice Reads a market object directly from storage. `buildMarket` should be called instead of this method\\n    /// which ensures that the rate oracle is set properly.\\n    function _loadMarketStorage(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        bool needsLiquidity,\\n        uint256 settlementDate\\n    ) private view {\\n        // Market object always uses the most current reference time as the settlement date\\n        mapping(uint256 => mapping(uint256 => \\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\n        MarketStorage storage marketStorage = store[currencyId][maturity][settlementDate];\\n        bytes32 slot;\\n        assembly {\\n            slot := marketStorage.slot\\n        }\\n\\n        market.storageSlot = slot;\\n        market.maturity = maturity;\\n        market.totalfCash = marketStorage.totalfCash;\\n        market.totalAssetCash = marketStorage.totalAssetCash;\\n        market.lastImpliedRate = marketStorage.lastImpliedRate;\\n        market.oracleRate = marketStorage.oracleRate;\\n        market.previousTradeTime = marketStorage.previousTradeTime;\\n\\n        if (needsLiquidity) {\\n            market.totalLiquidity = marketStorage.totalLiquidity;\\n        } else {\\n            market.totalLiquidity = 0;\\n        }\\n    }\\n\\n    function _getMarketStoragePointer(\\n        MarketParameters memory market\\n    ) private pure returns (MarketStorage storage marketStorage) {\\n        bytes32 slot = market.storageSlot;\\n        assembly {\\n            marketStorage.slot := slot\\n        }\\n    }\\n\\n    function _setMarketStorageForLiquidity(MarketParameters memory market) internal {\\n        MarketStorage storage marketStorage = _getMarketStoragePointer(market);\\n        // Oracle rate does not change on liquidity\\n        uint32 storedOracleRate = marketStorage.oracleRate;\\n\\n        _setMarketStorage(\\n            marketStorage,\\n            market.totalfCash,\\n            market.totalAssetCash,\\n            market.lastImpliedRate,\\n            storedOracleRate,\\n            market.previousTradeTime\\n        );\\n\\n        _setTotalLiquidity(marketStorage, market.totalLiquidity);\\n    }\\n\\n    function setMarketStorageForInitialize(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 settlementDate\\n    ) internal {\\n        // On initialization we have not yet calculated the storage slot so we get it here.\\n        mapping(uint256 => mapping(uint256 => \\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\n        MarketStorage storage marketStorage = store[currencyId][market.maturity][settlementDate];\\n\\n        _setMarketStorage(\\n            marketStorage,\\n            market.totalfCash,\\n            market.totalAssetCash,\\n            market.lastImpliedRate,\\n            market.oracleRate,\\n            market.previousTradeTime\\n        );\\n\\n        _setTotalLiquidity(marketStorage, market.totalLiquidity);\\n    }\\n\\n    function _setTotalLiquidity(\\n        MarketStorage storage marketStorage,\\n        int256 totalLiquidity\\n    ) internal {\\n        require(totalLiquidity >= 0 && totalLiquidity <= type(uint80).max); // dev: market storage totalLiquidity overflow\\n        marketStorage.totalLiquidity = uint80(totalLiquidity);\\n    }\\n\\n    function _setMarketStorage(\\n        MarketStorage storage marketStorage,\\n        int256 totalfCash,\\n        int256 totalAssetCash,\\n        uint256 lastImpliedRate,\\n        uint256 oracleRate,\\n        uint256 previousTradeTime\\n    ) private {\\n        require(totalfCash >= 0 && totalfCash <= type(uint80).max); // dev: storage totalfCash overflow\\n        require(totalAssetCash >= 0 && totalAssetCash <= type(uint80).max); // dev: storage totalAssetCash overflow\\n        require(0 < lastImpliedRate && lastImpliedRate <= type(uint32).max); // dev: storage lastImpliedRate overflow\\n        require(0 < oracleRate && oracleRate <= type(uint32).max); // dev: storage oracleRate overflow\\n        require(0 <= previousTradeTime && previousTradeTime <= type(uint32).max); // dev: storage previous trade time overflow\\n\\n        marketStorage.totalfCash = uint80(totalfCash);\\n        marketStorage.totalAssetCash = uint80(totalAssetCash);\\n        marketStorage.lastImpliedRate = uint32(lastImpliedRate);\\n        marketStorage.oracleRate = uint32(oracleRate);\\n        marketStorage.previousTradeTime = uint32(previousTradeTime);\\n    }\\n\\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately.\\n    function loadMarket(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        bool needsLiquidity,\\n        uint256 rateOracleTimeWindow\\n    ) internal view {\\n        // Always reference the current settlement date\\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\\n        loadMarketWithSettlementDate(\\n            market,\\n            currencyId,\\n            maturity,\\n            blockTime,\\n            needsLiquidity,\\n            rateOracleTimeWindow,\\n            settlementDate\\n        );\\n    }\\n\\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately, this\\n    /// is mainly used in the InitializeMarketAction contract.\\n    function loadMarketWithSettlementDate(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        bool needsLiquidity,\\n        uint256 rateOracleTimeWindow,\\n        uint256 settlementDate\\n    ) internal view {\\n        _loadMarketStorage(market, currencyId, maturity, needsLiquidity, settlementDate);\\n\\n        market.oracleRate = _updateRateOracle(\\n            market.previousTradeTime,\\n            market.lastImpliedRate,\\n            market.oracleRate,\\n            rateOracleTimeWindow,\\n            blockTime\\n        );\\n    }\\n\\n    function loadSettlementMarket(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 settlementDate\\n    ) internal view {\\n        _loadMarketStorage(market, currencyId, maturity, true, settlementDate);\\n    }\\n\\n    /// Uses Newton's method to converge on an fCash amount given the amount of\\n    /// cash. The relation between cash and fcash is:\\n    /// cashAmount * exchangeRate * fee + fCash = 0\\n    /// where exchangeRate(fCash) = (rateScalar ^ -1) * ln(p / (1 - p)) + rateAnchor\\n    ///       p = (totalfCash - fCash) / (totalfCash + totalCash)\\n    ///       if cashAmount < 0: fee = feeRate ^ -1\\n    ///       if cashAmount > 0: fee = feeRate\\n    ///\\n    /// Newton's method is:\\n    /// fCash_(n+1) = fCash_n - f(fCash) / f'(fCash)\\n    ///\\n    /// f(fCash) = cashAmount * exchangeRate(fCash) * fee + fCash\\n    ///\\n    ///                                    (totalfCash + totalCash)\\n    /// exchangeRate'(fCash) = -  ------------------------------------------\\n    ///                           (totalfCash - fCash) * (totalCash + fCash)\\n    ///\\n    /// https://www.wolframalpha.com/input/?i=ln%28%28%28a-x%29%2F%28a%2Bb%29%29%2F%281-%28a-x%29%2F%28a%2Bb%29%29%29\\n    ///\\n    ///                     (cashAmount * fee) * (totalfCash + totalCash)\\n    /// f'(fCash) = 1 - ------------------------------------------------------\\n    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)\\n    ///\\n    /// NOTE: each iteration costs about 11.3k so this is only done via a view function.\\n    function getfCashGivenCashAmount(\\n        int256 totalfCash,\\n        int256 netCashToAccount,\\n        int256 totalCashUnderlying,\\n        int256 rateScalar,\\n        int256 rateAnchor,\\n        int256 feeRate,\\n        int256 maxDelta\\n    ) internal pure returns (int256) {\\n        require(maxDelta >= 0);\\n        int256 fCashChangeToAccountGuess = netCashToAccount.mulInRatePrecision(rateAnchor).neg();\\n        for (uint8 i = 0; i < 250; i++) {\\n            (int256 exchangeRate, bool success) =\\n                _getExchangeRate(\\n                    totalfCash,\\n                    totalCashUnderlying,\\n                    rateScalar,\\n                    rateAnchor,\\n                    fCashChangeToAccountGuess\\n                );\\n\\n            require(success); // dev: invalid exchange rate\\n            int256 delta =\\n                _calculateDelta(\\n                    netCashToAccount,\\n                    totalfCash,\\n                    totalCashUnderlying,\\n                    rateScalar,\\n                    fCashChangeToAccountGuess,\\n                    exchangeRate,\\n                    feeRate\\n                );\\n\\n            if (delta.abs() <= maxDelta) return fCashChangeToAccountGuess;\\n            fCashChangeToAccountGuess = fCashChangeToAccountGuess.sub(delta);\\n        }\\n\\n        revert(\\\"No convergence\\\");\\n    }\\n\\n    /// @dev Calculates: f(fCash) / f'(fCash)\\n    /// f(fCash) = cashAmount * exchangeRate * fee + fCash\\n    ///                     (cashAmount * fee) * (totalfCash + totalCash)\\n    /// f'(fCash) = 1 - ------------------------------------------------------\\n    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)\\n    function _calculateDelta(\\n        int256 cashAmount,\\n        int256 totalfCash,\\n        int256 totalCashUnderlying,\\n        int256 rateScalar,\\n        int256 fCashGuess,\\n        int256 exchangeRate,\\n        int256 feeRate\\n    ) private pure returns (int256) {\\n        int256 derivative;\\n        // rateScalar * (totalfCash - fCash) * (totalCash + fCash)\\n        // Precision: TOKEN_PRECISION ^ 2\\n        int256 denominator =\\n            rateScalar.mulInRatePrecision(\\n                (totalfCash.sub(fCashGuess)).mul(totalCashUnderlying.add(fCashGuess))\\n            );\\n\\n        if (fCashGuess > 0) {\\n            // Lending\\n            exchangeRate = exchangeRate.divInRatePrecision(feeRate);\\n            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow\\n\\n            // (cashAmount / fee) * (totalfCash + totalCash)\\n            // Precision: TOKEN_PRECISION ^ 2\\n            derivative = cashAmount\\n                .mul(totalfCash.add(totalCashUnderlying))\\n                .divInRatePrecision(feeRate);\\n        } else {\\n            // Borrowing\\n            exchangeRate = exchangeRate.mulInRatePrecision(feeRate);\\n            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow\\n\\n            // (cashAmount * fee) * (totalfCash + totalCash)\\n            // Precision: TOKEN_PRECISION ^ 2\\n            derivative = cashAmount.mulInRatePrecision(\\n                feeRate.mul(totalfCash.add(totalCashUnderlying))\\n            );\\n        }\\n        // 1 - numerator / denominator\\n        // Precision: TOKEN_PRECISION\\n        derivative = Constants.INTERNAL_TOKEN_PRECISION.sub(derivative.div(denominator));\\n\\n        // f(fCash) = cashAmount * exchangeRate * fee + fCash\\n        // NOTE: exchangeRate at this point already has the fee taken into account\\n        int256 numerator = cashAmount.mulInRatePrecision(exchangeRate);\\n        numerator = numerator.add(fCashGuess);\\n\\n        // f(fCash) / f'(fCash), note that they are both denominated as cashAmount so use TOKEN_PRECISION\\n        // here instead of RATE_PRECISION\\n        return numerator.mul(Constants.INTERNAL_TOKEN_PRECISION).div(derivative);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/markets/CashGroup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./Market.sol\\\";\\nimport \\\"./AssetRate.sol\\\";\\nimport \\\"./DateTime.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary CashGroup {\\n    using SafeMath for uint256;\\n    using SafeInt256 for int256;\\n    using AssetRate for AssetRateParameters;\\n    using Market for MarketParameters;\\n\\n    // Bit number references for each parameter in the 32 byte word (0-indexed)\\n    uint256 private constant MARKET_INDEX_BIT = 31;\\n    uint256 private constant RATE_ORACLE_TIME_WINDOW_BIT = 30;\\n    uint256 private constant TOTAL_FEE_BIT = 29;\\n    uint256 private constant RESERVE_FEE_SHARE_BIT = 28;\\n    uint256 private constant DEBT_BUFFER_BIT = 27;\\n    uint256 private constant FCASH_HAIRCUT_BIT = 26;\\n    uint256 private constant SETTLEMENT_PENALTY_BIT = 25;\\n    uint256 private constant LIQUIDATION_FCASH_HAIRCUT_BIT = 24;\\n    uint256 private constant LIQUIDATION_DEBT_BUFFER_BIT = 23;\\n    // 7 bytes allocated, one byte per market for the liquidity token haircut\\n    uint256 private constant LIQUIDITY_TOKEN_HAIRCUT_FIRST_BIT = 22;\\n    // 7 bytes allocated, one byte per market for the rate scalar\\n    uint256 private constant RATE_SCALAR_FIRST_BIT = 15;\\n\\n    // Offsets for the bytes of the different parameters\\n    uint256 private constant MARKET_INDEX = (31 - MARKET_INDEX_BIT) * 8;\\n    uint256 private constant RATE_ORACLE_TIME_WINDOW = (31 - RATE_ORACLE_TIME_WINDOW_BIT) * 8;\\n    uint256 private constant TOTAL_FEE = (31 - TOTAL_FEE_BIT) * 8;\\n    uint256 private constant RESERVE_FEE_SHARE = (31 - RESERVE_FEE_SHARE_BIT) * 8;\\n    uint256 private constant DEBT_BUFFER = (31 - DEBT_BUFFER_BIT) * 8;\\n    uint256 private constant FCASH_HAIRCUT = (31 - FCASH_HAIRCUT_BIT) * 8;\\n    uint256 private constant SETTLEMENT_PENALTY = (31 - SETTLEMENT_PENALTY_BIT) * 8;\\n    uint256 private constant LIQUIDATION_FCASH_HAIRCUT = (31 - LIQUIDATION_FCASH_HAIRCUT_BIT) * 8;\\n    uint256 private constant LIQUIDATION_DEBT_BUFFER = (31 - LIQUIDATION_DEBT_BUFFER_BIT) * 8;\\n    uint256 private constant LIQUIDITY_TOKEN_HAIRCUT = (31 - LIQUIDITY_TOKEN_HAIRCUT_FIRST_BIT) * 8;\\n    uint256 private constant RATE_SCALAR = (31 - RATE_SCALAR_FIRST_BIT) * 8;\\n\\n    /// @notice Returns the rate scalar scaled by time to maturity. The rate scalar multiplies\\n    /// the ln() portion of the liquidity curve as an inverse so it increases with time to\\n    /// maturity. The effect of the rate scalar on slippage must decrease with time to maturity.\\n    function getRateScalar(\\n        CashGroupParameters memory cashGroup,\\n        uint256 marketIndex,\\n        uint256 timeToMaturity\\n    ) internal pure returns (int256) {\\n        require(1 <= marketIndex && marketIndex <= cashGroup.maxMarketIndex); // dev: invalid market index\\n\\n        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);\\n        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * Constants.RATE_PRECISION;\\n        int256 rateScalar =\\n            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(SafeInt256.toInt(timeToMaturity));\\n\\n        // Rate scalar is denominated in RATE_PRECISION, it is unlikely to underflow in the\\n        // division above.\\n        require(rateScalar > 0); // dev: rate scalar underflow\\n        return rateScalar;\\n    }\\n\\n    /// @notice Haircut on liquidity tokens to account for the risk associated with changes in the\\n    /// proportion of cash to fCash within the pool. This is set as a percentage less than or equal to 100.\\n    function getLiquidityHaircut(CashGroupParameters memory cashGroup, uint256 assetType)\\n        internal\\n        pure\\n        returns (uint8)\\n    {\\n        require(\\n            Constants.MIN_LIQUIDITY_TOKEN_INDEX <= assetType &&\\n            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX\\n        ); // dev: liquidity haircut invalid asset type\\n        uint256 offset =\\n            LIQUIDITY_TOKEN_HAIRCUT + 8 * (assetType - Constants.MIN_LIQUIDITY_TOKEN_INDEX);\\n        return uint8(uint256(cashGroup.data >> offset));\\n    }\\n\\n    /// @notice Total trading fee denominated in RATE_PRECISION with basis point increments\\n    function getTotalFee(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\n        return uint256(uint8(uint256(cashGroup.data >> TOTAL_FEE))) * Constants.BASIS_POINT;\\n    }\\n\\n    /// @notice Percentage of the total trading fee that goes to the reserve\\n    function getReserveFeeShare(CashGroupParameters memory cashGroup)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return uint8(uint256(cashGroup.data >> RESERVE_FEE_SHARE));\\n    }\\n\\n    /// @notice fCash haircut for valuation denominated in rate precision with five basis point increments\\n    function getfCashHaircut(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\n        return\\n            uint256(uint8(uint256(cashGroup.data >> FCASH_HAIRCUT))) * Constants.FIVE_BASIS_POINTS;\\n    }\\n\\n    /// @notice fCash debt buffer for valuation denominated in rate precision with five basis point increments\\n    function getDebtBuffer(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\n        return uint256(uint8(uint256(cashGroup.data >> DEBT_BUFFER))) * Constants.FIVE_BASIS_POINTS;\\n    }\\n\\n    /// @notice Time window factor for the rate oracle denominated in seconds with five minute increments.\\n    function getRateOracleTimeWindow(CashGroupParameters memory cashGroup)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        // This is denominated in 5 minute increments in storage\\n        return uint256(uint8(uint256(cashGroup.data >> RATE_ORACLE_TIME_WINDOW))) * Constants.FIVE_MINUTES;\\n    }\\n\\n    /// @notice Penalty rate for settling cash debts denominated in basis points\\n    function getSettlementPenalty(CashGroupParameters memory cashGroup)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            uint256(uint8(uint256(cashGroup.data >> SETTLEMENT_PENALTY))) * Constants.FIVE_BASIS_POINTS;\\n    }\\n\\n    /// @notice Haircut for positive fCash during liquidation denominated rate precision\\n    /// with five basis point increments\\n    function getLiquidationfCashHaircut(CashGroupParameters memory cashGroup)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            uint256(uint8(uint256(cashGroup.data >> LIQUIDATION_FCASH_HAIRCUT))) * Constants.FIVE_BASIS_POINTS;\\n    }\\n\\n    /// @notice Haircut for negative fCash during liquidation denominated rate precision\\n    /// with five basis point increments\\n    function getLiquidationDebtBuffer(CashGroupParameters memory cashGroup)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            uint256(uint8(uint256(cashGroup.data >> LIQUIDATION_DEBT_BUFFER))) * Constants.FIVE_BASIS_POINTS;\\n    }\\n\\n    function loadMarket(\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        uint256 marketIndex,\\n        bool needsLiquidity,\\n        uint256 blockTime\\n    ) internal view {\\n        require(1 <= marketIndex && marketIndex <= cashGroup.maxMarketIndex, \\\"Invalid market\\\");\\n        uint256 maturity =\\n            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));\\n\\n        market.loadMarket(\\n            cashGroup.currencyId,\\n            maturity,\\n            blockTime,\\n            needsLiquidity,\\n            getRateOracleTimeWindow(cashGroup)\\n        );\\n    }\\n\\n    /// @notice Returns the linear interpolation between two market rates. The formula is\\n    /// slope = (longMarket.oracleRate - shortMarket.oracleRate) / (longMarket.maturity - shortMarket.maturity)\\n    /// interpolatedRate = slope * (assetMaturity - shortMarket.maturity) + shortMarket.oracleRate\\n    function interpolateOracleRate(\\n        uint256 shortMaturity,\\n        uint256 longMaturity,\\n        uint256 shortRate,\\n        uint256 longRate,\\n        uint256 assetMaturity\\n    ) internal pure returns (uint256) {\\n        require(shortMaturity < assetMaturity); // dev: cash group interpolation error, short maturity\\n        require(assetMaturity < longMaturity); // dev: cash group interpolation error, long maturity\\n\\n        // It's possible that the rates are inverted where the short market rate > long market rate and\\n        // we will get an underflow here so we check for that\\n        if (longRate >= shortRate) {\\n            return\\n                (longRate - shortRate)\\n                    .mul(assetMaturity - shortMaturity)\\n                // No underflow here, checked above\\n                    .div(longMaturity - shortMaturity)\\n                    .add(shortRate);\\n        } else {\\n            // In this case the slope is negative so:\\n            // interpolatedRate = shortMarket.oracleRate - slope * (assetMaturity - shortMarket.maturity)\\n            // NOTE: this subtraction should never overflow, the linear interpolation between two points above zero\\n            // cannot go below zero\\n            return\\n                shortRate.sub(\\n                    // This is reversed to keep it it positive\\n                    (shortRate - longRate)\\n                        .mul(assetMaturity - shortMaturity)\\n                    // No underflow here, checked above\\n                        .div(longMaturity - shortMaturity)\\n                );\\n        }\\n    }\\n\\n    /// @dev Gets an oracle rate given any valid maturity.\\n    function calculateOracleRate(\\n        CashGroupParameters memory cashGroup,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal view returns (uint256) {\\n        (uint256 marketIndex, bool idiosyncratic) =\\n            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);\\n        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);\\n\\n        if (!idiosyncratic) {\\n            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);\\n        } else {\\n            uint256 referenceTime = DateTime.getReferenceTime(blockTime);\\n            // DateTime.getMarketIndex returns the market that is past the maturity if idiosyncratic\\n            uint256 longMaturity = referenceTime.add(DateTime.getTradedMarket(marketIndex));\\n            uint256 longRate =\\n                Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);\\n\\n            uint256 shortMaturity;\\n            uint256 shortRate;\\n            if (marketIndex == 1) {\\n                // In this case the short market is the annualized asset supply rate\\n                shortMaturity = blockTime;\\n                shortRate = cashGroup.assetRate.getSupplyRate();\\n            } else {\\n                // Minimum value for marketIndex here is 2\\n                shortMaturity = referenceTime.add(DateTime.getTradedMarket(marketIndex - 1));\\n\\n                shortRate = Market.getOracleRate(\\n                    cashGroup.currencyId,\\n                    shortMaturity,\\n                    timeWindow,\\n                    blockTime\\n                );\\n            }\\n\\n            return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);\\n        }\\n    }\\n\\n    function _getCashGroupStorageBytes(uint256 currencyId) private view returns (bytes32 data) {\\n        mapping(uint256 => bytes32) storage store = LibStorage.getCashGroupStorage();\\n        return store[currencyId];\\n    }\\n\\n    /// @dev Helper method for validating maturities in ERC1155Action\\n    function getMaxMarketIndex(uint256 currencyId) internal view returns (uint8) {\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\n        return uint8(data[MARKET_INDEX_BIT]);\\n    }\\n\\n    /// @notice Checks all cash group settings for invalid values and sets them into storage\\n    function setCashGroupStorage(uint256 currencyId, CashGroupSettings calldata cashGroup)\\n        internal\\n    {\\n        // Due to the requirements of the yield curve we do not allow a cash group to have solely a 3 month market.\\n        // The reason is that borrowers will not have a further maturity to roll from their 3 month fixed to a 6 month\\n        // fixed. It also complicates the logic in the nToken initialization method. Additionally, we cannot have cash\\n        // groups with 0 market index, it has no effect.\\n        require(2 <= cashGroup.maxMarketIndex && cashGroup.maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX,\\n            \\\"CG: invalid market index\\\"\\n        );\\n        require(\\n            cashGroup.reserveFeeShare <= Constants.PERCENTAGE_DECIMALS,\\n            \\\"CG: invalid reserve share\\\"\\n        );\\n        require(cashGroup.liquidityTokenHaircuts.length == cashGroup.maxMarketIndex);\\n        require(cashGroup.rateScalars.length == cashGroup.maxMarketIndex);\\n        // This is required so that fCash liquidation can proceed correctly\\n        require(cashGroup.liquidationfCashHaircut5BPS < cashGroup.fCashHaircut5BPS);\\n        require(cashGroup.liquidationDebtBuffer5BPS < cashGroup.debtBuffer5BPS);\\n\\n        // Market indexes cannot decrease or they will leave fCash assets stranded in the future with no valuation curve\\n        uint8 previousMaxMarketIndex = getMaxMarketIndex(currencyId);\\n        require(\\n            previousMaxMarketIndex <= cashGroup.maxMarketIndex,\\n            \\\"CG: market index cannot decrease\\\"\\n        );\\n\\n        // Per cash group settings\\n        bytes32 data =\\n            (bytes32(uint256(cashGroup.maxMarketIndex)) |\\n                (bytes32(uint256(cashGroup.rateOracleTimeWindow5Min)) << RATE_ORACLE_TIME_WINDOW) |\\n                (bytes32(uint256(cashGroup.totalFeeBPS)) << TOTAL_FEE) |\\n                (bytes32(uint256(cashGroup.reserveFeeShare)) << RESERVE_FEE_SHARE) |\\n                (bytes32(uint256(cashGroup.debtBuffer5BPS)) << DEBT_BUFFER) |\\n                (bytes32(uint256(cashGroup.fCashHaircut5BPS)) << FCASH_HAIRCUT) |\\n                (bytes32(uint256(cashGroup.settlementPenaltyRate5BPS)) << SETTLEMENT_PENALTY) |\\n                (bytes32(uint256(cashGroup.liquidationfCashHaircut5BPS)) <<\\n                    LIQUIDATION_FCASH_HAIRCUT) |\\n                (bytes32(uint256(cashGroup.liquidationDebtBuffer5BPS)) << LIQUIDATION_DEBT_BUFFER));\\n\\n        // Per market group settings\\n        for (uint256 i = 0; i < cashGroup.liquidityTokenHaircuts.length; i++) {\\n            require(\\n                cashGroup.liquidityTokenHaircuts[i] <= Constants.PERCENTAGE_DECIMALS,\\n                \\\"CG: invalid token haircut\\\"\\n            );\\n\\n            data =\\n                data |\\n                (bytes32(uint256(cashGroup.liquidityTokenHaircuts[i])) <<\\n                    (LIQUIDITY_TOKEN_HAIRCUT + i * 8));\\n        }\\n\\n        for (uint256 i = 0; i < cashGroup.rateScalars.length; i++) {\\n            // Causes a divide by zero error\\n            require(cashGroup.rateScalars[i] != 0, \\\"CG: invalid rate scalar\\\");\\n            data = data | (bytes32(uint256(cashGroup.rateScalars[i])) << (RATE_SCALAR + i * 8));\\n        }\\n\\n        mapping(uint256 => bytes32) storage store = LibStorage.getCashGroupStorage();\\n        store[currencyId] = data;\\n    }\\n\\n    /// @notice Deserialize the cash group storage bytes into a user friendly object\\n    function deserializeCashGroupStorage(uint256 currencyId)\\n        internal\\n        view\\n        returns (CashGroupSettings memory)\\n    {\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\n        uint8 maxMarketIndex = uint8(data[MARKET_INDEX_BIT]);\\n        uint8[] memory tokenHaircuts = new uint8[](uint256(maxMarketIndex));\\n        uint8[] memory rateScalars = new uint8[](uint256(maxMarketIndex));\\n\\n        for (uint8 i = 0; i < maxMarketIndex; i++) {\\n            tokenHaircuts[i] = uint8(data[LIQUIDITY_TOKEN_HAIRCUT_FIRST_BIT - i]);\\n            rateScalars[i] = uint8(data[RATE_SCALAR_FIRST_BIT - i]);\\n        }\\n\\n        return\\n            CashGroupSettings({\\n                maxMarketIndex: maxMarketIndex,\\n                rateOracleTimeWindow5Min: uint8(data[RATE_ORACLE_TIME_WINDOW_BIT]),\\n                totalFeeBPS: uint8(data[TOTAL_FEE_BIT]),\\n                reserveFeeShare: uint8(data[RESERVE_FEE_SHARE_BIT]),\\n                debtBuffer5BPS: uint8(data[DEBT_BUFFER_BIT]),\\n                fCashHaircut5BPS: uint8(data[FCASH_HAIRCUT_BIT]),\\n                settlementPenaltyRate5BPS: uint8(data[SETTLEMENT_PENALTY_BIT]),\\n                liquidationfCashHaircut5BPS: uint8(data[LIQUIDATION_FCASH_HAIRCUT_BIT]),\\n                liquidationDebtBuffer5BPS: uint8(data[LIQUIDATION_DEBT_BUFFER_BIT]),\\n                liquidityTokenHaircuts: tokenHaircuts,\\n                rateScalars: rateScalars\\n            });\\n    }\\n\\n    function _buildCashGroup(uint16 currencyId, AssetRateParameters memory assetRate)\\n        private\\n        view\\n        returns (CashGroupParameters memory)\\n    {\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\n        uint256 maxMarketIndex = uint8(data[MARKET_INDEX_BIT]);\\n\\n        return\\n            CashGroupParameters({\\n                currencyId: currencyId,\\n                maxMarketIndex: maxMarketIndex,\\n                assetRate: assetRate,\\n                data: data\\n            });\\n    }\\n\\n    /// @notice Builds a cash group using a view version of the asset rate\\n    function buildCashGroupView(uint16 currencyId)\\n        internal\\n        view\\n        returns (CashGroupParameters memory)\\n    {\\n        AssetRateParameters memory assetRate = AssetRate.buildAssetRateView(currencyId);\\n        return _buildCashGroup(currencyId, assetRate);\\n    }\\n\\n    /// @notice Builds a cash group using a stateful version of the asset rate\\n    function buildCashGroupStateful(uint16 currencyId)\\n        internal\\n        returns (CashGroupParameters memory)\\n    {\\n        AssetRateParameters memory assetRate = AssetRate.buildAssetRateStateful(currencyId);\\n        return _buildCashGroup(currencyId, assetRate);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/markets/AssetRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"interfaces/notional/AssetRateAdapter.sol\\\";\\n\\nlibrary AssetRate {\\n    using SafeInt256 for int256;\\n    event SetSettlementRate(uint256 indexed currencyId, uint256 indexed maturity, uint128 rate);\\n\\n    // Asset rates are in 1e18 decimals (cToken exchange rates), internal balances\\n    // are in 1e8 decimals. Therefore we leave this as 1e18 / 1e8 = 1e10\\n    int256 private constant ASSET_RATE_DECIMAL_DIFFERENCE = 1e10;\\n\\n    /// @notice Converts an internal asset cash value to its underlying token value.\\n    /// @param ar exchange rate object between asset and underlying\\n    /// @param assetBalance amount to convert to underlying\\n    function convertToUnderlying(AssetRateParameters memory ar, int256 assetBalance)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        // Calculation here represents:\\n        // rate * balance * internalPrecision / rateDecimals * underlyingPrecision\\n        int256 underlyingBalance = ar.rate\\n            .mul(assetBalance)\\n            .div(ASSET_RATE_DECIMAL_DIFFERENCE)\\n            .div(ar.underlyingDecimals);\\n\\n        return underlyingBalance;\\n    }\\n\\n    /// @notice Converts an internal underlying cash value to its asset cash value\\n    /// @param ar exchange rate object between asset and underlying\\n    /// @param underlyingBalance amount to convert to asset cash, denominated in internal token precision\\n    function convertFromUnderlying(AssetRateParameters memory ar, int256 underlyingBalance)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        // Calculation here represents:\\n        // rateDecimals * balance * underlyingPrecision / rate * internalPrecision\\n        int256 assetBalance = underlyingBalance\\n            .mul(ASSET_RATE_DECIMAL_DIFFERENCE)\\n            .mul(ar.underlyingDecimals)\\n            .div(ar.rate);\\n\\n        return assetBalance;\\n    }\\n\\n    /// @notice Returns the current per block supply rate, is used when calculating oracle rates\\n    /// for idiosyncratic fCash with a shorter duration than the 3 month maturity.\\n    function getSupplyRate(AssetRateParameters memory ar) internal view returns (uint256) {\\n        // If the rate oracle is not set, the asset is not interest bearing and has an oracle rate of zero.\\n        if (address(ar.rateOracle) == address(0)) return 0;\\n\\n        uint256 rate = ar.rateOracle.getAnnualizedSupplyRate();\\n        // Zero supply rate is valid since this is an interest rate, we do not divide by\\n        // the supply rate so we do not get div by zero errors.\\n        require(rate >= 0); // dev: invalid supply rate\\n\\n        return rate;\\n    }\\n\\n    function _getAssetRateStorage(uint256 currencyId)\\n        private\\n        view\\n        returns (AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces)\\n    {\\n        mapping(uint256 => AssetRateStorage) storage store = LibStorage.getAssetRateStorage();\\n        AssetRateStorage storage ar = store[currencyId];\\n        rateOracle = AssetRateAdapter(ar.rateOracle);\\n        underlyingDecimalPlaces = ar.underlyingDecimalPlaces;\\n    }\\n\\n    /// @notice Gets an asset rate using a view function, does not accrue interest so the\\n    /// exchange rate will not be up to date. Should only be used for non-stateful methods\\n    function _getAssetRateView(uint256 currencyId)\\n        private\\n        view\\n        returns (\\n            int256,\\n            AssetRateAdapter,\\n            uint8\\n        )\\n    {\\n        (AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) = _getAssetRateStorage(currencyId);\\n\\n        int256 rate;\\n        if (address(rateOracle) == address(0)) {\\n            // If no rate oracle is set, then set this to the identity\\n            rate = ASSET_RATE_DECIMAL_DIFFERENCE;\\n            // This will get raised to 10^x and return 1, will not end up with div by zero\\n            underlyingDecimalPlaces = 0;\\n        } else {\\n            rate = rateOracle.getExchangeRateView();\\n            require(rate > 0); // dev: invalid exchange rate\\n        }\\n\\n        return (rate, rateOracle, underlyingDecimalPlaces);\\n    }\\n\\n    /// @notice Gets an asset rate using a stateful function, accrues interest so the\\n    /// exchange rate will be up to date for the current block.\\n    function _getAssetRateStateful(uint256 currencyId)\\n        private\\n        returns (\\n            int256,\\n            AssetRateAdapter,\\n            uint8\\n        )\\n    {\\n        (AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) = _getAssetRateStorage(currencyId);\\n\\n        int256 rate;\\n        if (address(rateOracle) == address(0)) {\\n            // If no rate oracle is set, then set this to the identity\\n            rate = ASSET_RATE_DECIMAL_DIFFERENCE;\\n            // This will get raised to 10^x and return 1, will not end up with div by zero\\n            underlyingDecimalPlaces = 0;\\n        } else {\\n            rate = rateOracle.getExchangeRateStateful();\\n            require(rate > 0); // dev: invalid exchange rate\\n        }\\n\\n        return (rate, rateOracle, underlyingDecimalPlaces);\\n    }\\n\\n    /// @notice Returns an asset rate object using the view method\\n    function buildAssetRateView(uint256 currencyId)\\n        internal\\n        view\\n        returns (AssetRateParameters memory)\\n    {\\n        (int256 rate, AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) =\\n            _getAssetRateView(currencyId);\\n\\n        return\\n            AssetRateParameters({\\n                rateOracle: rateOracle,\\n                rate: rate,\\n                // No overflow, restricted on storage\\n                underlyingDecimals: int256(10**underlyingDecimalPlaces)\\n            });\\n    }\\n\\n    /// @notice Returns an asset rate object using the stateful method\\n    function buildAssetRateStateful(uint256 currencyId)\\n        internal\\n        returns (AssetRateParameters memory)\\n    {\\n        (int256 rate, AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) =\\n            _getAssetRateStateful(currencyId);\\n\\n        return\\n            AssetRateParameters({\\n                rateOracle: rateOracle,\\n                rate: rate,\\n                // No overflow, restricted on storage\\n                underlyingDecimals: int256(10**underlyingDecimalPlaces)\\n            });\\n    }\\n\\n    /// @dev Gets a settlement rate object\\n    function _getSettlementRateStorage(uint256 currencyId, uint256 maturity)\\n        private\\n        view\\n        returns (\\n            int256 settlementRate,\\n            uint8 underlyingDecimalPlaces\\n        )\\n    {\\n        mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store = LibStorage.getSettlementRateStorage();\\n        SettlementRateStorage storage rateStorage = store[currencyId][maturity];\\n        settlementRate = rateStorage.settlementRate;\\n        underlyingDecimalPlaces = rateStorage.underlyingDecimalPlaces;\\n    }\\n\\n    /// @notice Returns a settlement rate object using the view method\\n    function buildSettlementRateView(uint256 currencyId, uint256 maturity)\\n        internal\\n        view\\n        returns (AssetRateParameters memory)\\n    {\\n        // prettier-ignore\\n        (\\n            int256 settlementRate,\\n            uint8 underlyingDecimalPlaces\\n        ) = _getSettlementRateStorage(currencyId, maturity);\\n\\n        // Asset exchange rates cannot be zero\\n        if (settlementRate == 0) {\\n            // If settlement rate has not been set then we need to fetch it\\n            // prettier-ignore\\n            (\\n                settlementRate,\\n                /* address */,\\n                underlyingDecimalPlaces\\n            ) = _getAssetRateView(currencyId);\\n        }\\n\\n        return AssetRateParameters(\\n            AssetRateAdapter(address(0)),\\n            settlementRate,\\n            // No overflow, restricted on storage\\n            int256(10**underlyingDecimalPlaces)\\n        );\\n    }\\n\\n    /// @notice Returns a settlement rate object and sets the rate if it has not been set yet\\n    function buildSettlementRateStateful(\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal returns (AssetRateParameters memory) {\\n        (int256 settlementRate, uint8 underlyingDecimalPlaces) =\\n            _getSettlementRateStorage(currencyId, maturity);\\n\\n        if (settlementRate == 0) {\\n            // Settlement rate has not yet been set, set it in this branch\\n            AssetRateAdapter rateOracle;\\n            // If rate oracle == 0 then this will return the identity settlement rate\\n            // prettier-ignore\\n            (\\n                settlementRate,\\n                rateOracle,\\n                underlyingDecimalPlaces\\n            ) = _getAssetRateStateful(currencyId);\\n\\n            if (address(rateOracle) != address(0)) {\\n                mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store = LibStorage.getSettlementRateStorage();\\n                // Only need to set settlement rates when the rate oracle is set (meaning the asset token has\\n                // a conversion rate to an underlying). If not set then the asset cash always settles to underlying at a 1-1\\n                // rate since they are the same.\\n                require(blockTime != 0 && blockTime <= type(uint40).max); // dev: settlement rate timestamp overflow\\n                require(0 < settlementRate && settlementRate <= type(uint128).max); // dev: settlement rate overflow\\n\\n                SettlementRateStorage storage rateStorage = store[currencyId][maturity];\\n                rateStorage.blockTime = uint40(blockTime);\\n                rateStorage.settlementRate = uint128(settlementRate);\\n                rateStorage.underlyingDecimalPlaces = underlyingDecimalPlaces;\\n                emit SetSettlementRate(currencyId, maturity, uint128(settlementRate));\\n            }\\n        }\\n\\n        return AssetRateParameters(\\n            AssetRateAdapter(address(0)),\\n            settlementRate,\\n            // No overflow, restricted on storage\\n            int256(10**underlyingDecimalPlaces)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/balances/BalanceHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./Incentives.sol\\\";\\nimport \\\"./TokenHandler.sol\\\";\\nimport \\\"../AccountContextHandler.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../math/FloatingPoint56.sol\\\";\\n\\nlibrary BalanceHandler {\\n    using SafeInt256 for int256;\\n    using TokenHandler for Token;\\n    using AssetRate for AssetRateParameters;\\n    using AccountContextHandler for AccountContext;\\n\\n    /// @notice Emitted when a cash balance changes\\n    event CashBalanceChange(address indexed account, uint16 indexed currencyId, int256 netCashChange);\\n    /// @notice Emitted when nToken supply changes (not the same as transfers)\\n    event nTokenSupplyChange(address indexed account, uint16 indexed currencyId, int256 tokenSupplyChange);\\n    /// @notice Emitted when reserve fees are accrued\\n    event ReserveFeeAccrued(uint16 indexed currencyId, int256 fee);\\n\\n    /// @notice Deposits asset tokens into an account\\n    /// @dev Handles two special cases when depositing tokens into an account.\\n    ///  - If a token has transfer fees then the amount specified does not equal the amount that the contract\\n    ///    will receive. Complete the deposit here rather than in finalize so that the contract has the correct\\n    ///    balance to work with.\\n    ///  - Force a transfer before finalize to allow a different account to deposit into an account\\n    /// @return Returns two values:\\n    ///  - assetAmountInternal which is the converted asset amount accounting for transfer fees\\n    ///  - assetAmountTransferred which is the internal precision amount transferred into the account\\n    function depositAssetToken(\\n        BalanceState memory balanceState,\\n        address account,\\n        int256 assetAmountExternal,\\n        bool forceTransfer\\n    ) internal returns (int256) {\\n        if (assetAmountExternal == 0) return 0;\\n        require(assetAmountExternal > 0); // dev: deposit asset token amount negative\\n        Token memory token = TokenHandler.getAssetToken(balanceState.currencyId);\\n        int256 assetAmountInternal = token.convertToInternal(assetAmountExternal);\\n\\n        // Force transfer is used to complete the transfer before going to finalize\\n        if (token.hasTransferFee || forceTransfer) {\\n            // If the token has a transfer fee the deposit amount may not equal the actual amount\\n            // that the contract will receive. We handle the deposit here and then update the netCashChange\\n            // accordingly which is denominated in internal precision.\\n            int256 assetAmountExternalPrecisionFinal = token.transfer(account, assetAmountExternal);\\n            // Convert the external precision to internal, it's possible that we lose dust amounts here but\\n            // this is unavoidable because we do not know how transfer fees are calculated.\\n            assetAmountInternal = token.convertToInternal(assetAmountExternalPrecisionFinal);\\n            // Transfer has been called\\n            balanceState.netCashChange = balanceState.netCashChange.add(assetAmountInternal);\\n\\n            return assetAmountInternal;\\n        } else {\\n            // Otherwise add the asset amount here. It may be net off later and we want to only do\\n            // a single transfer during the finalize method. Use internal precision to ensure that internal accounting\\n            // and external account remain in sync.\\n            // Transfer will be deferred\\n            balanceState.netAssetTransferInternalPrecision = balanceState\\n                .netAssetTransferInternalPrecision\\n                .add(assetAmountInternal);\\n\\n            // Returns the converted assetAmountExternal to the internal amount\\n            return assetAmountInternal;\\n        }\\n    }\\n\\n    /// @notice Handle deposits of the underlying token\\n    /// @dev In this case we must wrap the underlying token into an asset token, ensuring that we do not end up\\n    /// with any underlying tokens left as dust on the contract.\\n    function depositUnderlyingToken(\\n        BalanceState memory balanceState,\\n        address account,\\n        int256 underlyingAmountExternal\\n    ) internal returns (int256) {\\n        if (underlyingAmountExternal == 0) return 0;\\n        require(underlyingAmountExternal > 0); // dev: deposit underlying token negative\\n\\n        Token memory underlyingToken = TokenHandler.getUnderlyingToken(balanceState.currencyId);\\n        // This is the exact amount of underlying tokens the account has in external precision.\\n        if (underlyingToken.tokenType == TokenType.Ether) {\\n            // Underflow checked above\\n            require(uint256(underlyingAmountExternal) == msg.value, \\\"ETH Balance\\\");\\n        } else {\\n            underlyingAmountExternal = underlyingToken.transfer(account, underlyingAmountExternal);\\n        }\\n\\n        Token memory assetToken = TokenHandler.getAssetToken(balanceState.currencyId);\\n        // Tokens that are not mintable like cTokens will be deposited as assetTokens\\n        require(assetToken.tokenType == TokenType.cToken || assetToken.tokenType == TokenType.cETH); // dev: deposit underlying token invalid token type\\n        int256 assetTokensReceivedExternalPrecision =\\n            assetToken.mint(SafeInt256.toUint(underlyingAmountExternal));\\n\\n        // cTokens match INTERNAL_TOKEN_PRECISION so this will short circuit but we leave this here in case a different\\n        // type of asset token is listed in the future. It's possible if those tokens have a different precision dust may\\n        // accrue but that is not relevant now.\\n        int256 assetTokensReceivedInternal =\\n            assetToken.convertToInternal(assetTokensReceivedExternalPrecision);\\n        // Transfer / mint has taken effect\\n        balanceState.netCashChange = balanceState.netCashChange.add(assetTokensReceivedInternal);\\n\\n        return assetTokensReceivedInternal;\\n    }\\n\\n    /// @notice Finalizes an account's balances, handling any transfer logic required\\n    /// @dev This method SHOULD NOT be used for nToken accounts, for that use setBalanceStorageForNToken\\n    /// as the nToken is limited in what types of balances it can hold.\\n    function finalize(\\n        BalanceState memory balanceState,\\n        address account,\\n        AccountContext memory accountContext,\\n        bool redeemToUnderlying\\n    ) internal returns (int256 transferAmountExternal) {\\n        bool mustUpdate;\\n        if (balanceState.netNTokenTransfer < 0) {\\n            require(\\n                balanceState.storedNTokenBalance\\n                    .add(balanceState.netNTokenSupplyChange)\\n                    .add(balanceState.netNTokenTransfer) >= 0,\\n                \\\"Neg nToken\\\"\\n            );\\n        }\\n\\n        if (balanceState.netAssetTransferInternalPrecision < 0) {\\n            require(\\n                balanceState.storedCashBalance\\n                    .add(balanceState.netCashChange)\\n                    .add(balanceState.netAssetTransferInternalPrecision) >= 0,\\n                \\\"Neg Cash\\\"\\n            );\\n        }\\n\\n        // Transfer amount is checked inside finalize transfers in case when converting to external we\\n        // round down to zero. This returns the actual net transfer in internal precision as well.\\n        (\\n            transferAmountExternal,\\n            balanceState.netAssetTransferInternalPrecision\\n        ) = _finalizeTransfers(balanceState, account, redeemToUnderlying);\\n        // No changes to total cash after this point\\n        int256 totalCashChange = balanceState.netCashChange.add(balanceState.netAssetTransferInternalPrecision);\\n\\n        if (totalCashChange != 0) {\\n            balanceState.storedCashBalance = balanceState.storedCashBalance.add(totalCashChange);\\n            mustUpdate = true;\\n\\n            emit CashBalanceChange(\\n                account,\\n                uint16(balanceState.currencyId),\\n                totalCashChange\\n            );\\n        }\\n\\n        if (balanceState.netNTokenTransfer != 0 || balanceState.netNTokenSupplyChange != 0) {\\n            // It's crucial that incentives are claimed before we do any sort of nToken transfer to prevent gaming\\n            // of the system. This method will update the lastClaimTime time and lastIntegralTotalSupply in balance\\n            // state in place.\\n            Incentives.claimIncentives(balanceState, account);\\n\\n            // nTokens are within the notional system so we can update balances directly.\\n            balanceState.storedNTokenBalance = balanceState\\n                .storedNTokenBalance\\n                .add(balanceState.netNTokenTransfer)\\n                .add(balanceState.netNTokenSupplyChange);\\n\\n            if (balanceState.netNTokenSupplyChange != 0) {\\n                emit nTokenSupplyChange(\\n                    account,\\n                    uint16(balanceState.currencyId),\\n                    balanceState.netNTokenSupplyChange\\n                );\\n            }\\n\\n            mustUpdate = true;\\n        }\\n\\n        if (mustUpdate) {\\n            _setBalanceStorage(\\n                account,\\n                balanceState.currencyId,\\n                balanceState.storedCashBalance,\\n                balanceState.storedNTokenBalance,\\n                balanceState.lastClaimTime,\\n                balanceState.lastClaimIntegralSupply\\n            );\\n        }\\n\\n        accountContext.setActiveCurrency(\\n            balanceState.currencyId,\\n            // Set active currency to true if either balance is non-zero\\n            balanceState.storedCashBalance != 0 || balanceState.storedNTokenBalance != 0,\\n            Constants.ACTIVE_IN_BALANCES\\n        );\\n\\n        if (balanceState.storedCashBalance < 0) {\\n            // NOTE: HAS_CASH_DEBT cannot be extinguished except by a free collateral check where all balances\\n            // are examined\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\n        }\\n    }\\n\\n    /// @dev Returns the amount transferred in underlying or asset terms depending on how redeem to underlying\\n    /// is specified.\\n    function _finalizeTransfers(\\n        BalanceState memory balanceState,\\n        address account,\\n        bool redeemToUnderlying\\n    ) private returns (int256 actualTransferAmountExternal, int256 assetTransferAmountInternal) {\\n        Token memory assetToken = TokenHandler.getAssetToken(balanceState.currencyId);\\n        // Dust accrual to the protocol is possible if the token decimals is less than internal token precision.\\n        // See the comments in TokenHandler.convertToExternal and TokenHandler.convertToInternal\\n        int256 assetTransferAmountExternal =\\n            assetToken.convertToExternal(balanceState.netAssetTransferInternalPrecision);\\n\\n        if (assetTransferAmountExternal == 0) {\\n            return (0, 0);\\n        } else if (redeemToUnderlying && assetTransferAmountExternal < 0) {\\n            // We only do the redeem to underlying if the asset transfer amount is less than zero. If it is greater than\\n            // zero then we will do a normal transfer instead.\\n\\n            // We use the internal amount here and then scale it to the external amount so that there is\\n            // no loss of precision between our internal accounting and the external account. In this case\\n            // there will be no dust accrual in underlying tokens since we will transfer the exact amount\\n            // of underlying that was received.\\n            Token memory underlyingToken = TokenHandler.getUnderlyingToken(balanceState.currencyId);\\n            // underlyingAmountExternal is converted from uint to int inside redeem, must be positive\\n            int256 underlyingAmountExternal = assetToken.redeem(\\n                underlyingToken,\\n                uint256(assetTransferAmountExternal.neg())\\n            );\\n\\n            // Withdraws the underlying amount out to the destination account\\n            actualTransferAmountExternal = underlyingToken.transfer(\\n                account,\\n                underlyingAmountExternal.neg()\\n            );\\n            // In this case we're transferring underlying tokens, we want to convert the internal\\n            // asset transfer amount to store in cash balances\\n            assetTransferAmountInternal = assetToken.convertToInternal(assetTransferAmountExternal);\\n        } else {\\n            actualTransferAmountExternal = assetToken.transfer(account, assetTransferAmountExternal);\\n            // Convert the actual transferred amount\\n            assetTransferAmountInternal = assetToken.convertToInternal(actualTransferAmountExternal);\\n        }\\n    }\\n\\n    /// @notice Special method for settling negative current cash debts. This occurs when an account\\n    /// has a negative fCash balance settle to cash. A settler may come and force the account to borrow\\n    /// at the prevailing 3 month rate\\n    /// @dev Use this method to avoid any nToken and transfer logic in finalize which is unnecessary.\\n    function setBalanceStorageForSettleCashDebt(\\n        address account,\\n        CashGroupParameters memory cashGroup,\\n        int256 amountToSettleAsset,\\n        AccountContext memory accountContext\\n    ) internal returns (int256) {\\n        require(amountToSettleAsset >= 0); // dev: amount to settle negative\\n        (int256 cashBalance, int256 nTokenBalance, uint256 lastClaimTime, uint256 lastClaimIntegralSupply) =\\n            getBalanceStorage(account, cashGroup.currencyId);\\n\\n        // Prevents settlement of positive balances\\n        require(cashBalance < 0, \\\"Invalid settle balance\\\");\\n        if (amountToSettleAsset == 0) {\\n            // Symbolizes that the entire debt should be settled\\n            amountToSettleAsset = cashBalance.neg();\\n            cashBalance = 0;\\n        } else {\\n            // A partial settlement of the debt\\n            require(amountToSettleAsset <= cashBalance.neg(), \\\"Invalid amount to settle\\\");\\n            cashBalance = cashBalance.add(amountToSettleAsset);\\n        }\\n\\n        // NOTE: we do not update HAS_CASH_DEBT here because it is possible that the other balances\\n        // also have cash debts\\n        if (cashBalance == 0 && nTokenBalance == 0) {\\n            accountContext.setActiveCurrency(\\n                cashGroup.currencyId,\\n                false,\\n                Constants.ACTIVE_IN_BALANCES\\n            );\\n        }\\n\\n        _setBalanceStorage(\\n            account,\\n            cashGroup.currencyId,\\n            cashBalance,\\n            nTokenBalance,\\n            lastClaimTime,\\n            lastClaimIntegralSupply\\n        );\\n\\n        // Emit the event here, we do not call finalize\\n        emit CashBalanceChange(account, cashGroup.currencyId, amountToSettleAsset);\\n\\n        return amountToSettleAsset;\\n    }\\n\\n    /// @notice Helper method for settling the output of the SettleAssets method\\n    function finalizeSettleAmounts(\\n        address account,\\n        AccountContext memory accountContext,\\n        SettleAmount[] memory settleAmounts\\n    ) internal {\\n        for (uint256 i = 0; i < settleAmounts.length; i++) {\\n            SettleAmount memory amt = settleAmounts[i];\\n            if (amt.netCashChange == 0) continue;\\n\\n            (\\n                int256 cashBalance,\\n                int256 nTokenBalance,\\n                uint256 lastClaimTime,\\n                uint256 lastClaimIntegralSupply\\n            ) = getBalanceStorage(account, amt.currencyId);\\n\\n            cashBalance = cashBalance.add(amt.netCashChange);\\n            accountContext.setActiveCurrency(\\n                amt.currencyId,\\n                cashBalance != 0 || nTokenBalance != 0,\\n                Constants.ACTIVE_IN_BALANCES\\n            );\\n\\n            if (cashBalance < 0) {\\n                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\n            }\\n\\n            emit CashBalanceChange(\\n                account,\\n                uint16(amt.currencyId),\\n                amt.netCashChange\\n            );\\n\\n            _setBalanceStorage(\\n                account,\\n                amt.currencyId,\\n                cashBalance,\\n                nTokenBalance,\\n                lastClaimTime,\\n                lastClaimIntegralSupply\\n            );\\n        }\\n    }\\n\\n    /// @notice Special method for setting balance storage for nToken\\n    function setBalanceStorageForNToken(\\n        address nTokenAddress,\\n        uint256 currencyId,\\n        int256 cashBalance\\n    ) internal {\\n        require(cashBalance >= 0); // dev: invalid nToken cash balance\\n        _setBalanceStorage(nTokenAddress, currencyId, cashBalance, 0, 0, 0);\\n    }\\n\\n    /// @notice increments fees to the reserve\\n    function incrementFeeToReserve(uint256 currencyId, int256 fee) internal {\\n        require(fee >= 0); // dev: invalid fee\\n        // prettier-ignore\\n        (int256 totalReserve, /* */, /* */, /* */) = getBalanceStorage(Constants.RESERVE, currencyId);\\n        totalReserve = totalReserve.add(fee);\\n        _setBalanceStorage(Constants.RESERVE, currencyId, totalReserve, 0, 0, 0);\\n        emit ReserveFeeAccrued(uint16(currencyId), fee);\\n    }\\n\\n    /// @notice Sets internal balance storage.\\n    function _setBalanceStorage(\\n        address account,\\n        uint256 currencyId,\\n        int256 cashBalance,\\n        int256 nTokenBalance,\\n        uint256 lastClaimTime,\\n        uint256 lastClaimIntegralSupply\\n    ) private {\\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\\n        BalanceStorage storage balanceStorage = store[account][currencyId];\\n\\n        require(cashBalance >= type(int88).min && cashBalance <= type(int88).max); // dev: stored cash balance overflow\\n        // Allows for 12 quadrillion nToken balance in 1e8 decimals before overflow\\n        require(nTokenBalance >= 0 && nTokenBalance <= type(uint80).max); // dev: stored nToken balance overflow\\n        require(lastClaimTime <= type(uint32).max); // dev: last claim time overflow\\n\\n        balanceStorage.nTokenBalance = uint80(nTokenBalance);\\n        balanceStorage.lastClaimTime = uint32(lastClaimTime);\\n        balanceStorage.cashBalance = int88(cashBalance);\\n\\n        // Last claim supply is stored in a \\\"floating point\\\" storage slot that does not maintain exact precision but\\n        // is also not limited by storage overflows. `packTo56Bits` will ensure that the the returned value will fit\\n        // in 56 bits (7 bytes)\\n        balanceStorage.packedLastClaimIntegralSupply = FloatingPoint56.packTo56Bits(lastClaimIntegralSupply);\\n    }\\n\\n    /// @notice Gets internal balance storage, nTokens are stored alongside cash balances\\n    function getBalanceStorage(address account, uint256 currencyId)\\n        internal\\n        view\\n        returns (\\n            int256 cashBalance,\\n            int256 nTokenBalance,\\n            uint256 lastClaimTime,\\n            uint256 lastClaimIntegralSupply\\n        )\\n    {\\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\\n        BalanceStorage storage balanceStorage = store[account][currencyId];\\n\\n        nTokenBalance = balanceStorage.nTokenBalance;\\n        lastClaimTime = balanceStorage.lastClaimTime;\\n        lastClaimIntegralSupply = FloatingPoint56.unpackFrom56Bits(balanceStorage.packedLastClaimIntegralSupply);\\n        cashBalance = balanceStorage.cashBalance;\\n    }\\n\\n    /// @notice Loads a balance state memory object\\n    /// @dev Balance state objects occupy a lot of memory slots, so this method allows\\n    /// us to reuse them if possible\\n    function loadBalanceState(\\n        BalanceState memory balanceState,\\n        address account,\\n        uint16 currencyId,\\n        AccountContext memory accountContext\\n    ) internal view {\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\n        balanceState.currencyId = currencyId;\\n\\n        if (accountContext.isActiveInBalances(currencyId)) {\\n            (\\n                balanceState.storedCashBalance,\\n                balanceState.storedNTokenBalance,\\n                balanceState.lastClaimTime,\\n                balanceState.lastClaimIntegralSupply\\n            ) = getBalanceStorage(account, currencyId);\\n        } else {\\n            balanceState.storedCashBalance = 0;\\n            balanceState.storedNTokenBalance = 0;\\n            balanceState.lastClaimTime = 0;\\n            balanceState.lastClaimIntegralSupply = 0;\\n        }\\n\\n        balanceState.netCashChange = 0;\\n        balanceState.netAssetTransferInternalPrecision = 0;\\n        balanceState.netNTokenTransfer = 0;\\n        balanceState.netNTokenSupplyChange = 0;\\n    }\\n\\n    /// @notice Used when manually claiming incentives in nTokenAction. Also sets the balance state\\n    /// to storage to update the lastClaimTime and lastClaimIntegralSupply\\n    function claimIncentivesManual(BalanceState memory balanceState, address account)\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 incentivesClaimed = Incentives.claimIncentives(balanceState, account);\\n        _setBalanceStorage(\\n            account,\\n            balanceState.currencyId,\\n            balanceState.storedCashBalance,\\n            balanceState.storedNTokenBalance,\\n            balanceState.lastClaimTime,\\n            balanceState.lastClaimIntegralSupply\\n        );\\n\\n        return incentivesClaimed;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/portfolio/PortfolioHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./TransferAssets.sol\\\";\\nimport \\\"../valuation/AssetHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\n\\n/// @notice Handles the management of an array of assets including reading from storage, inserting\\n/// updating, deleting and writing back to storage.\\nlibrary PortfolioHandler {\\n    using SafeInt256 for int256;\\n    using AssetHandler for PortfolioAsset;\\n\\n    // Mirror of LibStorage.MAX_PORTFOLIO_ASSETS\\n    uint256 private constant MAX_PORTFOLIO_ASSETS = 16;\\n\\n    /// @notice Primarily used by the TransferAssets library\\n    function addMultipleAssets(PortfolioState memory portfolioState, PortfolioAsset[] memory assets)\\n        internal\\n        pure\\n    {\\n        for (uint256 i = 0; i < assets.length; i++) {\\n            PortfolioAsset memory asset = assets[i];\\n            if (asset.notional == 0) continue;\\n\\n            addAsset(\\n                portfolioState,\\n                asset.currencyId,\\n                asset.maturity,\\n                asset.assetType,\\n                asset.notional\\n            );\\n        }\\n    }\\n\\n    function _mergeAssetIntoArray(\\n        PortfolioAsset[] memory assetArray,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 assetType,\\n        int256 notional\\n    ) private pure returns (bool) {\\n        for (uint256 i = 0; i < assetArray.length; i++) {\\n            PortfolioAsset memory asset = assetArray[i];\\n            if (\\n                asset.assetType != assetType ||\\n                asset.currencyId != currencyId ||\\n                asset.maturity != maturity\\n            ) continue;\\n\\n            // Either of these storage states mean that some error in logic has occurred, we cannot\\n            // store this portfolio\\n            require(\\n                asset.storageState != AssetStorageState.Delete &&\\n                asset.storageState != AssetStorageState.RevertIfStored\\n            ); // dev: portfolio handler deleted storage\\n\\n            int256 newNotional = asset.notional.add(notional);\\n            // Liquidity tokens cannot be reduced below zero.\\n            if (AssetHandler.isLiquidityToken(assetType)) {\\n                require(newNotional >= 0); // dev: portfolio handler negative liquidity token balance\\n            }\\n\\n            require(newNotional >= type(int88).min && newNotional <= type(int88).max); // dev: portfolio handler notional overflow\\n\\n            asset.notional = newNotional;\\n            asset.storageState = AssetStorageState.Update;\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Adds an asset to a portfolio state in memory (does not write to storage)\\n    /// @dev Ensures that only one version of an asset exists in a portfolio (i.e. does not allow two fCash assets of the same maturity\\n    /// to exist in a single portfolio). Also ensures that liquidity tokens do not have a negative notional.\\n    function addAsset(\\n        PortfolioState memory portfolioState,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 assetType,\\n        int256 notional\\n    ) internal pure {\\n        if (\\n            // Will return true if merged\\n            _mergeAssetIntoArray(\\n                portfolioState.storedAssets,\\n                currencyId,\\n                maturity,\\n                assetType,\\n                notional\\n            )\\n        ) return;\\n\\n        if (portfolioState.lastNewAssetIndex > 0) {\\n            bool merged = _mergeAssetIntoArray(\\n                portfolioState.newAssets,\\n                currencyId,\\n                maturity,\\n                assetType,\\n                notional\\n            );\\n            if (merged) return;\\n        }\\n\\n        // At this point if we have not merged the asset then append to the array\\n        // Cannot remove liquidity that the portfolio does not have\\n        if (AssetHandler.isLiquidityToken(assetType)) {\\n            require(notional >= 0); // dev: portfolio handler negative liquidity token balance\\n        }\\n        require(notional >= type(int88).min && notional <= type(int88).max); // dev: portfolio handler notional overflow\\n\\n        // Need to provision a new array at this point\\n        if (portfolioState.lastNewAssetIndex == portfolioState.newAssets.length) {\\n            portfolioState.newAssets = _extendNewAssetArray(portfolioState.newAssets);\\n        }\\n\\n        // Otherwise add to the new assets array. It should not be possible to add matching assets in a single transaction, we will\\n        // check this again when we write to storage. Assigning to memory directly here, do not allocate new memory via struct.\\n        PortfolioAsset memory newAsset = portfolioState.newAssets[portfolioState.lastNewAssetIndex];\\n        newAsset.currencyId = currencyId;\\n        newAsset.maturity = maturity;\\n        newAsset.assetType = assetType;\\n        newAsset.notional = notional;\\n        newAsset.storageState = AssetStorageState.NoChange;\\n        portfolioState.lastNewAssetIndex += 1;\\n    }\\n\\n    /// @dev Extends the new asset array if it is not large enough, this is likely to get a bit expensive if we do\\n    /// it too much\\n    function _extendNewAssetArray(PortfolioAsset[] memory newAssets)\\n        private\\n        pure\\n        returns (PortfolioAsset[] memory)\\n    {\\n        // Double the size of the new asset array every time we have to extend to reduce the number of times\\n        // that we have to extend it. This will go: 0, 1, 2, 4, 8 (probably stops there).\\n        uint256 newLength = newAssets.length == 0 ? 1 : newAssets.length * 2;\\n        PortfolioAsset[] memory extendedArray = new PortfolioAsset[](newLength);\\n        for (uint256 i = 0; i < newAssets.length; i++) {\\n            extendedArray[i] = newAssets[i];\\n        }\\n\\n        return extendedArray;\\n    }\\n\\n    /// @notice Takes a portfolio state and writes it to storage.\\n    /// @dev This method should only be called directly by the nToken. Account updates to portfolios should happen via\\n    /// the storeAssetsAndUpdateContext call in the AccountContextHandler.sol library.\\n    /// @return updated variables to update the account context with\\n    ///     hasDebt: whether or not the portfolio has negative fCash assets\\n    ///     portfolioActiveCurrencies: a byte32 word with all the currencies in the portfolio\\n    ///     uint8: the length of the storage array\\n    ///     uint40: the new nextSettleTime for the portfolio\\n    function storeAssets(PortfolioState memory portfolioState, address account)\\n        internal\\n        returns (\\n            bool,\\n            bytes32,\\n            uint8,\\n            uint40\\n        )\\n    {\\n        bool hasDebt;\\n        // NOTE: cannot have more than 16 assets or this byte object will overflow. Max assets is\\n        // set to 7 and the worst case during liquidation would be 7 liquidity tokens that generate\\n        // 7 additional fCash assets for a total of 14 assets. Although even in this case all assets\\n        // would be of the same currency so it would not change the end result of the active currency\\n        // calculation.\\n        bytes32 portfolioActiveCurrencies;\\n        uint256 nextSettleTime;\\n\\n        for (uint256 i = 0; i < portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\n            // NOTE: this is to prevent the storage of assets that have been modified in the AssetHandler\\n            // during valuation.\\n            require(asset.storageState != AssetStorageState.RevertIfStored);\\n\\n            // Mark any zero notional assets as deleted\\n            if (asset.storageState != AssetStorageState.Delete && asset.notional == 0) {\\n                deleteAsset(portfolioState, i);\\n            }\\n        }\\n\\n        // First delete assets from asset storage to maintain asset storage indexes\\n        for (uint256 i = 0; i < portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\n\\n            if (asset.storageState == AssetStorageState.Delete) {\\n                // Delete asset from storage\\n                uint256 currentSlot = asset.storageSlot;\\n                assembly {\\n                    sstore(currentSlot, 0x00)\\n                }\\n            } else {\\n                if (asset.storageState == AssetStorageState.Update) {\\n                    PortfolioAssetStorage storage assetStorage;\\n                    uint256 currentSlot = asset.storageSlot;\\n                    assembly {\\n                        assetStorage.slot := currentSlot\\n                    }\\n\\n                    _storeAsset(asset, assetStorage);\\n                }\\n\\n                // Update portfolio context for every asset that is in storage, whether it is\\n                // updated in storage or not.\\n                (hasDebt, portfolioActiveCurrencies, nextSettleTime) = _updatePortfolioContext(\\n                    asset,\\n                    hasDebt,\\n                    portfolioActiveCurrencies,\\n                    nextSettleTime\\n                );\\n            }\\n        }\\n\\n        // Add new assets\\n        uint256 assetStorageLength = portfolioState.storedAssetLength;\\n        mapping(address => \\n            PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store = LibStorage.getPortfolioArrayStorage();\\n        PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS] storage storageArray = store[account];\\n        for (uint256 i = 0; i < portfolioState.newAssets.length; i++) {\\n            PortfolioAsset memory asset = portfolioState.newAssets[i];\\n            if (asset.notional == 0) continue;\\n            require(\\n                asset.storageState != AssetStorageState.Delete &&\\n                asset.storageState != AssetStorageState.RevertIfStored\\n            ); // dev: store assets deleted storage\\n\\n            (hasDebt, portfolioActiveCurrencies, nextSettleTime) = _updatePortfolioContext(\\n                asset,\\n                hasDebt,\\n                portfolioActiveCurrencies,\\n                nextSettleTime\\n            );\\n\\n            _storeAsset(asset, storageArray[assetStorageLength]);\\n            assetStorageLength += 1;\\n        }\\n\\n        // 16 is the maximum number of assets or portfolio active currencies will overflow at 32 bytes with\\n        // 2 bytes per currency\\n        require(assetStorageLength <= 16 && nextSettleTime <= type(uint40).max); // dev: portfolio return value overflow\\n        return (\\n            hasDebt,\\n            portfolioActiveCurrencies,\\n            uint8(assetStorageLength),\\n            uint40(nextSettleTime)\\n        );\\n    }\\n\\n    /// @notice Updates context information during the store assets method\\n    function _updatePortfolioContext(\\n        PortfolioAsset memory asset,\\n        bool hasDebt,\\n        bytes32 portfolioActiveCurrencies,\\n        uint256 nextSettleTime\\n    )\\n        private\\n        pure\\n        returns (\\n            bool,\\n            bytes32,\\n            uint256\\n        )\\n    {\\n        uint256 settlementDate = asset.getSettlementDate();\\n        // Tis will set it to the minimum settlement date\\n        if (nextSettleTime == 0 || nextSettleTime > settlementDate) {\\n            nextSettleTime = settlementDate;\\n        }\\n        hasDebt = hasDebt || asset.notional < 0;\\n\\n        require(uint16(uint256(portfolioActiveCurrencies)) == 0); // dev: portfolio active currencies overflow\\n        portfolioActiveCurrencies = (portfolioActiveCurrencies >> 16) | (bytes32(asset.currencyId) << 240);\\n\\n        return (hasDebt, portfolioActiveCurrencies, nextSettleTime);\\n    }\\n\\n    /// @dev Encodes assets for storage\\n    function _storeAsset(\\n        PortfolioAsset memory asset,\\n        PortfolioAssetStorage storage assetStorage\\n    ) internal {\\n        require(0 < asset.currencyId && asset.currencyId <= Constants.MAX_CURRENCIES); // dev: encode asset currency id overflow\\n        require(0 < asset.maturity && asset.maturity <= type(uint40).max); // dev: encode asset maturity overflow\\n        require(0 < asset.assetType && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: encode asset type invalid\\n        require(type(int88).min <= asset.notional && asset.notional <= type(int88).max); // dev: encode asset notional overflow\\n\\n        assetStorage.currencyId = uint16(asset.currencyId);\\n        assetStorage.maturity = uint40(asset.maturity);\\n        assetStorage.assetType = uint8(asset.assetType);\\n        assetStorage.notional = int88(asset.notional);\\n    }\\n\\n    /// @notice Deletes an asset from a portfolio\\n    /// @dev This method should only be called during settlement, assets can only be removed from a portfolio before settlement\\n    /// by adding the offsetting negative position\\n    function deleteAsset(PortfolioState memory portfolioState, uint256 index) internal pure {\\n        require(index < portfolioState.storedAssets.length); // dev: stored assets bounds\\n        require(portfolioState.storedAssetLength > 0); // dev: stored assets length is zero\\n        PortfolioAsset memory assetToDelete = portfolioState.storedAssets[index];\\n        require(\\n            assetToDelete.storageState != AssetStorageState.Delete &&\\n            assetToDelete.storageState != AssetStorageState.RevertIfStored\\n        ); // dev: cannot delete asset\\n\\n        portfolioState.storedAssetLength -= 1;\\n\\n        uint256 maxActiveSlotIndex;\\n        uint256 maxActiveSlot;\\n        // The max active slot is the last storage slot where an asset exists, it's not clear where this will be in the\\n        // array so we search for it here.\\n        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory a = portfolioState.storedAssets[i];\\n            if (a.storageSlot > maxActiveSlot && a.storageState != AssetStorageState.Delete) {\\n                maxActiveSlot = a.storageSlot;\\n                maxActiveSlotIndex = i;\\n            }\\n        }\\n\\n        if (index == maxActiveSlotIndex) {\\n            // In this case we are deleting the asset with the max storage slot so no swap is necessary.\\n            assetToDelete.storageState = AssetStorageState.Delete;\\n            return;\\n        }\\n\\n        // Swap the storage slots of the deleted asset with the last non-deleted asset in the array. Mark them accordingly\\n        // so that when we call store assets they will be updated appropriately\\n        PortfolioAsset memory assetToSwap = portfolioState.storedAssets[maxActiveSlotIndex];\\n        (\\n            assetToSwap.storageSlot,\\n            assetToDelete.storageSlot\\n        ) = (\\n            assetToDelete.storageSlot,\\n            assetToSwap.storageSlot\\n        );\\n        assetToSwap.storageState = AssetStorageState.Update;\\n        assetToDelete.storageState = AssetStorageState.Delete;\\n    }\\n\\n    /// @notice Returns a portfolio array, will be sorted\\n    function getSortedPortfolio(address account, uint8 assetArrayLength)\\n        internal\\n        view\\n        returns (PortfolioAsset[] memory)\\n    {\\n        PortfolioAsset[] memory assets = _loadAssetArray(account, assetArrayLength);\\n        // No sorting required for length of 1\\n        if (assets.length <= 1) return assets;\\n\\n        _sortInPlace(assets);\\n        return assets;\\n    }\\n\\n    /// @notice Builds a portfolio array from storage. The new assets hint parameter will\\n    /// be used to provision a new array for the new assets. This will increase gas efficiency\\n    /// so that we don't have to make copies when we extend the array.\\n    function buildPortfolioState(\\n        address account,\\n        uint8 assetArrayLength,\\n        uint256 newAssetsHint\\n    ) internal view returns (PortfolioState memory) {\\n        PortfolioState memory state;\\n        if (assetArrayLength == 0) return state;\\n\\n        state.storedAssets = getSortedPortfolio(account, assetArrayLength);\\n        state.storedAssetLength = assetArrayLength;\\n        state.newAssets = new PortfolioAsset[](newAssetsHint);\\n\\n        return state;\\n    }\\n\\n    function _sortInPlace(PortfolioAsset[] memory assets) private pure {\\n        uint256 length = assets.length;\\n        uint256[] memory ids = new uint256[](length);\\n        for (uint256 k; k < length; k++) {\\n            PortfolioAsset memory asset = assets[k];\\n            // Prepopulate the ids to calculate just once\\n            ids[k] = TransferAssets.encodeAssetId(asset.currencyId, asset.maturity, asset.assetType);\\n        }\\n\\n        // Uses insertion sort \\n        uint256 i = 1;\\n        while (i < length) {\\n            uint256 j = i;\\n            while (j > 0 && ids[j - 1] > ids[j]) {\\n                // Swap j - 1 and j\\n                (ids[j - 1], ids[j]) = (ids[j], ids[j - 1]);\\n                (assets[j - 1], assets[j]) = (assets[j], assets[j - 1]);\\n                j--;\\n            }\\n            i++;\\n        }\\n    }\\n\\n    function _loadAssetArray(address account, uint8 length)\\n        private\\n        view\\n        returns (PortfolioAsset[] memory)\\n    {\\n        // This will overflow the storage pointer\\n        require(length <= MAX_PORTFOLIO_ASSETS);\\n\\n        mapping(address => \\n            PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store = LibStorage.getPortfolioArrayStorage();\\n        PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS] storage storageArray = store[account];\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](length);\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            PortfolioAssetStorage storage assetStorage = storageArray[i];\\n            PortfolioAsset memory asset = assets[i];\\n            uint256 slot;\\n            assembly {\\n                slot := assetStorage.slot\\n            }\\n\\n            asset.currencyId = assetStorage.currencyId;\\n            asset.maturity = assetStorage.maturity;\\n            asset.assetType = assetStorage.assetType;\\n            asset.notional = assetStorage.notional;\\n            asset.storageSlot = slot;\\n        }\\n\\n        return assets;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math/SafeInt256.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\nimport \\\"../global/Constants.sol\\\";\\n\\nlibrary SafeInt256 {\\n    int256 private constant _INT256_MIN = type(int256).min;\\n\\n    /// @dev Returns the multiplication of two signed integers, reverting on\\n    /// overflow.\\n\\n    /// Counterpart to Solidity's `*` operator.\\n\\n    /// Requirements:\\n\\n    /// - Multiplication cannot overflow.\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = a * b;\\n        if (a == -1) require (b == 0 || c / b == a);\\n        else require (a == 0 || c / a == b);\\n    }\\n\\n    /// @dev Returns the integer division of two signed integers. Reverts on\\n    /// division by zero. The result is rounded towards zero.\\n\\n    /// Counterpart to Solidity's `/` operator. Note: this function uses a\\n    /// `revert` opcode (which leaves remaining gas untouched) while Solidity\\n    /// uses an invalid opcode to revert (consuming all remaining gas).\\n\\n    /// Requirements:\\n\\n    /// - The divisor cannot be zero.\\n\\n    function div(int256 a, int256 b) internal pure returns (int256 c) {\\n        require(!(b == -1 && a == _INT256_MIN)); // dev: int256 div overflow\\n        // NOTE: solidity will automatically revert on divide by zero\\n        c = a / b;\\n    }\\n\\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\\n        //  taken from uniswap v3\\n        require((z = x - y) <= x == (y >= 0));\\n    }\\n\\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\\n        require((z = x + y) >= x == (y >= 0));\\n    }\\n\\n    function neg(int256 x) internal pure returns (int256 y) {\\n        return mul(-1, x);\\n    }\\n\\n    function abs(int256 x) internal pure returns (int256) {\\n        if (x < 0) return neg(x);\\n        else return x;\\n    }\\n\\n    function subNoNeg(int256 x, int256 y) internal pure returns (int256 z) {\\n        z = sub(x, y);\\n        require(z >= 0); // dev: int256 sub to negative\\n\\n        return z;\\n    }\\n\\n    /// @dev Calculates x * RATE_PRECISION / y while checking overflows\\n    function divInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\\n        return div(mul(x, Constants.RATE_PRECISION), y);\\n    }\\n\\n    /// @dev Calculates x * y / RATE_PRECISION while checking overflows\\n    function mulInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\\n        return div(mul(x, y), Constants.RATE_PRECISION);\\n    }\\n\\n    function toUint(int256 x) internal pure returns (uint256) {\\n        require(x >= 0);\\n        return uint256(x);\\n    }\\n\\n    function toInt(uint256 x) internal pure returns (int256) {\\n        require (x <= uint256(type(int256).max)); // dev: toInt overflow\\n        return int256(x);\\n    }\\n\\n    function max(int256 x, int256 y) internal pure returns (int256) {\\n        return x > y ? x : y;\\n    }\\n\\n    function min(int256 x, int256 y) internal pure returns (int256) {\\n        return x < y ? x : y;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/global/LibStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./Types.sol\\\";\\nimport \\\"./Constants.sol\\\";\\n\\nlibrary LibStorage {\\n\\n    /// @dev Offset for the initial slot in lib storage, gives us this number of storage slots\\n    /// available in StorageLayoutV1 and all subsequent storage layouts that inherit from it.\\n    uint256 private constant STORAGE_SLOT_BASE = 1000000;\\n    /// @dev Set to MAX_TRADED_MARKET_INDEX * 2, Solidity does not allow assigning constants from imported values\\n    uint256 private constant NUM_NTOKEN_MARKET_FACTORS = 14;\\n    /// @dev Theoretical maximum for MAX_PORTFOLIO_ASSETS, however, we limit this to MAX_TRADED_MARKET_INDEX\\n    /// in practice. It is possible to exceed that value during liquidation up to 14 potential assets.\\n    uint256 private constant MAX_PORTFOLIO_ASSETS = 16;\\n\\n    /// @dev Storage IDs for storage buckets. Each id maps to an internal storage\\n    /// slot used for a particular mapping\\n    ///     WARNING: APPEND ONLY\\n    enum StorageId {\\n        Unused,\\n        AccountStorage,\\n        nTokenContext,\\n        nTokenAddress,\\n        nTokenDeposit,\\n        nTokenInitialization,\\n        Balance,\\n        Token,\\n        SettlementRate,\\n        CashGroup,\\n        Market,\\n        AssetsBitmap,\\n        ifCashBitmap,\\n        PortfolioArray,\\n        nTokenTotalSupply,\\n        AssetRate,\\n        ExchangeRate\\n    }\\n\\n    /// @dev Mapping from an account address to account context\\n    function getAccountStorage() internal pure \\n        returns (mapping(address => AccountContext) storage store) \\n    {\\n        uint256 slot = _getStorageSlot(StorageId.AccountStorage);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from an nToken address to nTokenContext\\n    function getNTokenContextStorage() internal pure\\n        returns (mapping(address => nTokenContext) storage store) \\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenContext);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to nTokenAddress\\n    function getNTokenAddressStorage() internal pure\\n        returns (mapping(uint256 => address) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenAddress);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to uint32 fixed length array of\\n    /// deposit factors. Deposit shares and leverage thresholds are stored striped to\\n    /// reduce the number of storage reads.\\n    function getNTokenDepositStorage() internal pure\\n        returns (mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenDeposit);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to fixed length array of initialization factors,\\n    /// stored striped like deposit shares.\\n    function getNTokenInitStorage() internal pure\\n        returns (mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenInitialization);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from account to currencyId to it's balance storage for that currency\\n    function getBalanceStorage() internal pure\\n        returns (mapping(address => mapping(uint256 => BalanceStorage)) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.Balance);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to a boolean for underlying or asset token to\\n    /// the TokenStorage\\n    function getTokenStorage() internal pure\\n        returns (mapping(uint256 => mapping(bool => TokenStorage)) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.Token);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to maturity to its corresponding SettlementRate\\n    function getSettlementRateStorage() internal pure\\n        returns (mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.SettlementRate);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to maturity to its tightly packed cash group parameters\\n    function getCashGroupStorage() internal pure\\n        returns (mapping(uint256 => bytes32) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.CashGroup);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to maturity to settlement date for a market\\n    function getMarketStorage() internal pure\\n        returns (mapping(uint256 => mapping(uint256 => mapping(uint256 => MarketStorage))) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.Market);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from account to currency id to its assets bitmap\\n    function getAssetsBitmapStorage() internal pure\\n        returns (mapping(address => mapping(uint256 => bytes32)) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.AssetsBitmap);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from account to currency id to its maturity to its corresponding ifCash balance\\n    function getifCashBitmapStorage() internal pure\\n        returns (mapping(address => mapping(uint256 => mapping(uint256 => ifCashStorage))) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.ifCashBitmap);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from account to its fixed length array of portfolio assets\\n    function getPortfolioArrayStorage() internal pure\\n        returns (mapping(address => PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.PortfolioArray);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from nToken address to its total supply values\\n    function getNTokenTotalSupplyStorage() internal pure\\n        returns (mapping(address => nTokenTotalSupplyStorage) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenTotalSupply);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns the exchange rate between an underlying currency and asset for trading\\n    /// and free collateral. Mapping is from currency id to rate storage object.\\n    function getAssetRateStorage() internal pure\\n        returns (mapping(uint256 => AssetRateStorage) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.AssetRate);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns the exchange rate between an underlying currency and ETH for free\\n    /// collateral purposes. Mapping is from currency id to rate storage object.\\n    function getExchangeRateStorage() internal pure\\n        returns (mapping(uint256 => ETHRateStorage) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.ExchangeRate);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Get the storage slot given a storage ID.\\n    /// @param storageId An entry in `StorageId`\\n    /// @return slot The storage slot.\\n    function _getStorageSlot(StorageId storageId)\\n        private\\n        pure\\n        returns (uint256 slot)\\n    {\\n        // This should never overflow with a reasonable `STORAGE_SLOT_EXP`\\n        // because Solidity will do a range check on `storageId` during the cast.\\n        return uint256(storageId) + STORAGE_SLOT_BASE;\\n    }\\n\\n\\n} \"\r\n    },\r\n    \"contracts/internal/valuation/AssetHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../markets/CashGroup.sol\\\";\\nimport \\\"../markets/AssetRate.sol\\\";\\nimport \\\"../portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../math/ABDKMath64x64.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary AssetHandler {\\n    using SafeMath for uint256;\\n    using SafeInt256 for int256;\\n    using CashGroup for CashGroupParameters;\\n    using AssetRate for AssetRateParameters;\\n\\n    function isLiquidityToken(uint256 assetType) internal pure returns (bool) {\\n        return\\n            assetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\\n            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;\\n    }\\n\\n    /// @notice Liquidity tokens settle every 90 days (not at the designated maturity). This method\\n    /// calculates the settlement date for any PortfolioAsset.\\n    function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {\\n        require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: settlement date invalid asset type\\n        // 3 month tokens and fCash tokens settle at maturity\\n        if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;\\n\\n        uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);\\n        // Liquidity tokens settle at tRef + 90 days. The formula to get a maturity is:\\n        // maturity = tRef + marketLength\\n        // Here we calculate:\\n        // tRef = (maturity - marketLength) + 90 days\\n        return asset.maturity.sub(marketLength).add(Constants.QUARTER);\\n    }\\n\\n    /// @notice Returns the continuously compounded discount rate given an oracle rate and a time to maturity.\\n    /// The formula is: e^(-rate * timeToMaturity).\\n    function getDiscountFactor(uint256 timeToMaturity, uint256 oracleRate)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        int128 expValue =\\n            ABDKMath64x64.fromUInt(oracleRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME));\\n        expValue = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\\n        expValue = ABDKMath64x64.exp(ABDKMath64x64.neg(expValue));\\n        expValue = ABDKMath64x64.mul(expValue, Constants.RATE_PRECISION_64x64);\\n        int256 discountFactor = ABDKMath64x64.toInt(expValue);\\n\\n        return discountFactor;\\n    }\\n\\n    /// @notice Present value of an fCash asset without any risk adjustments.\\n    function getPresentfCashValue(\\n        int256 notional,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        uint256 oracleRate\\n    ) internal pure returns (int256) {\\n        if (notional == 0) return 0;\\n\\n        // NOTE: this will revert if maturity < blockTime. That is the correct behavior because we cannot\\n        // discount matured assets.\\n        uint256 timeToMaturity = maturity.sub(blockTime);\\n        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);\\n\\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor\\n        return notional.mulInRatePrecision(discountFactor);\\n    }\\n\\n    /// @notice Present value of an fCash asset with risk adjustments. Positive fCash value will be discounted more\\n    /// heavily than the oracle rate given and vice versa for negative fCash.\\n    function getRiskAdjustedPresentfCashValue(\\n        CashGroupParameters memory cashGroup,\\n        int256 notional,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        uint256 oracleRate\\n    ) internal pure returns (int256) {\\n        if (notional == 0) return 0;\\n        // NOTE: this will revert if maturity < blockTime. That is the correct behavior because we cannot\\n        // discount matured assets.\\n        uint256 timeToMaturity = maturity.sub(blockTime);\\n\\n        int256 discountFactor;\\n        if (notional > 0) {\\n            // If fCash is positive then discounting by a higher rate will result in a smaller\\n            // discount factor (e ^ -x), meaning a lower positive fCash value.\\n            discountFactor = getDiscountFactor(\\n                timeToMaturity,\\n                oracleRate.add(cashGroup.getfCashHaircut())\\n            );\\n        } else {\\n            uint256 debtBuffer = cashGroup.getDebtBuffer();\\n            // If the adjustment exceeds the oracle rate we floor the value of the fCash\\n            // at the notional value. We don't want to require the account to hold more than\\n            // absolutely required.\\n            if (debtBuffer >= oracleRate) return notional;\\n\\n            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);\\n        }\\n\\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor\\n        return notional.mulInRatePrecision(discountFactor);\\n    }\\n\\n    /// @notice Returns the non haircut claims on cash and fCash by the liquidity token.\\n    function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)\\n        internal\\n        pure\\n        returns (int256 assetCash, int256 fCash)\\n    {\\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset, get cash claims\\n\\n        assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\\n        fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\\n    }\\n\\n    /// @notice Returns the haircut claims on cash and fCash\\n    function getHaircutCashClaims(\\n        PortfolioAsset memory token,\\n        MarketParameters memory market,\\n        CashGroupParameters memory cashGroup\\n    ) internal pure returns (int256 assetCash, int256 fCash) {\\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset get haircut cash claims\\n\\n        require(token.currencyId == cashGroup.currencyId); // dev: haircut cash claims, currency id mismatch\\n        // This won't overflow, the liquidity token haircut is stored as an uint8\\n        int256 haircut = int256(cashGroup.getLiquidityHaircut(token.assetType));\\n\\n        assetCash =\\n            _calcToken(market.totalAssetCash, token.notional, haircut, market.totalLiquidity);\\n\\n        fCash =\\n            _calcToken(market.totalfCash, token.notional, haircut, market.totalLiquidity);\\n\\n        return (assetCash, fCash);\\n    }\\n\\n    /// @dev This is here to clean up the stack in getHaircutCashClaims\\n    function _calcToken(\\n        int256 numerator,\\n        int256 tokens,\\n        int256 haircut,\\n        int256 liquidity\\n    ) private pure returns (int256) {\\n        return numerator.mul(tokens).mul(haircut).div(Constants.PERCENTAGE_DECIMALS).div(liquidity);\\n    }\\n\\n    /// @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)\\n    function getLiquidityTokenValue(\\n        uint256 index,\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        PortfolioAsset[] memory assets,\\n        uint256 blockTime,\\n        bool riskAdjusted\\n    ) internal view returns (int256, int256) {\\n        PortfolioAsset memory liquidityToken = assets[index];\\n\\n        {\\n            (uint256 marketIndex, bool idiosyncratic) =\\n                DateTime.getMarketIndex(\\n                    cashGroup.maxMarketIndex,\\n                    liquidityToken.maturity,\\n                    blockTime\\n                );\\n            // Liquidity tokens can never be idiosyncratic\\n            require(!idiosyncratic); // dev: idiosyncratic liquidity token\\n\\n            // This market will always be initialized, if a liquidity token exists that means the\\n            // market has some liquidity in it.\\n            cashGroup.loadMarket(market, marketIndex, true, blockTime);\\n        }\\n\\n        int256 assetCashClaim;\\n        int256 fCashClaim;\\n        if (riskAdjusted) {\\n            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);\\n        } else {\\n            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);\\n        }\\n\\n        // Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and\\n        // in that case we know the previous asset will be the matching fCash asset\\n        if (index > 0) {\\n            PortfolioAsset memory maybefCash = assets[index - 1];\\n            if (\\n                maybefCash.assetType == Constants.FCASH_ASSET_TYPE &&\\n                maybefCash.currencyId == liquidityToken.currencyId &&\\n                maybefCash.maturity == liquidityToken.maturity\\n            ) {\\n                // Net off the fCashClaim here and we will discount it to present value in the second pass.\\n                // WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!\\n                maybefCash.notional = maybefCash.notional.add(fCashClaim);\\n                // This state will prevent the fCash asset from being stored.\\n                maybefCash.storageState = AssetStorageState.RevertIfStored;\\n                return (assetCashClaim, 0);\\n            }\\n        }\\n\\n        // If not matching fCash asset found then get the pv directly\\n        if (riskAdjusted) {\\n            int256 pv =\\n                getRiskAdjustedPresentfCashValue(\\n                    cashGroup,\\n                    fCashClaim,\\n                    liquidityToken.maturity,\\n                    blockTime,\\n                    market.oracleRate\\n                );\\n\\n            return (assetCashClaim, pv);\\n        } else {\\n            int256 pv =\\n                getPresentfCashValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);\\n\\n            return (assetCashClaim, pv);\\n        }\\n    }\\n\\n    /// @notice Returns present value of all assets in the cash group as asset cash and the updated\\n    /// portfolio index where the function has ended.\\n    /// @return the value of the cash group in asset cash\\n    function getNetCashGroupValue(\\n        PortfolioAsset[] memory assets,\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        uint256 blockTime,\\n        uint256 portfolioIndex\\n    ) internal view returns (int256, uint256) {\\n        int256 presentValueAsset;\\n        int256 presentValueUnderlying;\\n\\n        // First calculate value of liquidity tokens because we need to net off fCash value\\n        // before discounting to present value\\n        for (uint256 i = portfolioIndex; i < assets.length; i++) {\\n            if (!isLiquidityToken(assets[i].assetType)) continue;\\n            if (assets[i].currencyId != cashGroup.currencyId) break;\\n\\n            (int256 assetCashClaim, int256 pv) =\\n                getLiquidityTokenValue(\\n                    i,\\n                    cashGroup,\\n                    market,\\n                    assets,\\n                    blockTime,\\n                    true // risk adjusted\\n                );\\n\\n            presentValueAsset = presentValueAsset.add(assetCashClaim);\\n            presentValueUnderlying = presentValueUnderlying.add(pv);\\n        }\\n\\n        uint256 j = portfolioIndex;\\n        for (; j < assets.length; j++) {\\n            PortfolioAsset memory a = assets[j];\\n            if (a.assetType != Constants.FCASH_ASSET_TYPE) continue;\\n            // If we hit a different currency id then we've accounted for all assets in this currency\\n            // j will mark the index where we don't have this currency anymore\\n            if (a.currencyId != cashGroup.currencyId) break;\\n\\n            uint256 oracleRate = cashGroup.calculateOracleRate(a.maturity, blockTime);\\n\\n            int256 pv =\\n                getRiskAdjustedPresentfCashValue(\\n                    cashGroup,\\n                    a.notional,\\n                    a.maturity,\\n                    blockTime,\\n                    oracleRate\\n                );\\n            presentValueUnderlying = presentValueUnderlying.add(pv);\\n        }\\n\\n        presentValueAsset = presentValueAsset.add(\\n            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)\\n        );\\n\\n        return (presentValueAsset, j);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/portfolio/BitmapAssetsHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../AccountContextHandler.sol\\\";\\nimport \\\"../markets/CashGroup.sol\\\";\\nimport \\\"../valuation/AssetHandler.sol\\\";\\nimport \\\"../../math/Bitmap.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary BitmapAssetsHandler {\\n    using SafeMath for uint256;\\n    using SafeInt256 for int256;\\n    using Bitmap for bytes32;\\n    using CashGroup for CashGroupParameters;\\n    using AccountContextHandler for AccountContext;\\n\\n    function getAssetsBitmap(address account, uint256 currencyId) internal view returns (bytes32 assetsBitmap) {\\n        mapping(address => mapping(uint256 => bytes32)) storage store = LibStorage.getAssetsBitmapStorage();\\n        return store[account][currencyId];\\n    }\\n\\n    function setAssetsBitmap(\\n        address account,\\n        uint256 currencyId,\\n        bytes32 assetsBitmap\\n    ) internal {\\n        require(assetsBitmap.totalBitsSet() <= Constants.MAX_BITMAP_ASSETS, \\\"Over max assets\\\");\\n        mapping(address => mapping(uint256 => bytes32)) storage store = LibStorage.getAssetsBitmapStorage();\\n        store[account][currencyId] = assetsBitmap;\\n    }\\n\\n    function getifCashNotional(\\n        address account,\\n        uint256 currencyId,\\n        uint256 maturity\\n    ) internal view returns (int256 notional) {\\n        mapping(address => mapping(uint256 =>\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\n        return store[account][currencyId][maturity].notional;\\n    }\\n\\n    /// @notice Adds multiple assets to a bitmap portfolio\\n    function addMultipleifCashAssets(\\n        address account,\\n        AccountContext memory accountContext,\\n        PortfolioAsset[] memory assets\\n    ) internal {\\n        require(accountContext.isBitmapEnabled()); // dev: bitmap currency not set\\n        uint256 currencyId = accountContext.bitmapCurrencyId;\\n\\n        for (uint256 i; i < assets.length; i++) {\\n            PortfolioAsset memory asset = assets[i];\\n            if (asset.notional == 0) continue;\\n\\n            require(asset.currencyId == currencyId); // dev: invalid asset in set ifcash assets\\n            require(asset.assetType == Constants.FCASH_ASSET_TYPE); // dev: invalid asset in set ifcash assets\\n            int256 finalNotional;\\n\\n            finalNotional = addifCashAsset(\\n                account,\\n                currencyId,\\n                asset.maturity,\\n                accountContext.nextSettleTime,\\n                asset.notional\\n            );\\n\\n            if (finalNotional < 0)\\n                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\n        }\\n    }\\n\\n    /// @notice Add an ifCash asset in the bitmap and mapping. Updates the bitmap in memory\\n    /// but not in storage.\\n    /// @return the updated assets bitmap and the final notional amount\\n    function addifCashAsset(\\n        address account,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 nextSettleTime,\\n        int256 notional\\n    ) internal returns (int256) {\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\n        mapping(address => mapping(uint256 =>\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\n        ifCashStorage storage fCashSlot = store[account][currencyId][maturity];\\n        (uint256 bitNum, bool isExact) = DateTime.getBitNumFromMaturity(nextSettleTime, maturity);\\n        require(isExact); // dev: invalid maturity in set ifcash asset\\n\\n        if (assetsBitmap.isBitSet(bitNum)) {\\n            // Bit is set so we read and update the notional amount\\n            int256 finalNotional = notional.add(fCashSlot.notional);\\n            require(type(int128).min <= finalNotional && finalNotional <= type(int128).max); // dev: bitmap notional overflow\\n            fCashSlot.notional = int128(finalNotional);\\n\\n            // If the new notional is zero then turn off the bit\\n            if (finalNotional == 0) {\\n                assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            }\\n\\n            setAssetsBitmap(account, currencyId, assetsBitmap);\\n            return finalNotional;\\n        }\\n\\n        if (notional != 0) {\\n            // Bit is not set so we turn it on and update the mapping directly, no read required.\\n            require(type(int128).min <= notional && notional <= type(int128).max); // dev: bitmap notional overflow\\n            fCashSlot.notional = int128(notional);\\n\\n            assetsBitmap = assetsBitmap.setBit(bitNum, true);\\n            setAssetsBitmap(account, currencyId, assetsBitmap);\\n        }\\n\\n        return notional;\\n    }\\n\\n    /// @notice Returns the present value of an asset\\n    function _getPresentValue(\\n        address account,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        CashGroupParameters memory cashGroup,\\n        bool riskAdjusted\\n    ) private view returns (int256) {\\n        int256 notional = getifCashNotional(account, currencyId, maturity);\\n\\n        // In this case the asset has matured and the total value is just the notional amount\\n        if (maturity <= blockTime) {\\n            return notional;\\n        } else {\\n            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);\\n            if (riskAdjusted) {\\n                return AssetHandler.getRiskAdjustedPresentfCashValue(\\n                    cashGroup,\\n                    notional,\\n                    maturity,\\n                    blockTime,\\n                    oracleRate\\n                );\\n            } else {\\n                return AssetHandler.getPresentfCashValue(\\n                    notional,\\n                    maturity,\\n                    blockTime,\\n                    oracleRate\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @notice Get the net present value of all the ifCash assets\\n    function getifCashNetPresentValue(\\n        address account,\\n        uint256 currencyId,\\n        uint256 nextSettleTime,\\n        uint256 blockTime,\\n        CashGroupParameters memory cashGroup,\\n        bool riskAdjusted\\n    ) internal view returns (int256 totalValueUnderlying, bool hasDebt) {\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\n\\n        while (bitNum != 0) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);\\n            int256 pv = _getPresentValue(\\n                account,\\n                currencyId,\\n                maturity,\\n                blockTime,\\n                cashGroup,\\n                riskAdjusted\\n            );\\n            totalValueUnderlying = totalValueUnderlying.add(pv);\\n\\n            if (pv < 0) hasDebt = true;\\n\\n            // Turn off the bit and look for the next one\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            bitNum = assetsBitmap.getNextBitNum();\\n        }\\n    }\\n\\n    /// @notice Returns the ifCash assets as an array\\n    function getifCashArray(\\n        address account,\\n        uint256 currencyId,\\n        uint256 nextSettleTime\\n    ) internal view returns (PortfolioAsset[] memory) {\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\n        uint256 index = assetsBitmap.totalBitsSet();\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](index);\\n        index = 0;\\n\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\n        while (bitNum != 0) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);\\n            int256 notional = getifCashNotional(account, currencyId, maturity);\\n\\n            PortfolioAsset memory asset = assets[index];\\n            asset.currencyId = currencyId;\\n            asset.maturity = maturity;\\n            asset.assetType = Constants.FCASH_ASSET_TYPE;\\n            asset.notional = notional;\\n            index += 1;\\n\\n            // Turn off the bit and look for the next one\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            bitNum = assetsBitmap.getNextBitNum();\\n        }\\n\\n        return assets;\\n    }\\n\\n    /// @notice Used to reduce an nToken ifCash assets portfolio proportionately when redeeming\\n    /// nTokens to its underlying assets.\\n    function reduceifCashAssetsProportional(\\n        address account,\\n        uint256 currencyId,\\n        uint256 nextSettleTime,\\n        int256 tokensToRedeem,\\n        int256 totalSupply\\n    ) internal returns (PortfolioAsset[] memory) {\\n        // It is not possible to redeem the entire token supply because some liquidity tokens must remain\\n        // in the liquidity token portfolio in order to re-initialize markets.\\n        require(tokensToRedeem < totalSupply, \\\"Cannot redeem\\\");\\n\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\n        uint256 index = assetsBitmap.totalBitsSet();\\n        mapping(address => mapping(uint256 =>\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\n\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](index);\\n        index = 0;\\n\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\n        while (bitNum != 0) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);\\n            ifCashStorage storage fCashSlot = store[account][currencyId][maturity];\\n            int256 notional = fCashSlot.notional;\\n\\n            int256 notionalToTransfer = notional.mul(tokensToRedeem).div(totalSupply);\\n            int256 finalNotional = notional.sub(notionalToTransfer);\\n\\n            require(type(int128).min <= finalNotional && finalNotional <= type(int128).max); // dev: bitmap notional overflow\\n            fCashSlot.notional = int128(finalNotional);\\n\\n            PortfolioAsset memory asset = assets[index];\\n            asset.currencyId = currencyId;\\n            asset.maturity = maturity;\\n            asset.assetType = Constants.FCASH_ASSET_TYPE;\\n            asset.notional = notionalToTransfer;\\n            index += 1;\\n\\n            // Turn off the bit and look for the next one\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            bitNum = assetsBitmap.getNextBitNum();\\n        }\\n\\n        return assets;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/global/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\nimport \\\"interfaces/notional/AssetRateAdapter.sol\\\";\\n\\n/// @notice Different types of internal tokens\\n///  - UnderlyingToken: underlying asset for a cToken (except for Ether)\\n///  - cToken: Compound interest bearing token\\n///  - cETH: Special handling for cETH tokens\\n///  - Ether: the one and only\\n///  - NonMintable: tokens that do not have an underlying (therefore not cTokens)\\nenum TokenType {UnderlyingToken, cToken, cETH, Ether, NonMintable}\\n\\n/// @notice Specifies the different trade action types in the system. Each trade action type is\\n/// encoded in a tightly packed bytes32 object. Trade action type is the first big endian byte of the\\n/// 32 byte trade action object. The schemas for each trade action type are defined below.\\nenum TradeActionType {\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 minImpliedRate, uint120 unused)\\n    Lend,\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint128 unused)\\n    Borrow,\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 assetCashAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\\n    AddLiquidity,\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 tokenAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\\n    RemoveLiquidity,\\n    // (uint8 TradeActionType, uint32 Maturity, int88 fCashResidualAmount, uint128 unused)\\n    PurchaseNTokenResidual,\\n    // (uint8 TradeActionType, address CounterpartyAddress, int88 fCashAmountToSettle)\\n    SettleCashDebt\\n}\\n\\n/// @notice Specifies different deposit actions that can occur during BalanceAction or BalanceActionWithTrades\\nenum DepositActionType {\\n    // No deposit action\\n    None,\\n    // Deposit asset cash, depositActionAmount is specified in asset cash external precision\\n    DepositAsset,\\n    // Deposit underlying tokens that are mintable to asset cash, depositActionAmount is specified in underlying token\\n    // external precision\\n    DepositUnderlying,\\n    // Deposits specified asset cash external precision amount into an nToken and mints the corresponding amount of\\n    // nTokens into the account\\n    DepositAssetAndMintNToken,\\n    // Deposits specified underlying in external precision, mints asset cash, and uses that asset cash to mint nTokens\\n    DepositUnderlyingAndMintNToken,\\n    // Redeems an nToken balance to asset cash. depositActionAmount is specified in nToken precision. Considered a deposit action\\n    // because it deposits asset cash into an account. If there are fCash residuals that cannot be sold off, will revert.\\n    RedeemNToken,\\n    // Converts specified amount of asset cash balance already in Notional to nTokens. depositActionAmount is specified in\\n    // Notional internal 8 decimal precision.\\n    ConvertCashToNToken\\n}\\n\\n/// @notice Used internally for PortfolioHandler state\\nenum AssetStorageState {NoChange, Update, Delete, RevertIfStored}\\n\\n/****** Calldata objects ******/\\n\\n/// @notice Defines a balance action for batchAction\\nstruct BalanceAction {\\n    // Deposit action to take (if any)\\n    DepositActionType actionType;\\n    uint16 currencyId;\\n    // Deposit action amount must correspond to the depositActionType, see documentation above.\\n    uint256 depositActionAmount;\\n    // Withdraw an amount of asset cash specified in Notional internal 8 decimal precision\\n    uint256 withdrawAmountInternalPrecision;\\n    // If set to true, will withdraw entire cash balance. Useful if there may be an unknown amount of asset cash\\n    // residual left from trading.\\n    bool withdrawEntireCashBalance;\\n    // If set to true, will redeem asset cash to the underlying token on withdraw.\\n    bool redeemToUnderlying;\\n}\\n\\n/// @notice Defines a balance action with a set of trades to do as well\\nstruct BalanceActionWithTrades {\\n    DepositActionType actionType;\\n    uint16 currencyId;\\n    uint256 depositActionAmount;\\n    uint256 withdrawAmountInternalPrecision;\\n    bool withdrawEntireCashBalance;\\n    bool redeemToUnderlying;\\n    // Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\\n    bytes32[] trades;\\n}\\n\\n/****** In memory objects ******/\\n/// @notice Internal object that represents settled cash balances\\nstruct SettleAmount {\\n    uint256 currencyId;\\n    int256 netCashChange;\\n}\\n\\n/// @notice Internal object that represents a token\\nstruct Token {\\n    address tokenAddress;\\n    bool hasTransferFee;\\n    int256 decimals;\\n    TokenType tokenType;\\n    uint256 maxCollateralBalance;\\n}\\n\\n/// @notice Internal object that represents an nToken portfolio\\nstruct nTokenPortfolio {\\n    CashGroupParameters cashGroup;\\n    PortfolioState portfolioState;\\n    int256 totalSupply;\\n    int256 cashBalance;\\n    uint256 lastInitializedTime;\\n    bytes6 parameters;\\n    address tokenAddress;\\n}\\n\\n/// @notice Internal object used during liquidation\\nstruct LiquidationFactors {\\n    address account;\\n    // Aggregate free collateral of the account denominated in ETH underlying, 8 decimal precision\\n    int256 netETHValue;\\n    // Amount of net local currency asset cash before haircuts and buffers available\\n    int256 localAssetAvailable;\\n    // Amount of net collateral currency asset cash before haircuts and buffers available\\n    int256 collateralAssetAvailable;\\n    // Haircut value of nToken holdings denominated in asset cash, will be local or collateral nTokens based\\n    // on liquidation type\\n    int256 nTokenHaircutAssetValue;\\n    // nToken parameters for calculating liquidation amount\\n    bytes6 nTokenParameters;\\n    // ETH exchange rate from local currency to ETH\\n    ETHRate localETHRate;\\n    // ETH exchange rate from collateral currency to ETH\\n    ETHRate collateralETHRate;\\n    // Asset rate for the local currency, used in cross currency calculations to calculate local asset cash required\\n    AssetRateParameters localAssetRate;\\n    // Used during currency liquidations if the account has liquidity tokens\\n    CashGroupParameters collateralCashGroup;\\n    // Used during currency liquidations if it is only a calculation, defaults to false\\n    bool isCalculation;\\n}\\n\\n/// @notice Internal asset array portfolio state\\nstruct PortfolioState {\\n    // Array of currently stored assets\\n    PortfolioAsset[] storedAssets;\\n    // Array of new assets to add\\n    PortfolioAsset[] newAssets;\\n    uint256 lastNewAssetIndex;\\n    // Holds the length of stored assets after accounting for deleted assets\\n    uint256 storedAssetLength;\\n}\\n\\n/// @notice In memory ETH exchange rate used during free collateral calculation.\\nstruct ETHRate {\\n    // The decimals (i.e. 10^rateDecimalPlaces) of the exchange rate, defined by the rate oracle\\n    int256 rateDecimals;\\n    // The exchange rate from base to ETH (if rate invert is required it is already done)\\n    int256 rate;\\n    // Amount of buffer as a multiple with a basis of 100 applied to negative balances.\\n    int256 buffer;\\n    // Amount of haircut as a multiple with a basis of 100 applied to positive balances\\n    int256 haircut;\\n    // Liquidation discount as a multiple with a basis of 100 applied to the exchange rate\\n    // as an incentive given to liquidators.\\n    int256 liquidationDiscount;\\n}\\n\\n/// @notice Internal object used to handle balance state during a transaction\\nstruct BalanceState {\\n    uint16 currencyId;\\n    // Cash balance stored in balance state at the beginning of the transaction\\n    int256 storedCashBalance;\\n    // nToken balance stored at the beginning of the transaction\\n    int256 storedNTokenBalance;\\n    // The net cash change as a result of asset settlement or trading\\n    int256 netCashChange;\\n    // Net asset transfers into or out of the account\\n    int256 netAssetTransferInternalPrecision;\\n    // Net token transfers into or out of the account\\n    int256 netNTokenTransfer;\\n    // Net token supply change from minting or redeeming\\n    int256 netNTokenSupplyChange;\\n    // The last time incentives were claimed for this currency\\n    uint256 lastClaimTime;\\n    // The last integral supply amount when tokens were claimed\\n    uint256 lastClaimIntegralSupply;\\n}\\n\\n/// @dev Asset rate used to convert between underlying cash and asset cash\\nstruct AssetRateParameters {\\n    // Address of the asset rate oracle\\n    AssetRateAdapter rateOracle;\\n    // The exchange rate from base to quote (if invert is required it is already done)\\n    int256 rate;\\n    // The decimals of the underlying, the rate converts to the underlying decimals\\n    int256 underlyingDecimals;\\n}\\n\\n/// @dev Cash group when loaded into memory\\nstruct CashGroupParameters {\\n    uint16 currencyId;\\n    uint256 maxMarketIndex;\\n    AssetRateParameters assetRate;\\n    bytes32 data;\\n}\\n\\n/// @dev A portfolio asset when loaded in memory\\nstruct PortfolioAsset {\\n    // Asset currency id\\n    uint256 currencyId;\\n    uint256 maturity;\\n    // Asset type, fCash or liquidity token.\\n    uint256 assetType;\\n    // fCash amount or liquidity token amount\\n    int256 notional;\\n    // Used for managing portfolio asset state\\n    uint256 storageSlot;\\n    // The state of the asset for when it is written to storage\\n    AssetStorageState storageState;\\n}\\n\\n/// @dev Market object as represented in memory\\nstruct MarketParameters {\\n    bytes32 storageSlot;\\n    uint256 maturity;\\n    // Total amount of fCash available for purchase in the market.\\n    int256 totalfCash;\\n    // Total amount of cash available for purchase in the market.\\n    int256 totalAssetCash;\\n    // Total amount of liquidity tokens (representing a claim on liquidity) in the market.\\n    int256 totalLiquidity;\\n    // This is the previous annualized interest rate in RATE_PRECISION that the market traded\\n    // at. This is used to calculate the rate anchor to smooth interest rates over time.\\n    uint256 lastImpliedRate;\\n    // Time lagged version of lastImpliedRate, used to value fCash assets at market rates while\\n    // remaining resistent to flash loan attacks.\\n    uint256 oracleRate;\\n    // This is the timestamp of the previous trade\\n    uint256 previousTradeTime;\\n}\\n\\n/****** Storage objects ******/\\n\\n/// @dev Token object in storage:\\n///  20 bytes for token address\\n///  1 byte for hasTransferFee\\n///  1 byte for tokenType\\n///  1 byte for tokenDecimals\\n///  9 bytes for maxCollateralBalance (may not always be set)\\nstruct TokenStorage {\\n    // Address of the token\\n    address tokenAddress;\\n    // Transfer fees will change token deposit behavior\\n    bool hasTransferFee;\\n    TokenType tokenType;\\n    uint8 decimalPlaces;\\n    // Upper limit on how much of this token the contract can hold at any time\\n    uint72 maxCollateralBalance;\\n}\\n\\n/// @dev Exchange rate object as it is represented in storage, total storage is 25 bytes.\\nstruct ETHRateStorage {\\n    // Address of the rate oracle\\n    AggregatorV2V3Interface rateOracle;\\n    // The decimal places of precision that the rate oracle uses\\n    uint8 rateDecimalPlaces;\\n    // True of the exchange rate must be inverted\\n    bool mustInvert;\\n    // NOTE: both of these governance values are set with BUFFER_DECIMALS precision\\n    // Amount of buffer to apply to the exchange rate for negative balances.\\n    uint8 buffer;\\n    // Amount of haircut to apply to the exchange rate for positive balances\\n    uint8 haircut;\\n    // Liquidation discount in percentage point terms, 106 means a 6% discount\\n    uint8 liquidationDiscount;\\n}\\n\\n/// @dev Asset rate oracle object as it is represented in storage, total storage is 21 bytes.\\nstruct AssetRateStorage {\\n    // Address of the rate oracle\\n    AssetRateAdapter rateOracle;\\n    // The decimal places of the underlying asset\\n    uint8 underlyingDecimalPlaces;\\n}\\n\\n/// @dev Governance parameters for a cash group, total storage is 9 bytes + 7 bytes for liquidity token haircuts\\n/// and 7 bytes for rate scalars, total of 23 bytes. Note that this is stored packed in the storage slot so there\\n/// are no indexes stored for liquidityTokenHaircuts or rateScalars, maxMarketIndex is used instead to determine the\\n/// length.\\nstruct CashGroupSettings {\\n    // Index of the AMMs on chain that will be made available. Idiosyncratic fCash\\n    // that is dated less than the longest AMM will be tradable.\\n    uint8 maxMarketIndex;\\n    // Time window in 5 minute increments that the rate oracle will be averaged over\\n    uint8 rateOracleTimeWindow5Min;\\n    // Total fees per trade, specified in BPS\\n    uint8 totalFeeBPS;\\n    // Share of the fees given to the protocol, denominated in percentage\\n    uint8 reserveFeeShare;\\n    // Debt buffer specified in 5 BPS increments\\n    uint8 debtBuffer5BPS;\\n    // fCash haircut specified in 5 BPS increments\\n    uint8 fCashHaircut5BPS;\\n    // If an account has a negative cash balance, it can be settled by incurring debt at the 3 month market. This\\n    // is the basis points for the penalty rate that will be added the current 3 month oracle rate.\\n    uint8 settlementPenaltyRate5BPS;\\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\\n    uint8 liquidationfCashHaircut5BPS;\\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\\n    uint8 liquidationDebtBuffer5BPS;\\n    // Liquidity token haircut applied to cash claims, specified as a percentage between 0 and 100\\n    uint8[] liquidityTokenHaircuts;\\n    // Rate scalar used to determine the slippage of the market\\n    uint8[] rateScalars;\\n}\\n\\n/// @dev Holds account level context information used to determine settlement and\\n/// free collateral actions. Total storage is 28 bytes\\nstruct AccountContext {\\n    // Used to check when settlement must be triggered on an account\\n    uint40 nextSettleTime;\\n    // For lenders that never incur debt, we use this flag to skip the free collateral check.\\n    bytes1 hasDebt;\\n    // Length of the account's asset array\\n    uint8 assetArrayLength;\\n    // If this account has bitmaps set, this is the corresponding currency id\\n    uint16 bitmapCurrencyId;\\n    // 9 total active currencies possible (2 bytes each)\\n    bytes18 activeCurrencies;\\n}\\n\\n/// @dev Holds nToken context information mapped via the nToken address, total storage is\\n/// 16 bytes\\nstruct nTokenContext {\\n    // Currency id that the nToken represents\\n    uint16 currencyId;\\n    // Annual incentive emission rate denominated in WHOLE TOKENS (multiply by \\n    // INTERNAL_TOKEN_PRECISION to get the actual rate)\\n    uint32 incentiveAnnualEmissionRate;\\n    // The last block time at utc0 that the nToken was initialized at, zero if it\\n    // has never been initialized\\n    uint32 lastInitializedTime;\\n    // Length of the asset array, refers to the number of liquidity tokens an nToken\\n    // currently holds\\n    uint8 assetArrayLength;\\n    // Each byte is a specific nToken parameter\\n    bytes5 nTokenParameters;\\n}\\n\\n/// @dev Holds account balance information, total storage 32 bytes\\nstruct BalanceStorage {\\n    // Number of nTokens held by the account\\n    uint80 nTokenBalance;\\n    // Last time the account claimed their nTokens\\n    uint32 lastClaimTime;\\n    // The total integral supply of the nToken at the last claim time packed into\\n    // 56 bits. There is some loss of precision here but it is acceptable\\n    uint56 packedLastClaimIntegralSupply;\\n    // Cash balance of the account\\n    int88 cashBalance;\\n}\\n\\n/// @dev Holds information about a settlement rate, total storage 25 bytes\\nstruct SettlementRateStorage {\\n    uint40 blockTime;\\n    uint128 settlementRate;\\n    uint8 underlyingDecimalPlaces;\\n}\\n\\n/// @dev Holds information about a market, total storage is 42 bytes so this spans\\n/// two storage words\\nstruct MarketStorage {\\n    // Total fCash in the market\\n    uint80 totalfCash;\\n    // Total asset cash in the market\\n    uint80 totalAssetCash;\\n    // Last annualized interest rate the market traded at\\n    uint32 lastImpliedRate;\\n    // Last recorded oracle rate for the market\\n    uint32 oracleRate;\\n    // Last time a trade was made\\n    uint32 previousTradeTime;\\n    // This is stored in slot + 1\\n    uint80 totalLiquidity;\\n}\\n\\nstruct ifCashStorage {\\n    // Notional amount of fCash at the slot, limited to int128 to allow for\\n    // future expansion\\n    int128 notional;\\n}\\n\\n/// @dev A single portfolio asset in storage, total storage of 19 bytes\\nstruct PortfolioAssetStorage {\\n    // Currency Id for the asset\\n    uint16 currencyId;\\n    // Maturity of the asset\\n    uint40 maturity;\\n    // Asset type (fCash or Liquidity Token marker)\\n    uint8 assetType;\\n    // Notional\\n    int88 notional;\\n}\\n\\n/// @dev nToken total supply factors for the nToken, includes factors related\\n/// to claiming incentives, total storage 32 bytes\\nstruct nTokenTotalSupplyStorage {\\n    // Total supply of the nToken\\n    uint96 totalSupply;\\n    // Integral of the total supply used for calculating the average total supply\\n    uint128 integralTotalSupply;\\n    // Last timestamp the supply value changed, used for calculating the integralTotalSupply\\n    uint32 lastSupplyChangeTime;\\n}\\n\\n/// @dev Used in view methods to return account balances in a developer friendly manner\\nstruct AccountBalance {\\n    uint16 currencyId;\\n    int256 cashBalance;\\n    int256 nTokenBalance;\\n    uint256 lastClaimTime;\\n    uint256 lastClaimIntegralSupply;\\n}\\n\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\\n{\\n}\"\r\n    },\r\n    \"interfaces/notional/AssetRateAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-v3\\npragma solidity >=0.7.0;\\n\\n/// @notice Used as a wrapper for tokens that are interest bearing for an\\n/// underlying token. Follows the cToken interface, however, can be adapted\\n/// for other interest bearing tokens.\\ninterface AssetRateAdapter {\\n    function token() external view returns (address);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    function underlying() external view returns (address);\\n\\n    function getExchangeRateStateful() external returns (int256);\\n\\n    function getExchangeRateView() external view returns (int256);\\n\\n    function getAnnualizedSupplyRate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n  function latestTimestamp() external view returns (uint256);\\n  function latestRound() external view returns (uint256);\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\"\r\n    },\r\n    \"contracts/internal/markets/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary DateTime {\\n    using SafeMath for uint256;\\n\\n    /// @notice Returns the current reference time which is how all the AMM dates are calculated.\\n    function getReferenceTime(uint256 blockTime) internal pure returns (uint256) {\\n        require(blockTime >= Constants.QUARTER);\\n        return blockTime - (blockTime % Constants.QUARTER);\\n    }\\n\\n    /// @notice Truncates a date to midnight UTC time\\n    function getTimeUTC0(uint256 time) internal pure returns (uint256) {\\n        require(time >= Constants.DAY);\\n        return time - (time % Constants.DAY);\\n    }\\n\\n    /// @notice These are the predetermined market offsets for trading\\n    /// @dev Markets are 1-indexed because the 0 index means that no markets are listed for the cash group.\\n    function getTradedMarket(uint256 index) internal pure returns (uint256) {\\n        if (index == 1) return Constants.QUARTER;\\n        if (index == 2) return 2 * Constants.QUARTER;\\n        if (index == 3) return Constants.YEAR;\\n        if (index == 4) return 2 * Constants.YEAR;\\n        if (index == 5) return 5 * Constants.YEAR;\\n        if (index == 6) return 10 * Constants.YEAR;\\n        if (index == 7) return 20 * Constants.YEAR;\\n\\n        revert(\\\"Invalid index\\\");\\n    }\\n\\n    /// @notice Determines if the maturity falls on one of the valid on chain market dates.\\n    function isValidMarketMaturity(\\n        uint256 maxMarketIndex,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal pure returns (bool) {\\n        require(maxMarketIndex > 0, \\\"CG: no markets listed\\\");\\n        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, \\\"CG: market index bound\\\");\\n\\n        if (maturity % Constants.QUARTER != 0) return false;\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n\\n        for (uint256 i = 1; i <= maxMarketIndex; i++) {\\n            if (maturity == tRef.add(DateTime.getTradedMarket(i))) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Determines if an idiosyncratic maturity is valid and returns the bit reference that is the case.\\n    function isValidMaturity(\\n        uint256 maxMarketIndex,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal pure returns (bool) {\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n        uint256 maxMaturity = tRef.add(DateTime.getTradedMarket(maxMarketIndex));\\n        // Cannot trade past max maturity\\n        if (maturity > maxMaturity) return false;\\n\\n        // prettier-ignore\\n        (/* */, bool isValid) = DateTime.getBitNumFromMaturity(blockTime, maturity);\\n        return isValid;\\n    }\\n\\n    /// @notice Returns the market index for a given maturity, if the maturity is idiosyncratic\\n    /// will return the nearest market index that is larger than the maturity.\\n    /// @return uint marketIndex, bool isIdiosyncratic\\n    function getMarketIndex(\\n        uint256 maxMarketIndex,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal pure returns (uint256, bool) {\\n        require(maxMarketIndex > 0, \\\"CG: no markets listed\\\");\\n        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, \\\"CG: market index bound\\\");\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n\\n        for (uint256 i = 1; i <= maxMarketIndex; i++) {\\n            uint256 marketMaturity = tRef.add(DateTime.getTradedMarket(i));\\n            // If market matches then is not idiosyncratic\\n            if (marketMaturity == maturity) return (i, false);\\n            // Returns the market that is immediately greater than the maturity\\n            if (marketMaturity > maturity) return (i, true);\\n        }\\n\\n        revert(\\\"CG: no market found\\\");\\n    }\\n\\n    /// @notice Given a bit number and the reference time of the first bit, returns the bit number\\n    /// of a given maturity.\\n    /// @return bitNum and a true or false if the maturity falls on the exact bit\\n    function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)\\n        internal\\n        pure\\n        returns (uint256, bool)\\n    {\\n        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);\\n\\n        // Maturities must always divide days evenly\\n        if (maturity % Constants.DAY != 0) return (0, false);\\n        // Maturity cannot be in the past\\n        if (blockTimeUTC0 >= maturity) return (0, false);\\n\\n        // Overflow check done above\\n        // daysOffset has no remainders, checked above\\n        uint256 daysOffset = (maturity - blockTimeUTC0) / Constants.DAY;\\n\\n        // These if statements need to fall through to the next one\\n        if (daysOffset <= Constants.MAX_DAY_OFFSET) {\\n            return (daysOffset, true);\\n        } else if (daysOffset <= Constants.MAX_WEEK_OFFSET) {\\n            // (daysOffset - MAX_DAY_OFFSET) is the days overflow into the week portion, must be > 0\\n            // (blockTimeUTC0 % WEEK) / DAY is the offset into the week portion\\n            // This returns the offset from the previous max offset in days\\n            uint256 offsetInDays =\\n                daysOffset -\\n                    Constants.MAX_DAY_OFFSET +\\n                    (blockTimeUTC0 % Constants.WEEK) /\\n                    Constants.DAY;\\n            \\n            return (\\n                // This converts the offset in days to its corresponding bit position, truncating down\\n                // if it does not divide evenly into DAYS_IN_WEEK\\n                Constants.WEEK_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_WEEK,\\n                (offsetInDays % Constants.DAYS_IN_WEEK) == 0\\n            );\\n        } else if (daysOffset <= Constants.MAX_MONTH_OFFSET) {\\n            uint256 offsetInDays =\\n                daysOffset -\\n                    Constants.MAX_WEEK_OFFSET +\\n                    (blockTimeUTC0 % Constants.MONTH) /\\n                    Constants.DAY;\\n\\n            return (\\n                Constants.MONTH_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_MONTH,\\n                (offsetInDays % Constants.DAYS_IN_MONTH) == 0\\n            );\\n        } else if (daysOffset <= Constants.MAX_QUARTER_OFFSET) {\\n            uint256 offsetInDays =\\n                daysOffset -\\n                    Constants.MAX_MONTH_OFFSET +\\n                    (blockTimeUTC0 % Constants.QUARTER) /\\n                    Constants.DAY;\\n\\n            return (\\n                Constants.QUARTER_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_QUARTER,\\n                (offsetInDays % Constants.DAYS_IN_QUARTER) == 0\\n            );\\n        }\\n\\n        // This is the maximum 1-indexed bit num, it is never valid because it is beyond the 20\\n        // year max maturity\\n        return (256, false);\\n    }\\n\\n    /// @notice Given a bit number and a block time returns the maturity that the bit number\\n    /// should reference. Bit numbers are one indexed.\\n    function getMaturityFromBitNum(uint256 blockTime, uint256 bitNum)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(bitNum != 0); // dev: cash group get maturity from bit num is zero\\n        require(bitNum <= 256); // dev: cash group get maturity from bit num overflow\\n        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);\\n        uint256 firstBit;\\n\\n        if (bitNum <= Constants.WEEK_BIT_OFFSET) {\\n            return blockTimeUTC0 + bitNum * Constants.DAY;\\n        } else if (bitNum <= Constants.MONTH_BIT_OFFSET) {\\n            firstBit =\\n                blockTimeUTC0 +\\n                Constants.MAX_DAY_OFFSET * Constants.DAY -\\n                // This backs up to the day that is divisible by a week\\n                (blockTimeUTC0 % Constants.WEEK);\\n            return firstBit + (bitNum - Constants.WEEK_BIT_OFFSET) * Constants.WEEK;\\n        } else if (bitNum <= Constants.QUARTER_BIT_OFFSET) {\\n            firstBit =\\n                blockTimeUTC0 +\\n                Constants.MAX_WEEK_OFFSET * Constants.DAY -\\n                (blockTimeUTC0 % Constants.MONTH);\\n            return firstBit + (bitNum - Constants.MONTH_BIT_OFFSET) * Constants.MONTH;\\n        } else {\\n            firstBit =\\n                blockTimeUTC0 +\\n                Constants.MAX_MONTH_OFFSET * Constants.DAY -\\n                (blockTimeUTC0 % Constants.QUARTER);\\n            return firstBit + (bitNum - Constants.QUARTER_BIT_OFFSET) * Constants.QUARTER;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.5.0 || ^0.6.0 || ^0.7.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with signed\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\n * represented by int128 type holding only the numerator.\\n */\\nlibrary ABDKMath64x64 {\\n  /*\\n   * Minimum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\n\\n  /*\\n   * Maximum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromInt (int256 x) internal pure returns (int128) {\\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\n    return int128 (x << 64);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\n   * rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64-bit integer number\\n   */\\n  function toInt (int128 x) internal pure returns (int64) {\\n    return int64 (x >> 64);\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\n    require (x <= 0x7FFFFFFFFFFFFFFF);\\n    return int128 (x << 64);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\n   * number rounding down.  Revert on underflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return unsigned 64-bit integer number\\n   */\\n  function toUInt (int128 x) internal pure returns (uint64) {\\n    require (x >= 0);\\n    return uint64 (x >> 64);\\n  }\\n\\n  /**\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\n   * number rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 128.128-bin fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function from128x128 (int256 x) internal pure returns (int128) {\\n    int256 result = x >> 64;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\n   * number.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 128.128 fixed point number\\n   */\\n  function to128x128 (int128 x) internal pure returns (int256) {\\n    return int256 (x) << 64;\\n  }\\n\\n  /**\\n   * Calculate x + y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) + y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x - y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) - y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) * y >> 64;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y signed 256-bit integer number\\n   * @return signed 256-bit integer number\\n   */\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\n    if (x == MIN_64x64) {\\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\n        y <= 0x1000000000000000000000000000000000000000000000000);\\n      return -y << 63;\\n    } else {\\n      bool negativeResult = false;\\n      if (x < 0) {\\n        x = -x;\\n        negativeResult = true;\\n      }\\n      if (y < 0) {\\n        y = -y; // We rely on overflow behavior here\\n        negativeResult = !negativeResult;\\n      }\\n      uint256 absoluteResult = mulu (x, uint256 (y));\\n      if (negativeResult) {\\n        require (absoluteResult <=\\n          0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (absoluteResult); // We rely on overflow behavior here\\n      } else {\\n        require (absoluteResult <=\\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (absoluteResult);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\n    if (y == 0) return 0;\\n\\n    require (x >= 0);\\n\\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\n    uint256 hi = uint256 (x) * (y >> 128);\\n\\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    hi <<= 64;\\n\\n    require (hi <=\\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\n    return hi + lo;\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\n    require (y != 0);\\n    int256 result = (int256 (x) << 64) / y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @param y signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\n    require (y != 0);\\n\\n    bool negativeResult = false;\\n    if (x < 0) {\\n      x = -x; // We rely on overflow behavior here\\n      negativeResult = true;\\n    }\\n    if (y < 0) {\\n      y = -y; // We rely on overflow behavior here\\n      negativeResult = !negativeResult;\\n    }\\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\n    if (negativeResult) {\\n      require (absoluteResult <= 0x80000000000000000000000000000000);\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\n    } else {\\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\n    require (y != 0);\\n    uint128 result = divuu (x, y);\\n    require (result <= uint128 (MAX_64x64));\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate -x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function neg (int128 x) internal pure returns (int128) {\\n    require (x != MIN_64x64);\\n    return -x;\\n  }\\n\\n  /**\\n   * Calculate |x|.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function abs (int128 x) internal pure returns (int128) {\\n    require (x != MIN_64x64);\\n    return x < 0 ? -x : x;\\n  }\\n\\n  /**\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function inv (int128 x) internal pure returns (int128) {\\n    require (x != 0);\\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\n    return int128 ((int256 (x) + int256 (y)) >> 1);\\n  }\\n\\n  /**\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\n   * Revert on overflow or in case x * y is negative.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\n    int256 m = int256 (x) * int256 (y);\\n    require (m >= 0);\\n    require (m <\\n        0x4000000000000000000000000000000000000000000000000000000000000000);\\n    return int128 (sqrtu (uint256 (m)));\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y uint256 value\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\n    bool negative = x < 0 && y & 1 == 1;\\n\\n    uint256 absX = uint128 (x < 0 ? -x : x);\\n    uint256 absResult;\\n    absResult = 0x100000000000000000000000000000000;\\n\\n    if (absX <= 0x10000000000000000) {\\n      absX <<= 63;\\n      while (y != 0) {\\n        if (y & 0x1 != 0) {\\n          absResult = absResult * absX >> 127;\\n        }\\n        absX = absX * absX >> 127;\\n\\n        if (y & 0x2 != 0) {\\n          absResult = absResult * absX >> 127;\\n        }\\n        absX = absX * absX >> 127;\\n\\n        if (y & 0x4 != 0) {\\n          absResult = absResult * absX >> 127;\\n        }\\n        absX = absX * absX >> 127;\\n\\n        if (y & 0x8 != 0) {\\n          absResult = absResult * absX >> 127;\\n        }\\n        absX = absX * absX >> 127;\\n\\n        y >>= 4;\\n      }\\n\\n      absResult >>= 64;\\n    } else {\\n      uint256 absXShift = 63;\\n      if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\\n      if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\\n      if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\\n      if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\\n      if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\\n      if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\\n\\n      uint256 resultShift = 0;\\n      while (y != 0) {\\n        require (absXShift < 64);\\n\\n        if (y & 0x1 != 0) {\\n          absResult = absResult * absX >> 127;\\n          resultShift += absXShift;\\n          if (absResult > 0x100000000000000000000000000000000) {\\n            absResult >>= 1;\\n            resultShift += 1;\\n          }\\n        }\\n        absX = absX * absX >> 127;\\n        absXShift <<= 1;\\n        if (absX >= 0x100000000000000000000000000000000) {\\n            absX >>= 1;\\n            absXShift += 1;\\n        }\\n\\n        y >>= 1;\\n      }\\n\\n      require (resultShift < 64);\\n      absResult >>= 64 - resultShift;\\n    }\\n    int256 result = negative ? -int256 (absResult) : int256 (absResult);\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sqrt (int128 x) internal pure returns (int128) {\\n    require (x >= 0);\\n    return int128 (sqrtu (uint256 (x) << 64));\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function log_2 (int128 x) internal pure returns (int128) {\\n    require (x > 0);\\n\\n    int256 msb = 0;\\n    int256 xc = x;\\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n    int256 result = msb - 64 << 64;\\n    uint256 ux = uint256 (x) << uint256 (127 - msb);\\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n      ux *= ux;\\n      uint256 b = ux >> 255;\\n      ux >>= 127 + b;\\n      result += bit * int256 (b);\\n    }\\n\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function ln (int128 x) internal pure returns (int128) {\\n    require (x > 0);\\n\\n    return int128 (\\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\\n  }\\n\\n  /**\\n   * Calculate binary exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp_2 (int128 x) internal pure returns (int128) {\\n    require (x < 0x400000000000000000); // Overflow\\n\\n    if (x < -0x400000000000000000) return 0; // Underflow\\n\\n    uint256 result = 0x80000000000000000000000000000000;\\n\\n    if (x & 0x8000000000000000 > 0)\\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n    if (x & 0x4000000000000000 > 0)\\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n    if (x & 0x2000000000000000 > 0)\\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n    if (x & 0x1000000000000000 > 0)\\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n    if (x & 0x800000000000000 > 0)\\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n    if (x & 0x400000000000000 > 0)\\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n    if (x & 0x200000000000000 > 0)\\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n    if (x & 0x100000000000000 > 0)\\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n    if (x & 0x80000000000000 > 0)\\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n    if (x & 0x40000000000000 > 0)\\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n    if (x & 0x20000000000000 > 0)\\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n    if (x & 0x10000000000000 > 0)\\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n    if (x & 0x8000000000000 > 0)\\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n    if (x & 0x4000000000000 > 0)\\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n    if (x & 0x2000000000000 > 0)\\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\n    if (x & 0x1000000000000 > 0)\\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n    if (x & 0x800000000000 > 0)\\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n    if (x & 0x400000000000 > 0)\\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n    if (x & 0x200000000000 > 0)\\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n    if (x & 0x100000000000 > 0)\\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n    if (x & 0x80000000000 > 0)\\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n    if (x & 0x40000000000 > 0)\\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n    if (x & 0x20000000000 > 0)\\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n    if (x & 0x10000000000 > 0)\\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n    if (x & 0x8000000000 > 0)\\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n    if (x & 0x4000000000 > 0)\\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n    if (x & 0x2000000000 > 0)\\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n    if (x & 0x1000000000 > 0)\\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n    if (x & 0x800000000 > 0)\\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n    if (x & 0x400000000 > 0)\\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n    if (x & 0x200000000 > 0)\\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n    if (x & 0x100000000 > 0)\\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n    if (x & 0x80000000 > 0)\\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n    if (x & 0x40000000 > 0)\\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n    if (x & 0x20000000 > 0)\\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n    if (x & 0x10000000 > 0)\\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n    if (x & 0x8000000 > 0)\\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n    if (x & 0x4000000 > 0)\\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n    if (x & 0x2000000 > 0)\\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n    if (x & 0x1000000 > 0)\\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n    if (x & 0x800000 > 0)\\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n    if (x & 0x400000 > 0)\\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n    if (x & 0x200000 > 0)\\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n    if (x & 0x100000 > 0)\\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n    if (x & 0x80000 > 0)\\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n    if (x & 0x40000 > 0)\\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n    if (x & 0x20000 > 0)\\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n    if (x & 0x10000 > 0)\\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n    if (x & 0x8000 > 0)\\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n    if (x & 0x4000 > 0)\\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n    if (x & 0x2000 > 0)\\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n    if (x & 0x1000 > 0)\\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n    if (x & 0x800 > 0)\\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n    if (x & 0x400 > 0)\\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n    if (x & 0x200 > 0)\\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n    if (x & 0x100 > 0)\\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n    if (x & 0x80 > 0)\\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n    if (x & 0x40 > 0)\\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n    if (x & 0x20 > 0)\\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\n    if (x & 0x10 > 0)\\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n    if (x & 0x8 > 0)\\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n    if (x & 0x4 > 0)\\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n    if (x & 0x2 > 0)\\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n    if (x & 0x1 > 0)\\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n\\n    result >>= uint256 (63 - (x >> 64));\\n    require (result <= uint256 (MAX_64x64));\\n\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate natural exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp (int128 x) internal pure returns (int128) {\\n    require (x < 0x400000000000000000); // Overflow\\n\\n    if (x < -0x400000000000000000) return 0; // Underflow\\n\\n    return exp_2 (\\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 64.64-bit fixed point number\\n   */\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\n    require (y != 0);\\n\\n    uint256 result;\\n\\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      result = (x << 64) / y;\\n    else {\\n      uint256 msb = 192;\\n      uint256 xc = x >> 192;\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n      uint256 hi = result * (y >> 128);\\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n      uint256 xh = x >> 192;\\n      uint256 xl = x << 64;\\n\\n      if (xl < lo) xh -= 1;\\n      xl -= lo; // We rely on overflow behavior here\\n      lo = hi << 128;\\n      if (xl < lo) xh -= 1;\\n      xl -= lo; // We rely on overflow behavior here\\n\\n      assert (xh == hi >> 128);\\n\\n      result += xl / y;\\n    }\\n\\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    return uint128 (result);\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n   * number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return unsigned 128-bit integer number\\n   */\\n  function sqrtu (uint256 x) private pure returns (uint128) {\\n    if (x == 0) return 0;\\n    else {\\n      uint256 xx = x;\\n      uint256 r = 1;\\n      if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\\n      if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\\n      if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\\n      if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\\n      if (xx >= 0x100) { xx >>= 8; r <<= 4; }\\n      if (xx >= 0x10) { xx >>= 4; r <<= 2; }\\n      if (xx >= 0x8) { r <<= 1; }\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1; // Seven iterations should be enough\\n      uint256 r1 = x / r;\\n      return uint128 (r < r1 ? r : r1);\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/internal/balances/Incentives.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./TokenHandler.sol\\\";\\nimport \\\"../nTokenHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary Incentives {\\n    using SafeMath for uint256;\\n    using SafeInt256 for int256;\\n\\n    /// @dev Notional incentivizes nTokens using the formula:\\n    ///     incentivesToClaim = (tokenBalance / totalSupply) * emissionRatePerYear * proRataYears\\n    ///     where proRataYears is:\\n    ///         (timeSinceLastClaim / YEAR) * INTERNAL_TOKEN_PRECISION\\n    /// @return (emissionRatePerYear * proRataYears), decimal basis is (1e8 * 1e8 = 1e16)\\n    function _getIncentiveRate(uint256 timeSinceLastClaim, uint256 emissionRatePerYear)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        // (timeSinceLastClaim * INTERNAL_TOKEN_PRECISION) / YEAR\\n        uint256 proRataYears =\\n            timeSinceLastClaim.mul(uint256(Constants.INTERNAL_TOKEN_PRECISION)).div(Constants.YEAR);\\n\\n        return proRataYears.mul(emissionRatePerYear);\\n    }\\n\\n    /// @notice Calculates the claimable incentives for a particular nToken and account\\n    function calculateIncentivesToClaim(\\n        address tokenAddress,\\n        uint256 nTokenBalance,\\n        uint256 lastClaimTime,\\n        uint256 lastClaimIntegralSupply,\\n        uint256 blockTime,\\n        uint256 integralTotalSupply\\n    ) internal view returns (uint256) {\\n        if (lastClaimTime == 0 || lastClaimTime >= blockTime) return 0;\\n\\n        // prettier-ignore\\n        (\\n            /* currencyId */,\\n            uint256 emissionRatePerYear,\\n            /* initializedTime */,\\n            /* assetArrayLength */,\\n            /* parameters */\\n        ) = nTokenHandler.getNTokenContext(tokenAddress);\\n\\n        // No overflow here, checked above\\n        uint256 timeSinceLastClaim = blockTime - lastClaimTime;\\n        uint256 incentiveRate =\\n            _getIncentiveRate(\\n                timeSinceLastClaim,\\n                // Convert this to the appropriate denomination, emissionRatePerYear is denominated\\n                // in whole tokens\\n                emissionRatePerYear.mul(uint256(Constants.INTERNAL_TOKEN_PRECISION))\\n            );\\n\\n        // Returns the average supply between now and the previous mint time using the integral of the total\\n        // supply.\\n        uint256 avgTotalSupply = integralTotalSupply.sub(lastClaimIntegralSupply).div(timeSinceLastClaim);\\n        if (avgTotalSupply == 0) return 0;\\n\\n        uint256 incentivesToClaim = nTokenBalance.mul(incentiveRate).div(avgTotalSupply);\\n        // incentiveRate has a decimal basis of 1e16 so divide by token precision to reduce to 1e8\\n        incentivesToClaim = incentivesToClaim.div(uint256(Constants.INTERNAL_TOKEN_PRECISION));\\n\\n        return incentivesToClaim;\\n    }\\n\\n    /// @notice Incentives must be claimed every time nToken balance changes\\n    function claimIncentives(BalanceState memory balanceState, address account)\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 blockTime = block.timestamp;\\n        address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\\n        // This will set the new supply and return the previous integral total supply\\n        uint256 integralTotalSupply = nTokenHandler.changeNTokenSupply(\\n            tokenAddress,\\n            balanceState.netNTokenSupplyChange,\\n            blockTime\\n        );\\n\\n        uint256 incentivesToClaim = calculateIncentivesToClaim(\\n            tokenAddress,\\n            balanceState.storedNTokenBalance.toUint(),\\n            balanceState.lastClaimTime,\\n            balanceState.lastClaimIntegralSupply,\\n            blockTime,\\n            integralTotalSupply\\n        );\\n\\n        balanceState.lastClaimTime = blockTime;\\n        balanceState.lastClaimIntegralSupply = integralTotalSupply;\\n\\n        if (incentivesToClaim > 0) TokenHandler.transferIncentive(account, incentivesToClaim);\\n\\n        return incentivesToClaim;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/balances/TokenHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"interfaces/compound/CErc20Interface.sol\\\";\\nimport \\\"interfaces/compound/CEtherInterface.sol\\\";\\nimport \\\"interfaces/IEIP20NonStandard.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n/// @notice Handles all external token transfers and events\\nlibrary TokenHandler {\\n    using SafeInt256 for int256;\\n    using SafeMath for uint256;\\n\\n    function setMaxCollateralBalance(uint256 currencyId, uint72 maxCollateralBalance) internal {\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\n        TokenStorage storage tokenStorage = store[currencyId][false];\\n        tokenStorage.maxCollateralBalance = maxCollateralBalance;\\n    } \\n\\n    function getAssetToken(uint256 currencyId) internal view returns (Token memory) {\\n        return _getToken(currencyId, false);\\n    }\\n\\n    function getUnderlyingToken(uint256 currencyId) internal view returns (Token memory) {\\n        return _getToken(currencyId, true);\\n    }\\n\\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\\n    /// the underlying token. (These may not always exist)\\n    function _getToken(uint256 currencyId, bool underlying) private view returns (Token memory) {\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\n        TokenStorage storage tokenStorage = store[currencyId][underlying];\\n\\n        return\\n            Token({\\n                tokenAddress: tokenStorage.tokenAddress,\\n                hasTransferFee: tokenStorage.hasTransferFee,\\n                // No overflow, restricted on storage\\n                decimals: int256(10**tokenStorage.decimalPlaces),\\n                tokenType: tokenStorage.tokenType,\\n                maxCollateralBalance: tokenStorage.maxCollateralBalance\\n            });\\n    }\\n\\n    /// @notice Sets a token for a currency id.\\n    function setToken(\\n        uint256 currencyId,\\n        bool underlying,\\n        TokenStorage memory tokenStorage\\n    ) internal {\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\n\\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\\n            // Hardcoded parameters for ETH just to make sure we don't get it wrong.\\n            TokenStorage storage ts = store[currencyId][true];\\n            ts.tokenAddress = address(0);\\n            ts.hasTransferFee = false;\\n            ts.tokenType = TokenType.Ether;\\n            ts.decimalPlaces = Constants.ETH_DECIMAL_PLACES;\\n            ts.maxCollateralBalance = 0;\\n\\n            return;\\n        }\\n\\n        // Check token address\\n        require(tokenStorage.tokenAddress != address(0), \\\"TH: address is zero\\\");\\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\\n        // then we should explicitly upgrade this method to allow for a token to be changed.\\n        Token memory token = _getToken(currencyId, underlying);\\n        require(\\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\\n            \\\"TH: token cannot be reset\\\"\\n        );\\n\\n        require(0 < tokenStorage.decimalPlaces \\n            && tokenStorage.decimalPlaces <= Constants.MAX_DECIMAL_PLACES, \\\"TH: invalid decimals\\\");\\n\\n        // Validate token type\\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\\n        if (underlying) {\\n            // Underlying tokens cannot have max collateral balances, the contract only has a balance temporarily\\n            // during mint and redeem actions.\\n            require(tokenStorage.maxCollateralBalance == 0); // dev: underlying cannot have max collateral balance\\n            require(tokenStorage.tokenType == TokenType.UnderlyingToken); // dev: underlying token inconsistent\\n        } else {\\n            require(tokenStorage.tokenType != TokenType.UnderlyingToken); // dev: underlying token inconsistent\\n        }\\n\\n        if (tokenStorage.tokenType == TokenType.cToken) {\\n            // Set the approval for the underlying so that we can mint cTokens\\n            Token memory underlyingToken = getUnderlyingToken(currencyId);\\n            // ERC20 tokens should return true on success for an approval, but Tether\\n            // does not return a value here so we use the NonStandard interface here to\\n            // check that the approval was successful.\\n            IEIP20NonStandard(underlyingToken.tokenAddress).approve(\\n                tokenStorage.tokenAddress,\\n                type(uint256).max\\n            );\\n            checkReturnCode();\\n        }\\n\\n        store[currencyId][underlying] = tokenStorage;\\n    }\\n\\n    /// @notice This method only works with cTokens, it's unclear how we can make this more generic\\n    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {\\n        uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\\n\\n        uint256 success;\\n        if (token.tokenType == TokenType.cToken) {\\n            success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);\\n        } else if (token.tokenType == TokenType.cETH) {\\n            // Reverts on error\\n            CEtherInterface(token.tokenAddress).mint{value: msg.value}();\\n        } else {\\n            revert(); // dev: non mintable token\\n        }\\n\\n        require(success == Constants.COMPOUND_RETURN_CODE_NO_ERROR, \\\"Mint\\\");\\n        uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\\n\\n        // This is the starting and ending balance in external precision\\n        return SafeInt256.toInt(endingBalance.sub(startingBalance));\\n    }\\n\\n    function redeem(\\n        Token memory assetToken,\\n        Token memory underlyingToken,\\n        uint256 assetAmountExternal\\n    ) internal returns (int256) {\\n        uint256 startingBalance;\\n        if (assetToken.tokenType == TokenType.cETH) {\\n            startingBalance = address(this).balance;\\n        } else if (assetToken.tokenType == TokenType.cToken) {\\n            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\\n        } else {\\n            revert(); // dev: non redeemable failure\\n        }\\n\\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\\n        require(success == Constants.COMPOUND_RETURN_CODE_NO_ERROR, \\\"Redeem\\\");\\n\\n        uint256 endingBalance;\\n        if (assetToken.tokenType == TokenType.cETH) {\\n            endingBalance = address(this).balance;\\n        } else {\\n            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\\n        }\\n\\n        // Underlying token external precision\\n        return SafeInt256.toInt(endingBalance.sub(startingBalance));\\n    }\\n\\n    /// @notice Handles transfers into and out of the system denominated in the external token decimal\\n    /// precision.\\n    function transfer(\\n        Token memory token,\\n        address account,\\n        int256 netTransferExternal\\n    ) internal returns (int256) {\\n        if (netTransferExternal > 0) {\\n            // Deposits must account for transfer fees.\\n            netTransferExternal = _deposit(token, account, uint256(netTransferExternal));\\n        } else if (token.tokenType == TokenType.Ether) {\\n            require(netTransferExternal <= 0); // dev: cannot deposit ether\\n            address payable accountPayable = payable(account);\\n            // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying\\n            // ETH they will have to withdraw the cETH token and then redeem it manually.\\n            accountPayable.transfer(uint256(netTransferExternal.neg()));\\n        } else {\\n            safeTransferOut(\\n                token.tokenAddress,\\n                account,\\n                // netTransferExternal is zero or negative here\\n                uint256(netTransferExternal.neg())\\n            );\\n        }\\n\\n        return netTransferExternal;\\n    }\\n\\n    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must\\n    /// calculate the net balance after transfer. Amounts are denominated in the destination token's\\n    /// precision.\\n    function _deposit(\\n        Token memory token,\\n        address account,\\n        uint256 amount\\n    ) private returns (int256) {\\n        uint256 startingBalance;\\n        uint256 endingBalance;\\n\\n        if (token.hasTransferFee) {\\n            startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\\n        }\\n\\n        safeTransferIn(token.tokenAddress, account, amount);\\n\\n        if (token.hasTransferFee || token.maxCollateralBalance > 0) {\\n            endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\\n        }\\n\\n        if (token.maxCollateralBalance > 0) {\\n            int256 internalPrecisionBalance = convertToInternal(token, SafeInt256.toInt(endingBalance));\\n            // Max collateral balance is stored as uint72, no overflow\\n            require(internalPrecisionBalance <= SafeInt256.toInt(token.maxCollateralBalance)); // dev: over max collateral balance\\n        }\\n\\n        // Math is done in uint inside these statements and will revert on negative\\n        if (token.hasTransferFee) {\\n            return SafeInt256.toInt(endingBalance.sub(startingBalance));\\n        } else {\\n            return SafeInt256.toInt(amount);\\n        }\\n    }\\n\\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\\n        // If token decimals > INTERNAL_TOKEN_PRECISION:\\n        //  on deposit: resulting dust will accumulate to protocol\\n        //  on withdraw: protocol may lose dust amount. However, withdraws are only calculated based\\n        //    on a conversion from internal token precision to external token precision so therefore dust\\n        //    amounts cannot be specified for withdraws.\\n        // If token decimals < INTERNAL_TOKEN_PRECISION then this will add zeros to the\\n        // end of amount and will not result in dust.\\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\\n    }\\n\\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\\n        // If token decimals > INTERNAL_TOKEN_PRECISION then this will increase amount\\n        // by adding a number of zeros to the end and will not result in dust.\\n        // If token decimals < INTERNAL_TOKEN_PRECISION:\\n        //  on deposit: Deposits are specified in external token precision and there is no loss of precision when\\n        //      tokens are converted from external to internal precision\\n        //  on withdraw: this calculation will round down such that the protocol retains the residual cash balance\\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\\n    }\\n\\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\\n        safeTransferOut(Constants.NOTE_TOKEN_ADDRESS, account, tokensToTransfer);\\n    }\\n\\n    function safeTransferOut(\\n        address token,\\n        address account,\\n        uint256 amount\\n    ) private {\\n        IEIP20NonStandard(token).transfer(account, amount);\\n        checkReturnCode();\\n    }\\n\\n    function safeTransferIn(\\n        address token,\\n        address account,\\n        uint256 amount\\n    ) private {\\n        IEIP20NonStandard(token).transferFrom(account, address(this), amount);\\n        checkReturnCode();\\n    }\\n\\n    function checkReturnCode() private pure {\\n        bool success;\\n        uint256[1] memory result;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {\\n                    // This is a non-standard ERC-20\\n                    success := 1 // set success to true\\n                }\\n                case 32 {\\n                    // This is a compliant ERC-20\\n                    returndatacopy(result, 0, 32)\\n                    success := mload(result) // Set `success = returndata` of external call\\n                }\\n                default {\\n                    // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n        }\\n\\n        require(success, \\\"ERC20\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/AccountContextHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../global/LibStorage.sol\\\";\\nimport \\\"./balances/BalanceHandler.sol\\\";\\nimport \\\"./portfolio/BitmapAssetsHandler.sol\\\";\\nimport \\\"./portfolio/PortfolioHandler.sol\\\";\\n\\nlibrary AccountContextHandler {\\n    using PortfolioHandler for PortfolioState;\\n\\n    bytes18 private constant TURN_OFF_PORTFOLIO_FLAGS = 0x7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF;\\n    event AccountContextUpdate(address indexed account);\\n\\n    /// @notice Returns the account context of a given account\\n    function getAccountContext(address account) internal view returns (AccountContext memory) {\\n        mapping(address => AccountContext) storage store = LibStorage.getAccountStorage();\\n        return store[account];\\n    }\\n\\n    /// @notice Sets the account context of a given account\\n    function setAccountContext(AccountContext memory accountContext, address account) internal {\\n        mapping(address => AccountContext) storage store = LibStorage.getAccountStorage();\\n        store[account] = accountContext;\\n        emit AccountContextUpdate(account);\\n    }\\n\\n    function isBitmapEnabled(AccountContext memory accountContext) internal pure returns (bool) {\\n        return accountContext.bitmapCurrencyId != 0;\\n    }\\n\\n    /// @notice Sets the account context of a given account\\n    function enableBitmapForAccount(\\n        AccountContext memory accountContext,\\n        address account,\\n        uint16 currencyId,\\n        uint256 blockTime\\n    ) internal view {\\n        // Allow setting the currency id to zero to turn off bitmap\\n        require(currencyId <= Constants.MAX_CURRENCIES, \\\"AC: invalid currency id\\\");\\n\\n        if (isBitmapEnabled(accountContext)) {\\n            // Account cannot change their bitmap if they have assets set\\n            bytes32 ifCashBitmap =\\n                BitmapAssetsHandler.getAssetsBitmap(account, accountContext.bitmapCurrencyId);\\n            require(ifCashBitmap == 0, \\\"AC: cannot have assets\\\");\\n        } else {\\n            require(accountContext.assetArrayLength == 0, \\\"AC: cannot have assets\\\");\\n            // Account context also cannot have negative cash debts\\n            require(accountContext.hasDebt == 0x00, \\\"AC: cannot have debt\\\");\\n\\n            // Ensure that the active currency is set to false in the array so that there is no double\\n            // counting during FreeCollateral\\n            setActiveCurrency(accountContext, currencyId, false, Constants.ACTIVE_IN_BALANCES);\\n        }\\n\\n        accountContext.bitmapCurrencyId = currencyId;\\n\\n        // Setting this is required to initialize the assets bitmap\\n        uint256 nextSettleTime = DateTime.getTimeUTC0(blockTime);\\n        require(nextSettleTime < type(uint40).max); // dev: blockTime overflow\\n        accountContext.nextSettleTime = uint40(nextSettleTime);\\n    }\\n\\n    /// @notice Returns true if the context needs to settle\\n    function mustSettleAssets(AccountContext memory accountContext) internal view returns (bool) {\\n        uint256 blockTime = block.timestamp;\\n\\n        if (isBitmapEnabled(accountContext)) {\\n            // nextSettleTime will be set to utc0 after settlement so we\\n            // settle if this is strictly less than utc0\\n            return accountContext.nextSettleTime < DateTime.getTimeUTC0(blockTime);\\n        } else {\\n            // 0 value occurs on an uninitialized account\\n            // Assets mature exactly on the blockTime (not one second past) so in this\\n            // case we settle on the block timestamp\\n            return 0 < accountContext.nextSettleTime && accountContext.nextSettleTime <= blockTime;\\n        }\\n    }\\n\\n    /// @notice Checks if a currency id (uint16 max) is in the 9 slots in the account\\n    /// context active currencies list.\\n    /// @dev NOTE: this may be more efficient as a binary search since we know that the array\\n    /// is sorted\\n    function isActiveInBalances(AccountContext memory accountContext, uint256 currencyId)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        require(currencyId != 0 && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\n        bytes18 currencies = accountContext.activeCurrencies;\\n\\n        if (accountContext.bitmapCurrencyId == currencyId) return true;\\n\\n        while (currencies != 0x00) {\\n            uint256 cid = uint16(bytes2(currencies) & Constants.UNMASK_FLAGS);\\n            if (cid == currencyId) {\\n                // Currency found, return if it is active in balances or not\\n                return bytes2(currencies) & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES;\\n            }\\n\\n            currencies = currencies << 16;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Iterates through the active currency list and removes, inserts or does nothing\\n    /// to ensure that the active currency list is an ordered byte array of uint16 currency ids\\n    /// that refer to the currencies that an account is active in.\\n    ///\\n    /// This is called to ensure that currencies are active when the account has a non zero cash balance,\\n    /// a non zero nToken balance or a portfolio asset.\\n    function setActiveCurrency(\\n        AccountContext memory accountContext,\\n        uint256 currencyId,\\n        bool isActive,\\n        bytes2 flags\\n    ) internal pure {\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\n\\n        // If the bitmapped currency is already set then return here. Turning off the bitmap currency\\n        // id requires other logical handling so we will do it elsewhere.\\n        if (isActive && accountContext.bitmapCurrencyId == currencyId) return;\\n\\n        bytes18 prefix;\\n        bytes18 suffix = accountContext.activeCurrencies;\\n        uint256 shifts;\\n\\n        /// There are six possible outcomes from this search:\\n        /// 1. The currency id is in the list\\n        ///      - it must be set to active, do nothing\\n        ///      - it must be set to inactive, shift suffix and concatenate\\n        /// 2. The current id is greater than the one in the search:\\n        ///      - it must be set to active, append to prefix and then concatenate the suffix,\\n        ///        ensure that we do not lose the last 2 bytes if set.\\n        ///      - it must be set to inactive, it is not in the list, do nothing\\n        /// 3. Reached the end of the list:\\n        ///      - it must be set to active, check that the last two bytes are not set and then\\n        ///        append to the prefix\\n        ///      - it must be set to inactive, do nothing\\n        while (suffix != 0x00) {\\n            uint256 cid = uint256(uint16(bytes2(suffix) & Constants.UNMASK_FLAGS));\\n            // if matches and isActive then return, already in list\\n            if (cid == currencyId && isActive) {\\n                // set flag and return\\n                accountContext.activeCurrencies =\\n                    accountContext.activeCurrencies |\\n                    (bytes18(flags) >> (shifts * 16));\\n                return;\\n            }\\n\\n            // if matches and not active then shift suffix to remove\\n            if (cid == currencyId && !isActive) {\\n                // turn off flag, if both flags are off then remove\\n                suffix = suffix & ~bytes18(flags);\\n                if (bytes2(suffix) & ~Constants.UNMASK_FLAGS == 0x0000) suffix = suffix << 16;\\n                accountContext.activeCurrencies = prefix | (suffix >> (shifts * 16));\\n                return;\\n            }\\n\\n            // if greater than and isActive then insert into prefix\\n            if (cid > currencyId && isActive) {\\n                prefix = prefix | (bytes18(bytes2(uint16(currencyId)) | flags) >> (shifts * 16));\\n                // check that the total length is not greater than 9, meaning that the last\\n                // two bytes of the active currencies array should be zero\\n                require((accountContext.activeCurrencies << 128) == 0x00); // dev: AC: too many currencies\\n\\n                // append the suffix\\n                accountContext.activeCurrencies = prefix | (suffix >> ((shifts + 1) * 16));\\n                return;\\n            }\\n\\n            // if past the point of the currency id and not active, not in list\\n            if (cid > currencyId && !isActive) return;\\n\\n            prefix = prefix | (bytes18(bytes2(suffix)) >> (shifts * 16));\\n            suffix = suffix << 16;\\n            shifts += 1;\\n        }\\n\\n        // If reached this point and not active then return\\n        if (!isActive) return;\\n\\n        // if end and isActive then insert into suffix, check max length\\n        require(shifts < 9); // dev: AC: too many currencies\\n        accountContext.activeCurrencies =\\n            prefix |\\n            (bytes18(bytes2(uint16(currencyId)) | flags) >> (shifts * 16));\\n    }\\n\\n    function _clearPortfolioActiveFlags(bytes18 activeCurrencies) internal pure returns (bytes18) {\\n        bytes18 result;\\n        // This is required to clear the suffix as we append below\\n        bytes18 suffix = activeCurrencies & TURN_OFF_PORTFOLIO_FLAGS;\\n        uint256 shifts;\\n\\n        // This loop will append all currencies that are active in balances into the result.\\n        while (suffix != 0x00) {\\n            if (bytes2(suffix) & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES) {\\n                // If any flags are active, then append.\\n                result = result | (bytes18(bytes2(suffix)) >> shifts);\\n                shifts += 16;\\n            }\\n            suffix = suffix << 16;\\n        }\\n\\n        return result;\\n    }\\n\\n    /// @notice Stores a portfolio array and updates the account context information, this method should\\n    /// be used whenever updating a portfolio array except in the case of nTokens\\n    function storeAssetsAndUpdateContext(\\n        AccountContext memory accountContext,\\n        address account,\\n        PortfolioState memory portfolioState,\\n        bool isLiquidation\\n    ) internal {\\n        // Each of these parameters is recalculated based on the entire array of assets in store assets,\\n        // regardless of whether or not they have been updated.\\n        (bool hasDebt, bytes32 portfolioCurrencies, uint8 assetArrayLength, uint40 nextSettleTime) =\\n            portfolioState.storeAssets(account);\\n        accountContext.nextSettleTime = nextSettleTime;\\n        require(mustSettleAssets(accountContext) == false); // dev: cannot store matured assets\\n        accountContext.assetArrayLength = assetArrayLength;\\n\\n        // During liquidation it is possible for an array to go over the max amount of assets allowed due to\\n        // liquidity tokens being withdrawn into fCash.\\n        if (!isLiquidation) {\\n            require(assetArrayLength <= uint8(Constants.MAX_TRADED_MARKET_INDEX)); // dev: max assets allowed\\n        }\\n\\n        // Sets the hasDebt flag properly based on whether or not portfolio has asset debt, meaning\\n        // a negative fCash balance.\\n        if (hasDebt) {\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\n        } else {\\n            // Turns off the ASSET_DEBT flag\\n            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_ASSET_DEBT;\\n        }\\n\\n        // Clear the active portfolio active flags and they will be recalculated in the next step\\n        accountContext.activeCurrencies = _clearPortfolioActiveFlags(accountContext.activeCurrencies);\\n\\n        uint256 lastCurrency;\\n        while (portfolioCurrencies != 0) {\\n            // Portfolio currencies will not have flags, it is just an byte array of all the currencies found\\n            // in a portfolio. They are appended in a sorted order so we can compare to the previous currency\\n            // and only set it if they are different.\\n            uint256 currencyId = uint16(bytes2(portfolioCurrencies));\\n            if (currencyId != lastCurrency) {\\n                setActiveCurrency(accountContext, currencyId, true, Constants.ACTIVE_IN_PORTFOLIO);\\n            }\\n            lastCurrency = currencyId;\\n\\n            portfolioCurrencies = portfolioCurrencies << 16;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math/FloatingPoint56.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Bitmap.sol\\\";\\n\\n/**\\n * Packs an uint value into a \\\"floating point\\\" storage slot. Used for storing\\n * lastClaimIntegralSupply values in balance storage. For these values, we don't need\\n * to maintain exact precision but we don't want to be limited by storage size overflows.\\n *\\n * A floating point value is defined by the 48 most significant bits and an 8 bit number\\n * of bit shifts required to restore its precision. The unpacked value will always be less\\n * than the packed value with a maximum absolute loss of precision of (2 ** bitShift) - 1.\\n */\\nlibrary FloatingPoint56 {\\n\\n    function packTo56Bits(uint256 value) internal pure returns (uint56) {\\n        uint256 bitShift;\\n        // If the value is over the uint48 max value then we will shift it down\\n        // given the index of the most significant bit. We store this bit shift \\n        // in the least significant byte of the 56 bit slot available.\\n        if (value > type(uint48).max) bitShift = (Bitmap.getMSB(value) - 47);\\n\\n        uint256 shiftedValue = value >> bitShift;\\n        return uint56((shiftedValue << 8) | bitShift);\\n    }\\n\\n    function unpackFrom56Bits(uint256 value) internal pure returns (uint256) {\\n        // The least significant 8 bits will be the amount to bit shift\\n        uint256 bitShift = uint256(uint8(value));\\n        return ((value >> 8) << bitShift);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"interfaces/compound/CErc20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.7.0;\\n\\nimport \\\"./CTokenInterface.sol\\\";\\n\\ninterface CErc20Interface {\\n\\n    /*** User Interface ***/\\n\\n    function mint(uint mintAmount) external returns (uint);\\n    function redeem(uint redeemTokens) external returns (uint);\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\n    function borrow(uint borrowAmount) external returns (uint);\\n    function repayBorrow(uint repayAmount) external returns (uint);\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint);\\n}\\n\"\r\n    },\r\n    \"interfaces/compound/CEtherInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.7.0;\\n\\ninterface CEtherInterface {\\n    function mint() external payable;\\n}\"\r\n    },\r\n    \"interfaces/IEIP20NonStandard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title EIP20NonStandardInterface\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n */\\ninterface IEIP20NonStandard {\\n\\n    /**\\n     * @notice Get the total number of tokens in circulation\\n     * @return The supply of tokens\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transfer(address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `approve` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved\\n      */\\n    function approve(address spender, uint256 amount) external;\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return remaining The number of tokens allowed to be spent\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"interfaces/compound/CTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.7.0;\\n\\ninterface CTokenInterface {\\n\\n    /*** User Interface ***/\\n\\n    function underlying() external view returns (address);\\n    function transfer(address dst, uint amount) external returns (bool);\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\n    function approve(address spender, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function balanceOfUnderlying(address owner) external returns (uint);\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\\n    function borrowRatePerBlock() external view returns (uint);\\n    function supplyRatePerBlock() external view returns (uint);\\n    function totalBorrowsCurrent() external returns (uint);\\n    function borrowBalanceCurrent(address account) external returns (uint);\\n    function borrowBalanceStored(address account) external view returns (uint);\\n    function exchangeRateCurrent() external returns (uint);\\n    function exchangeRateStored() external view returns (uint);\\n    function getCash() external view returns (uint);\\n    function accrueInterest() external returns (uint);\\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/internal/portfolio/TransferAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./PortfolioHandler.sol\\\";\\nimport \\\"./BitmapAssetsHandler.sol\\\";\\nimport \\\"../AccountContextHandler.sol\\\";\\nimport \\\"../../external/SettleAssetsExternal.sol\\\";\\n\\n/// @notice Helper library for transferring assets from one portfolio to another\\nlibrary TransferAssets {\\n    using AccountContextHandler for AccountContext;\\n    using PortfolioHandler for PortfolioState;\\n    using SafeInt256 for int256;\\n\\n    /// @notice Decodes asset ids\\n    function decodeAssetId(uint256 id)\\n        internal\\n        pure\\n        returns (\\n            uint256 currencyId,\\n            uint256 maturity,\\n            uint256 assetType\\n        )\\n    {\\n        assetType = uint8(id);\\n        maturity = uint40(id >> 8);\\n        currencyId = uint16(id >> 48);\\n    }\\n\\n    /// @notice Encodes asset ids\\n    function encodeAssetId(\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 assetType\\n    ) internal pure returns (uint256) {\\n        require(currencyId <= Constants.MAX_CURRENCIES);\\n        require(maturity <= type(uint40).max);\\n        require(assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX);\\n\\n        return\\n            uint256(\\n                (bytes32(uint256(uint16(currencyId))) << 48) |\\n                    (bytes32(uint256(uint40(maturity))) << 8) |\\n                    bytes32(uint256(uint8(assetType)))\\n            );\\n    }\\n\\n    /// @dev Used to flip the sign of assets to decrement the `from` account that is sending assets\\n    function invertNotionalAmountsInPlace(PortfolioAsset[] memory assets) internal pure {\\n        for (uint256 i; i < assets.length; i++) {\\n            assets[i].notional = assets[i].notional.neg();\\n        }\\n    }\\n\\n    /// @dev Useful method for hiding the logic of updating an account. WARNING: the account\\n    /// context returned from this method may not be the same memory location as the account\\n    /// context provided if the account is settled.\\n    function placeAssetsInAccount(\\n        address account,\\n        AccountContext memory accountContext,\\n        PortfolioAsset[] memory assets\\n    ) internal returns (AccountContext memory) {\\n        // If an account has assets that require settlement then placing assets inside it\\n        // may cause issues.\\n        require(!accountContext.mustSettleAssets(), \\\"Account must settle\\\");\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            // Adds fCash assets into the account and finalized storage\\n            BitmapAssetsHandler.addMultipleifCashAssets(account, accountContext, assets);\\n        } else {\\n            PortfolioState memory portfolioState = PortfolioHandler.buildPortfolioState(\\n                account,\\n                accountContext.assetArrayLength,\\n                assets.length\\n            );\\n            // This will add assets in memory\\n            portfolioState.addMultipleAssets(assets);\\n            // This will store assets and update the account context in memory\\n            accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);\\n        }\\n\\n        return accountContext;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/SettleAssetsExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../internal/portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../internal/balances/BalanceHandler.sol\\\";\\nimport \\\"../internal/settlement/SettlePortfolioAssets.sol\\\";\\nimport \\\"../internal/settlement/SettleBitmapAssets.sol\\\";\\nimport \\\"../internal/AccountContextHandler.sol\\\";\\n\\n/// @notice External library for settling assets\\nlibrary SettleAssetsExternal {\\n    using PortfolioHandler for PortfolioState;\\n    using AccountContextHandler for AccountContext;\\n    event AccountSettled(address indexed account);\\n\\n    /// @notice Settles an account, returns the new account context object after settlement.\\n    /// @dev The memory location of the account context object is not the same as the one returned.\\n    function settleAccount(\\n        address account,\\n        AccountContext memory accountContext\\n    ) external returns (AccountContext memory) {\\n        // Defensive check to ensure that this is a valid settlement\\n        require(accountContext.mustSettleAssets());\\n        SettleAmount[] memory settleAmounts;\\n        PortfolioState memory portfolioState;\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            (int256 settledCash, uint256 blockTimeUTC0) =\\n                SettleBitmapAssets.settleBitmappedCashGroup(\\n                    account,\\n                    accountContext.bitmapCurrencyId,\\n                    accountContext.nextSettleTime,\\n                    block.timestamp\\n                );\\n            require(blockTimeUTC0 < type(uint40).max); // dev: block time utc0 overflow\\n            accountContext.nextSettleTime = uint40(blockTimeUTC0);\\n\\n            settleAmounts = new SettleAmount[](1);\\n            settleAmounts[0] = SettleAmount(accountContext.bitmapCurrencyId, settledCash);\\n        } else {\\n            portfolioState = PortfolioHandler.buildPortfolioState(\\n                account,\\n                accountContext.assetArrayLength,\\n                0\\n            );\\n            settleAmounts = SettlePortfolioAssets.settlePortfolio(portfolioState, block.timestamp);\\n            accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);\\n        }\\n\\n        BalanceHandler.finalizeSettleAmounts(account, accountContext, settleAmounts);\\n\\n        emit AccountSettled(account);\\n\\n        return accountContext;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math/Bitmap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../global/Types.sol\\\";\\nimport \\\"../global/Constants.sol\\\";\\n\\n/// @notice Helper methods for bitmaps, they are big-endian and 1-indexed.\\nlibrary Bitmap {\\n\\n    /// @notice Set a bit on or off in a bitmap, index is 1-indexed\\n    function setBit(\\n        bytes32 bitmap,\\n        uint256 index,\\n        bool setOn\\n    ) internal pure returns (bytes32) {\\n        require(index >= 1 && index <= 256); // dev: set bit index bounds\\n\\n        if (setOn) {\\n            return bitmap | (Constants.MSB >> (index - 1));\\n        } else {\\n            return bitmap & ~(Constants.MSB >> (index - 1));\\n        }\\n    }\\n\\n    /// @notice Check if a bit is set\\n    function isBitSet(bytes32 bitmap, uint256 index) internal pure returns (bool) {\\n        require(index >= 1 && index <= 256); // dev: set bit index bounds\\n        return ((bitmap << (index - 1)) & Constants.MSB) == Constants.MSB;\\n    }\\n\\n    /// @notice Count the total bits set\\n    function totalBitsSet(bytes32 bitmap) internal pure returns (uint256) {\\n        uint256 x = uint256(bitmap);\\n        x = (x & 0x5555555555555555555555555555555555555555555555555555555555555555) + (x >> 1 & 0x5555555555555555555555555555555555555555555555555555555555555555);\\n        x = (x & 0x3333333333333333333333333333333333333333333333333333333333333333) + (x >> 2 & 0x3333333333333333333333333333333333333333333333333333333333333333);\\n        x = (x & 0x0707070707070707070707070707070707070707070707070707070707070707) + (x >> 4);\\n        x = (x & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F) + (x >> 8 & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F);\\n        x = x + (x >> 16);\\n        x = x + (x >> 32);\\n        x = x  + (x >> 64);\\n        return (x & 0xFF) + (x >> 128 & 0xFF);\\n    }\\n\\n    // Does a binary search over x to get the position of the most significant bit\\n    function getMSB(uint256 x) internal pure returns (uint256 msb) {\\n        // If x == 0 then there is no MSB and this method will return zero. That would\\n        // be the same as the return value when x == 1 (MSB is zero indexed), so instead\\n        // we have this require here to ensure that the values don't get mixed up.\\n        require(x != 0); // dev: get msb zero value\\n        if (x >= 0x100000000000000000000000000000000) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 0x10000000000000000) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 0x100000000) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 0x10000) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 0x100) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 0x10) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 0x4) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 0x2) msb += 1; // No need to shift xc anymore\\n    }\\n\\n    /// @dev getMSB returns a zero indexed bit number where zero is the first bit counting\\n    /// from the right (little endian). Asset Bitmaps are counted from the left (big endian)\\n    /// and one indexed.\\n    function getNextBitNum(bytes32 bitmap) internal pure returns (uint256 bitNum) {\\n        // Short circuit the search if bitmap is all zeros\\n        if (bitmap == 0x00) return 0;\\n\\n        return 255 - getMSB(uint256(bitmap)) + 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/settlement/SettlePortfolioAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../valuation/AssetHandler.sol\\\";\\nimport \\\"../markets/Market.sol\\\";\\nimport \\\"../markets/AssetRate.sol\\\";\\nimport \\\"../portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\n\\nlibrary SettlePortfolioAssets {\\n    using SafeInt256 for int256;\\n    using AssetRate for AssetRateParameters;\\n    using Market for MarketParameters;\\n    using PortfolioHandler for PortfolioState;\\n    using AssetHandler for PortfolioAsset;\\n\\n    /// @dev Returns a SettleAmount array for the assets that will be settled\\n    function _getSettleAmountArray(PortfolioState memory portfolioState, uint256 blockTime)\\n        private\\n        pure\\n        returns (SettleAmount[] memory)\\n    {\\n        uint256 currenciesSettled;\\n        uint256 lastCurrencyId = 0;\\n        if (portfolioState.storedAssets.length == 0) return new SettleAmount[](0);\\n\\n        // Loop backwards so \\\"lastCurrencyId\\\" will be set to the first currency in the portfolio\\n        // NOTE: if this contract is ever upgraded to Solidity 0.8+ then this i-- will underflow and cause\\n        // a revert, must wrap in an unchecked.\\n        for (uint256 i = portfolioState.storedAssets.length; (i--) > 0;) {\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\n            // Assets settle on exactly blockTime\\n            if (asset.getSettlementDate() > blockTime) continue;\\n\\n            // Assume that this is sorted by cash group and maturity, currencyId = 0 is unused so this\\n            // will work for the first asset\\n            if (lastCurrencyId != asset.currencyId) {\\n                lastCurrencyId = asset.currencyId;\\n                currenciesSettled++;\\n            }\\n        }\\n\\n        // Actual currency ids will be set as we loop through the portfolio and settle assets\\n        SettleAmount[] memory settleAmounts = new SettleAmount[](currenciesSettled);\\n        if (currenciesSettled > 0) settleAmounts[0].currencyId = lastCurrencyId;\\n        return settleAmounts;\\n    }\\n\\n    /// @notice Settles a portfolio array\\n    function settlePortfolio(PortfolioState memory portfolioState, uint256 blockTime)\\n        internal\\n        returns (SettleAmount[] memory)\\n    {\\n        AssetRateParameters memory settlementRate;\\n        SettleAmount[] memory settleAmounts = _getSettleAmountArray(portfolioState, blockTime);\\n        MarketParameters memory market;\\n        if (settleAmounts.length == 0) return settleAmounts;\\n        uint256 settleAmountIndex;\\n\\n        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\n            uint256 settleDate = asset.getSettlementDate();\\n            // Settlement date is on block time exactly\\n            if (settleDate > blockTime) continue;\\n\\n            // On the first loop the lastCurrencyId is already set.\\n            if (settleAmounts[settleAmountIndex].currencyId != asset.currencyId) {\\n                // New currency in the portfolio\\n                settleAmountIndex += 1;\\n                settleAmounts[settleAmountIndex].currencyId = asset.currencyId;\\n            }\\n\\n            settlementRate = AssetRate.buildSettlementRateStateful(\\n                asset.currencyId,\\n                asset.maturity,\\n                blockTime\\n            );\\n\\n            int256 assetCash;\\n            if (asset.assetType == Constants.FCASH_ASSET_TYPE) {\\n                assetCash = settlementRate.convertFromUnderlying(asset.notional);\\n                portfolioState.deleteAsset(i);\\n            } else if (AssetHandler.isLiquidityToken(asset.assetType)) {\\n                Market.loadSettlementMarket(market, asset.currencyId, asset.maturity, settleDate);\\n                int256 fCash;\\n                (assetCash, fCash) = market.removeLiquidity(asset.notional);\\n\\n                // Assets mature exactly on block time\\n                if (asset.maturity > blockTime) {\\n                    // If fCash has not yet matured then add it to the portfolio\\n                    _settleLiquidityTokenTofCash(portfolioState, i, fCash);\\n                } else {\\n                    // If asset has matured then settle fCash to asset cash\\n                    assetCash = assetCash.add(settlementRate.convertFromUnderlying(fCash));\\n                    portfolioState.deleteAsset(i);\\n                }\\n            }\\n            settleAmounts[settleAmountIndex].netCashChange = settleAmounts[settleAmountIndex]\\n                .netCashChange\\n                .add(assetCash);\\n        }\\n\\n        return settleAmounts;\\n    }\\n\\n    /// @notice Settles a liquidity token to idiosyncratic fCash, this occurs when the maturity is still in the future\\n    function _settleLiquidityTokenTofCash(\\n        PortfolioState memory portfolioState,\\n        uint256 index,\\n        int256 fCash\\n    ) private pure {\\n        PortfolioAsset memory liquidityToken = portfolioState.storedAssets[index];\\n        // If the liquidity token's maturity is still in the future then we change the entry to be\\n        // an idiosyncratic fCash entry with the net fCash amount.\\n        if (index != 0) {\\n            // Check to see if the previous index is the matching fCash asset, this will be the case when the\\n            // portfolio is sorted\\n            PortfolioAsset memory fCashAsset = portfolioState.storedAssets[index - 1];\\n\\n            if (\\n                fCashAsset.currencyId == liquidityToken.currencyId &&\\n                fCashAsset.maturity == liquidityToken.maturity &&\\n                fCashAsset.assetType == Constants.FCASH_ASSET_TYPE\\n            ) {\\n                // This fCash asset has not matured if we are settling to fCash\\n                fCashAsset.notional = fCashAsset.notional.add(fCash);\\n                fCashAsset.storageState = AssetStorageState.Update;\\n                portfolioState.deleteAsset(index);\\n            }\\n        }\\n\\n        // We are going to delete this asset anyway, convert to an fCash position\\n        liquidityToken.assetType = Constants.FCASH_ASSET_TYPE;\\n        liquidityToken.notional = fCash;\\n        liquidityToken.storageState = AssetStorageState.Update;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/settlement/SettleBitmapAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../markets/AssetRate.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../portfolio/BitmapAssetsHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../math/Bitmap.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\n\\n/**\\n * Settles a bitmap portfolio by checking for all matured fCash assets and turning them into cash\\n * at the prevailing settlement rate. It will also update the asset bitmap to ensure that it continues\\n * to correctly reference all actual maturities. fCash asset notional values are stored in *absolute* \\n * time terms and bitmap bits are *relative* time terms based on the bitNumber and the stored oldSettleTime.\\n * Remapping bits requires converting the old relative bit numbers to new relative bit numbers based on\\n * newSettleTime and the absolute times (maturities) that the previous bitmap references.\\n */\\nlibrary SettleBitmapAssets {\\n    using SafeInt256 for int256;\\n    using AssetRate for AssetRateParameters;\\n    using Bitmap for bytes32;\\n\\n    /// @notice Given a bitmap for a cash group and timestamps, will settle all assets\\n    /// that have matured and remap the bitmap to correspond to the current time.\\n    function settleBitmappedCashGroup(\\n        address account,\\n        uint256 currencyId,\\n        uint256 oldSettleTime,\\n        uint256 blockTime\\n    ) internal returns (int256 totalAssetCash, uint256 newSettleTime) {\\n        bytes32 bitmap = BitmapAssetsHandler.getAssetsBitmap(account, currencyId);\\n\\n        // This newSettleTime will be set to the new `oldSettleTime`. The bits between 1 and\\n        // `lastSettleBit` (inclusive) will be shifted out of the bitmap and settled. The reason\\n        // that lastSettleBit is inclusive is that it refers to newSettleTime which always less\\n        // than the current block time.\\n        newSettleTime = DateTime.getTimeUTC0(blockTime);\\n        // If newSettleTime == oldSettleTime lastSettleBit will be zero\\n        require(newSettleTime >= oldSettleTime); // dev: new settle time before previous\\n\\n        // Do not need to worry about validity, if newSettleTime is not on an exact bit we will settle up until\\n        // the closest maturity that is less than newSettleTime.\\n        (uint256 lastSettleBit, /* isValid */) = DateTime.getBitNumFromMaturity(oldSettleTime, newSettleTime);\\n        if (lastSettleBit == 0) return (totalAssetCash, newSettleTime);\\n\\n        // Returns the next bit that is set in the bitmap\\n        uint256 nextBitNum = bitmap.getNextBitNum();\\n        while (nextBitNum != 0 && nextBitNum <= lastSettleBit) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(oldSettleTime, nextBitNum);\\n            totalAssetCash = totalAssetCash.add(\\n                _settlefCashAsset(account, currencyId, maturity, blockTime)\\n            );\\n\\n            // Turn the bit off now that it is settled\\n            bitmap = bitmap.setBit(nextBitNum, false);\\n            nextBitNum = bitmap.getNextBitNum();\\n        }\\n\\n        bytes32 newBitmap;\\n        while (nextBitNum != 0) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(oldSettleTime, nextBitNum);\\n            (uint256 newBitNum, bool isValid) = DateTime.getBitNumFromMaturity(newSettleTime, maturity);\\n            require(isValid); // dev: invalid new bit num\\n\\n            newBitmap = newBitmap.setBit(newBitNum, true);\\n\\n            // Turn the bit off now that it is remapped\\n            bitmap = bitmap.setBit(nextBitNum, false);\\n            nextBitNum = bitmap.getNextBitNum();\\n        }\\n\\n        BitmapAssetsHandler.setAssetsBitmap(account, currencyId, newBitmap);\\n    }\\n\\n    /// @dev Stateful settlement function to settle a bitmapped asset. Deletes the\\n    /// asset from storage after calculating it.\\n    function _settlefCashAsset(\\n        address account,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) private returns (int256 assetCash) {\\n        mapping(address => mapping(uint256 =>\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\n        int256 notional = store[account][currencyId][maturity].notional;\\n        \\n        // Gets the current settlement rate or will store a new settlement rate if it does not\\n        // yet exist.\\n        AssetRateParameters memory rate =\\n            AssetRate.buildSettlementRateStateful(currencyId, maturity, blockTime);\\n        assetCash = rate.convertFromUnderlying(notional);\\n\\n        delete store[account][currencyId][maturity];\\n\\n        return assetCash;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[]","ContractName":"nTokenMintAction","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]