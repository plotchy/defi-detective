[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"cache/solpp-generated-contracts/zksync/DiamondUpgrade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./interfaces/IExecutor.sol\\\";\\nimport \\\"./facets/Base.sol\\\";\\nimport \\\"./Config.sol\\\";\\nimport \\\"./libraries/Diamond.sol\\\";\\n\\n/// @author Matter Labs\\ncontract DiamondUpgrade is Base {\\n    function initialize(\\n        bytes32 _genesisBlockHash,\\n        bytes32 _genesisBlockCommitment,\\n        uint64 _genesisIndexRepeatedStorageChanges\\n    ) external returns (bytes32) {\\n        IExecutor.StoredBlockInfo memory storedBlockZero = IExecutor.StoredBlockInfo(\\n            0,\\n            _genesisBlockHash,\\n            _genesisIndexRepeatedStorageChanges,\\n            0,\\n            EMPTY_STRING_KECCAK,\\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\\n            0,\\n            _genesisBlockCommitment\\n        );\\n\\n        s.storedBlockHashes[0] = keccak256(abi.encode(storedBlockZero));\\n\\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/interfaces/IExecutor.sol\": {\r\n      \"content\": \"pragma solidity ^0.8;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\ninterface IExecutor {\\n    /// @notice Rollup block stored data\\n    /// @param blockNumber Rollup block number\\n    /// @param blockHash Hash of L2 block\\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\\n    /// @param priorityOperationsHash Hash of all priority operations from this block\\n    /// @param l2LogsTreeRoot Root hash of tree that contains L2 -> L1 messages from this block\\n    /// @param timestamp Rollup block timestamp, have the same format as Ethereum block constant\\n    /// @param commitment Verified input for the zkSync circuit\\n    struct StoredBlockInfo {\\n        uint64 blockNumber;\\n        bytes32 blockHash;\\n        uint64 indexRepeatedStorageChanges;\\n        uint256 numberOfLayer1Txs;\\n        bytes32 priorityOperationsHash;\\n        bytes32 l2LogsTreeRoot;\\n        uint256 timestamp;\\n        bytes32 commitment;\\n    }\\n\\n    /// @notice Data needed to commit new block\\n    /// @param blockNumber Number of the committed block\\n    /// @param timestamp Unix timestamp denoting the start of the block execution\\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\\n    /// @param newStateRoot The state root of the full state tree\\n    /// @param ergsPerPubdataByteInBlock Price in ergs per one byte of published pubdata in block\\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\\n    /// @param l2LogsTreeRoot The root hash of the tree that contains all L2 -> L1 logs in the block\\n    /// @param priorityOperationsHash Hash of all priority operations from this block\\n    /// @param initialStorageChanges Storage write access as a concatenation key-value\\n    /// @param repeatedStorageChanges Storage write access as a concatenation index-value\\n    /// @param l2Logs concatenation of all L2 -> L1 logs in the block\\n    /// @param l2ArbitraryLengthMessages array of hash preimages that were sent as value of L2 logs by special system L2 contract\\n    /// @param factoryDeps array of l2 bytecodes that were marked as known on L2\\n    struct CommitBlockInfo {\\n        uint64 blockNumber;\\n        uint64 timestamp;\\n        uint64 indexRepeatedStorageChanges;\\n        bytes32 newStateRoot;\\n        uint256 numberOfLayer1Txs;\\n        bytes32 l2LogsTreeRoot;\\n        bytes32 priorityOperationsHash;\\n        bytes initialStorageChanges;\\n        bytes repeatedStorageChanges;\\n        bytes l2Logs;\\n        bytes[] l2ArbitraryLengthMessages;\\n        bytes[] factoryDeps;\\n    }\\n\\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\\n    /// TODO: The verifier integration is not finished yet, change the structure for compatibility later\\n    struct ProofInput {\\n        uint256[] recurisiveAggregationInput;\\n        uint256[] serializedProof;\\n    }\\n\\n    /// @notice Specifies whether to verify Zero Knowledge Proof for the block or just ignore the proof\\n    /// @dev This is a temporary measure for the first release, a validator can skip block verification\\n    /// if they failed to create the proof or faced any infrastructure issues\\n    /// @param Ignore The provided proof does NOT need to be verified\\n    /// @param Verify The provided proof does need to be verified\\n    enum BlockVerificationMode {\\n        Ignore,\\n        Verify\\n    }\\n\\n    function commitBlocks(StoredBlockInfo calldata _lastCommittedBlockData, CommitBlockInfo[] calldata _newBlocksData)\\n        external;\\n\\n    function proveBlocks(\\n        StoredBlockInfo calldata _prevBlock,\\n        StoredBlockInfo[] calldata _committedBlocks,\\n        ProofInput calldata _proof,\\n        BlockVerificationMode _verificationMode\\n    ) external;\\n\\n    function executeBlocks(StoredBlockInfo[] calldata _blocksData) external;\\n\\n    function revertBlocks(uint256 _newLastBlock) external;\\n\\n    /// @notice Event emitted when a block is committed\\n    event BlockCommit(uint256 indexed blockNumber, bytes32 indexed blockHash, bytes32 indexed commitment);\\n\\n    /// @notice Event emitted when blocks are verified\\n    event BlocksVerification(\\n        uint256 indexed previousLastVerifiedBlock,\\n        uint256 indexed currentLastVerifiedBlock,\\n        BlockVerificationMode verificationMode\\n    );\\n\\n    /// @notice Event emitted when a block is executed\\n    event BlockExecution(uint256 indexed blockNumber, bytes32 indexed blockHash, bytes32 indexed commitment);\\n\\n    /// @notice Event emitted when blocks are reverted\\n    event BlocksRevert(uint256 totalBlocksCommitted, uint256 totalBlocksVerified, uint256 totalBlocksExecuted);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/facets/Base.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"../Storage.sol\\\";\\nimport \\\"../../common/ReentrancyGuard.sol\\\";\\nimport \\\"../../common/AllowListed.sol\\\";\\n\\n/// @title Base contract containing functions accessible to the other facets.\\n/// @author Matter Labs\\ncontract Base is ReentrancyGuard, AllowListed {\\n    AppStorage internal s;\\n\\n    /// @notice Checks that the message sender is an active governor\\n    modifier onlyGovernor() {\\n        require(msg.sender == s.governor, \\\"1g\\\"); // only by governor\\n        _;\\n    }\\n\\n    /// @notice Checks if validator is active\\n    modifier onlyValidator() {\\n        require(s.validators[msg.sender], \\\"1h\\\"); // validator is not active\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/Config.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nbytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n/// @dev Bytes in raw L2 log\\n/// @dev Equal to the bytes size of the tuple - (uint8 ShardId, bool isService, uint16 txNumberInBlock, address sender, bytes32 key, bytes32 value)\\nuint256 constant L2_TO_L1_LOG_SERIALIZE_SIZE = 88;\\n\\n/// @dev Length of the bytes array with L2->L1 logs\\nuint256 constant L2_TO_L1_LOGS_COMMITMENT_BYTES = 4 + L2_TO_L1_LOG_SERIALIZE_SIZE * 512;\\n\\n/// @dev L2 -> L1 logs Merkle tree height\\nuint256 constant L2_TO_L1_LOG_MERKLE_TREE_HEIGHT = 9;\\n\\n/// @dev The value of default leaf hash for L2 -> L1 logs Merkle tree\\n/// @dev An incomplete fixed-size tree is filled with this value to be a full binary tree\\n/// @dev Actually equal to the `keccak256(new bytes(L2_LOG_BYTES))`\\nbytes32 constant L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH = 0x72abee45b59e344af8a6e520241c4744aff26ed411f4c4b00f8af09adada43ba;\\n\\n/// @dev Length of the bytes array with initial storage changes\\nuint256 constant INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + 64 * 4896;\\n\\n/// @dev Length of the bytes array with repeated storage changes\\nuint256 constant REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + 40 * 7787;\\n\\n// TODO: change constant to the real root hash of empty Merkle tree (SMA-184)\\nbytes32 constant DEFAULT_L2_LOGS_TREE_ROOT_HASH = bytes32(0);\\n\\n/// @dev The address of the special smart contract that can send arbitrary length message as an L2 log\\naddress constant L2_TO_L1_MESSENGER = address(0x8008);\\n\\n/// @dev The address of the bootloader start program\\naddress constant L2_BOOTLOADER_ADDRESS = address(0x8001);\\n\\n/// @dev The address of the known code storage system contract\\naddress constant L2_KNOWN_CODE_STORAGE_ADDRESS = address(0x8004);\\n\\n/// @dev The address of the context system contract\\naddress constant L2_SYSTEM_CONTEXT_ADDRESS = address(0x800b);\\n\\n/// @dev Denotes the first byte of the zkSync transaction that came from L1.\\nuint256 constant PRIORITY_OPERATION_L2_TX_TYPE = 255;\\n\\n/// @dev Expected average period of block creation\\nuint256 constant BLOCK_PERIOD = 13 seconds;\\n\\n/// @dev Expiration delta for priority request to be satisfied (in seconds)\\n/// @dev otherwise incorrect block with priority op could not be reverted.\\nuint256 constant PRIORITY_EXPIRATION_PERIOD = 3 days;\\n\\n/// @dev Expiration delta for priority request to be satisfied (in ETH blocks)\\nuint256 constant PRIORITY_EXPIRATION = PRIORITY_EXPIRATION_PERIOD/BLOCK_PERIOD;\\n\\n/// @dev Notice period before activation preparation status of upgrade mode (in seconds)\\n/// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this operation and withdraw funds from it.\\nuint256 constant UPGRADE_NOTICE_PERIOD = 0;\\n\\n/// @dev Timestamp - seconds since unix epoch\\nuint256 constant COMMIT_TIMESTAMP_NOT_OLDER = 365 days;\\n\\n/// @dev Maximum available error between real commit block timestamp and analog used in the verifier (in seconds)\\n/// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 15 seconds)\\nuint256 constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 365 days;\\n\\n/// @dev Bit mask to apply for verifier public input before verifying.\\nuint256 constant INPUT_MASK = 452312848583266388373324160190187140051835877600158453279131187530910662655;\\n\\n/// @dev The maximum number of ergs that a user can request for L1 -> L2 transactions\\nuint256 constant PRIORITY_TX_MAX_ERGS_LIMIT = 2097152;\\n\\n/// @dev Number of security council members that should approve an emergency upgrade\\nuint256 constant SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE = 1;\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/libraries/Diamond.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n\\n/// @author Matter Labs\\n/// @notice The helper library for managing the EIP-2535 diamond proxy.\\nlibrary Diamond {\\n    /// @dev Magic value that should be returned by diamond cut initialize contracts.\\n    /// @dev Used to distinguish calls to contracts that were supposed to be used as diamond initializer from other contracts.\\n    bytes32 constant DIAMOND_INIT_SUCCESS_RETURN_VALUE =\\n        0x33774e659306e47509050e97cb651e731180a42d458212294d30751925c551a2; // keccak256(\\\"diamond.zksync.init\\\") - 1\\n\\n    // TODO: Restore the diamond storage position when deploy to mainnet!\\n    // bytes32 constant DIAMOND_STORAGE_POSITION = 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131b; // keccak256(\\\"diamond.standard.diamond.storage\\\") - 1;\\n\\n    /// @dev Storage position of `DiamondStorage` structure.\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    event DiamondCut(FacetCut[] facetCuts, address initAddress, bytes initCalldata);\\n\\n    /// @dev Utility struct that contains associated facet & meta information of selector\\n    /// @param facetAddress address of the facet which is connected with selector\\n    /// @param selectorPosition index in `FacetToSelectors.selectors` array, where is selector stored\\n    /// @param isFreezable denotes whether the selector can be frozen.\\n    struct SelectorToFacet {\\n        address facetAddress;\\n        uint16 selectorPosition;\\n        bool isFreezable;\\n    }\\n\\n    /// @dev Utility struct that contains associated selectors & meta information of facet\\n    /// @param selectors list of all selectors that belong to the facet\\n    /// @param facetPosition index in `DiamondStorage.facets` array, where is facet stored\\n    struct FacetToSelectors {\\n        bytes4[] selectors;\\n        uint16 facetPosition;\\n    }\\n\\n    /// @notice The structure that holds all diamond proxy associated parameters\\n    /// @dev According to the EIP-2535 should be stored on a special storage key - `DIAMOND_STORAGE_POSITION`\\n    /// @param selectorToFacet A mapping from the selector to the facet address and its meta information\\n    /// @param facetToSelectors A mapping from facet address to its selector with meta information\\n    /// @param facets The array of all unique facet addresses that belong to the diamond proxy\\n    /// @param isFrozen Denotes whether the diamond proxy is frozen and all freezable facets are not accessible\\n    struct DiamondStorage {\\n        mapping(bytes4 => SelectorToFacet) selectorToFacet;\\n        mapping(address => FacetToSelectors) facetToSelectors;\\n        address[] facets;\\n        bool isFrozen;\\n    }\\n\\n    /// @dev Parameters for diamond changes that touch one of the facets\\n    /// @param facet The address of facet that's affected by the cut\\n    /// @param action The action that is made on the facet\\n    /// @param isFreezable Denotes whether the facet & all their selectors can be frozen\\n    /// @param selectors An array of unique selectors that belongs to the facet address\\n    struct FacetCut {\\n        address facet;\\n        Action action;\\n        bool isFreezable;\\n        bytes4[] selectors;\\n    }\\n\\n    /// @dev Structure of the diamond proxy changes\\n    /// @param facetCuts The set of changes (adding/removing/replacement) of implementation contracts\\n    /// @param initAddress The address that's dellegate called after setting up new facet changes\\n    /// @param initCalldata Calldata for the delegete call to `initAddress`\\n    struct DiamondCutData {\\n        FacetCut[] facetCuts;\\n        address initAddress;\\n        bytes initCalldata;\\n    }\\n\\n    /// @dev Add/replace/remove any number of selectors and optionally execute a function with delegatecall\\n    /// @param _diamondCut Diamond's facet changes and the parameters to optional initialization delegatecall\\n    enum Action {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n\\n    /// @return diamondStorage The pointer to the storage where all specific diamond proxy parameters stored\\n    function getDiamondStorage() internal pure returns (DiamondStorage storage diamondStorage) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            diamondStorage.slot := position\\n        }\\n    }\\n\\n    /// @dev Add/replace/remove any number of selectors and optionally execute a function with delegatecall\\n    /// @param _diamondCut Diamond's facet changes and the parameters to optional initialization delegatecall\\n    function diamondCut(DiamondCutData memory _diamondCut) internal {\\n        FacetCut[] memory facetCuts = _diamondCut.facetCuts;\\n        address initAddress = _diamondCut.initAddress;\\n        bytes memory initCalldata = _diamondCut.initCalldata;\\n        uint256 facetCutsLength = facetCuts.length;\\n        for (uint256 i = 0; i < facetCutsLength; ++i) {\\n            Action action = facetCuts[i].action;\\n            address facet = facetCuts[i].facet;\\n            bool isFacetFreezable = facetCuts[i].isFreezable;\\n            bytes4[] memory selectors = facetCuts[i].selectors;\\n\\n            require(selectors.length > 0, \\\"B\\\"); // no functions for diamond cut\\n\\n            if (action == Action.Add) {\\n                _addFunctions(facet, selectors, isFacetFreezable);\\n            } else if (action == Action.Replace) {\\n                _replaceFunctions(facet, selectors, isFacetFreezable);\\n            } else if (action == Action.Remove) {\\n                _removeFunctions(facet, selectors);\\n            } else {\\n                revert(\\\"C\\\"); // undefined diamond cut action\\n            }\\n        }\\n\\n        _initializeDiamondCut(initAddress, initCalldata);\\n        emit DiamondCut(facetCuts, initAddress, initCalldata);\\n    }\\n\\n    /// @dev Add new functions to the diamond proxy\\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\\n    function _addFunctions(\\n        address _facet,\\n        bytes4[] memory _selectors,\\n        bool _isFacetFreezable\\n    ) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        require(_facet != address(0), \\\"G\\\"); // facet with zero address cannot be added\\n\\n        // Add facet to the list of facets if the facet address is new one\\n        _saveFacetIfNew(_facet);\\n\\n        uint256 selectorsLength = _selectors.length;\\n        for (uint256 i = 0; i < selectorsLength; ++i) {\\n            bytes4 selector = _selectors[i];\\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\\n            require(oldFacet.facetAddress == address(0), \\\"J\\\"); // facet for this selector already exists\\n\\n            _addOneFunction(_facet, selector, _isFacetFreezable);\\n        }\\n    }\\n\\n    /// @dev Change associated facets to already known function selectors\\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\\n    function _replaceFunctions(\\n        address _facet,\\n        bytes4[] memory _selectors,\\n        bool _isFacetFreezable\\n    ) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        require(_facet != address(0), \\\"K\\\"); // cannot replace facet with zero address\\n\\n        uint256 selectorsLength = _selectors.length;\\n        for (uint256 i = 0; i < selectorsLength; ++i) {\\n            bytes4 selector = _selectors[i];\\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\\n            require(oldFacet.facetAddress != address(0), \\\"L\\\"); // it is impossible to replace the facet with zero address\\n\\n            _removeOneFunction(oldFacet.facetAddress, selector);\\n            // Add facet to the list of facets if the facet address is a new one\\n            _saveFacetIfNew(_facet);\\n            _addOneFunction(_facet, selector, _isFacetFreezable);\\n        }\\n    }\\n\\n    /// @dev Remove association with function and facet\\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\\n    function _removeFunctions(address _facet, bytes4[] memory _selectors) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        require(_facet == address(0), \\\"a1\\\"); // facet address must be zero\\n\\n        uint256 selectorsLength = _selectors.length;\\n        for (uint256 i = 0; i < selectorsLength; ++i) {\\n            bytes4 selector = _selectors[i];\\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\\n            require(oldFacet.facetAddress != address(0), \\\"a2\\\"); // Can't delete a non-existent facet\\n\\n            _removeOneFunction(oldFacet.facetAddress, selector);\\n        }\\n    }\\n\\n    /// @dev Add address to the list of known facets if it is not on the list yet\\n    /// NOTE: should be called ONLY before adding a new selector associated with the address\\n    function _saveFacetIfNew(address _facet) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        uint256 selectorsLength = ds.facetToSelectors[_facet].selectors.length;\\n        // If there are no selectors associated with facet then save facet as new one\\n        if (selectorsLength == 0) {\\n            ds.facetToSelectors[_facet].facetPosition = uint16(ds.facets.length);\\n            ds.facets.push(_facet);\\n        }\\n    }\\n\\n    /// @dev Add one function to the already known facet\\n    /// NOTE: It is expected but NOT enforced that:\\n    /// - `_facet` is NON-ZERO address\\n    /// - `_facet` is already stored address in `DiamondStorage.facets`\\n    /// - `_selector` is NOT associated by another facet\\n    function _addOneFunction(\\n        address _facet,\\n        bytes4 _selector,\\n        bool _isSelectorFreezable\\n    ) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        uint16 selectorPosition = uint16(ds.facetToSelectors[_facet].selectors.length);\\n\\n        // if selectorPosition is nonzero, it means it is not a new facet\\n        // so the freezability of the first selector must be matched to _isSelectorFreezable\\n        // so all the selectors in a facet will have the same freezability\\n        if (selectorPosition != 0) {\\n            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];\\n            require(_isSelectorFreezable == ds.selectorToFacet[selector0].isFreezable, \\\"J1\\\");\\n        }\\n\\n        ds.selectorToFacet[_selector] = SelectorToFacet({\\n            facetAddress: _facet,\\n            selectorPosition: selectorPosition,\\n            isFreezable: _isSelectorFreezable\\n        });\\n        ds.facetToSelectors[_facet].selectors.push(_selector);\\n    }\\n\\n    /// @dev Remove one associated function with facet\\n    /// NOTE: It is expected but NOT enforced that `_facet` is NON-ZERO address\\n    function _removeOneFunction(address _facet, bytes4 _selector) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        // Get index of `FacetToSelectors.selectors` of the selector and last element of array\\n        uint256 selectorPosition = ds.selectorToFacet[_selector].selectorPosition;\\n        uint256 lastSelectorPosition = ds.facetToSelectors[_facet].selectors.length - 1;\\n\\n        // If the selector is not at the end of the array then move the last element to the selector position\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetToSelectors[_facet].selectors[lastSelectorPosition];\\n\\n            ds.facetToSelectors[_facet].selectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacet[lastSelector].selectorPosition = uint16(selectorPosition);\\n        }\\n\\n        // Remove last element from the selectors array\\n        ds.facetToSelectors[_facet].selectors.pop();\\n\\n        // Finally, clean up the association with facet\\n        delete ds.selectorToFacet[_selector];\\n\\n        // If there are no selectors for facet then remove the facet from the list of known facets\\n        if (lastSelectorPosition == 0) {\\n            _removeFacet(_facet);\\n        }\\n    }\\n\\n    /// @dev remove facet from the list of known facets\\n    /// NOTE: It is expected but NOT enforced that there are no selectors associated wih `_facet`\\n    function _removeFacet(address _facet) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        // Get index of `DiamondStorage.facets` of the facet and last element of array\\n        uint256 facetPosition = ds.facetToSelectors[_facet].facetPosition;\\n        uint256 lastFacetPosition = ds.facets.length - 1;\\n\\n        // If the facet is not at the end of the array then move the last element to the facet position\\n        if (facetPosition != lastFacetPosition) {\\n            address lastFacet = ds.facets[lastFacetPosition];\\n\\n            ds.facets[facetPosition] = lastFacet;\\n            ds.facetToSelectors[lastFacet].facetPosition = uint16(facetPosition);\\n        }\\n\\n        // Remove last element from the facets array\\n        ds.facets.pop();\\n    }\\n\\n    /// @dev Delegates call to the initialization address with provided calldata\\n    /// @dev Used as a final step of diamond cut to execute the logic of the initialization for changed facets\\n    function _initializeDiamondCut(address _init, bytes memory _calldata) private {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"H\\\"); // Non-empty calldata for zero address\\n        } else {\\n            // Do not check whether `_init` is a contract since later we check that it returns data.\\n            (bool success, bytes memory data) = _init.delegatecall(_calldata);\\n            require(success, \\\"I\\\"); // delegatecall failed\\n\\n            // Check that called contract returns magic value to make sure that contract logic\\n            // supposed to be used as diamond cut initializer.\\n            require(data.length == 32, \\\"lp\\\");\\n            require(abi.decode(data, (bytes32)) == DIAMOND_INIT_SUCCESS_RETURN_VALUE, \\\"lp1\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/Storage.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Verifier.sol\\\";\\nimport \\\"../common/interfaces/IAllowList.sol\\\";\\nimport \\\"./libraries/PriorityQueue.sol\\\";\\n\\n/// @dev Logically separated part of the storage structure, which is responsible for everything related to proxy upgrades and diamond cuts\\n/// @param proposedDiamondCutHash The hash of diamond cut that was proposed in the current upgrade\\n/// @param proposedDiamondCutTimestamp The timestamp when the diamond cut was proposed, zero if there are no active proposals\\n/// @param lastDiamondFreezeTimestamp The timestamp when the diamond was frozen last time, zero if the diamond was never frozen\\n/// @param currentProposalId The serial number of proposed diamond cuts, increments when proposing a new diamond cut\\n/// @param securityCouncilMembers The set of the trustedÂ addresses that can instantly finish upgrade (diamond cut)\\n/// @param securityCouncilMemberLastApprovedProposalId The mapping of the security council addresses and the last diamond cut that they approved\\n/// @param securityCouncilEmergencyApprovals The number of received upgrade approvals from the security council\\nstruct DiamondCutStorage {\\n    bytes32 proposedDiamondCutHash;\\n    uint256 proposedDiamondCutTimestamp;\\n    uint256 lastDiamondFreezeTimestamp;\\n    uint256 currentProposalId;\\n    mapping(address => bool) securityCouncilMembers;\\n    mapping(address => uint256) securityCouncilMemberLastApprovedProposalId;\\n    uint256 securityCouncilEmergencyApprovals;\\n}\\n\\n/// @dev The log passed from L2\\n/// @param l2ShardId The shard identifier, 0 - rollup, 1 - porter. All other values are not used but are reserved for the future\\n/// @param isService A boolean flag that is part of the log along with `key`, `value`, and `sender` address.\\n/// This field is required formally but does not have any special meaning.\\n/// @param txNumberInBlock The L2 transaction number in a block, in which the log was sent\\n/// @param sender The L2 address which sent the log\\n/// @param key The 32 bytes of information that was sent in the log\\n/// @param value The 32 bytes of information that was sent in the log\\n// Both `key` and `value` are arbitrary 32-bytes selected by the log sender\\nstruct L2Log {\\n    uint8 l2ShardId;\\n    bool isService;\\n    uint16 txNumberInBlock;\\n    address sender;\\n    bytes32 key;\\n    bytes32 value;\\n}\\n\\n/// @dev An arbitrary length message passed from L2\\n/// @notice Under the hood it is `L2Log` sent from the special system L2 contract\\n/// @param txNumberInBlock The L2 transaction number in a block, in which the message was sent\\n/// @param sender The address of the L2 account from which the message was passed\\n/// @param data An arbitrary length message\\nstruct L2Message {\\n    uint16 txNumberInBlock;\\n    address sender;\\n    bytes data;\\n}\\n\\n/// @notice Part of the configuration parameters of ZKP circuits\\nstruct VerifierParams {\\n    bytes32 recursionNodeLevelVkHash;\\n    bytes32 recursionLeafLevelVkHash;\\n    bytes32 recursionCircuitsSetVksHash;\\n}\\n\\n/// @dev storing all storage variables for zkSync facets\\n/// NOTE: It is used in a proxy, so it is possible to add new variables to the end\\n/// NOTE: but NOT to modify already existing variables or change their order\\nstruct AppStorage {\\n    /// @dev Storage of variables needed for diamond cut facet\\n    DiamondCutStorage diamondCutStorage;\\n    /// @notice Address which will exercise governance over the network i.e. change validator set, conduct upgrades\\n    address governor;\\n    /// @notice Address that governor proposed as one that will replace it\\n    address pendingGovernor;\\n    /// @notice List of permitted validators\\n    mapping(address => bool) validators;\\n    // TODO: should be used an external library approach\\n    /// @dev Verifier contract. Used to verify aggregated proof for blocks\\n    Verifier verifier;\\n    /// @notice Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)\\n    uint256 totalBlocksExecuted;\\n    /// @notice Total number of proved blocks i.e. blocks[totalBlocksProved] points at the latest proved block\\n    uint256 totalBlocksVerified;\\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\\n    uint256 totalBlocksCommitted;\\n    /// @dev Stored hashed StoredBlock for block number\\n    mapping(uint256 => bytes32) storedBlockHashes;\\n    /// @dev Stored root hashes of L2 -> L1 logs\\n    mapping(uint256 => bytes32) l2LogsRootHashes;\\n    /// @dev Container that stores transactions requested from L1\\n    PriorityQueue.Queue priorityQueue;\\n    /// @dev The smart contract that manages the list with permission to call contract functions\\n    IAllowList allowList;\\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\\n    VerifierParams verifierParams;\\n    /// @notice Bytecode hash of bootloader program.\\n    /// @dev Used as an input to zkp-circuit.\\n    bytes32 l2BootloaderBytecodeHash;\\n    /// @notice Bytecode hash of default account (bytecode for EOA).\\n    /// @dev Used as an input to zkp-circuit.\\n    bytes32 l2DefaultAccountBytecodeHash;\\n    /// @dev Indicates that the porter may be touched on L2 transactions.\\n    /// @dev Used as an input to zkp-circuit.\\n    bool zkPorterIsAvailable;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/common/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\nabstract contract ReentrancyGuard {\\n    /// @dev Address of lock flag variable.\\n    /// @dev Flag is placed at random memory location to not interfere with Storage contract.\\n    uint256 private constant LOCK_FLAG_ADDRESS = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4; // keccak256(\\\"ReentrancyGuard\\\") - 1;\\n\\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/security/ReentrancyGuard.sol\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    modifier reentrancyGuardInitializer() {\\n        _initializeReentrancyGuard();\\n        _;\\n    }\\n\\n    function _initializeReentrancyGuard() private {\\n        uint256 lockSlotOldValue;\\n\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive but in exchange every call to nonReentrant\\n        // will be cheaper.\\n        assembly {\\n            lockSlotOldValue := sload(LOCK_FLAG_ADDRESS)\\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\\n        }\\n\\n        // Check that storage slot for reentrancy guard is empty to rule out possibility of slot conflict\\n        require(lockSlotOldValue == 0, \\\"1B\\\");\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        uint256 _status;\\n        assembly {\\n            _status := sload(LOCK_FLAG_ADDRESS)\\n        }\\n\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status == _NOT_ENTERED, \\\"r1\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        assembly {\\n            sstore(LOCK_FLAG_ADDRESS, _ENTERED)\\n        }\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        assembly {\\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/common/AllowListed.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./interfaces/IAllowList.sol\\\";\\n\\n/// @author Matter Labs\\nabstract contract AllowListed {\\n    modifier senderCanCallFunction(IAllowList _allowList) {\\n        // Preventing the stack too deep error\\n        {\\n            // Take the first four bytes of the calldata as a function selector.\\n            // Please note, `msg.data[:4]` will revert the call if the calldata is less than four bytes.\\n            bytes4 functionSig = bytes4(msg.data[:4]);\\n            require(_allowList.canCall(msg.sender, address(this), functionSig), \\\"nr\\\");\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/Verifier.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Plonk4VerifierWithAccessToDNext.sol\\\";\\nimport \\\"../common/libraries/UncheckedMath.sol\\\";\\n\\ncontract Verifier is Plonk4VerifierWithAccessToDNext {\\n    using UncheckedMath for uint256;\\n\\n    function get_verification_key() internal pure returns (VerificationKey memory vk) {\\n        vk.num_inputs = 1;\\n        vk.domain_size = 67108864;\\n        vk.omega = PairingsBn254.new_fr(0x1dba8b5bdd64ef6ce29a9039aca3c0e524395c43b9227b96c75090cc6cc7ec97);\\n        // coefficients\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x19af674d98a56e4b530aa94bf82df98768bb214aa1f261b1d1fb6789f9e66d67,\\n            0x0335e647418f85e76d27feca0cce7027b92b0eabf93888219b9beca066886730\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x0503f826267486c0a6d73afb4d9a8f0ed019d5d129fcedcbfa0b2970c8a3d7fa,\\n            0x008af7d231afc190a96c02da5cc6721fcff5e01ba1ad65540a3fde576802d1cd\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x0198011f9c1c53811036bc8e0e8002c1b8892001e9ce0cd18110af9a03087421,\\n            0x25933f6eb6db13720269a863a55db5dd31c96b1ee0da61e34e09f83a59297ca2\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x17e76e39a1a2e71f32b5cab55c4eef178a632e7d907153e06f53e364dbd2cbc8,\\n            0x21fccb59891624d9d9d35d0f661afb120ca1f78628b8aa59beeefd4431107e88\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x1b041d57c56b8521f2520442e462f755721ab4aeb573487618ce09910a8c6354,\\n            0x0e4ec17897446c4fd1c36559405a0d2def071c4ad5b9124116db5654129ffed5\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x2a06f3104a04d0a5272f5e623cdecdce7e06b4aef361be0786f3a6814280d05b,\\n            0x21541f91d1e19e517d6471dba9f048355896e9a2bf7ececbecbdc63431ecb261\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x204b887749553f1d24bec0f6066088454b586d25fc57d716679517d12082e1ed,\\n            0x27f989c5dd011c6aaf441068780f3b133eb2bde878843155c85abeec4ab91f11\\n        );\\n        vk.gate_setup_commitments[7] = PairingsBn254.new_g1(\\n            0x1a8cd862024729474b1b5ef122acf86f759433abaefdcfb8fa7e6ad761b112b2,\\n            0x2a80832c2d1f2e7aa625b720d14b93f628c107ef41d78d492aa123c75d97a848\\n        );\\n        // gate selectors\\n        vk.gate_selectors_commitments[0] = PairingsBn254.new_g1(\\n            0x1633993f359a7b1738f2fbd69ce7643e423570fb0a6fe55a244bea41596dfc3d,\\n            0x2cf6203dad1d1295d1793cdd114195c129b0ecc663f4e92917c1490980385a44\\n        );\\n        vk.gate_selectors_commitments[1] = PairingsBn254.new_g1(\\n            0x10f0ab2fda24f693b7851a3c626c5eb3dd1ef9bacc68fdbfe638466f8fc2b949,\\n            0x15fde64ce1ae3313f039d7b9b7f192fa5a7b0bd80307c67cfed47fae20f008e4\\n        );\\n        // permutation\\n        vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x03a5af959e223de35693573bc896f333fac84cfe4f272c4080bc102e4c4752b3,\\n            0x102cd8e77890c56a99a9cf9bb964ee3e3b60629e35f60b94a97932903b31cbc6\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x0f4c46be8af3e4fa5e0ce6d2985b1db29177975309e55748da391d2b81c98288,\\n            0x1c5bed67fe034739a649e373e684120495431377c2d4e81689d678635ea737b2\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x2a990254375e7cc9bec8ab68e5a5ec5ee49de5b2a6b0b33cecb557125aa93b43,\\n            0x046b3e9a530f72b2a8d3226b1285ce7b656bb112e243750664fe066423bcb4ca\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x281baa0297d9c6d6a8d79caa59fa5dd78efe760dfd4a1ae7575b8b996497e4cc,\\n            0x22a32326f73a3d070184f7da88ebec776d1ef63207bb2b5e04d28307eeed9c47\\n        );\\n        // lookup table commitments\\n        vk.lookup_selector_commitment = PairingsBn254.new_g1(\\n            0x1035bcc4f67bc18af0db54384cc120d50060121d3b2a4e8698937756b3f73b54,\\n            0x1b1eebcd824d7b114cd230e0a450b63ff5218a6141bb5bf013a79ba2ab6f7ddb\\n        );\\n        vk.lookup_tables_commitments[0] = PairingsBn254.new_g1(\\n            0x0ebe0de4a2f39df3b903da484c1641ffdffb77ff87ce4f9508c548659eb22d3c,\\n            0x12a3209440242d5662729558f1017ed9dcc08fe49a99554dd45f5f15da5e4e0b\\n        );\\n        vk.lookup_tables_commitments[1] = PairingsBn254.new_g1(\\n            0x1b7d54f8065ca63bed0bfbb9280a1011b886d07e0c0a26a66ecc96af68c53bf9,\\n            0x2c51121fff5b8f58c302f03c74e0cb176ae5a1d1730dec4696eb9cce3fe284ca\\n        );\\n        vk.lookup_tables_commitments[2] = PairingsBn254.new_g1(\\n            0x0138733c5faa9db6d4b8df9748081e38405999e511fb22d40f77cf3aef293c44,\\n            0x269bee1c1ac28053238f7fe789f1ea2e481742d6d16ae78ed81e87c254af0765\\n        );\\n        vk.lookup_tables_commitments[3] = PairingsBn254.new_g1(\\n            0x1b1be7279d59445065a95f01f16686adfa798ec4f1e6845ffcec9b837e88372e,\\n            0x057c90cb96d8259238ed86b05f629efd55f472a721efeeb56926e979433e6c0e\\n        );\\n        vk.lookup_table_type_commitment = PairingsBn254.new_g1(\\n            0x011967367ae87879d15a58c58e4849bc897764ce3f016d5abc04bc7804d6bdf7,\\n            0x29775ffa2d2ddd439a664e165294f68ea17d6d754bcf4c20a52fbf766eeb1995\\n        );\\n        // non residues\\n        vk.non_residues[0] = PairingsBn254.new_fr(0x0000000000000000000000000000000000000000000000000000000000000005);\\n        vk.non_residues[1] = PairingsBn254.new_fr(0x0000000000000000000000000000000000000000000000000000000000000007);\\n        vk.non_residues[2] = PairingsBn254.new_fr(0x000000000000000000000000000000000000000000000000000000000000000a);\\n\\n        // g2 elements\\n        vk.g2_elements[0] = PairingsBn254.new_g2(\\n            [\\n                0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n                0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\\n            ],\\n            [\\n                0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n                0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n            ]\\n        );\\n        vk.g2_elements[1] = PairingsBn254.new_g2(\\n            [\\n                0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n                0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0\\n            ],\\n            [\\n                0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n                0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55\\n            ]\\n        );\\n    }\\n\\n    function deserialize_proof(uint256[] calldata public_inputs, uint256[] calldata serialized_proof)\\n        internal\\n        pure\\n        returns (Proof memory proof)\\n    {\\n        // require(serialized_proof.length == 44); TODO\\n        proof.input_values = new uint256[](public_inputs.length);\\n        for (uint256 i = 0; i < public_inputs.length; i = i.uncheckedInc()) {\\n            proof.input_values[i] = public_inputs[i];\\n        }\\n\\n        uint256 j;\\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\\n            proof.state_polys_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j.uncheckedInc()]\\n            );\\n\\n            j = j.uncheckedAdd(2);\\n        }\\n        proof.copy_permutation_grand_product_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j.uncheckedInc()]\\n        );\\n        j = j.uncheckedAdd(2);\\n\\n        proof.lookup_s_poly_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j.uncheckedInc()]\\n        );\\n        j = j.uncheckedAdd(2);\\n\\n        proof.lookup_grand_product_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j.uncheckedInc()]\\n        );\\n        j = j.uncheckedAdd(2);\\n        for (uint256 i = 0; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\\n            proof.quotient_poly_parts_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j.uncheckedInc()]\\n            );\\n            j = j.uncheckedAdd(2);\\n        }\\n\\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; i = i.uncheckedInc()) {\\n            proof.state_polys_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j = j.uncheckedInc();\\n        }\\n\\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega.length; i = i.uncheckedInc()) {\\n            proof.state_polys_openings_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j = j.uncheckedInc();\\n        }\\n        for (uint256 i = 0; i < proof.gate_selectors_openings_at_z.length; i = i.uncheckedInc()) {\\n            proof.gate_selectors_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j = j.uncheckedInc();\\n        }\\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\\n            proof.copy_permutation_polys_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j = j.uncheckedInc();\\n        }\\n        proof.copy_permutation_grand_product_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j = j.uncheckedInc();\\n        proof.lookup_s_poly_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n        j = j.uncheckedInc();\\n        proof.lookup_grand_product_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j = j.uncheckedInc();\\n        proof.lookup_t_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j = j.uncheckedInc();\\n        proof.lookup_t_poly_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n        j = j.uncheckedInc();\\n        proof.lookup_selector_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n        j = j.uncheckedInc();\\n        proof.lookup_table_type_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n        j = j.uncheckedInc();\\n        proof.quotient_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n        j = j.uncheckedInc();\\n        proof.linearization_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n        j = j.uncheckedInc();\\n        proof.opening_proof_at_z = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j.uncheckedInc()]\\n        );\\n        j = j.uncheckedAdd(2);\\n        proof.opening_proof_at_z_omega = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j.uncheckedInc()]\\n        );\\n    }\\n\\n    function verify_serialized_proof(uint256[] calldata public_inputs, uint256[] calldata serialized_proof)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        VerificationKey memory vk = get_verification_key();\\n        require(vk.num_inputs == public_inputs.length);\\n\\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\\n\\n        return verify(proof, vk);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/common/interfaces/IAllowList.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\ninterface IAllowList {\\n    /*//////////////////////////////////////////////////////////////\\n                            EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice public access is changed\\n    event UpdatePublicAccess(address indexed target, bool newStatus);\\n\\n    /// @notice permission to call is changed\\n    event UpdateCallPermission(address indexed caller, address indexed target, bytes4 indexed functionSig, bool status);\\n\\n    /// @notice pendingOwner is changed\\n    /// @dev Also emitted when the new owner is accepted and in this case, `newPendingOwner` would be zero address\\n    event NewPendingOwner(address indexed oldPendingOwner, address indexed newPendingOwner);\\n\\n    /// @notice Owner changed\\n    event NewOwner(address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            GETTERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function isAccessPublic(address _target) external view returns (bool);\\n\\n    function hasSpecialAccessToCall(\\n        address _caller,\\n        address _target,\\n        bytes4 _functionSig\\n    ) external view returns (bool);\\n\\n    function canCall(\\n        address _caller,\\n        address _target,\\n        bytes4 _functionSig\\n    ) external view returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           ALLOW LIST LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setBatchPublicAccess(address[] calldata _targets, bool[] calldata _enables) external;\\n\\n    function setPublicAccess(address _target, bool _enable) external;\\n\\n    function setBatchPermissionToCall(\\n        address[] calldata _callers,\\n        address[] calldata _targets,\\n        bytes4[] calldata _functionSigs,\\n        bool[] calldata _enables\\n    ) external;\\n\\n    function setPermissionToCall(\\n        address _caller,\\n        address _target,\\n        bytes4 _functionSig,\\n        bool _enable\\n    ) external;\\n\\n    function setPendingOwner(address _newPendingOwner) external;\\n\\n    function acceptOwner() external;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/libraries/PriorityQueue.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @notice The structure that contains meta information of the L2 transaction that was requested from L1\\n/// @dev The weird size of fields was selected specifically to minimize the structure storage size\\n/// @param canonicalTxHash Hashed L2 transaction data that is needed to process it\\n/// @param expirationBlock Expiration block number (ETH block) for this request (must be satisfied before)\\n/// @param layer2Tip Additional payment to the validator as an incentive to perform the operation\\nstruct PriorityOperation {\\n    bytes32 canonicalTxHash;\\n    uint64 expirationBlock;\\n    uint192 layer2Tip;\\n}\\n\\n/// @author Matter Labs\\n/// @dev The library provides the API to interact with the priority queue container\\n/// @dev Order of processing operations from queue - FIFO (Fist in - first out)\\nlibrary PriorityQueue {\\n    using PriorityQueue for Queue;\\n\\n    /// @notice Container that stores priority operations\\n    /// @param data The inner mapping that saves priority operation by its index\\n    /// @param head The pointer to the first unprocessed priority operation\\n    /// @param tail The pointer to the last added priority operation\\n    struct Queue {\\n        mapping(uint256 => PriorityOperation) data;\\n        uint256 tail;\\n        uint256 head;\\n    }\\n\\n    /// @notice Returns zero if and only if no operations were processed from the queue\\n    /// @return Index of the oldest priority operation that wasn't processed yet\\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\\n        return _queue.head;\\n    }\\n\\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\\n        return _queue.tail;\\n    }\\n\\n    /// @return The total number of unprocessed priority operations in a priority queue\\n    function getSize(Queue storage _queue) internal view returns (uint256) {\\n        return uint256(_queue.tail - _queue.head);\\n    }\\n\\n    /// @return Whether the priority queue contains no operations\\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\\n        return _queue.tail == _queue.head;\\n    }\\n\\n    /// @notice Add the priority operation to the end of the priority queue\\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\\n        // Save value into the stack to avoid double reading from the storage\\n        uint256 tail = _queue.tail;\\n\\n        _queue.data[tail] = _operation;\\n        _queue.tail = tail + 1;\\n    }\\n\\n    /// @return The first unprocessed priority operation from the queue\\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\\n        require(!_queue.isEmpty(), \\\"D\\\"); // priority queue is empty\\n\\n        return _queue.data[_queue.head];\\n    }\\n\\n    /// @notice Remove the first unprocessed priority operation from the queue\\n    /// @return priorityOperation that was popped from the priority queue\\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\\n        require(!_queue.isEmpty(), \\\"s\\\"); // priority queue is empty\\n\\n        // Save value into the stack to avoid double reading from the storage\\n        uint256 head = _queue.head;\\n\\n        priorityOperation = _queue.data[head];\\n        delete _queue.data[head];\\n        _queue.head = head + 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/Plonk4VerifierWithAccessToDNext.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./libraries/PairingsBn254.sol\\\";\\nimport \\\"./libraries/TranscriptLib.sol\\\";\\nimport \\\"../common/libraries/UncheckedMath.sol\\\";\\n\\nuint256 constant STATE_WIDTH = 4;\\nuint256 constant NUM_G2_ELS = 2;\\n\\nstruct VerificationKey {\\n    uint256 domain_size;\\n    uint256 num_inputs;\\n    PairingsBn254.Fr omega;\\n    PairingsBn254.G1Point[2] gate_selectors_commitments;\\n    PairingsBn254.G1Point[8] gate_setup_commitments;\\n    PairingsBn254.G1Point[STATE_WIDTH] permutation_commitments;\\n    PairingsBn254.G1Point lookup_selector_commitment;\\n    PairingsBn254.G1Point[4] lookup_tables_commitments;\\n    PairingsBn254.G1Point lookup_table_type_commitment;\\n    PairingsBn254.Fr[STATE_WIDTH - 1] non_residues;\\n    PairingsBn254.G2Point[NUM_G2_ELS] g2_elements;\\n}\\n\\ncontract Plonk4VerifierWithAccessToDNext {\\n    using PairingsBn254 for PairingsBn254.G1Point;\\n    using PairingsBn254 for PairingsBn254.G2Point;\\n    using PairingsBn254 for PairingsBn254.Fr;\\n\\n    using TranscriptLib for TranscriptLib.Transcript;\\n\\n    using UncheckedMath for uint256;\\n\\n    struct Proof {\\n        uint256[] input_values;\\n        // commitments\\n        PairingsBn254.G1Point[STATE_WIDTH] state_polys_commitments;\\n        PairingsBn254.G1Point copy_permutation_grand_product_commitment;\\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_parts_commitments;\\n        // openings\\n        PairingsBn254.Fr[STATE_WIDTH] state_polys_openings_at_z;\\n        PairingsBn254.Fr[1] state_polys_openings_at_z_omega; // TODO: not use array while there is only D_next\\n        PairingsBn254.Fr[1] gate_selectors_openings_at_z;\\n        PairingsBn254.Fr[STATE_WIDTH - 1] copy_permutation_polys_openings_at_z;\\n        PairingsBn254.Fr copy_permutation_grand_product_opening_at_z_omega;\\n        PairingsBn254.Fr quotient_poly_opening_at_z;\\n        PairingsBn254.Fr linearization_poly_opening_at_z;\\n        // lookup commitments\\n        PairingsBn254.G1Point lookup_s_poly_commitment;\\n        PairingsBn254.G1Point lookup_grand_product_commitment;\\n        // lookup openings\\n        PairingsBn254.Fr lookup_s_poly_opening_at_z_omega;\\n        PairingsBn254.Fr lookup_grand_product_opening_at_z_omega;\\n        PairingsBn254.Fr lookup_t_poly_opening_at_z;\\n        PairingsBn254.Fr lookup_t_poly_opening_at_z_omega;\\n        PairingsBn254.Fr lookup_selector_poly_opening_at_z;\\n        PairingsBn254.Fr lookup_table_type_poly_opening_at_z;\\n        PairingsBn254.G1Point opening_proof_at_z;\\n        PairingsBn254.G1Point opening_proof_at_z_omega;\\n    }\\n\\n    struct PartialVerifierState {\\n        PairingsBn254.Fr zero;\\n        PairingsBn254.Fr alpha;\\n        PairingsBn254.Fr beta;\\n        PairingsBn254.Fr gamma;\\n        PairingsBn254.Fr[9] alpha_values;\\n        PairingsBn254.Fr eta;\\n        PairingsBn254.Fr beta_lookup;\\n        PairingsBn254.Fr gamma_lookup;\\n        PairingsBn254.Fr beta_plus_one;\\n        PairingsBn254.Fr beta_gamma;\\n        PairingsBn254.Fr v;\\n        PairingsBn254.Fr u;\\n        PairingsBn254.Fr z;\\n        PairingsBn254.Fr z_omega;\\n        PairingsBn254.Fr z_minus_last_omega;\\n        PairingsBn254.Fr l_0_at_z;\\n        PairingsBn254.Fr l_n_minus_one_at_z;\\n        PairingsBn254.Fr t;\\n        PairingsBn254.G1Point tp;\\n    }\\n\\n    function evaluate_l0_at_point(uint256 domain_size, PairingsBn254.Fr memory at)\\n        internal\\n        view\\n        returns (PairingsBn254.Fr memory num)\\n    {\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.Fr memory size_fe = PairingsBn254.new_fr(domain_size);\\n        PairingsBn254.Fr memory den = at.copy();\\n        den.sub_assign(one);\\n        den.mul_assign(size_fe);\\n\\n        den = den.inverse();\\n\\n        num = at.pow(domain_size);\\n        num.sub_assign(one);\\n        num.mul_assign(den);\\n    }\\n\\n    function evaluate_lagrange_poly_out_of_domain(\\n        uint256 poly_num,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        // (omega^i / N) / (X - omega^i) * (X^N - 1)\\n        require(poly_num < domain_size);\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\\n        res = at.pow(domain_size);\\n        res.sub_assign(one);\\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\\n        res.mul_assign(omega_power);\\n\\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\\n        den.sub_assign(omega_power);\\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\\n\\n        den = den.inverse();\\n\\n        res.mul_assign(den);\\n    }\\n\\n    function evaluate_vanishing(uint256 domain_size, PairingsBn254.Fr memory at)\\n        internal\\n        view\\n        returns (PairingsBn254.Fr memory res)\\n    {\\n        res = at.pow(domain_size);\\n        res.sub_assign(PairingsBn254.new_fr(1));\\n    }\\n\\n    function initialize_transcript(Proof memory proof, VerificationKey memory vk)\\n        internal\\n        pure\\n        returns (PartialVerifierState memory state)\\n    {\\n        TranscriptLib.Transcript memory transcript = TranscriptLib.new_transcript();\\n\\n        for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc()) {\\n            transcript.update_with_u256(proof.input_values[i]);\\n        }\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\\n            transcript.update_with_g1(proof.state_polys_commitments[i]);\\n        }\\n\\n        state.eta = transcript.get_challenge();\\n        transcript.update_with_g1(proof.lookup_s_poly_commitment);\\n\\n        state.beta = transcript.get_challenge();\\n        state.gamma = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.copy_permutation_grand_product_commitment);\\n        state.beta_lookup = transcript.get_challenge();\\n        state.gamma_lookup = transcript.get_challenge();\\n        transcript.update_with_g1(proof.lookup_grand_product_commitment);\\n        state.alpha = transcript.get_challenge();\\n\\n        for (uint256 i = 0; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\\n            transcript.update_with_g1(proof.quotient_poly_parts_commitments[i]);\\n        }\\n        state.z = transcript.get_challenge();\\n\\n        transcript.update_with_fr(proof.quotient_poly_opening_at_z);\\n\\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; i = i.uncheckedInc()) {\\n            transcript.update_with_fr(proof.state_polys_openings_at_z[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega.length; i = i.uncheckedInc()) {\\n            transcript.update_with_fr(proof.state_polys_openings_at_z_omega[i]);\\n        }\\n        for (uint256 i = 0; i < proof.gate_selectors_openings_at_z.length; i = i.uncheckedInc()) {\\n            transcript.update_with_fr(proof.gate_selectors_openings_at_z[i]);\\n        }\\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\\n            transcript.update_with_fr(proof.copy_permutation_polys_openings_at_z[i]);\\n        }\\n\\n        state.z_omega = state.z.copy();\\n        state.z_omega.mul_assign(vk.omega);\\n\\n        transcript.update_with_fr(proof.copy_permutation_grand_product_opening_at_z_omega);\\n\\n        transcript.update_with_fr(proof.lookup_t_poly_opening_at_z);\\n        transcript.update_with_fr(proof.lookup_selector_poly_opening_at_z);\\n        transcript.update_with_fr(proof.lookup_table_type_poly_opening_at_z);\\n        transcript.update_with_fr(proof.lookup_s_poly_opening_at_z_omega);\\n        transcript.update_with_fr(proof.lookup_grand_product_opening_at_z_omega);\\n        transcript.update_with_fr(proof.lookup_t_poly_opening_at_z_omega);\\n        transcript.update_with_fr(proof.linearization_poly_opening_at_z);\\n\\n        state.v = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.opening_proof_at_z);\\n        transcript.update_with_g1(proof.opening_proof_at_z_omega);\\n\\n        state.u = transcript.get_challenge();\\n    }\\n\\n    // compute some powers of challenge alpha([alpha^1, .. alpha^8])\\n    function compute_powers_of_alpha(PartialVerifierState memory state) public pure {\\n        require(state.alpha.value != 0);\\n        state.alpha_values[0] = PairingsBn254.new_fr(1);\\n        state.alpha_values[1] = state.alpha.copy();\\n        PairingsBn254.Fr memory current_alpha = state.alpha.copy();\\n        for (uint256 i = 2; i < state.alpha_values.length; i = i.uncheckedInc()) {\\n            current_alpha.mul_assign(state.alpha);\\n            state.alpha_values[i] = current_alpha.copy();\\n        }\\n    }\\n\\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\\n        // we initialize all challenges beforehand, we can draw each challenge in its own place\\n        PartialVerifierState memory state = initialize_transcript(proof, vk);\\n        if (verify_quotient_evaluation(vk, proof, state) == false) {\\n            return false;\\n        }\\n        require(proof.state_polys_openings_at_z_omega.length == 1); // TODO\\n\\n        PairingsBn254.G1Point memory quotient_result = proof.quotient_poly_parts_commitments[0].copy_g1();\\n        {\\n            // block scope\\n            PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\\n            PairingsBn254.Fr memory current_z = z_in_domain_size.copy();\\n            PairingsBn254.G1Point memory tp;\\n            // start from i =1\\n            for (uint256 i = 1; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\\n                tp = proof.quotient_poly_parts_commitments[i].copy_g1();\\n                tp.point_mul_assign(current_z);\\n                quotient_result.point_add_assign(tp);\\n\\n                current_z.mul_assign(z_in_domain_size);\\n            }\\n        }\\n\\n        Queries memory queries = prepare_queries(vk, proof, state);\\n        queries.commitments_at_z[0] = quotient_result;\\n        queries.values_at_z[0] = proof.quotient_poly_opening_at_z;\\n        queries.commitments_at_z[1] = aggregated_linearization_commitment(vk, proof, state);\\n        queries.values_at_z[1] = proof.linearization_poly_opening_at_z;\\n\\n        require(queries.commitments_at_z.length == queries.values_at_z.length);\\n\\n        PairingsBn254.G1Point memory aggregated_commitment_at_z = queries.commitments_at_z[0];\\n\\n        PairingsBn254.Fr memory aggregated_opening_at_z = queries.values_at_z[0];\\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\\n        PairingsBn254.G1Point memory scaled;\\n        for (uint256 i = 1; i < queries.commitments_at_z.length; i = i.uncheckedInc()) {\\n            aggregation_challenge.mul_assign(state.v);\\n            scaled = queries.commitments_at_z[i].point_mul(aggregation_challenge);\\n            aggregated_commitment_at_z.point_add_assign(scaled);\\n\\n            state.t = queries.values_at_z[i];\\n            state.t.mul_assign(aggregation_challenge);\\n            aggregated_opening_at_z.add_assign(state.t);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        PairingsBn254.G1Point memory aggregated_commitment_at_z_omega = queries.commitments_at_z_omega[0].point_mul(\\n            aggregation_challenge\\n        );\\n        PairingsBn254.Fr memory aggregated_opening_at_z_omega = queries.values_at_z_omega[0];\\n        aggregated_opening_at_z_omega.mul_assign(aggregation_challenge);\\n        for (uint256 i = 1; i < queries.commitments_at_z_omega.length; i = i.uncheckedInc()) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            scaled = queries.commitments_at_z_omega[i].point_mul(aggregation_challenge);\\n            aggregated_commitment_at_z_omega.point_add_assign(scaled);\\n\\n            state.t = queries.values_at_z_omega[i];\\n            state.t.mul_assign(aggregation_challenge);\\n            aggregated_opening_at_z_omega.add_assign(state.t);\\n        }\\n\\n        return\\n            final_pairing(\\n                vk.g2_elements,\\n                proof,\\n                state,\\n                aggregated_commitment_at_z,\\n                aggregated_commitment_at_z_omega,\\n                aggregated_opening_at_z,\\n                aggregated_opening_at_z_omega\\n            );\\n    }\\n\\n    function verify_quotient_evaluation(\\n        VerificationKey memory vk,\\n        Proof memory proof,\\n        PartialVerifierState memory state\\n    ) internal view returns (bool) {\\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i = i.uncheckedInc()) {\\n            lagrange_poly_numbers[i] = i;\\n        }\\n        // require(vk.num_inputs > 0); // TODO\\n\\n        PairingsBn254.Fr memory inputs_term = PairingsBn254.new_fr(0);\\n        for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc()) {\\n            // TODO we may use batched lagrange compputation\\n            state.t = evaluate_lagrange_poly_out_of_domain(i, vk.domain_size, vk.omega, state.z);\\n            state.t.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\\n            inputs_term.add_assign(state.t);\\n        }\\n        inputs_term.mul_assign(proof.gate_selectors_openings_at_z[0]);\\n        PairingsBn254.Fr memory result = proof.linearization_poly_opening_at_z.copy();\\n        result.add_assign(inputs_term);\\n\\n        // compute powers of alpha\\n        compute_powers_of_alpha(state);\\n        PairingsBn254.Fr memory factor = state.alpha_values[4].copy();\\n        factor.mul_assign(proof.copy_permutation_grand_product_opening_at_z_omega);\\n\\n        // - alpha_0 * (a + perm(z) * beta + gamma)*()*(d + gamma) * z(z*omega)\\n        require(proof.copy_permutation_polys_openings_at_z.length == STATE_WIDTH - 1);\\n        PairingsBn254.Fr memory t; // TMP;\\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\\n            t = proof.copy_permutation_polys_openings_at_z[i].copy();\\n            t.mul_assign(state.beta);\\n            t.add_assign(proof.state_polys_openings_at_z[i]);\\n            t.add_assign(state.gamma);\\n\\n            factor.mul_assign(t);\\n        }\\n\\n        t = proof.state_polys_openings_at_z[3].copy();\\n        t.add_assign(state.gamma);\\n        factor.mul_assign(t);\\n        result.sub_assign(factor);\\n\\n        // - L_0(z) * alpha_1\\n        PairingsBn254.Fr memory l_0_at_z = evaluate_l0_at_point(vk.domain_size, state.z);\\n        l_0_at_z.mul_assign(state.alpha_values[4 + 1]);\\n        result.sub_assign(l_0_at_z);\\n\\n        PairingsBn254.Fr memory lookup_quotient_contrib = lookup_quotient_contribution(vk, proof, state);\\n        result.add_assign(lookup_quotient_contrib);\\n\\n        PairingsBn254.Fr memory lhs = proof.quotient_poly_opening_at_z.copy();\\n        lhs.mul_assign(evaluate_vanishing(vk.domain_size, state.z));\\n        return lhs.value == result.value;\\n    }\\n\\n    function lookup_quotient_contribution(\\n        VerificationKey memory vk,\\n        Proof memory proof,\\n        PartialVerifierState memory state\\n    ) internal view returns (PairingsBn254.Fr memory result) {\\n        PairingsBn254.Fr memory t;\\n\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        state.beta_plus_one = state.beta_lookup.copy();\\n        state.beta_plus_one.add_assign(one);\\n        state.beta_gamma = state.beta_plus_one.copy();\\n        state.beta_gamma.mul_assign(state.gamma_lookup);\\n\\n        // (s'*beta + gamma)*(zw')*alpha\\n        t = proof.lookup_s_poly_opening_at_z_omega.copy();\\n        t.mul_assign(state.beta_lookup);\\n        t.add_assign(state.beta_gamma);\\n        t.mul_assign(proof.lookup_grand_product_opening_at_z_omega);\\n        t.mul_assign(state.alpha_values[6]);\\n\\n        // (z - omega^{n-1}) for this part\\n        PairingsBn254.Fr memory last_omega = vk.omega.pow(vk.domain_size - 1);\\n        state.z_minus_last_omega = state.z.copy();\\n        state.z_minus_last_omega.sub_assign(last_omega);\\n        t.mul_assign(state.z_minus_last_omega);\\n        result.add_assign(t);\\n\\n        // - alpha_1 * L_{0}(z)\\n        state.l_0_at_z = evaluate_lagrange_poly_out_of_domain(0, vk.domain_size, vk.omega, state.z);\\n        t = state.l_0_at_z.copy();\\n        t.mul_assign(state.alpha_values[6 + 1]);\\n        result.sub_assign(t);\\n\\n        // - alpha_2 * beta_gamma_powered L_{n-1}(z)\\n        PairingsBn254.Fr memory beta_gamma_powered = state.beta_gamma.pow(vk.domain_size - 1);\\n        state.l_n_minus_one_at_z = evaluate_lagrange_poly_out_of_domain(\\n            vk.domain_size - 1,\\n            vk.domain_size,\\n            vk.omega,\\n            state.z\\n        );\\n        t = state.l_n_minus_one_at_z.copy();\\n        t.mul_assign(beta_gamma_powered);\\n        t.mul_assign(state.alpha_values[6 + 2]);\\n\\n        result.sub_assign(t);\\n    }\\n\\n    function aggregated_linearization_commitment(\\n        VerificationKey memory vk,\\n        Proof memory proof,\\n        PartialVerifierState memory state\\n    ) internal view returns (PairingsBn254.G1Point memory result) {\\n        // qMain*(Q_a * A + Q_b * B + Q_c * C + Q_d * D + Q_m * A*B + Q_const + Q_dNext * D_next)\\n        result = PairingsBn254.new_g1(0, 0);\\n        // Q_a * A\\n        PairingsBn254.G1Point memory scaled = vk.gate_setup_commitments[0].point_mul(\\n            proof.state_polys_openings_at_z[0]\\n        );\\n        result.point_add_assign(scaled);\\n        // Q_b * B\\n        scaled = vk.gate_setup_commitments[1].point_mul(proof.state_polys_openings_at_z[1]);\\n        result.point_add_assign(scaled);\\n        // Q_c * C\\n        scaled = vk.gate_setup_commitments[2].point_mul(proof.state_polys_openings_at_z[2]);\\n        result.point_add_assign(scaled);\\n        // Q_d * D\\n        scaled = vk.gate_setup_commitments[3].point_mul(proof.state_polys_openings_at_z[3]);\\n        result.point_add_assign(scaled);\\n        // Q_m* A*B or Q_ab*A*B\\n        PairingsBn254.Fr memory t = proof.state_polys_openings_at_z[0].copy();\\n        t.mul_assign(proof.state_polys_openings_at_z[1]);\\n        scaled = vk.gate_setup_commitments[4].point_mul(t);\\n        result.point_add_assign(scaled);\\n        // Q_AC* A*C\\n        t = proof.state_polys_openings_at_z[0].copy();\\n        t.mul_assign(proof.state_polys_openings_at_z[2]);\\n        scaled = vk.gate_setup_commitments[5].point_mul(t);\\n        result.point_add_assign(scaled);\\n        // Q_const\\n        result.point_add_assign(vk.gate_setup_commitments[6]);\\n        // Q_dNext * D_next\\n        scaled = vk.gate_setup_commitments[7].point_mul(proof.state_polys_openings_at_z_omega[0]);\\n        result.point_add_assign(scaled);\\n        result.point_mul_assign(proof.gate_selectors_openings_at_z[0]);\\n\\n        PairingsBn254.G1Point\\n            memory rescue_custom_gate_linearization_contrib = rescue_custom_gate_linearization_contribution(\\n                vk,\\n                proof,\\n                state\\n            );\\n        result.point_add_assign(rescue_custom_gate_linearization_contrib);\\n        require(vk.non_residues.length == STATE_WIDTH - 1);\\n\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory factor = state.alpha_values[4].copy();\\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; ) {\\n            t = state.z.copy();\\n            if (i == 0) {\\n                t.mul_assign(one);\\n            } else {\\n                t.mul_assign(vk.non_residues[i - 1]); // TODO add one into non-residues during codegen?\\n            }\\n            t.mul_assign(state.beta);\\n            t.add_assign(state.gamma);\\n            t.add_assign(proof.state_polys_openings_at_z[i]);\\n\\n            factor.mul_assign(t);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        scaled = proof.copy_permutation_grand_product_commitment.point_mul(factor);\\n        result.point_add_assign(scaled);\\n\\n        // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)\\n        factor = state.alpha_values[4].copy();\\n        factor.mul_assign(state.beta);\\n        factor.mul_assign(proof.copy_permutation_grand_product_opening_at_z_omega);\\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\\n            t = proof.copy_permutation_polys_openings_at_z[i].copy();\\n            t.mul_assign(state.beta);\\n            t.add_assign(state.gamma);\\n            t.add_assign(proof.state_polys_openings_at_z[i]);\\n\\n            factor.mul_assign(t);\\n        }\\n        scaled = vk.permutation_commitments[3].point_mul(factor);\\n        result.point_sub_assign(scaled);\\n\\n        // + L_0(z) * Z(x)\\n        // TODO\\n        state.l_0_at_z = evaluate_lagrange_poly_out_of_domain(0, vk.domain_size, vk.omega, state.z);\\n        require(state.l_0_at_z.value != 0);\\n        factor = state.l_0_at_z.copy();\\n        factor.mul_assign(state.alpha_values[4 + 1]);\\n        scaled = proof.copy_permutation_grand_product_commitment.point_mul(factor);\\n        result.point_add_assign(scaled);\\n\\n        PairingsBn254.G1Point memory lookup_linearization_contrib = lookup_linearization_contribution(proof, state);\\n        result.point_add_assign(lookup_linearization_contrib);\\n    }\\n\\n    function rescue_custom_gate_linearization_contribution(\\n        VerificationKey memory vk,\\n        Proof memory proof,\\n        PartialVerifierState memory state\\n    ) public view returns (PairingsBn254.G1Point memory result) {\\n        PairingsBn254.Fr memory t;\\n        PairingsBn254.Fr memory intermediate_result;\\n\\n        // a^2 - b = 0\\n        t = proof.state_polys_openings_at_z[0].copy();\\n        t.mul_assign(t);\\n        t.sub_assign(proof.state_polys_openings_at_z[1]);\\n        // t.mul_assign(challenge1);\\n        t.mul_assign(state.alpha_values[1]);\\n        intermediate_result.add_assign(t);\\n\\n        // b^2 - c = 0\\n        t = proof.state_polys_openings_at_z[1].copy();\\n        t.mul_assign(t);\\n        t.sub_assign(proof.state_polys_openings_at_z[2]);\\n        t.mul_assign(state.alpha_values[1 + 1]);\\n        intermediate_result.add_assign(t);\\n\\n        // c*a - d = 0;\\n        t = proof.state_polys_openings_at_z[2].copy();\\n        t.mul_assign(proof.state_polys_openings_at_z[0]);\\n        t.sub_assign(proof.state_polys_openings_at_z[3]);\\n        t.mul_assign(state.alpha_values[1 + 2]);\\n        intermediate_result.add_assign(t);\\n\\n        result = vk.gate_selectors_commitments[1].point_mul(intermediate_result);\\n    }\\n\\n    function lookup_linearization_contribution(Proof memory proof, PartialVerifierState memory state)\\n        internal\\n        view\\n        returns (PairingsBn254.G1Point memory result)\\n    {\\n        PairingsBn254.Fr memory zero = PairingsBn254.new_fr(0);\\n\\n        PairingsBn254.Fr memory t;\\n        PairingsBn254.Fr memory factor;\\n        // s(x) from the Z(x*omega)*(\\\\gamma*(1 + \\\\beta) + s(x) + \\\\beta * s(x*omega)))\\n        factor = proof.lookup_grand_product_opening_at_z_omega.copy();\\n        factor.mul_assign(state.alpha_values[6]);\\n        factor.mul_assign(state.z_minus_last_omega);\\n\\n        PairingsBn254.G1Point memory scaled = proof.lookup_s_poly_commitment.point_mul(factor);\\n        result.point_add_assign(scaled);\\n\\n        // Z(x) from - alpha_0 * Z(x) * (\\\\beta + 1) * (\\\\gamma + f(x)) * (\\\\gamma(1 + \\\\beta) + t(x) + \\\\beta * t(x*omega))\\n        // + alpha_1 * Z(x) * L_{0}(z) + alpha_2 * Z(x) * L_{n-1}(z)\\n\\n        // accumulate coefficient\\n        factor = proof.lookup_t_poly_opening_at_z_omega.copy();\\n        factor.mul_assign(state.beta_lookup);\\n        factor.add_assign(proof.lookup_t_poly_opening_at_z);\\n        factor.add_assign(state.beta_gamma);\\n\\n        // (\\\\gamma + f(x))\\n        PairingsBn254.Fr memory f_reconstructed;\\n        PairingsBn254.Fr memory current = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory tmp0;\\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\\n            tmp0 = proof.state_polys_openings_at_z[i].copy();\\n            tmp0.mul_assign(current);\\n            f_reconstructed.add_assign(tmp0);\\n\\n            current.mul_assign(state.eta);\\n        }\\n\\n        // add type of table\\n        t = proof.lookup_table_type_poly_opening_at_z.copy();\\n        t.mul_assign(current);\\n        f_reconstructed.add_assign(t);\\n\\n        f_reconstructed.mul_assign(proof.lookup_selector_poly_opening_at_z);\\n        f_reconstructed.add_assign(state.gamma_lookup);\\n\\n        // end of (\\\\gamma + f(x)) part\\n        factor.mul_assign(f_reconstructed);\\n        factor.mul_assign(state.beta_plus_one);\\n        t = zero.copy();\\n        t.sub_assign(factor);\\n        factor = t;\\n        factor.mul_assign(state.alpha_values[6]);\\n\\n        // Multiply by (z - omega^{n-1})\\n        factor.mul_assign(state.z_minus_last_omega);\\n\\n        // L_{0}(z) in front of Z(x)\\n        t = state.l_0_at_z.copy();\\n        t.mul_assign(state.alpha_values[6 + 1]);\\n        factor.add_assign(t);\\n\\n        // L_{n-1}(z) in front of Z(x)\\n        t = state.l_n_minus_one_at_z.copy();\\n        t.mul_assign(state.alpha_values[6 + 2]);\\n        factor.add_assign(t);\\n\\n        scaled = proof.lookup_grand_product_commitment.point_mul(factor);\\n        result.point_add_assign(scaled);\\n    }\\n\\n    struct Queries {\\n        PairingsBn254.G1Point[13] commitments_at_z;\\n        PairingsBn254.Fr[13] values_at_z;\\n        PairingsBn254.G1Point[6] commitments_at_z_omega;\\n        PairingsBn254.Fr[6] values_at_z_omega;\\n    }\\n\\n    function prepare_queries(\\n        VerificationKey memory vk,\\n        Proof memory proof,\\n        PartialVerifierState memory state\\n    ) public view returns (Queries memory queries) {\\n        // we set first two items in calee side so start idx from 2\\n        uint256 idx = 2;\\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\\n            queries.commitments_at_z[idx] = proof.state_polys_commitments[i];\\n            queries.values_at_z[idx] = proof.state_polys_openings_at_z[i];\\n            idx = idx.uncheckedInc();\\n        }\\n        require(proof.gate_selectors_openings_at_z.length == 1);\\n        queries.commitments_at_z[idx] = vk.gate_selectors_commitments[0];\\n        queries.values_at_z[idx] = proof.gate_selectors_openings_at_z[0];\\n        idx = idx.uncheckedInc();\\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\\n            queries.commitments_at_z[idx] = vk.permutation_commitments[i];\\n            queries.values_at_z[idx] = proof.copy_permutation_polys_openings_at_z[i];\\n            idx = idx.uncheckedInc();\\n        }\\n\\n        queries.commitments_at_z_omega[0] = proof.copy_permutation_grand_product_commitment;\\n        queries.commitments_at_z_omega[1] = proof.state_polys_commitments[STATE_WIDTH - 1];\\n\\n        queries.values_at_z_omega[0] = proof.copy_permutation_grand_product_opening_at_z_omega;\\n        queries.values_at_z_omega[1] = proof.state_polys_openings_at_z_omega[0];\\n\\n        PairingsBn254.G1Point memory lookup_t_poly_commitment_aggregated = vk.lookup_tables_commitments[0];\\n        PairingsBn254.Fr memory current_eta = state.eta.copy();\\n        for (uint256 i = 1; i < vk.lookup_tables_commitments.length; i = i.uncheckedInc()) {\\n            state.tp = vk.lookup_tables_commitments[i].point_mul(current_eta);\\n            lookup_t_poly_commitment_aggregated.point_add_assign(state.tp);\\n\\n            current_eta.mul_assign(state.eta);\\n        }\\n        queries.commitments_at_z[idx] = lookup_t_poly_commitment_aggregated;\\n        queries.values_at_z[idx] = proof.lookup_t_poly_opening_at_z;\\n        idx = idx.uncheckedInc();\\n        queries.commitments_at_z[idx] = vk.lookup_selector_commitment;\\n        queries.values_at_z[idx] = proof.lookup_selector_poly_opening_at_z;\\n        idx = idx.uncheckedInc();\\n        queries.commitments_at_z[idx] = vk.lookup_table_type_commitment;\\n        queries.values_at_z[idx] = proof.lookup_table_type_poly_opening_at_z;\\n        queries.commitments_at_z_omega[2] = proof.lookup_s_poly_commitment;\\n        queries.values_at_z_omega[2] = proof.lookup_s_poly_opening_at_z_omega;\\n        queries.commitments_at_z_omega[3] = proof.lookup_grand_product_commitment;\\n        queries.values_at_z_omega[3] = proof.lookup_grand_product_opening_at_z_omega;\\n        queries.commitments_at_z_omega[4] = lookup_t_poly_commitment_aggregated;\\n        queries.values_at_z_omega[4] = proof.lookup_t_poly_opening_at_z_omega;\\n    }\\n\\n    function final_pairing(\\n        // VerificationKey memory vk,\\n        PairingsBn254.G2Point[NUM_G2_ELS] memory g2_elements,\\n        Proof memory proof,\\n        PartialVerifierState memory state,\\n        PairingsBn254.G1Point memory aggregated_commitment_at_z,\\n        PairingsBn254.G1Point memory aggregated_commitment_at_z_omega,\\n        PairingsBn254.Fr memory aggregated_opening_at_z,\\n        PairingsBn254.Fr memory aggregated_opening_at_z_omega\\n    ) internal view returns (bool) {\\n        // q(x) = f(x) - f(z) / (x - z)\\n        // q(x) * (x-z)  = f(x) - f(z)\\n\\n        // f(x)\\n        PairingsBn254.G1Point memory pair_with_generator = aggregated_commitment_at_z.copy_g1();\\n        aggregated_commitment_at_z_omega.point_mul_assign(state.u);\\n        pair_with_generator.point_add_assign(aggregated_commitment_at_z_omega);\\n\\n        // - f(z)*g\\n        PairingsBn254.Fr memory aggregated_value = aggregated_opening_at_z_omega.copy();\\n        aggregated_value.mul_assign(state.u);\\n        aggregated_value.add_assign(aggregated_opening_at_z);\\n        PairingsBn254.G1Point memory tp = PairingsBn254.P1().point_mul(aggregated_value);\\n        pair_with_generator.point_sub_assign(tp);\\n\\n        // +z * q(x)\\n        tp = proof.opening_proof_at_z.point_mul(state.z);\\n        PairingsBn254.Fr memory t = state.z_omega.copy();\\n        t.mul_assign(state.u);\\n        PairingsBn254.G1Point memory t1 = proof.opening_proof_at_z_omega.point_mul(t);\\n        tp.point_add_assign(t1);\\n        pair_with_generator.point_add_assign(tp);\\n\\n        // rhs\\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_proof_at_z_omega.point_mul(state.u);\\n        pair_with_x.point_add_assign(proof.opening_proof_at_z);\\n        pair_with_x.negate();\\n        // Pairing precompile expects points to be in a `i*x[1] + x[0]` form instead of `x[0] + i*x[1]`\\n        // so we handle it in code generation step\\n        PairingsBn254.G2Point memory first_g2 = g2_elements[0];\\n        PairingsBn254.G2Point memory second_g2 = g2_elements[1];\\n        PairingsBn254.G2Point memory gen2 = PairingsBn254.P2();\\n\\n        return PairingsBn254.pairingProd2(pair_with_generator, first_g2, pair_with_x, second_g2);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/common/libraries/UncheckedMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nlibrary UncheckedMath {\\n    function uncheckedInc(uint256 _number) internal pure returns (uint256) {\\n        unchecked {\\n            return _number + 1;\\n        }\\n    }\\n\\n    function uncheckedAdd(uint256 _lhs, uint256 _rhs) internal pure returns (uint256) {\\n        unchecked {\\n            return _lhs + _rhs;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/libraries/PairingsBn254.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nlibrary PairingsBn254 {\\n    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    uint256 constant bn254_b_coeff = 3;\\n\\n    struct G1Point {\\n        uint256 X;\\n        uint256 Y;\\n    }\\n\\n    struct Fr {\\n        uint256 value;\\n    }\\n\\n    function new_fr(uint256 fr) internal pure returns (Fr memory) {\\n        require(fr < r_mod);\\n        return Fr({value: fr});\\n    }\\n\\n    function copy(Fr memory self) internal pure returns (Fr memory n) {\\n        n.value = self.value;\\n    }\\n\\n    function assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = other.value;\\n    }\\n\\n    function inverse(Fr memory fr) internal view returns (Fr memory) {\\n        require(fr.value != 0);\\n        return pow(fr, r_mod - 2);\\n    }\\n\\n    function add_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, other.value, r_mod);\\n    }\\n\\n    function sub_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, r_mod - other.value, r_mod);\\n    }\\n\\n    function mul_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = mulmod(self.value, other.value, r_mod);\\n    }\\n\\n    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {\\n        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];\\n        uint256[1] memory result;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\\n        }\\n        require(success);\\n        return Fr({value: result[0]});\\n    }\\n\\n    // Encoding of field elements is: X[0] * z + X[1]\\n    struct G2Point {\\n        uint256[2] X;\\n        uint256[2] Y;\\n    }\\n\\n    function P1() internal pure returns (G1Point memory) {\\n        return G1Point(1, 2);\\n    }\\n\\n    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        return G1Point(x, y);\\n    }\\n\\n    // function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        if (x == 0 && y == 0) {\\n            // point of infinity is (0,0)\\n            return G1Point(x, y);\\n        }\\n\\n        // check encoding\\n        require(x < q_mod, \\\"x axis isn't valid\\\");\\n        require(y < q_mod, \\\"y axis isn't valid\\\");\\n        // check on curve\\n        uint256 lhs = mulmod(y, y, q_mod); // y^2\\n\\n        uint256 rhs = mulmod(x, x, q_mod); // x^2\\n        rhs = mulmod(rhs, x, q_mod); // x^3\\n        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b\\n        require(lhs == rhs, \\\"is not on curve\\\");\\n\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {\\n        return G2Point(x, y);\\n    }\\n\\n    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {\\n        result.X = self.X;\\n        result.Y = self.Y;\\n    }\\n\\n    function P2() internal pure returns (G2Point memory) {\\n        // for some reason ethereum expects to have c1*v + c0 form\\n\\n        return\\n            G2Point(\\n                [\\n                    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n                    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\\n                ],\\n                [\\n                    0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n                    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n                ]\\n            );\\n    }\\n\\n    function negate(G1Point memory self) internal pure {\\n        // The prime q in the base field F_q for G1\\n        if (self.Y == 0) {\\n            require(self.X == 0);\\n            return;\\n        }\\n\\n        self.Y = q_mod - self.Y;\\n    }\\n\\n    function point_add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\\n        point_add_into_dest(p1, p2, r);\\n        return r;\\n    }\\n\\n    function point_add_assign(G1Point memory p1, G1Point memory p2) internal view {\\n        point_add_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_add_into_dest(\\n        G1Point memory p1,\\n        G1Point memory p2,\\n        G1Point memory dest\\n    ) internal view {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we add zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we add into zero, and we add non-zero point\\n            dest.X = p2.X;\\n            dest.Y = p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = p2.Y;\\n\\n            bool success;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_sub_assign(G1Point memory p1, G1Point memory p2) internal view {\\n        point_sub_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_sub_into_dest(\\n        G1Point memory p1,\\n        G1Point memory p2,\\n        G1Point memory dest\\n    ) internal view {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we subtracted zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we subtract from zero, and we subtract non-zero point\\n            dest.X = p2.X;\\n            dest.Y = q_mod - p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = q_mod - p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_mul(G1Point memory p, Fr memory s) internal view returns (G1Point memory r) {\\n        // https://eips.ethereum.org/EIPS/eip-197\\n        // Elliptic curve points are encoded as a Jacobian pair (X, Y) where the point at infinity is encoded as (0, 0)\\n        // TODO\\n        if (p.X == 0 && p.Y == 1) {\\n            p.Y = 0;\\n        }\\n        point_mul_into_dest(p, s, r);\\n        return r;\\n    }\\n\\n    function point_mul_assign(G1Point memory p, Fr memory s) internal view {\\n        point_mul_into_dest(p, s, p);\\n    }\\n\\n    function point_mul_into_dest(\\n        G1Point memory p,\\n        Fr memory s,\\n        G1Point memory dest\\n    ) internal view {\\n        uint256[3] memory input;\\n        input[0] = p.X;\\n        input[1] = p.Y;\\n        input[2] = s.value;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)\\n        }\\n        require(success);\\n    }\\n\\n    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {\\n        require(p1.length == p2.length);\\n        uint256 elements = p1.length;\\n        uint256 inputSize = elements * 6;\\n        uint256[] memory input = new uint256[](inputSize);\\n        for (uint256 i = 0; i < elements; ) {\\n            input[i * 6 + 0] = p1[i].X;\\n            input[i * 6 + 1] = p1[i].Y;\\n            input[i * 6 + 2] = p2[i].X[0];\\n            input[i * 6 + 3] = p2[i].X[1];\\n            input[i * 6 + 4] = p2[i].Y[0];\\n            input[i * 6 + 5] = p2[i].Y[1];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        uint256[1] memory out;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\\n        }\\n        require(success);\\n        return out[0] != 0;\\n    }\\n\\n    /// Convenience method for a pairing check for two pairs.\\n    function pairingProd2(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2\\n    ) internal view returns (bool) {\\n        G1Point[] memory p1 = new G1Point[](2);\\n        G2Point[] memory p2 = new G2Point[](2);\\n        p1[0] = a1;\\n        p1[1] = b1;\\n        p2[0] = a2;\\n        p2[1] = b2;\\n        return pairing(p1, p2);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/libraries/TranscriptLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./PairingsBn254.sol\\\";\\n\\nlibrary TranscriptLib {\\n    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    uint32 constant DST_0 = 0;\\n    uint32 constant DST_1 = 1;\\n    uint32 constant DST_CHALLENGE = 2;\\n\\n    struct Transcript {\\n        bytes32 state_0;\\n        bytes32 state_1;\\n        uint32 challenge_counter;\\n    }\\n\\n    function new_transcript() internal pure returns (Transcript memory t) {\\n        t.state_0 = bytes32(0);\\n        t.state_1 = bytes32(0);\\n        t.challenge_counter = 0;\\n    }\\n\\n    function update_with_u256(Transcript memory self, uint256 value) internal pure {\\n        bytes32 old_state_0 = self.state_0;\\n        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));\\n        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));\\n    }\\n\\n    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {\\n        update_with_u256(self, value.value);\\n    }\\n\\n    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {\\n        update_with_u256(self, p.X);\\n        update_with_u256(self, p.Y);\\n    }\\n\\n    function get_challenge(Transcript memory self) internal pure returns (PairingsBn254.Fr memory challenge) {\\n        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));\\n        self.challenge_counter += 1;\\n        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_genesisBlockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_genesisBlockCommitment\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_genesisIndexRepeatedStorageChanges\",\"type\":\"uint64\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DiamondUpgrade","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]