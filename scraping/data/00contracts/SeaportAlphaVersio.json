[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Seaport.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { Consideration } from \\\"./lib/Consideration.sol\\\";\\n\\n/**\\n * @title Seaport (alpha version)\\n * @custom:version 1.2-ALPHA\\n * @author 0age (0age.eth)\\n * @custom:coauthor d1ll0n (d1ll0n.eth)\\n * @custom:coauthor transmissions11 (t11s.eth)\\n * @custom:coauthor James Wenzel (emo.eth)\\n * @custom:contributor Kartik (slokh.eth)\\n * @custom:contributor LeFevre (lefevre.eth)\\n * @custom:contributor Joseph Schiarizzi (CupOJoseph.eth)\\n * @custom:contributor Aspyn Palatnick (stuckinaboot.eth)\\n * @custom:contributor Stephan Min (stephanm.eth)\\n * @custom:contributor Ryan Ghods (ralxz.eth)\\n * @custom:contributor Daniel Viau (snotrocket.eth)\\n * @custom:contributor hack3r-0m (hack3r-0m.eth)\\n * @custom:contributor Diego Estevez (antidiego.eth)\\n * @custom:contributor Chomtana (chomtana.eth)\\n * @custom:contributor Saw-mon and Natalie (sawmonandnatalie.eth)\\n * @custom:contributor 0xBeans (0xBeans.eth)\\n * @custom:contributor 0x4non (punkdev.eth)\\n * @custom:contributor Laurence E. Day (norsefire.eth)\\n * @custom:contributor vectorized.eth (vectorized.eth)\\n * @custom:contributor karmacoma (karmacoma.eth)\\n * @custom:contributor horsefacts (horsefacts.eth)\\n * @custom:contributor UncarvedBlock (uncarvedblock.eth)\\n * @custom:contributor Zoraiz Mahmood (zorz.eth)\\n * @custom:contributor William Poulin (wpoulin.eth)\\n * @custom:contributor Rajiv Patel-O'Connor (rajivpoc.eth)\\n * @custom:contributor tserg (tserg.eth)\\n * @custom:contributor cygaar (cygaar.eth)\\n * @custom:contributor Meta0xNull (meta0xnull.eth)\\n * @custom:contributor gpersoon (gpersoon.eth)\\n * @custom:contributor Matt Solomon (msolomon.eth)\\n * @custom:contributor Weikang Song (weikangs.eth)\\n * @custom:contributor zer0dot (zer0dot.eth)\\n * @custom:contributor Mudit Gupta (mudit.eth)\\n * @custom:contributor leonardoalt (leoalt.eth)\\n * @custom:contributor cmichel (cmichel.eth)\\n * @custom:contributor PraneshASP (pranesh.eth)\\n * @custom:contributor JasperAlexander (jasperalexander.eth)\\n * @custom:contributor Ellahi (ellahi.eth)\\n * @custom:contributor zaz (1zaz1.eth)\\n * @custom:contributor berndartmueller (berndartmueller.eth)\\n * @custom:contributor dmfxyz (dmfxyz.eth)\\n * @custom:contributor daltoncoder (dontkillrobots.eth)\\n * @custom:contributor 0xf4ce (0xf4ce.eth)\\n * @custom:contributor phaze (phaze.eth)\\n * @custom:contributor hrkrshnn (hrkrshnn.eth)\\n * @custom:contributor axic (axic.eth)\\n * @custom:contributor leastwood (leastwood.eth)\\n * @custom:contributor 0xsanson (sanson.eth)\\n * @custom:contributor blockdev (blockd3v.eth)\\n * @custom:contributor fiveoutofnine (fiveoutofnine.eth)\\n * @custom:contributor shuklaayush (shuklaayush.eth)\\n * @custom:contributor 0xPatissier\\n * @custom:contributor pcaversaccio\\n * @custom:contributor David Eiber\\n * @custom:contributor csanuragjain\\n * @custom:contributor sach1r0\\n * @custom:contributor twojoy0\\n * @custom:contributor ori_dabush\\n * @custom:contributor Daniel Gelfand\\n * @custom:contributor okkothejawa\\n * @custom:contributor FlameHorizon\\n * @custom:contributor vdrg\\n * @custom:contributor dmitriia\\n * @custom:contributor bokeh-eth\\n * @custom:contributor asutorufos\\n * @custom:contributor rfart(rfa)\\n * @custom:contributor Riley Holterhus\\n * @custom:contributor big-tech-sux\\n * @notice Seaport is a generalized ETH/ERC20/ERC721/ERC1155 marketplace with\\n *         lightweight methods for common routes as well as more flexible\\n *         methods for composing advanced orders or groups of orders. Each order\\n *         contains an arbitrary number of items that may be spent (the \\\"offer\\\")\\n *         along with an arbitrary number of items that must be received back by\\n *         the indicated recipients (the \\\"consideration\\\").\\n */\\ncontract SeaportAlphaVersion is Consideration {\\n    /**\\n     * @notice Derive and set hashes, reference chainId, and associated domain\\n     *         separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) Consideration(conduitController) {}\\n\\n    /**\\n     * @dev Internal pure function to retrieve and return the name of this\\n     *      contract.\\n     *\\n     * @return The name of this contract.\\n     */\\n    function _name() internal pure override returns (string memory) {\\n        // Return the name of the contract.\\n        return _nameString();\\n    }\\n\\n    /**\\n     * @dev Internal pure function to retrieve the name of this contract as a\\n     *      string that will be used to derive the name hash in the constructor.\\n     *\\n     * @return The name of this contract as a string.\\n     */\\n    function _nameString() internal pure override returns (string memory) {\\n        // Return the name of the contract.\\n        return \\\"Seaport-alpha\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Consideration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {\\n    ConsiderationInterface\\n} from \\\"../interfaces/ConsiderationInterface.sol\\\";\\n\\nimport {\\n    OrderComponents,\\n    BasicOrderParameters,\\n    OrderParameters,\\n    Order,\\n    AdvancedOrder,\\n    OrderStatus,\\n    CriteriaResolver,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Execution\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { OrderCombiner } from \\\"./OrderCombiner.sol\\\";\\n\\nimport \\\"../helpers/PointerLibraries.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title Consideration\\n * @author 0age (0age.eth)\\n * @custom:coauthor d1ll0n (d1ll0n.eth)\\n * @custom:coauthor transmissions11 (t11s.eth)\\n * @custom:coauthor James Wenzel (emo.eth)\\n * @custom:version 1.2\\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace\\n *         that provides lightweight methods for common routes as well as more\\n *         flexible methods for composing advanced orders or groups of orders.\\n *         Each order contains an arbitrary number of items that may be spent\\n *         (the \\\"offer\\\") along with an arbitrary number of items that must be\\n *         received back by the indicated recipients (the \\\"consideration\\\").\\n */\\ncontract Consideration is ConsiderationInterface, OrderCombiner {\\n    /**\\n     * @notice Derive and set hashes, reference chainId, and associated domain\\n     *         separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) OrderCombiner(conduitController) {}\\n\\n    /**\\n     * @notice Accept native token transfers during execution that may then be\\n     *         used to facilitate native token transfers, where any tokens that\\n     *         remain will be transferred to the caller. Native tokens are only\\n     *         acceptable mid-fulfillment (and not during basic fulfillment).\\n     */\\n    receive() external payable {\\n        // Ensure the reentrancy guard is currently set to accept native tokens.\\n        _assertAcceptingNativeTokens();\\n    }\\n\\n    /**\\n     * @notice Fulfill an order offering an ERC20, ERC721, or ERC1155 item by\\n     *         supplying Ether (or other native tokens), ERC20 tokens, an ERC721\\n     *         item, or an ERC1155 item as consideration. Six permutations are\\n     *         supported: Native token to ERC721, Native token to ERC1155, ERC20\\n     *         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to\\n     *         ERC20 (with native tokens supplied as msg.value). For an order to\\n     *         be eligible for fulfillment via this method, it must contain a\\n     *         single offer item (though that item may have a greater amount if\\n     *         the item is not an ERC721). An arbitrary number of \\\"additional\\n     *         recipients\\\" may also be supplied which will each receive native\\n     *         tokens or ERC20 items from the fulfiller as consideration. Refer\\n     *         to the documentation for a more comprehensive summary of how to\\n     *         utilize this method and what orders are compatible with it.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer and the fulfiller must first approve\\n     *                   this contract (or their chosen conduit if indicated)\\n     *                   before any tokens can be transferred. Also note that\\n     *                   contract recipients of ERC1155 consideration items must\\n     *                   implement `onERC1155Received` to receive those items.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillBasicOrder(\\n        BasicOrderParameters calldata parameters\\n    ) external payable override returns (bool fulfilled) {\\n        // Validate and fulfill the basic order.\\n        fulfilled = _validateAndFulfillBasicOrder(parameters);\\n    }\\n\\n    /**\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\n     *         consideration. Note that this function does not support\\n     *         criteria-based orders or partial filling of orders (though\\n     *         filling the remainder of a partially-filled order is supported).\\n     *\\n     * @custom:param order        The order to fulfill. Note that both the\\n     *                            offerer and the fulfiller must first approve\\n     *                            this contract (or the corresponding conduit if\\n     *                            indicated) to transfer any relevant tokens on\\n     *                            their behalf and that contracts must implement\\n     *                            `onERC1155Received` to receive ERC1155 tokens\\n     *                            as consideration.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used (and direct approvals set on\\n     *                            this contract).\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillOrder(\\n        Order calldata,\\n        /**\\n         * @custom:name order\\n         */\\n        bytes32 fulfillerConduitKey\\n    ) external payable override returns (bool fulfilled) {\\n        // Convert order to \\\"advanced\\\" order, then validate and fulfill it.\\n        fulfilled = _validateAndFulfillAdvancedOrder(\\n            _toAdvancedOrderReturnType(_decodeOrderAsAdvancedOrder)(\\n                CalldataStart.pptr()\\n            ),\\n            new CriteriaResolver[](0), // No criteria resolvers supplied.\\n            fulfillerConduitKey,\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\n     *         items for offer and consideration alongside criteria resolvers\\n     *         containing specific token identifiers and associated proofs.\\n     *\\n     * @custom:param advancedOrder     The order to fulfill along with the\\n     *                                 fraction of the order to attempt to fill.\\n     *                                 Note that both the offerer and the\\n     *                                 fulfiller must first approve this\\n     *                                 contract (or their conduit if indicated\\n     *                                 by the order) to transfer any relevant\\n     *                                 tokens on their behalf and that contracts\\n     *                                 must implement `onERC1155Received` to\\n     *                                 receive ERC1155 tokens as consideration.\\n     *                                 Also note that all offer and\\n     *                                 consideration components must have no\\n     *                                 remainder after multiplication of the\\n     *                                 respective amount with the supplied\\n     *                                 fraction for the partial fill to be\\n     *                                 considered valid.\\n     * @custom:param criteriaResolvers An array where each element contains a\\n     *                                 reference to a specific offer or\\n     *                                 consideration, a token identifier, and a\\n     *                                 proof that the supplied token identifier\\n     *                                 is contained in the merkle root held by\\n     *                                 the item in question's criteria element.\\n     *                                 Note that an empty criteria indicates\\n     *                                 that any (transferable) token identifier\\n     *                                 on the token in question is valid and\\n     *                                 that no associated proof needs to be\\n     *                                 supplied.\\n     * @param fulfillerConduitKey      A bytes32 value indicating what conduit,\\n     *                                 if any, to source the fulfiller's token\\n     *                                 approvals from. The zero hash signifies\\n     *                                 that no conduit should be used (and\\n     *                                 direct approvals set on this contract).\\n     * @param recipient                The intended recipient for all received\\n     *                                 items, with `address(0)` indicating that\\n     *                                 the caller should receive the items.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillAdvancedOrder(\\n        AdvancedOrder calldata,\\n        /**\\n         * @custom:name advancedOrder\\n         */\\n        CriteriaResolver[] calldata,\\n        /**\\n         * @custom:name criteriaResolvers\\n         */\\n        bytes32 fulfillerConduitKey,\\n        address recipient\\n    ) external payable override returns (bool fulfilled) {\\n        // Validate and fulfill the order.\\n        fulfilled = _validateAndFulfillAdvancedOrder(\\n            _toAdvancedOrderReturnType(_decodeAdvancedOrder)(\\n                CalldataStart.pptr()\\n            ),\\n            _toCriteriaResolversReturnType(_decodeCriteriaResolvers)(\\n                CalldataStart.pptr(\\n                    Offset_fulfillAdvancedOrder_criteriaResolvers\\n                )\\n            ),\\n            fulfillerConduitKey,\\n            _substituteCallerForEmptyRecipient(recipient)\\n        );\\n    }\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\\n     *         of items for offer and consideration. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *         Note that this function does not support criteria-based orders or\\n     *         partial filling of orders (though filling the remainder of a\\n     *         partially-filled order is supported).\\n     *\\n     * @custom:param orders                    The orders to fulfill. Note that\\n     *                                         both the offerer and the\\n     *                                         fulfiller must first approve this\\n     *                                         contract (or the corresponding\\n     *                                         conduit if indicated) to transfer\\n     *                                         any relevant tokens on their\\n     *                                         behalf and that contracts must\\n     *                                         implement `onERC1155Received` to\\n     *                                         receive ERC1155 tokens as\\n     *                                         consideration.\\n     * @custom:param offerFulfillments         An array of FulfillmentComponent\\n     *                                         arrays indicating which offer\\n     *                                         items to attempt to aggregate\\n     *                                         when preparing executions. Note\\n     *                                         that any offer items not included\\n     *                                         as part of a fulfillment will be\\n     *                                         sent unaggregated to the caller.\\n     * @custom:param considerationFulfillments An array of FulfillmentComponent\\n     *                                         arrays indicating which\\n     *                                         consideration items to attempt to\\n     *                                         aggregate when preparing\\n     *                                         executions.\\n     * @param fulfillerConduitKey              A bytes32 value indicating what\\n     *                                         conduit, if any, to source the\\n     *                                         fulfiller's token approvals from.\\n     *                                         The zero hash signifies that no\\n     *                                         conduit should be used (and\\n     *                                         direct approvals set on this\\n     *                                         contract).\\n     * @param maximumFulfilled                 The maximum number of orders to\\n     *                                         fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders.\\n     */\\n    function fulfillAvailableOrders(\\n        Order[] calldata,\\n        /**\\n         * @custom:name orders\\n         */\\n        FulfillmentComponent[][] calldata,\\n        /**\\n         * @custom:name offerFulfillments\\n         */\\n        FulfillmentComponent[][] calldata,\\n        /**\\n         * @custom:name considerationFulfillments\\n         */\\n        bytes32 fulfillerConduitKey,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            bool[] memory /* availableOrders */,\\n            Execution[] memory /* executions */\\n        )\\n    {\\n        // Convert orders to \\\"advanced\\\" orders and fulfill all available orders.\\n        return\\n            _fulfillAvailableAdvancedOrders(\\n                _toAdvancedOrdersReturnType(_decodeOrdersAsAdvancedOrders)(\\n                    CalldataStart.pptr()\\n                ), // Convert to advanced orders.\\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\\n                _toNestedFulfillmentComponentsReturnType(\\n                    _decodeNestedFulfillmentComponents\\n                )(\\n                    CalldataStart.pptr(\\n                        Offset_fulfillAvailableOrders_offerFulfillments\\n                    )\\n                ),\\n                _toNestedFulfillmentComponentsReturnType(\\n                    _decodeNestedFulfillmentComponents\\n                )(\\n                    CalldataStart.pptr(\\n                        Offset_fulfillAvailableOrders_considerationFulfillments\\n                    )\\n                ),\\n                fulfillerConduitKey,\\n                msg.sender,\\n                maximumFulfilled\\n            );\\n    }\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\n     *         arbitrary number of items for offer and consideration per order\\n     *         alongside criteria resolvers containing specific token\\n     *         identifiers and associated proofs. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @custom:param advancedOrders            The orders to fulfill along with\\n     *                                         the fraction of those orders to\\n     *                                         attempt to fill. Note that both\\n     *                                         the offerer and the fulfiller\\n     *                                         must first approve this contract\\n     *                                         (or their conduit if indicated by\\n     *                                         the order) to transfer any\\n     *                                         relevant tokens on their behalf\\n     *                                         and that contracts must implement\\n     *                                         `onERC1155Received` to receive\\n     *                                         ERC1155 tokens as consideration.\\n     *                                         Also note that all offer and\\n     *                                         consideration components must\\n     *                                         have no remainder after\\n     *                                         multiplication of the respective\\n     *                                         amount with the supplied fraction\\n     *                                         for an order's partial fill\\n     *                                         amount to be considered valid.\\n     * @custom:param criteriaResolvers         An array where each element\\n     *                                         contains a reference to a\\n     *                                         specific offer or consideration,\\n     *                                         a token identifier, and a proof\\n     *                                         that the supplied token\\n     *                                         identifier is contained in the\\n     *                                         merkle root held by the item in\\n     *                                         question's criteria element. Note\\n     *                                         that an empty criteria indicates\\n     *                                         that any (transferable) token\\n     *                                         identifier on the token in\\n     *                                         question is valid and that no\\n     *                                         associated proof needs to be\\n     *                                         supplied.\\n     * @custom:param offerFulfillments         An array of FulfillmentComponent\\n     *                                         arrays indicating which offer\\n     *                                         items to attempt to aggregate\\n     *                                         when preparing executions. Note\\n     *                                         that any offer items not included\\n     *                                         as part of a fulfillment will be\\n     *                                         sent unaggregated to the caller.\\n     * @custom:param considerationFulfillments An array of FulfillmentComponent\\n     *                                         arrays indicating which\\n     *                                         consideration items to attempt to\\n     *                                         aggregate when preparing\\n     *                                         executions.\\n     * @param fulfillerConduitKey              A bytes32 value indicating what\\n     *                                         conduit, if any, to source the\\n     *                                         fulfiller's token approvals from.\\n     *                                         The zero hash signifies that no\\n     *                                         conduit should be used (and\\n     *                                         direct approvals set on this\\n     *                                         contract).\\n     * @param recipient                        The intended recipient for all\\n     *                                         received items, with `address(0)`\\n     *                                         indicating that the caller should\\n     *                                         receive the offer items.\\n     * @param maximumFulfilled                 The maximum number of orders to\\n     *                                         fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] calldata,\\n        /**\\n         * @custom:name advancedOrders\\n         */\\n        CriteriaResolver[] calldata,\\n        /**\\n         * @custom:name criteriaResolvers\\n         */\\n        FulfillmentComponent[][] calldata,\\n        /**\\n         * @custom:name offerFulfillments\\n         */\\n        FulfillmentComponent[][] calldata,\\n        /**\\n         * @custom:name considerationFulfillments\\n         */\\n        bytes32 fulfillerConduitKey,\\n        address recipient,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            bool[] memory /* availableOrders */,\\n            Execution[] memory /* executions */\\n        )\\n    {\\n        // Fulfill all available orders.\\n        return\\n            _fulfillAvailableAdvancedOrders(\\n                _toAdvancedOrdersReturnType(_decodeAdvancedOrders)(\\n                    CalldataStart.pptr()\\n                ),\\n                _toCriteriaResolversReturnType(_decodeCriteriaResolvers)(\\n                    CalldataStart.pptr(\\n                        Offset_fulfillAvailableAdvancedOrders_criteriaResolvers\\n                    )\\n                ),\\n                _toNestedFulfillmentComponentsReturnType(\\n                    _decodeNestedFulfillmentComponents\\n                )(\\n                    CalldataStart.pptr(\\n                        Offset_fulfillAvailableAdvancedOrders_offerFulfillments\\n                    )\\n                ),\\n                _toNestedFulfillmentComponentsReturnType(\\n                    _decodeNestedFulfillmentComponents\\n                )(\\n                    CalldataStart.pptr(\\n                        Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts\\n                    )\\n                ),\\n                fulfillerConduitKey,\\n                _substituteCallerForEmptyRecipient(recipient),\\n                maximumFulfilled\\n            );\\n    }\\n\\n    /**\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\n     *         number of items for offer and consideration along with a set of\\n     *         fulfillments allocating offer components to consideration\\n     *         components. Note that this function does not support\\n     *         criteria-based or partial filling of orders (though filling the\\n     *         remainder of a partially-filled order is supported). Any unspent\\n     *         offer item amounts or native tokens will be transferred to the\\n     *         caller.\\n     *\\n     * @custom:param orders       The orders to match. Note that both the\\n     *                            offerer and fulfiller on each order must first\\n     *                            approve this contract (or their conduit if\\n     *                            indicated by the order) to transfer any\\n     *                            relevant tokens on their behalf and each\\n     *                            consideration recipient must implement\\n     *                            `onERC1155Received` to receive ERC1155 tokens.\\n     * @custom:param fulfillments An array of elements allocating offer\\n     *                            components to consideration components. Note\\n     *                            that each consideration component must be\\n     *                            fully met for the match operation to be valid,\\n     *                            and that any unspent offer items will be sent\\n     *                            unaggregated to the caller.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders. Note that unspent offer item amounts or native\\n     *                    tokens will not be reflected as part of this array.\\n     */\\n    function matchOrders(\\n        Order[] calldata,\\n        /**\\n         * @custom:name orders\\n         */\\n        Fulfillment[] calldata /* fulfillments */\\n    ) external payable override returns (Execution[] memory /* executions */) {\\n        // Convert to advanced, validate, and match orders using fulfillments.\\n        return\\n            _matchAdvancedOrders(\\n                _toAdvancedOrdersReturnType(_decodeOrdersAsAdvancedOrders)(\\n                    CalldataStart.pptr()\\n                ),\\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\\n                _toFulfillmentsReturnType(_decodeFulfillments)(\\n                    CalldataStart.pptr(Offset_matchOrders_fulfillments)\\n                ),\\n                msg.sender\\n            );\\n    }\\n\\n    /**\\n     * @notice Match an arbitrary number of full, partial, or contract orders,\\n     *         each with an arbitrary number of items for offer and\\n     *         consideration, supplying criteria resolvers containing specific\\n     *         token identifiers and associated proofs as well as fulfillments\\n     *         allocating offer components to consideration components. Any\\n     *         unspent offer item amounts will be transferred to the designated\\n     *         recipient (with the null address signifying to use the caller)\\n     *         and any unspent native tokens will be returned to the caller.\\n     *\\n     * @custom:param advancedOrders    The advanced orders to match. Note that\\n     *                                 both the offerer and fulfiller on each\\n     *                                 order must first approve this contract\\n     *                                 (or their conduit if indicated by the\\n     *                                 order) to transfer any relevant tokens on\\n     *                                 their behalf and each consideration\\n     *                                 recipient must implement\\n     *                                 `onERC1155Received` to receive ERC1155\\n     *                                 tokens. Also note that the offer and\\n     *                                 consideration components for each order\\n     *                                 must have no remainder after multiplying\\n     *                                 the respective amount with the supplied\\n     *                                 fraction for the group of partial fills\\n     *                                 to be considered valid.\\n     * @custom:param criteriaResolvers An array where each element contains a\\n     *                                 reference to a specific offer or\\n     *                                 consideration, a token identifier, and a\\n     *                                 proof that the supplied token identifier\\n     *                                 is contained in the merkle root held by\\n     *                                 the item in question's criteria element.\\n     *                                 Note that an empty criteria indicates\\n     *                                 that any (transferable) token identifier\\n     *                                 on the token in question is valid and\\n     *                                 that no associated proof needs to be\\n     *                                 supplied.\\n     * @custom:param fulfillments      An array of elements allocating offer\\n     *                                 components to consideration components.\\n     *                                 Note that each consideration component\\n     *                                 must be fully met for the match operation\\n     *                                 to be valid, and that any unspent offer\\n     *                                 items will be sent unaggregated to the\\n     *                                 designated recipient.\\n     * @param recipient                The intended recipient for all unspent\\n     *                                 offer item amounts, or the caller if the\\n     *                                 null address is supplied.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                     transfers performed as part of matching the given\\n     *                     orders. Note that unspent offer item amounts or\\n     *                     native tokens will not be reflected as part of this\\n     *                     array.\\n     */\\n    function matchAdvancedOrders(\\n        AdvancedOrder[] calldata,\\n        /**\\n         * @custom:name advancedOrders\\n         */\\n        CriteriaResolver[] calldata,\\n        /**\\n         * @custom:name criteriaResolvers\\n         */\\n        Fulfillment[] calldata,\\n        /**\\n         * @custom:name fulfillments\\n         */\\n        address recipient\\n    ) external payable override returns (Execution[] memory /* executions */) {\\n        // Validate and match the advanced orders using supplied fulfillments.\\n        return\\n            _matchAdvancedOrders(\\n                _toAdvancedOrdersReturnType(_decodeAdvancedOrders)(\\n                    CalldataStart.pptr()\\n                ),\\n                _toCriteriaResolversReturnType(_decodeCriteriaResolvers)(\\n                    CalldataStart.pptr(\\n                        Offset_matchAdvancedOrders_criteriaResolvers\\n                    )\\n                ),\\n                _toFulfillmentsReturnType(_decodeFulfillments)(\\n                    CalldataStart.pptr(Offset_matchAdvancedOrders_fulfillments)\\n                ),\\n                _substituteCallerForEmptyRecipient(recipient)\\n            );\\n    }\\n\\n    /**\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\n     *         or the zone of a given order may cancel it. Callers should ensure\\n     *         that the intended order was cancelled by calling `getOrderStatus`\\n     *         and confirming that `isCancelled` returns `true`.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders have\\n     *                   been successfully cancelled.\\n     */\\n    function cancel(\\n        OrderComponents[] calldata orders\\n    ) external override returns (bool cancelled) {\\n        // Cancel the orders.\\n        cancelled = _cancel(orders);\\n    }\\n\\n    /**\\n     * @notice Validate an arbitrary number of orders, thereby registering their\\n     *         signatures as valid and allowing the fulfiller to skip signature\\n     *         verification on fulfillment. Note that validated orders may still\\n     *         be unfulfillable due to invalid item amounts or other factors;\\n     *         callers should determine whether validated orders are fulfillable\\n     *         by simulating the fulfillment call prior to execution. Also note\\n     *         that anyone can validate a signed order, but only the offerer can\\n     *         validate an order without supplying a signature.\\n     *\\n     * @custom:param orders The orders to validate.\\n     *\\n     * @return validated A boolean indicating whether the supplied orders have\\n     *                   been successfully validated.\\n     */\\n    function validate(\\n        Order[] calldata\\n    )\\n        external\\n        override\\n        returns (\\n            /**\\n             * @custom:name orders\\n             */\\n            bool /* validated */\\n        )\\n    {\\n        return\\n            _validate(_toOrdersReturnType(_decodeOrders)(CalldataStart.pptr()));\\n    }\\n\\n    /**\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\n     *         by incrementing a counter. Note that only the offerer may\\n     *         increment the counter.\\n     *\\n     * @return newCounter The new counter.\\n     */\\n    function incrementCounter() external override returns (uint256 newCounter) {\\n        // Increment current counter for the supplied offerer.  Note that the\\n        // counter is incremented by a large, quasi-random interval.\\n        newCounter = _incrementCounter();\\n    }\\n\\n    /**\\n     * @notice Retrieve the order hash for a given order.\\n     *\\n     * @custom:param order The components of the order.\\n     *\\n     * @return orderHash The order hash.\\n     */\\n    function getOrderHash(\\n        OrderComponents calldata\\n    )\\n        external\\n        view\\n        override\\n        returns (\\n            /**\\n             * @custom:name order\\n             */\\n            bytes32 orderHash\\n        )\\n    {\\n        CalldataPointer orderPointer = CalldataStart.pptr();\\n\\n        // Derive order hash by supplying order parameters along with counter.\\n        orderHash = _deriveOrderHash(\\n            _toOrderParametersReturnType(\\n                _decodeOrderComponentsAsOrderParameters\\n            )(orderPointer),\\n            // Read order counter\\n            orderPointer.offset(OrderParameters_counter_offset).readUint256()\\n        );\\n    }\\n\\n    /**\\n     * @notice Retrieve the status of a given order by hash, including whether\\n     *         the order has been cancelled or validated and the fraction of the\\n     *         order that has been filled. Since the _orderStatus[orderHash]\\n     *         does not get set for contract orders, getOrderStatus will always\\n     *         return (false, false, 0, 0) for those hashes. Note that this\\n     *         function is susceptible to view reentrancy and so should be used\\n     *         with care when calling from other contracts.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function getOrderStatus(\\n        bytes32 orderHash\\n    )\\n        external\\n        view\\n        override\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        )\\n    {\\n        // Retrieve the order status using the order hash.\\n        return _getOrderStatus(orderHash);\\n    }\\n\\n    /**\\n     * @notice Retrieve the current counter for a given offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return counter The current counter.\\n     */\\n    function getCounter(\\n        address offerer\\n    ) external view override returns (uint256 counter) {\\n        // Return the counter for the supplied offerer.\\n        counter = _getCounter(offerer);\\n    }\\n\\n    /**\\n     * @notice Retrieve configuration information for this contract.\\n     *\\n     * @return version           The contract version.\\n     * @return domainSeparator   The domain separator for this contract.\\n     * @return conduitController The conduit Controller set for this contract.\\n     */\\n    function information()\\n        external\\n        view\\n        override\\n        returns (\\n            string memory version,\\n            bytes32 domainSeparator,\\n            address conduitController\\n        )\\n    {\\n        // Return the information for this contract.\\n        return _information();\\n    }\\n\\n    /**\\n     * @dev Gets the contract offerer nonce for the specified contract offerer.\\n     *      Note that this function is susceptible to view reentrancy and so\\n     *      should be used with care when calling from other contracts.\\n     *\\n     * @param contractOfferer The contract offerer for which to get the nonce.\\n     *\\n     * @return nonce The contract offerer nonce.\\n     */\\n    function getContractOffererNonce(\\n        address contractOfferer\\n    ) external view override returns (uint256 nonce) {\\n        nonce = _contractNonces[contractOfferer];\\n    }\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return contractName The name of this contract.\\n     */\\n    function name()\\n        external\\n        pure\\n        override\\n        returns (string memory /* contractName */)\\n    {\\n        // Return the name of the contract.\\n        return _name();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ConsiderationInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    BasicOrderParameters,\\n    OrderComponents,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Execution,\\n    Order,\\n    AdvancedOrder,\\n    CriteriaResolver\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title ConsiderationInterface\\n * @author 0age\\n * @custom:version 1.2\\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.\\n *         It minimizes external calls to the greatest extent possible and\\n *         provides lightweight methods for common routes as well as more\\n *         flexible methods for composing advanced orders.\\n *\\n * @dev ConsiderationInterface contains all external function interfaces for\\n *      Consideration.\\n */\\ninterface ConsiderationInterface {\\n    /**\\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\\n     *         the native token for the given chain) as consideration for the\\n     *         order. An arbitrary number of \\\"additional recipients\\\" may also be\\n     *         supplied which will each receive native tokens from the fulfiller\\n     *         as consideration.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer must first approve this contract (or\\n     *                   their preferred conduit if indicated by the order) for\\n     *                   their offered ERC721 token to be transferred.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillBasicOrder(\\n        BasicOrderParameters calldata parameters\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\n     *         consideration. Note that this function does not support\\n     *         criteria-based orders or partial filling of orders (though\\n     *         filling the remainder of a partially-filled order is supported).\\n     *\\n     * @param order               The order to fulfill. Note that both the\\n     *                            offerer and the fulfiller must first approve\\n     *                            this contract (or the corresponding conduit if\\n     *                            indicated) to transfer any relevant tokens on\\n     *                            their behalf and that contracts must implement\\n     *                            `onERC1155Received` to receive ERC1155 tokens\\n     *                            as consideration.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillOrder(\\n        Order calldata order,\\n        bytes32 fulfillerConduitKey\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\n     *         items for offer and consideration alongside criteria resolvers\\n     *         containing specific token identifiers and associated proofs.\\n     *\\n     * @param advancedOrder       The order to fulfill along with the fraction\\n     *                            of the order to attempt to fill. Note that\\n     *                            both the offerer and the fulfiller must first\\n     *                            approve this contract (or their preferred\\n     *                            conduit if indicated by the order) to transfer\\n     *                            any relevant tokens on their behalf and that\\n     *                            contracts must implement `onERC1155Received`\\n     *                            to receive ERC1155 tokens as consideration.\\n     *                            Also note that all offer and consideration\\n     *                            components must have no remainder after\\n     *                            multiplication of the respective amount with\\n     *                            the supplied fraction for the partial fill to\\n     *                            be considered valid.\\n     * @param criteriaResolvers   An array where each element contains a\\n     *                            reference to a specific offer or\\n     *                            consideration, a token identifier, and a proof\\n     *                            that the supplied token identifier is\\n     *                            contained in the merkle root held by the item\\n     *                            in question's criteria element. Note that an\\n     *                            empty criteria indicates that any\\n     *                            (transferable) token identifier on the token\\n     *                            in question is valid and that no associated\\n     *                            proof needs to be supplied.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     * @param recipient           The intended recipient for all received items,\\n     *                            with `address(0)` indicating that the caller\\n     *                            should receive the items.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillAdvancedOrder(\\n        AdvancedOrder calldata advancedOrder,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        bytes32 fulfillerConduitKey,\\n        address recipient\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\\n     *         of items for offer and consideration. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *         Note that this function does not support criteria-based orders or\\n     *         partial filling of orders (though filling the remainder of a\\n     *         partially-filled order is supported).\\n     *\\n     * @param orders                    The orders to fulfill. Note that both\\n     *                                  the offerer and the fulfiller must first\\n     *                                  approve this contract (or the\\n     *                                  corresponding conduit if indicated) to\\n     *                                  transfer any relevant tokens on their\\n     *                                  behalf and that contracts must implement\\n     *                                  `onERC1155Received` to receive ERC1155\\n     *                                  tokens as consideration.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders. Note that unspent offer item amounts or\\n     *                         native tokens will not be reflected as part of\\n     *                         this array.\\n     */\\n    function fulfillAvailableOrders(\\n        Order[] calldata orders,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\n     *         arbitrary number of items for offer and consideration per order\\n     *         alongside criteria resolvers containing specific token\\n     *         identifiers and associated proofs. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or their preferred conduit if\\n     *                                  indicated by the order) to transfer any\\n     *                                  relevant tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` to enable receipt of\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param criteriaResolvers         An array where each element contains a\\n     *                                  reference to a specific offer or\\n     *                                  consideration, a token identifier, and a\\n     *                                  proof that the supplied token identifier\\n     *                                  is contained in the merkle root held by\\n     *                                  the item in question's criteria element.\\n     *                                  Note that an empty criteria indicates\\n     *                                  that any (transferable) token\\n     *                                  identifier on the token in question is\\n     *                                  valid and that no associated proof needs\\n     *                                  to be supplied.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param recipient                 The intended recipient for all received\\n     *                                  items, with `address(0)` indicating that\\n     *                                  the caller should receive the items.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders. Note that unspent offer item amounts or\\n     *                         native tokens will not be reflected as part of\\n     *                         this array.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] calldata advancedOrders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        address recipient,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\n     *         number of items for offer and consideration along with a set of\\n     *         fulfillments allocating offer components to consideration\\n     *         components. Note that this function does not support\\n     *         criteria-based or partial filling of orders (though filling the\\n     *         remainder of a partially-filled order is supported). Any unspent\\n     *         offer item amounts or native tokens will be transferred to the\\n     *         caller.\\n     *\\n     * @param orders       The orders to match. Note that both the offerer and\\n     *                     fulfiller on each order must first approve this\\n     *                     contract (or their conduit if indicated by the order)\\n     *                     to transfer any relevant tokens on their behalf and\\n     *                     each consideration recipient must implement\\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\\n     * @param fulfillments An array of elements allocating offer components to\\n     *                     consideration components. Note that each\\n     *                     consideration component must be fully met for the\\n     *                     match operation to be valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders. Note that unspent offer item amounts or\\n     *                    native tokens will not be reflected as part of this\\n     *                    array.\\n     */\\n    function matchOrders(\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of full or partial orders, each with an\\n     *         arbitrary number of items for offer and consideration, supplying\\n     *         criteria resolvers containing specific token identifiers and\\n     *         associated proofs as well as fulfillments allocating offer\\n     *         components to consideration components. Any unspent offer item\\n     *         amounts will be transferred to the designated recipient (with the\\n     *         null address signifying to use the caller) and any unspent native\\n     *         tokens will be returned to the caller.\\n     *\\n     * @param orders            The advanced orders to match. Note that both the\\n     *                          offerer and fulfiller on each order must first\\n     *                          approve this contract (or a preferred conduit if\\n     *                          indicated by the order) to transfer any relevant\\n     *                          tokens on their behalf and each consideration\\n     *                          recipient must implement `onERC1155Received` in\\n     *                          order to receive ERC1155 tokens. Also note that\\n     *                          the offer and consideration components for each\\n     *                          order must have no remainder after multiplying\\n     *                          the respective amount with the supplied fraction\\n     *                          in order for the group of partial fills to be\\n     *                          considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          an empty root indicates that any (transferable)\\n     *                          token identifier is valid and that no associated\\n     *                          proof needs to be supplied.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     * @param recipient         The intended recipient for all unspent offer\\n     *                          item amounts, or the caller if the null address\\n     *                          is supplied.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders. Note that unspent offer item amounts or native\\n     *                    tokens will not be reflected as part of this array.\\n     */\\n    function matchAdvancedOrders(\\n        AdvancedOrder[] calldata orders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments,\\n        address recipient\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\n     *         or the zone of a given order may cancel it. Callers should ensure\\n     *         that the intended order was cancelled by calling `getOrderStatus`\\n     *         and confirming that `isCancelled` returns `true`.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders have\\n     *                   been successfully cancelled.\\n     */\\n    function cancel(\\n        OrderComponents[] calldata orders\\n    ) external returns (bool cancelled);\\n\\n    /**\\n     * @notice Validate an arbitrary number of orders, thereby registering their\\n     *         signatures as valid and allowing the fulfiller to skip signature\\n     *         verification on fulfillment. Note that validated orders may still\\n     *         be unfulfillable due to invalid item amounts or other factors;\\n     *         callers should determine whether validated orders are fulfillable\\n     *         by simulating the fulfillment call prior to execution. Also note\\n     *         that anyone can validate a signed order, but only the offerer can\\n     *         validate an order without supplying a signature.\\n     *\\n     * @param orders The orders to validate.\\n     *\\n     * @return validated A boolean indicating whether the supplied orders have\\n     *                   been successfully validated.\\n     */\\n    function validate(\\n        Order[] calldata orders\\n    ) external returns (bool validated);\\n\\n    /**\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\n     *         by incrementing a counter. Note that only the offerer may\\n     *         increment the counter.\\n     *\\n     * @return newCounter The new counter.\\n     */\\n    function incrementCounter() external returns (uint256 newCounter);\\n\\n    /**\\n     * @notice Retrieve the order hash for a given order.\\n     *\\n     * @param order The components of the order.\\n     *\\n     * @return orderHash The order hash.\\n     */\\n    function getOrderHash(\\n        OrderComponents calldata order\\n    ) external view returns (bytes32 orderHash);\\n\\n    /**\\n     * @notice Retrieve the status of a given order by hash, including whether\\n     *         the order has been cancelled or validated and the fraction of the\\n     *         order that has been filled.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function getOrderStatus(\\n        bytes32 orderHash\\n    )\\n        external\\n        view\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        );\\n\\n    /**\\n     * @notice Retrieve the current counter for a given offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return counter The current counter.\\n     */\\n    function getCounter(\\n        address offerer\\n    ) external view returns (uint256 counter);\\n\\n    /**\\n     * @notice Retrieve configuration information for this contract.\\n     *\\n     * @return version           The contract version.\\n     * @return domainSeparator   The domain separator for this contract.\\n     * @return conduitController The conduit Controller set for this contract.\\n     */\\n    function information()\\n        external\\n        view\\n        returns (\\n            string memory version,\\n            bytes32 domainSeparator,\\n            address conduitController\\n        );\\n\\n    function getContractOffererNonce(\\n        address contractOfferer\\n    ) external view returns (uint256 nonce);\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return contractName The name of this contract.\\n     */\\n    function name() external view returns (string memory contractName);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ConsiderationStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    OrderType,\\n    BasicOrderType,\\n    ItemType,\\n    Side\\n} from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    CalldataPointer,\\n    MemoryPointer\\n} from \\\"../helpers/PointerLibraries.sol\\\";\\n\\n/**\\n * @dev An order contains eleven components: an offerer, a zone (or account that\\n *      can cancel the order or restrict who can fulfill the order depending on\\n *      the type), the order type (specifying partial fill support as well as\\n *      restricted order status), the start and end time, a hash that will be\\n *      provided to the zone when validating restricted orders, a salt, a key\\n *      corresponding to a given conduit, a counter, and an arbitrary number of\\n *      offer items that can be spent along with consideration items that must\\n *      be received by their respective recipient.\\n */\\nstruct OrderComponents {\\n    address offerer;\\n    address zone;\\n    OfferItem[] offer;\\n    ConsiderationItem[] consideration;\\n    OrderType orderType;\\n    uint256 startTime;\\n    uint256 endTime;\\n    bytes32 zoneHash;\\n    uint256 salt;\\n    bytes32 conduitKey;\\n    uint256 counter;\\n}\\n\\n/**\\n * @dev An offer item has five components: an item type (ETH or other native\\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\\n *      ERC1155), a token address, a dual-purpose \\\"identifierOrCriteria\\\"\\n *      component that will either represent a tokenId or a merkle root\\n *      depending on the item type, and a start and end amount that support\\n *      increasing or decreasing amounts over the duration of the respective\\n *      order.\\n */\\nstruct OfferItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n}\\n\\n/**\\n * @dev A consideration item has the same five components as an offer item and\\n *      an additional sixth component designating the required recipient of the\\n *      item.\\n */\\nstruct ConsiderationItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev A spent item is translated from a utilized offer item and has four\\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\\n *      ERC1155), a token address, a tokenId, and an amount.\\n */\\nstruct SpentItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev A received item is translated from a utilized consideration item and has\\n *      the same four components as a spent item, as well as an additional fifth\\n *      component designating the required recipient of the item.\\n */\\nstruct ReceivedItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\\n *      matching, a group of six functions may be called that only requires a\\n *      subset of the usual order arguments. Note the use of a \\\"basicOrderType\\\"\\n *      enum; this represents both the usual order type as well as the \\\"route\\\"\\n *      of the basic order (a simple derivation function for the basic order\\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\\n */\\nstruct BasicOrderParameters {\\n    // calldata offset\\n    address considerationToken; // 0x24\\n    uint256 considerationIdentifier; // 0x44\\n    uint256 considerationAmount; // 0x64\\n    address payable offerer; // 0x84\\n    address zone; // 0xa4\\n    address offerToken; // 0xc4\\n    uint256 offerIdentifier; // 0xe4\\n    uint256 offerAmount; // 0x104\\n    BasicOrderType basicOrderType; // 0x124\\n    uint256 startTime; // 0x144\\n    uint256 endTime; // 0x164\\n    bytes32 zoneHash; // 0x184\\n    uint256 salt; // 0x1a4\\n    bytes32 offererConduitKey; // 0x1c4\\n    bytes32 fulfillerConduitKey; // 0x1e4\\n    uint256 totalOriginalAdditionalRecipients; // 0x204\\n    AdditionalRecipient[] additionalRecipients; // 0x224\\n    bytes signature; // 0x244\\n    // Total length, excluding dynamic array data: 0x264 (580)\\n}\\n\\n/**\\n * @dev Basic orders can supply any number of additional recipients, with the\\n *      implied assumption that they are supplied from the offered ETH (or other\\n *      native token) or ERC20 token for the order.\\n */\\nstruct AdditionalRecipient {\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev The full set of order components, with the exception of the counter,\\n *      must be supplied when fulfilling more sophisticated orders or groups of\\n *      orders. The total number of original consideration items must also be\\n *      supplied, as the caller may specify additional consideration items.\\n */\\nstruct OrderParameters {\\n    address offerer; // 0x00\\n    address zone; // 0x20\\n    OfferItem[] offer; // 0x40\\n    ConsiderationItem[] consideration; // 0x60\\n    OrderType orderType; // 0x80\\n    uint256 startTime; // 0xa0\\n    uint256 endTime; // 0xc0\\n    bytes32 zoneHash; // 0xe0\\n    uint256 salt; // 0x100\\n    bytes32 conduitKey; // 0x120\\n    uint256 totalOriginalConsiderationItems; // 0x140\\n    // offer.length                          // 0x160\\n}\\n\\n/**\\n * @dev Orders require a signature in addition to the other order parameters.\\n */\\nstruct Order {\\n    OrderParameters parameters;\\n    bytes signature;\\n}\\n\\n/**\\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\\n *      and a denominator (the total size of the order) in addition to the\\n *      signature and other order parameters. It also supports an optional field\\n *      for supplying extra data; this data will be provided to the zone if the\\n *      order type is restricted and the zone is not the caller, or will be\\n *      provided to the offerer as context for contract order types.\\n */\\nstruct AdvancedOrder {\\n    OrderParameters parameters;\\n    uint120 numerator;\\n    uint120 denominator;\\n    bytes signature;\\n    bytes extraData;\\n}\\n\\n/**\\n * @dev Orders can be validated (either explicitly via `validate`, or as a\\n *      consequence of a full or partial fill), specifically cancelled (they can\\n *      also be cancelled in bulk via incrementing a per-zone counter), and\\n *      partially or fully filled (with the fraction filled represented by a\\n *      numerator and denominator).\\n */\\nstruct OrderStatus {\\n    bool isValidated;\\n    bool isCancelled;\\n    uint120 numerator;\\n    uint120 denominator;\\n}\\n\\n/**\\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\\n *      alongside a merkle proof demonstrating the identifier meets the required\\n *      criteria.\\n */\\nstruct CriteriaResolver {\\n    uint256 orderIndex;\\n    Side side;\\n    uint256 index;\\n    uint256 identifier;\\n    bytes32[] criteriaProof;\\n}\\n\\n/**\\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\\n *      offer and consideration items, then generates a single execution\\n *      element. A given fulfillment can be applied to as many offer and\\n *      consideration items as desired, but must contain at least one offer and\\n *      at least one consideration that match. The fulfillment must also remain\\n *      consistent on all key parameters across all offer items (same offerer,\\n *      token, type, tokenId, and conduit preference) as well as across all\\n *      consideration items (token, type, tokenId, and recipient).\\n */\\nstruct Fulfillment {\\n    FulfillmentComponent[] offerComponents;\\n    FulfillmentComponent[] considerationComponents;\\n}\\n\\n/**\\n * @dev Each fulfillment component contains one index referencing a specific\\n *      order and another referencing a specific offer or consideration item.\\n */\\nstruct FulfillmentComponent {\\n    uint256 orderIndex;\\n    uint256 itemIndex;\\n}\\n\\n/**\\n * @dev An execution is triggered once all consideration items have been zeroed\\n *      out. It sends the item in question from the offerer to the item's\\n *      recipient, optionally sourcing approvals from either this contract\\n *      directly or from the offerer's chosen conduit if one is specified. An\\n *      execution is not provided as an argument, but rather is derived via\\n *      orders, criteria resolvers, and fulfillments (where the total number of\\n *      executions will be less than or equal to the total number of indicated\\n *      fulfillments) and returned as part of `matchOrders`.\\n */\\nstruct Execution {\\n    ReceivedItem item;\\n    address offerer;\\n    bytes32 conduitKey;\\n}\\n\\n/**\\n * @dev Restricted orders are validated post-execution by calling validateOrder\\n *      on the zone. This struct provides context about the order fulfillment\\n *      and any supplied extraData, as well as all order hashes fulfilled in a\\n *      call to a match or fulfillAvailable method.\\n */\\nstruct ZoneParameters {\\n    bytes32 orderHash;\\n    address fulfiller;\\n    address offerer;\\n    SpentItem[] offer;\\n    ReceivedItem[] consideration;\\n    bytes extraData;\\n    bytes32[] orderHashes;\\n    uint256 startTime;\\n    uint256 endTime;\\n    bytes32 zoneHash;\\n}\\n\\nusing StructPointers for OrderComponents global;\\nusing StructPointers for OfferItem global;\\nusing StructPointers for ConsiderationItem global;\\nusing StructPointers for SpentItem global;\\nusing StructPointers for ReceivedItem global;\\nusing StructPointers for BasicOrderParameters global;\\nusing StructPointers for AdditionalRecipient global;\\nusing StructPointers for OrderParameters global;\\nusing StructPointers for Order global;\\nusing StructPointers for AdvancedOrder global;\\nusing StructPointers for OrderStatus global;\\nusing StructPointers for CriteriaResolver global;\\nusing StructPointers for Fulfillment global;\\nusing StructPointers for FulfillmentComponent global;\\nusing StructPointers for Execution global;\\nusing StructPointers for ZoneParameters global;\\n\\nlibrary StructPointers {\\n    function toMemoryPointer(\\n        OrderComponents memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        OrderComponents calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        OfferItem memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        OfferItem calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        ConsiderationItem memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        ConsiderationItem calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        SpentItem memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        SpentItem calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        ReceivedItem memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        ReceivedItem calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        BasicOrderParameters memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        BasicOrderParameters calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        AdditionalRecipient memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        AdditionalRecipient calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        OrderParameters memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        OrderParameters calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        Order memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        Order calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        AdvancedOrder memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        AdvancedOrder calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        OrderStatus memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        OrderStatus calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        CriteriaResolver memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        CriteriaResolver calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        Fulfillment memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        Fulfillment calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        FulfillmentComponent memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        FulfillmentComponent calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        Execution memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        Execution calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toMemoryPointer(\\n        ZoneParameters memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    function toCalldataPointer(\\n        ZoneParameters calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OrderCombiner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { Side, ItemType, OrderType } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    OfferItem,\\n    ConsiderationItem,\\n    ReceivedItem,\\n    OrderParameters,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Execution,\\n    Order,\\n    AdvancedOrder,\\n    CriteriaResolver\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { OrderFulfiller } from \\\"./OrderFulfiller.sol\\\";\\n\\nimport { FulfillmentApplier } from \\\"./FulfillmentApplier.sol\\\";\\n\\nimport \\\"./ConsiderationErrors.sol\\\";\\n\\n/**\\n * @title OrderCombiner\\n * @author 0age\\n * @notice OrderCombiner contains logic for fulfilling combinations of orders,\\n *         either by matching offer items to consideration items or by\\n *         fulfilling orders where available.\\n */\\ncontract OrderCombiner is OrderFulfiller, FulfillmentApplier {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) OrderFulfiller(conduitController) {}\\n\\n    /**\\n     * @notice Internal function to attempt to fill a group of orders, fully or\\n     *         partially, with an arbitrary number of items for offer and\\n     *         consideration per order alongside criteria resolvers containing\\n     *         specific token identifiers and associated proofs. Any order that\\n     *         is not currently active, has already been fully filled, or has\\n     *         been cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or a conduit if indicated by\\n     *                                  the order) to transfer any relevant\\n     *                                  tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` in order to receive\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param criteriaResolvers         An array where each element contains a\\n     *                                  reference to a specific offer or\\n     *                                  consideration, a token identifier, and a\\n     *                                  proof that the supplied token identifier\\n     *                                  is contained in the merkle root held by\\n     *                                  the item in question's criteria element.\\n     *                                  Note that an empty criteria indicates\\n     *                                  that any (transferable) token\\n     *                                  identifier on the token in question is\\n     *                                  valid and that no associated proof needs\\n     *                                  to be supplied.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used (and\\n     *                                  direct approvals set on Consideration).\\n     * @param recipient                 The intended recipient for all received\\n     *                                  items.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders.\\n     */\\n    function _fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        FulfillmentComponent[][] memory offerFulfillments,\\n        FulfillmentComponent[][] memory considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        address recipient,\\n        uint256 maximumFulfilled\\n    )\\n        internal\\n        returns (\\n            bool[] memory /* availableOrders */,\\n            Execution[] memory /* executions */\\n        )\\n    {\\n        // Validate orders, apply amounts, & determine if they utilize conduits.\\n        bytes32[] memory orderHashes = _validateOrdersAndPrepareToFulfill(\\n            advancedOrders,\\n            criteriaResolvers,\\n            false, // Signifies that invalid orders should NOT revert.\\n            maximumFulfilled,\\n            recipient\\n        );\\n\\n        // Aggregate used offer and consideration items and execute transfers.\\n        return\\n            _executeAvailableFulfillments(\\n                advancedOrders,\\n                offerFulfillments,\\n                considerationFulfillments,\\n                fulfillerConduitKey,\\n                recipient,\\n                orderHashes\\n            );\\n    }\\n\\n    /**\\n     * @dev Internal function to validate a group of orders, update their\\n     *      statuses, reduce amounts by their previously filled fractions, apply\\n     *      criteria resolvers, and emit OrderFulfilled events. Note that this\\n     *      function needs to be called before\\n     *      _aggregateValidFulfillmentConsiderationItems to set the memory\\n     *      layout that _aggregateValidFulfillmentConsiderationItems depends on.\\n     *\\n     * @param advancedOrders    The advanced orders to validate and reduce by\\n     *                          their previously filled amounts.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          a root of zero indicates that any transferable\\n     *                          token identifier is valid and that no proof\\n     *                          needs to be supplied.\\n     * @param revertOnInvalid   A boolean indicating whether to revert on any\\n     *                          order being invalid; setting this to false will\\n     *                          instead cause the invalid order to be skipped.\\n     * @param maximumFulfilled  The maximum number of orders to fulfill.\\n     * @param recipient         The intended recipient for all items that do not\\n     *                          already have a designated recipient and are not\\n     *                          already used as part of a provided fulfillment.\\n     *\\n     * @return orderHashes      The hashes of the orders being fulfilled.\\n     */\\n    function _validateOrdersAndPrepareToFulfill(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        bool revertOnInvalid,\\n        uint256 maximumFulfilled,\\n        address recipient\\n    ) internal returns (bytes32[] memory orderHashes) {\\n        // Ensure this function cannot be triggered during a reentrant call.\\n        _setReentrancyGuard(true); // Native tokens accepted during execution.\\n\\n        // Declare an error buffer indicating status of any native offer items.\\n        // Note that contract orders may still designate native offer items.\\n        // {00} == 0 => In a match function, no native offer items: allow.\\n        // {01} == 1 => In a match function, some native offer items: allow.\\n        // {10} == 2 => Not in a match function, no native offer items: allow.\\n        // {11} == 3 => Not in a match function, some native offer items: THROW.\\n        uint256 invalidNativeOfferItemErrorBuffer;\\n\\n        // Use assembly to set the value for the second bit of the error buffer.\\n        assembly {\\n            /**\\n             * Use the 231st bit of the error buffer to indicate whether the\\n             * current function is not matchAdvancedOrders or matchOrders.\\n             *\\n             * sig                                func\\n             * -----------------------------------------------------------------\\n             * 1010100000010111010001000 0 000100 matchOrders\\n             * 1111001011010001001010110 0 010010 matchAdvancedOrders\\n             * 1110110110011000101001010 1 110100 fulfillAvailableOrders\\n             * 1000011100100000000110110 1 000001 fulfillAvailableAdvancedOrders\\n             *                           ^ 7th bit\\n             */\\n            invalidNativeOfferItemErrorBuffer := and(\\n                NonMatchSelector_MagicMask,\\n                calldataload(0)\\n            )\\n        }\\n\\n        // Declare variables for later use.\\n        AdvancedOrder memory advancedOrder;\\n        uint256 terminalMemoryOffset;\\n\\n        unchecked {\\n            // Read length of orders array and place on the stack.\\n            uint256 totalOrders = advancedOrders.length;\\n\\n            // Track the order hash for each order being fulfilled.\\n            orderHashes = new bytes32[](totalOrders);\\n\\n            // Determine the memory offset to terminate on during loops.\\n            terminalMemoryOffset = (totalOrders + 1) * 32;\\n        }\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Declare inner variables.\\n            OfferItem[] memory offer;\\n            ConsiderationItem[] memory consideration;\\n\\n            // Iterate over each order.\\n            for (uint256 i = 32; i < terminalMemoryOffset; i += 32) {\\n                // Retrieve order using assembly to bypass out-of-range check.\\n                assembly {\\n                    advancedOrder := mload(add(advancedOrders, i))\\n                }\\n\\n                // Determine if max number orders have already been fulfilled.\\n                if (maximumFulfilled == 0) {\\n                    // Mark fill fraction as zero as the order will not be used.\\n                    advancedOrder.numerator = 0;\\n\\n                    // Continue iterating through the remaining orders.\\n                    continue;\\n                }\\n\\n                // Validate it, update status, and determine fraction to fill.\\n                (\\n                    bytes32 orderHash,\\n                    uint256 numerator,\\n                    uint256 denominator\\n                ) = _validateOrderAndUpdateStatus(\\n                        advancedOrder,\\n                        revertOnInvalid\\n                    );\\n\\n                // Do not track hash or adjust prices if order is not fulfilled.\\n                if (numerator == 0) {\\n                    // Mark fill fraction as zero if the order is not fulfilled.\\n                    advancedOrder.numerator = 0;\\n\\n                    // Continue iterating through the remaining orders.\\n                    continue;\\n                }\\n\\n                // Otherwise, track the order hash in question.\\n                assembly {\\n                    mstore(add(orderHashes, i), orderHash)\\n                }\\n\\n                // Decrement the number of fulfilled orders.\\n                // Skip underflow check as the condition before\\n                // implies that maximumFulfilled > 0.\\n                maximumFulfilled--;\\n\\n                // Place the start time for the order on the stack.\\n                uint256 startTime = advancedOrder.parameters.startTime;\\n\\n                // Place the end time for the order on the stack.\\n                uint256 endTime = advancedOrder.parameters.endTime;\\n\\n                // Retrieve array of offer items for the order in question.\\n                offer = advancedOrder.parameters.offer;\\n\\n                // Read length of offer array and place on the stack.\\n                uint256 totalOfferItems = offer.length;\\n\\n                {\\n                    // Create a variable indicating if the order is not a\\n                    // contract order. Cache in scratch space to avoid stack\\n                    // depth errors.\\n                    OrderType orderType = advancedOrder.parameters.orderType;\\n                    assembly {\\n                        let isNonContract := lt(orderType, 4)\\n                        mstore(0, isNonContract)\\n                    }\\n                }\\n\\n                // Iterate over each offer item on the order.\\n                for (uint256 j = 0; j < totalOfferItems; ++j) {\\n                    // Retrieve the offer item.\\n                    OfferItem memory offerItem = offer[j];\\n\\n                    {\\n                        assembly {\\n                            // If the offer item is for the native token and the\\n                            // order type is not a contract order type, set the\\n                            // first bit of the error buffer to true.\\n                            invalidNativeOfferItemErrorBuffer := or(\\n                                invalidNativeOfferItemErrorBuffer,\\n                                lt(mload(offerItem), mload(0))\\n                            )\\n                        }\\n                    }\\n\\n                    // Apply order fill fraction to offer item end amount.\\n                    uint256 endAmount = _getFraction(\\n                        numerator,\\n                        denominator,\\n                        offerItem.endAmount\\n                    );\\n\\n                    // Reuse same fraction if start and end amounts are equal.\\n                    if (offerItem.startAmount == offerItem.endAmount) {\\n                        // Apply derived amount to both start and end amount.\\n                        offerItem.startAmount = endAmount;\\n                    } else {\\n                        // Apply order fill fraction to offer item start amount.\\n                        offerItem.startAmount = _getFraction(\\n                            numerator,\\n                            denominator,\\n                            offerItem.startAmount\\n                        );\\n                    }\\n\\n                    // Adjust offer amount using current time; round down.\\n                    uint256 currentAmount = _locateCurrentAmount(\\n                        offerItem.startAmount,\\n                        endAmount,\\n                        startTime,\\n                        endTime,\\n                        false // round down\\n                    );\\n\\n                    // Update amounts in memory to match the current amount.\\n                    // Note that the end amount is used to track spent amounts.\\n                    offerItem.startAmount = currentAmount;\\n                    offerItem.endAmount = currentAmount;\\n                }\\n\\n                // Retrieve array of consideration items for order in question.\\n                consideration = (advancedOrder.parameters.consideration);\\n\\n                // Read length of consideration array and place on the stack.\\n                uint256 totalConsiderationItems = consideration.length;\\n\\n                // Iterate over each consideration item on the order.\\n                for (uint256 j = 0; j < totalConsiderationItems; ++j) {\\n                    // Retrieve the consideration item.\\n                    ConsiderationItem memory considerationItem = (\\n                        consideration[j]\\n                    );\\n\\n                    // Apply fraction to consideration item end amount.\\n                    uint256 endAmount = _getFraction(\\n                        numerator,\\n                        denominator,\\n                        considerationItem.endAmount\\n                    );\\n\\n                    // Reuse same fraction if start and end amounts are equal.\\n                    if (\\n                        considerationItem.startAmount ==\\n                        considerationItem.endAmount\\n                    ) {\\n                        // Apply derived amount to both start and end amount.\\n                        considerationItem.startAmount = endAmount;\\n                    } else {\\n                        // Apply fraction to consideration item start amount.\\n                        considerationItem.startAmount = _getFraction(\\n                            numerator,\\n                            denominator,\\n                            considerationItem.startAmount\\n                        );\\n                    }\\n\\n                    // Adjust consideration amount using current time; round up.\\n                    uint256 currentAmount = (\\n                        _locateCurrentAmount(\\n                            considerationItem.startAmount,\\n                            endAmount,\\n                            startTime,\\n                            endTime,\\n                            true // round up\\n                        )\\n                    );\\n\\n                    considerationItem.startAmount = currentAmount;\\n\\n                    // Utilize assembly to manually \\\"shift\\\" the recipient value,\\n                    // then to copy the start amount to the recipient.\\n                    // Note that this sets up the memory layout that is\\n                    // subsequently relied upon by\\n                    // _aggregateValidFulfillmentConsiderationItems.\\n                    assembly {\\n                        // Derive the pointer to the recipient using the item\\n                        // pointer along with the offset to the recipient.\\n                        let considerationItemRecipient := add(\\n                            considerationItem,\\n                            ConsiderationItem_recipient_offset // recipient\\n                        )\\n\\n                        // Write recipient to endAmount, as endAmount is not\\n                        // used from this point on and can be repurposed to fit\\n                        // the layout of a ReceivedItem.\\n                        mstore(\\n                            add(\\n                                considerationItem,\\n                                ReceivedItem_recipient_offset // old endAmount\\n                            ),\\n                            mload(considerationItemRecipient)\\n                        )\\n\\n                        // Write startAmount to recipient, as recipient is not\\n                        // used from this point on and can be repurposed to\\n                        // track received amounts.\\n                        mstore(considerationItemRecipient, currentAmount)\\n                    }\\n                }\\n            }\\n        }\\n\\n        // If the first bit is set, a native offer item was encountered. If the\\n        // second bit is set in the error buffer, the current function is not\\n        // matchOrders or matchAdvancedOrders. If the value is three, both the\\n        // first and second bits were set; in that case, revert with an error.\\n        if (\\n            invalidNativeOfferItemErrorBuffer ==\\n            NonMatchSelector_InvalidErrorValue\\n        ) {\\n            _revertInvalidNativeOfferItem();\\n        }\\n\\n        // Apply criteria resolvers to each order as applicable.\\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\\n\\n        // Emit an event for each order signifying that it has been fulfilled.\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            bytes32 orderHash;\\n\\n            // Iterate over each order.\\n            for (uint256 i = 32; i < terminalMemoryOffset; i += 32) {\\n                assembly {\\n                    orderHash := mload(add(orderHashes, i))\\n                }\\n\\n                // Do not emit an event if no order hash is present.\\n                if (orderHash == bytes32(0)) {\\n                    continue;\\n                }\\n\\n                // Retrieve order using assembly to bypass out-of-range check.\\n                assembly {\\n                    advancedOrder := mload(add(advancedOrders, i))\\n                }\\n\\n                // Retrieve parameters for the order in question.\\n                OrderParameters memory orderParameters = (\\n                    advancedOrder.parameters\\n                );\\n\\n                // Emit an OrderFulfilled event.\\n                _emitOrderFulfilledEvent(\\n                    orderHash,\\n                    orderParameters.offerer,\\n                    orderParameters.zone,\\n                    recipient,\\n                    orderParameters.offer,\\n                    orderParameters.consideration\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to fulfill a group of validated orders, fully or\\n     *      partially, with an arbitrary number of items for offer and\\n     *      consideration per order and to execute transfers. Any order that is\\n     *      not currently active, has already been fully filled, or has been\\n     *      cancelled will be omitted. Remaining offer and consideration items\\n     *      will then be aggregated where possible as indicated by the supplied\\n     *      offer and consideration component arrays and aggregated items will\\n     *      be transferred to the fulfiller or to each intended recipient,\\n     *      respectively. Note that a failing item transfer or an issue with\\n     *      order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or the conduit if indicated by\\n     *                                  the order) to transfer any relevant\\n     *                                  tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` in order to receive\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on Consideration.\\n     * @param recipient                 The intended recipient for all items\\n     *                                  that do not already have a designated\\n     *                                  recipient and are not already used as\\n     *                                  part of a provided fulfillment.\\n     * @param orderHashes               An array of order hashes for each order.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders.\\n     */\\n    function _executeAvailableFulfillments(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[][] memory offerFulfillments,\\n        FulfillmentComponent[][] memory considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        address recipient,\\n        bytes32[] memory orderHashes\\n    )\\n        internal\\n        returns (bool[] memory availableOrders, Execution[] memory executions)\\n    {\\n        // Retrieve length of offer fulfillments array and place on the stack.\\n        uint256 totalOfferFulfillments = offerFulfillments.length;\\n\\n        // Retrieve length of consideration fulfillments array & place on stack.\\n        uint256 totalConsiderationFulfillments = (\\n            considerationFulfillments.length\\n        );\\n\\n        // Allocate an execution for each offer and consideration fulfillment.\\n        executions = new Execution[](\\n            totalOfferFulfillments + totalConsiderationFulfillments\\n        );\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Track number of filtered executions.\\n            uint256 totalFilteredExecutions = 0;\\n\\n            // Iterate over each offer fulfillment.\\n            for (uint256 i = 0; i < totalOfferFulfillments; ) {\\n                // Derive aggregated execution corresponding with fulfillment.\\n                Execution memory execution = _aggregateAvailable(\\n                    advancedOrders,\\n                    Side.OFFER,\\n                    offerFulfillments[i],\\n                    fulfillerConduitKey,\\n                    recipient\\n                );\\n\\n                // If offerer and recipient on the execution are the same...\\n                if (\\n                    _unmaskedAddressComparison(\\n                        execution.item.recipient,\\n                        execution.offerer\\n                    )\\n                ) {\\n                    // Increment total filtered executions.\\n                    ++totalFilteredExecutions;\\n                } else {\\n                    // Otherwise, assign the execution to the executions array.\\n                    executions[i - totalFilteredExecutions] = execution;\\n                }\\n\\n                // Increment iterator.\\n                ++i;\\n            }\\n\\n            // Iterate over each consideration fulfillment.\\n            for (uint256 i = 0; i < totalConsiderationFulfillments; ) {\\n                // Derive aggregated execution corresponding with fulfillment.\\n                Execution memory execution = _aggregateAvailable(\\n                    advancedOrders,\\n                    Side.CONSIDERATION,\\n                    considerationFulfillments[i],\\n                    fulfillerConduitKey,\\n                    address(0) // unused\\n                );\\n\\n                // If offerer and recipient on the execution are the same...\\n                if (\\n                    _unmaskedAddressComparison(\\n                        execution.item.recipient,\\n                        execution.offerer\\n                    )\\n                ) {\\n                    // Increment total filtered executions.\\n                    ++totalFilteredExecutions;\\n                } else {\\n                    // Otherwise, assign the execution to the executions array.\\n                    executions[\\n                        i + totalOfferFulfillments - totalFilteredExecutions\\n                    ] = execution;\\n                }\\n\\n                // Increment iterator.\\n                ++i;\\n            }\\n\\n            // If some number of executions have been filtered...\\n            if (totalFilteredExecutions != 0) {\\n                // reduce the total length of the executions array.\\n                assembly {\\n                    mstore(\\n                        executions,\\n                        sub(mload(executions), totalFilteredExecutions)\\n                    )\\n                }\\n            }\\n        }\\n\\n        // Revert if no orders are available.\\n        if (executions.length == 0) {\\n            _revertNoSpecifiedOrdersAvailable();\\n        }\\n\\n        // Perform final checks and return.\\n        availableOrders = _performFinalChecksAndExecuteOrders(\\n            advancedOrders,\\n            executions,\\n            orderHashes,\\n            recipient\\n        );\\n\\n        return (availableOrders, executions);\\n    }\\n\\n    /**\\n     * @dev Internal function to perform a final check that each consideration\\n     *      item for an arbitrary number of fulfilled orders has been met and to\\n     *      trigger associated executions, transferring the respective items.\\n     *\\n     * @param advancedOrders     The orders to check and perform executions for.\\n     * @param executions         An array of elements indicating the sequence of\\n     *                           transfers to perform when fulfilling the given\\n     *                           orders.\\n     * @param orderHashes        An array of order hashes for each order.\\n     * @param recipient          The intended recipient for all items that do\\n     *                           not already have a designated recipient and are\\n     *                           not used as part of a provided fulfillment.\\n     *\\n     * @return availableOrders   An array of booleans indicating if each order\\n     *                           with an index corresponding to the index of the\\n     *                           returned boolean was fulfillable or not.\\n     */\\n    function _performFinalChecksAndExecuteOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        Execution[] memory executions,\\n        bytes32[] memory orderHashes,\\n        address recipient\\n    ) internal returns (bool[] memory /* availableOrders */) {\\n        // Declare a variable for the available native token balance.\\n        uint256 nativeTokenBalance;\\n\\n        // Retrieve the length of the advanced orders array and place on stack.\\n        uint256 totalOrders = advancedOrders.length;\\n\\n        // Initialize array for tracking available orders.\\n        bool[] memory availableOrders = new bool[](totalOrders);\\n\\n        // Initialize an accumulator array. From this point forward, no new\\n        // memory regions can be safely allocated until the accumulator is no\\n        // longer being utilized, as the accumulator operates in an open-ended\\n        // fashion from this memory pointer; existing memory may still be\\n        // accessed and modified, however.\\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\\n\\n        // Retrieve the length of the executions array and place on stack.\\n        uint256 totalExecutions = executions.length;\\n\\n        // Iterate over each execution.\\n        for (uint256 i = 0; i < totalExecutions; ) {\\n            // Retrieve the execution and the associated received item.\\n            Execution memory execution = executions[i];\\n            ReceivedItem memory item = execution.item;\\n\\n            // If execution transfers native tokens, reduce value available.\\n            if (item.itemType == ItemType.NATIVE) {\\n                // Get the current available balance of native tokens.\\n                assembly {\\n                    nativeTokenBalance := selfbalance()\\n                }\\n\\n                // Ensure that sufficient native tokens are still available.\\n                if (item.amount > nativeTokenBalance) {\\n                    _revertInsufficientEtherSupplied();\\n                }\\n            }\\n\\n            // Transfer the item specified by the execution.\\n            _transfer(\\n                item,\\n                execution.offerer,\\n                execution.conduitKey,\\n                accumulator\\n            );\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // duplicate recipient address to stack to avoid stack-too-deep\\n            address _recipient = recipient;\\n\\n            // Iterate over orders to ensure all consideration items are met.\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\n                // Retrieve the order in question.\\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\\n\\n                // Skip consideration item checks for order if not fulfilled.\\n                if (advancedOrder.numerator == 0) {\\n                    // This is required because the current memory region, which\\n                    // was previously used by the accumulator, might be dirty.\\n                    availableOrders[i] = false;\\n                    continue;\\n                }\\n\\n                // Mark the order as available.\\n                availableOrders[i] = true;\\n\\n                // Retrieve the order parameters.\\n                OrderParameters memory parameters = advancedOrder.parameters;\\n\\n                {\\n                    // Retrieve offer items.\\n                    OfferItem[] memory offer = parameters.offer;\\n\\n                    // Read length of offer array & place on the stack.\\n                    uint256 totalOfferItems = offer.length;\\n\\n                    // Iterate over each offer item to restore it.\\n                    for (uint256 j = 0; j < totalOfferItems; ++j) {\\n                        OfferItem memory offerItem = offer[j];\\n                        // Retrieve original amount on the offer item.\\n                        uint256 originalAmount = offerItem.endAmount;\\n                        // Retrieve remaining amount on the offer item.\\n                        uint256 unspentAmount = offerItem.startAmount;\\n\\n                        // Transfer to recipient if unspent amount is not zero.\\n                        // Note that the transfer will not be reflected in the\\n                        // executions array.\\n                        if (unspentAmount != 0) {\\n                            _transfer(\\n                                _convertOfferItemToReceivedItemWithRecipient(\\n                                    offerItem,\\n                                    _recipient\\n                                ),\\n                                parameters.offerer,\\n                                parameters.conduitKey,\\n                                accumulator\\n                            );\\n                        }\\n\\n                        // Restore original amount on the offer item.\\n                        offerItem.startAmount = originalAmount;\\n                    }\\n                }\\n\\n                {\\n                    // Retrieve consideration items & ensure they are fulfilled.\\n                    ConsiderationItem[] memory consideration = (\\n                        parameters.consideration\\n                    );\\n\\n                    // Read length of consideration array & place on the stack.\\n                    uint256 totalConsiderationItems = consideration.length;\\n\\n                    // Iterate over each consideration item to ensure it is met.\\n                    for (uint256 j = 0; j < totalConsiderationItems; ++j) {\\n                        ConsiderationItem memory considerationItem = (\\n                            consideration[j]\\n                        );\\n\\n                        // Retrieve remaining amount on the consideration item.\\n                        uint256 unmetAmount = considerationItem.startAmount;\\n\\n                        // Revert if the remaining amount is not zero.\\n                        if (unmetAmount != 0) {\\n                            _revertConsiderationNotMet(i, j, unmetAmount);\\n                        }\\n\\n                        // Utilize assembly to restore the original value.\\n                        assembly {\\n                            // Write recipient to startAmount.\\n                            mstore(\\n                                add(\\n                                    considerationItem,\\n                                    ReceivedItem_amount_offset\\n                                ),\\n                                mload(\\n                                    add(\\n                                        considerationItem,\\n                                        ConsiderationItem_recipient_offset\\n                                    )\\n                                )\\n                            )\\n                        }\\n                    }\\n                }\\n\\n                // Check restricted orders and contract orders.\\n                _assertRestrictedAdvancedOrderValidity(\\n                    advancedOrder,\\n                    orderHashes,\\n                    orderHashes[i]\\n                );\\n            }\\n        }\\n\\n        // Trigger any remaining accumulated transfers via call to the conduit.\\n        _triggerIfArmed(accumulator);\\n\\n        // Determine whether any native token balance remains.\\n        assembly {\\n            nativeTokenBalance := selfbalance()\\n        }\\n\\n        // Return any remaining native token balance to the caller.\\n        if (nativeTokenBalance != 0) {\\n            _transferNativeTokens(payable(msg.sender), nativeTokenBalance);\\n        }\\n\\n        // Clear the reentrancy guard.\\n        _clearReentrancyGuard();\\n\\n        // Return the array containing available orders.\\n        return availableOrders;\\n    }\\n\\n    /**\\n     * @dev Internal function to emit an OrdersMatched event using the same\\n     *      memory region as the existing order hash array.\\n     *\\n     * @param orderHashes An array of order hashes to include as an argument for\\n     *                    the OrdersMatched event.\\n     */\\n    function _emitOrdersMatched(bytes32[] memory orderHashes) internal {\\n        assembly {\\n            // Load the array length from memory.\\n            let length := mload(orderHashes)\\n\\n            // Get the full size of the event data - one word for the offset,\\n            // one for the array length and one per hash.\\n            let dataSize := add(TwoWords, shl(OneWordShift, length))\\n\\n            // Get pointer to start of data, reusing word before array length\\n            // for the offset.\\n            let dataPointer := sub(orderHashes, OneWord)\\n\\n            // Cache the existing word in memory at the offset pointer.\\n            let cache := mload(dataPointer)\\n\\n            // Write an offset of 32.\\n            mstore(dataPointer, OneWord)\\n\\n            // Emit the OrdersMatched event.\\n            log1(dataPointer, dataSize, OrdersMatchedTopic0)\\n\\n            // Restore the cached word.\\n            mstore(dataPointer, cache)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to match an arbitrary number of full or partial\\n     *      orders, each with an arbitrary number of items for offer and\\n     *      consideration, supplying criteria resolvers containing specific\\n     *      token identifiers and associated proofs as well as fulfillments\\n     *      allocating offer components to consideration components.\\n     *\\n     * @param advancedOrders    The advanced orders to match. Note that both the\\n     *                          offerer and fulfiller on each order must first\\n     *                          approve this contract (or their conduit if\\n     *                          indicated by the order) to transfer any relevant\\n     *                          tokens on their behalf and each consideration\\n     *                          recipient must implement `onERC1155Received` in\\n     *                          order to receive ERC1155 tokens. Also note that\\n     *                          the offer and consideration components for each\\n     *                          order must have no remainder after multiplying\\n     *                          the respective amount with the supplied fraction\\n     *                          in order for the group of partial fills to be\\n     *                          considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          an empty root indicates that any (transferable)\\n     *                          token identifier is valid and that no associated\\n     *                          proof needs to be supplied.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     * @param recipient         The intended recipient for all unspent offer\\n     *                          item amounts.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function _matchAdvancedOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        Fulfillment[] memory fulfillments,\\n        address recipient\\n    ) internal returns (Execution[] memory /* executions */) {\\n        // Validate orders, update order status, and determine item amounts.\\n        bytes32[] memory orderHashes = _validateOrdersAndPrepareToFulfill(\\n            advancedOrders,\\n            criteriaResolvers,\\n            true, // Signifies that invalid orders should revert.\\n            advancedOrders.length,\\n            recipient\\n        );\\n\\n        // Emit OrdersMatched event, providing an array of matched order hashes.\\n        _emitOrdersMatched(orderHashes);\\n\\n        // Fulfill the orders using the supplied fulfillments and recipient.\\n        return\\n            _fulfillAdvancedOrders(\\n                advancedOrders,\\n                fulfillments,\\n                orderHashes,\\n                recipient\\n            );\\n    }\\n\\n    /**\\n     * @dev Internal function to fulfill an arbitrary number of orders, either\\n     *      full or partial, after validating, adjusting amounts, and applying\\n     *      criteria resolvers.\\n     *\\n     * @param advancedOrders     The orders to match, including a fraction to\\n     *                           attempt to fill for each order.\\n     * @param fulfillments       An array of elements allocating offer\\n     *                           components to consideration components. Note\\n     *                           that the final amount of each consideration\\n     *                           component must be zero for a match operation to\\n     *                           be considered valid.\\n     * @param orderHashes        An array of order hashes for each order.\\n     * @param recipient          The intended recipient for all items that do\\n     *                           not already have a designated recipient and are\\n     *                           not used as part of a provided fulfillment.\\n     *\\n     * @return executions        An array of elements indicating the sequence of\\n     *                           transfers performed as part of matching the\\n     *                           given orders.\\n     */\\n    function _fulfillAdvancedOrders(\\n        AdvancedOrder[] memory advancedOrders,\\n        Fulfillment[] memory fulfillments,\\n        bytes32[] memory orderHashes,\\n        address recipient\\n    ) internal returns (Execution[] memory executions) {\\n        // Retrieve fulfillments array length and place on the stack.\\n        uint256 totalFulfillments = fulfillments.length;\\n\\n        // Allocate executions by fulfillment and apply them to each execution.\\n        executions = new Execution[](totalFulfillments);\\n\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Track number of filtered executions.\\n            uint256 totalFilteredExecutions = 0;\\n\\n            // Iterate over each fulfillment.\\n            for (uint256 i = 0; i < totalFulfillments; ++i) {\\n                /// Retrieve the fulfillment in question.\\n                Fulfillment memory fulfillment = fulfillments[i];\\n\\n                // Derive the execution corresponding with the fulfillment.\\n                Execution memory execution = _applyFulfillment(\\n                    advancedOrders,\\n                    fulfillment.offerComponents,\\n                    fulfillment.considerationComponents,\\n                    i\\n                );\\n\\n                // If offerer and recipient on the execution are the same...\\n                if (\\n                    _unmaskedAddressComparison(\\n                        execution.item.recipient,\\n                        execution.offerer\\n                    )\\n                ) {\\n                    // Increment total filtered executions.\\n                    ++totalFilteredExecutions;\\n                } else {\\n                    // Otherwise, assign the execution to the executions array.\\n                    executions[i - totalFilteredExecutions] = execution;\\n                }\\n            }\\n\\n            // If some number of executions have been filtered...\\n            if (totalFilteredExecutions != 0) {\\n                // reduce the total length of the executions array.\\n                assembly {\\n                    mstore(\\n                        executions,\\n                        sub(mload(executions), totalFilteredExecutions)\\n                    )\\n                }\\n            }\\n        }\\n\\n        // Perform final checks and execute orders.\\n        _performFinalChecksAndExecuteOrders(\\n            advancedOrders,\\n            executions,\\n            orderHashes,\\n            recipient\\n        );\\n\\n        // Return the executions array.\\n        return executions;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/PointerLibraries.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ntype CalldataPointer is uint256;\\n\\ntype ReturndataPointer is uint256;\\n\\ntype MemoryPointer is uint256;\\n\\nusing CalldataPointerLib for CalldataPointer global;\\nusing MemoryPointerLib for MemoryPointer global;\\nusing ReturndataPointerLib for ReturndataPointer global;\\n\\nusing CalldataReaders for CalldataPointer global;\\nusing ReturndataReaders for ReturndataPointer global;\\nusing MemoryReaders for MemoryPointer global;\\nusing MemoryWriters for MemoryPointer global;\\n\\nCalldataPointer constant CalldataStart = CalldataPointer.wrap(0x04);\\nMemoryPointer constant FreeMemoryPPtr = MemoryPointer.wrap(0x40);\\nuint256 constant IdentityPrecompileAddress = 4;\\nuint256 constant OffsetOrLengthMask = 0xffffffff;\\n\\n/// @dev Allocates `size` bytes in memory by increasing the free memory pointer\\n///    and returns the memory pointer to the first byte of the allocated region.\\n// (Free functions cannot have visibility.)\\n// solhint-disable-next-line func-visibility\\nfunction malloc(uint256 size) pure returns (MemoryPointer mPtr) {\\n    assembly {\\n        mPtr := mload(0x40)\\n        mstore(0x40, add(mPtr, size))\\n    }\\n}\\n\\n// (Free functions cannot have visibility.)\\n// solhint-disable-next-line func-visibility\\nfunction getFreeMemoryPointer() pure returns (MemoryPointer mPtr) {\\n    mPtr = FreeMemoryPPtr.readMemoryPointer();\\n}\\n\\n// (Free functions cannot have visibility.)\\n// solhint-disable-next-line func-visibility\\nfunction setFreeMemoryPointer(MemoryPointer mPtr) pure {\\n    FreeMemoryPPtr.write(mPtr);\\n}\\n\\nlibrary CalldataPointerLib {\\n    function lt(\\n        CalldataPointer a,\\n        CalldataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := lt(a, b)\\n        }\\n    }\\n\\n    function gt(\\n        CalldataPointer a,\\n        CalldataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := gt(a, b)\\n        }\\n    }\\n\\n    function eq(\\n        CalldataPointer a,\\n        CalldataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := eq(a, b)\\n        }\\n    }\\n\\n    /// @dev Resolves an offset stored at `cdPtr + headOffset` to a calldata.\\n    ///      pointer `cdPtr` must point to some parent object with a dynamic\\n    ///      type's head stored at `cdPtr + headOffset`.\\n    function pptr(\\n        CalldataPointer cdPtr,\\n        uint256 headOffset\\n    ) internal pure returns (CalldataPointer cdPtrChild) {\\n        cdPtrChild = cdPtr.offset(\\n            cdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\\n        );\\n    }\\n\\n    /// @dev Resolves an offset stored at `cdPtr` to a calldata pointer.\\n    ///      `cdPtr` must point to some parent object with a dynamic type as its\\n    ///      first member, e.g. `struct { bytes data; }`\\n    function pptr(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (CalldataPointer cdPtrChild) {\\n        cdPtrChild = cdPtr.offset(cdPtr.readUint256() & OffsetOrLengthMask);\\n    }\\n\\n    /// @dev Returns the calldata pointer one word after `cdPtr`.\\n    function next(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (CalldataPointer cdPtrNext) {\\n        assembly {\\n            cdPtrNext := add(cdPtr, 32)\\n        }\\n    }\\n\\n    /// @dev Returns the calldata pointer `_offset` bytes after `cdPtr`.\\n    function offset(\\n        CalldataPointer cdPtr,\\n        uint256 _offset\\n    ) internal pure returns (CalldataPointer cdPtrNext) {\\n        assembly {\\n            cdPtrNext := add(cdPtr, _offset)\\n        }\\n    }\\n\\n    /// @dev Copies `size` bytes from calldata starting at `src` to memory at\\n    ///      `dst`.\\n    function copy(\\n        CalldataPointer src,\\n        MemoryPointer dst,\\n        uint256 size\\n    ) internal pure {\\n        assembly {\\n            calldatacopy(dst, src, size)\\n        }\\n    }\\n}\\n\\nlibrary ReturndataPointerLib {\\n    function lt(\\n        ReturndataPointer a,\\n        ReturndataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := lt(a, b)\\n        }\\n    }\\n\\n    function gt(\\n        ReturndataPointer a,\\n        ReturndataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := gt(a, b)\\n        }\\n    }\\n\\n    function eq(\\n        ReturndataPointer a,\\n        ReturndataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := eq(a, b)\\n        }\\n    }\\n\\n    /// @dev Resolves an offset stored at `rdPtr + headOffset` to a returndata\\n    ///      pointer. `rdPtr` must point to some parent object with a dynamic\\n    ///      type's head stored at `rdPtr + headOffset`.\\n    function pptr(\\n        ReturndataPointer rdPtr,\\n        uint256 headOffset\\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\\n        rdPtrChild = rdPtr.offset(\\n            rdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\\n        );\\n    }\\n\\n    /// @dev Resolves an offset stored at `rdPtr` to a returndata pointer.\\n    ///    `rdPtr` must point to some parent object with a dynamic type as its\\n    ///    first member, e.g. `struct { bytes data; }`\\n    function pptr(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\\n        rdPtrChild = rdPtr.offset(rdPtr.readUint256() & OffsetOrLengthMask);\\n    }\\n\\n    /// @dev Returns the returndata pointer one word after `cdPtr`.\\n    function next(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\\n        assembly {\\n            rdPtrNext := add(rdPtr, 32)\\n        }\\n    }\\n\\n    /// @dev Returns the returndata pointer `_offset` bytes after `cdPtr`.\\n    function offset(\\n        ReturndataPointer rdPtr,\\n        uint256 _offset\\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\\n        assembly {\\n            rdPtrNext := add(rdPtr, _offset)\\n        }\\n    }\\n\\n    /// @dev Copies `size` bytes from returndata starting at `src` to memory at\\n    /// `dst`.\\n    function copy(\\n        ReturndataPointer src,\\n        MemoryPointer dst,\\n        uint256 size\\n    ) internal pure {\\n        assembly {\\n            returndatacopy(dst, src, size)\\n        }\\n    }\\n}\\n\\nlibrary MemoryPointerLib {\\n    function copy(\\n        MemoryPointer src,\\n        MemoryPointer dst,\\n        uint256 size\\n    ) internal view {\\n        assembly {\\n            let success := staticcall(\\n                gas(),\\n                IdentityPrecompileAddress,\\n                src,\\n                size,\\n                dst,\\n                size\\n            )\\n            if or(iszero(success), iszero(returndatasize())) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    function lt(\\n        MemoryPointer a,\\n        MemoryPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := lt(a, b)\\n        }\\n    }\\n\\n    function gt(\\n        MemoryPointer a,\\n        MemoryPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := gt(a, b)\\n        }\\n    }\\n\\n    function eq(\\n        MemoryPointer a,\\n        MemoryPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := eq(a, b)\\n        }\\n    }\\n\\n    /// @dev Returns the memory pointer one word after `mPtr`.\\n    function next(\\n        MemoryPointer mPtr\\n    ) internal pure returns (MemoryPointer mPtrNext) {\\n        assembly {\\n            mPtrNext := add(mPtr, 32)\\n        }\\n    }\\n\\n    /// @dev Returns the memory pointer `_offset` bytes after `mPtr`.\\n    function offset(\\n        MemoryPointer mPtr,\\n        uint256 _offset\\n    ) internal pure returns (MemoryPointer mPtrNext) {\\n        assembly {\\n            mPtrNext := add(mPtr, _offset)\\n        }\\n    }\\n\\n    /// @dev Resolves a pointer pointer at `mPtr + headOffset` to a memory\\n    ///    pointer. `mPtr` must point to some parent object with a dynamic\\n    ///    type's pointer stored at `mPtr + headOffset`.\\n    function pptr(\\n        MemoryPointer mPtr,\\n        uint256 headOffset\\n    ) internal pure returns (MemoryPointer mPtrChild) {\\n        mPtrChild = mPtr.offset(headOffset).readMemoryPointer();\\n    }\\n\\n    /// @dev Resolves a pointer pointer stored at `mPtr` to a memory pointer.\\n    ///    `mPtr` must point to some parent object with a dynamic type as its\\n    ///    first member, e.g. `struct { bytes data; }`\\n    function pptr(\\n        MemoryPointer mPtr\\n    ) internal pure returns (MemoryPointer mPtrChild) {\\n        mPtrChild = mPtr.readMemoryPointer();\\n    }\\n}\\n\\nlibrary CalldataReaders {\\n    /// @dev Reads the value at `cdPtr` and applies a mask to return only the\\n    ///    last 4 bytes.\\n    function readMaskedUint256(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint256 value) {\\n        value = cdPtr.readUint256() & OffsetOrLengthMask;\\n    }\\n\\n    /// @dev Reads the bool at `cdPtr` in calldata.\\n    function readBool(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bool value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the address at `cdPtr` in calldata.\\n    function readAddress(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (address value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes1 at `cdPtr` in calldata.\\n    function readBytes1(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes1 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes2 at `cdPtr` in calldata.\\n    function readBytes2(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes2 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes3 at `cdPtr` in calldata.\\n    function readBytes3(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes3 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes4 at `cdPtr` in calldata.\\n    function readBytes4(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes4 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes5 at `cdPtr` in calldata.\\n    function readBytes5(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes5 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes6 at `cdPtr` in calldata.\\n    function readBytes6(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes6 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes7 at `cdPtr` in calldata.\\n    function readBytes7(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes7 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes8 at `cdPtr` in calldata.\\n    function readBytes8(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes8 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes9 at `cdPtr` in calldata.\\n    function readBytes9(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes9 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes10 at `cdPtr` in calldata.\\n    function readBytes10(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes10 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes11 at `cdPtr` in calldata.\\n    function readBytes11(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes11 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes12 at `cdPtr` in calldata.\\n    function readBytes12(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes12 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes13 at `cdPtr` in calldata.\\n    function readBytes13(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes13 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes14 at `cdPtr` in calldata.\\n    function readBytes14(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes14 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes15 at `cdPtr` in calldata.\\n    function readBytes15(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes15 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes16 at `cdPtr` in calldata.\\n    function readBytes16(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes16 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes17 at `cdPtr` in calldata.\\n    function readBytes17(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes17 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes18 at `cdPtr` in calldata.\\n    function readBytes18(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes18 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes19 at `cdPtr` in calldata.\\n    function readBytes19(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes19 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes20 at `cdPtr` in calldata.\\n    function readBytes20(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes20 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes21 at `cdPtr` in calldata.\\n    function readBytes21(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes21 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes22 at `cdPtr` in calldata.\\n    function readBytes22(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes22 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes23 at `cdPtr` in calldata.\\n    function readBytes23(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes23 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes24 at `cdPtr` in calldata.\\n    function readBytes24(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes24 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes25 at `cdPtr` in calldata.\\n    function readBytes25(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes25 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes26 at `cdPtr` in calldata.\\n    function readBytes26(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes26 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes27 at `cdPtr` in calldata.\\n    function readBytes27(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes27 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes28 at `cdPtr` in calldata.\\n    function readBytes28(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes28 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes29 at `cdPtr` in calldata.\\n    function readBytes29(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes29 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes30 at `cdPtr` in calldata.\\n    function readBytes30(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes30 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes31 at `cdPtr` in calldata.\\n    function readBytes31(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes31 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes32 at `cdPtr` in calldata.\\n    function readBytes32(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes32 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint8 at `cdPtr` in calldata.\\n    function readUint8(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint8 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint16 at `cdPtr` in calldata.\\n    function readUint16(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint16 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint24 at `cdPtr` in calldata.\\n    function readUint24(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint24 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint32 at `cdPtr` in calldata.\\n    function readUint32(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint32 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint40 at `cdPtr` in calldata.\\n    function readUint40(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint40 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint48 at `cdPtr` in calldata.\\n    function readUint48(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint48 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint56 at `cdPtr` in calldata.\\n    function readUint56(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint56 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint64 at `cdPtr` in calldata.\\n    function readUint64(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint64 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint72 at `cdPtr` in calldata.\\n    function readUint72(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint72 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint80 at `cdPtr` in calldata.\\n    function readUint80(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint80 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint88 at `cdPtr` in calldata.\\n    function readUint88(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint88 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint96 at `cdPtr` in calldata.\\n    function readUint96(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint96 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint104 at `cdPtr` in calldata.\\n    function readUint104(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint104 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint112 at `cdPtr` in calldata.\\n    function readUint112(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint112 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint120 at `cdPtr` in calldata.\\n    function readUint120(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint120 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint128 at `cdPtr` in calldata.\\n    function readUint128(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint128 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint136 at `cdPtr` in calldata.\\n    function readUint136(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint136 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint144 at `cdPtr` in calldata.\\n    function readUint144(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint144 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint152 at `cdPtr` in calldata.\\n    function readUint152(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint152 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint160 at `cdPtr` in calldata.\\n    function readUint160(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint160 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint168 at `cdPtr` in calldata.\\n    function readUint168(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint168 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint176 at `cdPtr` in calldata.\\n    function readUint176(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint176 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint184 at `cdPtr` in calldata.\\n    function readUint184(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint184 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint192 at `cdPtr` in calldata.\\n    function readUint192(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint192 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint200 at `cdPtr` in calldata.\\n    function readUint200(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint200 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint208 at `cdPtr` in calldata.\\n    function readUint208(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint208 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint216 at `cdPtr` in calldata.\\n    function readUint216(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint216 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint224 at `cdPtr` in calldata.\\n    function readUint224(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint224 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint232 at `cdPtr` in calldata.\\n    function readUint232(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint232 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint240 at `cdPtr` in calldata.\\n    function readUint240(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint240 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint248 at `cdPtr` in calldata.\\n    function readUint248(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint248 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint256 at `cdPtr` in calldata.\\n    function readUint256(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int8 at `cdPtr` in calldata.\\n    function readInt8(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int8 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int16 at `cdPtr` in calldata.\\n    function readInt16(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int16 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int24 at `cdPtr` in calldata.\\n    function readInt24(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int24 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int32 at `cdPtr` in calldata.\\n    function readInt32(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int32 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int40 at `cdPtr` in calldata.\\n    function readInt40(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int40 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int48 at `cdPtr` in calldata.\\n    function readInt48(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int48 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int56 at `cdPtr` in calldata.\\n    function readInt56(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int56 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int64 at `cdPtr` in calldata.\\n    function readInt64(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int64 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int72 at `cdPtr` in calldata.\\n    function readInt72(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int72 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int80 at `cdPtr` in calldata.\\n    function readInt80(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int80 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int88 at `cdPtr` in calldata.\\n    function readInt88(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int88 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int96 at `cdPtr` in calldata.\\n    function readInt96(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int96 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int104 at `cdPtr` in calldata.\\n    function readInt104(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int104 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int112 at `cdPtr` in calldata.\\n    function readInt112(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int112 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int120 at `cdPtr` in calldata.\\n    function readInt120(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int120 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int128 at `cdPtr` in calldata.\\n    function readInt128(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int128 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int136 at `cdPtr` in calldata.\\n    function readInt136(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int136 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int144 at `cdPtr` in calldata.\\n    function readInt144(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int144 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int152 at `cdPtr` in calldata.\\n    function readInt152(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int152 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int160 at `cdPtr` in calldata.\\n    function readInt160(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int160 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int168 at `cdPtr` in calldata.\\n    function readInt168(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int168 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int176 at `cdPtr` in calldata.\\n    function readInt176(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int176 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int184 at `cdPtr` in calldata.\\n    function readInt184(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int184 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int192 at `cdPtr` in calldata.\\n    function readInt192(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int192 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int200 at `cdPtr` in calldata.\\n    function readInt200(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int200 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int208 at `cdPtr` in calldata.\\n    function readInt208(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int208 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int216 at `cdPtr` in calldata.\\n    function readInt216(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int216 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int224 at `cdPtr` in calldata.\\n    function readInt224(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int224 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int232 at `cdPtr` in calldata.\\n    function readInt232(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int232 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int240 at `cdPtr` in calldata.\\n    function readInt240(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int240 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int248 at `cdPtr` in calldata.\\n    function readInt248(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int248 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int256 at `cdPtr` in calldata.\\n    function readInt256(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int256 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n}\\n\\nlibrary ReturndataReaders {\\n    /// @dev Reads value at `rdPtr` & applies a mask to return only last 4 bytes\\n    function readMaskedUint256(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint256 value) {\\n        value = rdPtr.readUint256() & OffsetOrLengthMask;\\n    }\\n\\n    /// @dev Reads the bool at `rdPtr` in returndata.\\n    function readBool(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bool value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the address at `rdPtr` in returndata.\\n    function readAddress(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (address value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes1 at `rdPtr` in returndata.\\n    function readBytes1(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes1 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes2 at `rdPtr` in returndata.\\n    function readBytes2(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes2 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes3 at `rdPtr` in returndata.\\n    function readBytes3(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes3 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes4 at `rdPtr` in returndata.\\n    function readBytes4(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes4 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes5 at `rdPtr` in returndata.\\n    function readBytes5(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes5 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes6 at `rdPtr` in returndata.\\n    function readBytes6(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes6 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes7 at `rdPtr` in returndata.\\n    function readBytes7(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes7 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes8 at `rdPtr` in returndata.\\n    function readBytes8(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes8 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes9 at `rdPtr` in returndata.\\n    function readBytes9(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes9 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes10 at `rdPtr` in returndata.\\n    function readBytes10(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes10 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes11 at `rdPtr` in returndata.\\n    function readBytes11(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes11 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes12 at `rdPtr` in returndata.\\n    function readBytes12(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes12 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes13 at `rdPtr` in returndata.\\n    function readBytes13(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes13 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes14 at `rdPtr` in returndata.\\n    function readBytes14(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes14 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes15 at `rdPtr` in returndata.\\n    function readBytes15(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes15 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes16 at `rdPtr` in returndata.\\n    function readBytes16(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes16 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes17 at `rdPtr` in returndata.\\n    function readBytes17(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes17 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes18 at `rdPtr` in returndata.\\n    function readBytes18(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes18 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes19 at `rdPtr` in returndata.\\n    function readBytes19(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes19 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes20 at `rdPtr` in returndata.\\n    function readBytes20(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes20 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes21 at `rdPtr` in returndata.\\n    function readBytes21(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes21 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes22 at `rdPtr` in returndata.\\n    function readBytes22(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes22 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes23 at `rdPtr` in returndata.\\n    function readBytes23(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes23 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes24 at `rdPtr` in returndata.\\n    function readBytes24(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes24 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes25 at `rdPtr` in returndata.\\n    function readBytes25(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes25 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes26 at `rdPtr` in returndata.\\n    function readBytes26(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes26 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes27 at `rdPtr` in returndata.\\n    function readBytes27(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes27 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes28 at `rdPtr` in returndata.\\n    function readBytes28(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes28 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes29 at `rdPtr` in returndata.\\n    function readBytes29(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes29 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes30 at `rdPtr` in returndata.\\n    function readBytes30(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes30 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes31 at `rdPtr` in returndata.\\n    function readBytes31(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes31 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes32 at `rdPtr` in returndata.\\n    function readBytes32(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes32 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint8 at `rdPtr` in returndata.\\n    function readUint8(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint8 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint16 at `rdPtr` in returndata.\\n    function readUint16(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint16 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint24 at `rdPtr` in returndata.\\n    function readUint24(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint24 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint32 at `rdPtr` in returndata.\\n    function readUint32(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint32 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint40 at `rdPtr` in returndata.\\n    function readUint40(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint40 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint48 at `rdPtr` in returndata.\\n    function readUint48(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint48 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint56 at `rdPtr` in returndata.\\n    function readUint56(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint56 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint64 at `rdPtr` in returndata.\\n    function readUint64(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint64 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint72 at `rdPtr` in returndata.\\n    function readUint72(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint72 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint80 at `rdPtr` in returndata.\\n    function readUint80(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint80 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint88 at `rdPtr` in returndata.\\n    function readUint88(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint88 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint96 at `rdPtr` in returndata.\\n    function readUint96(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint96 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint104 at `rdPtr` in returndata.\\n    function readUint104(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint104 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint112 at `rdPtr` in returndata.\\n    function readUint112(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint112 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint120 at `rdPtr` in returndata.\\n    function readUint120(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint120 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint128 at `rdPtr` in returndata.\\n    function readUint128(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint128 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint136 at `rdPtr` in returndata.\\n    function readUint136(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint136 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint144 at `rdPtr` in returndata.\\n    function readUint144(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint144 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint152 at `rdPtr` in returndata.\\n    function readUint152(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint152 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint160 at `rdPtr` in returndata.\\n    function readUint160(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint160 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint168 at `rdPtr` in returndata.\\n    function readUint168(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint168 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint176 at `rdPtr` in returndata.\\n    function readUint176(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint176 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint184 at `rdPtr` in returndata.\\n    function readUint184(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint184 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint192 at `rdPtr` in returndata.\\n    function readUint192(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint192 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint200 at `rdPtr` in returndata.\\n    function readUint200(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint200 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint208 at `rdPtr` in returndata.\\n    function readUint208(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint208 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint216 at `rdPtr` in returndata.\\n    function readUint216(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint216 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint224 at `rdPtr` in returndata.\\n    function readUint224(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint224 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint232 at `rdPtr` in returndata.\\n    function readUint232(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint232 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint240 at `rdPtr` in returndata.\\n    function readUint240(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint240 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint248 at `rdPtr` in returndata.\\n    function readUint248(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint248 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint256 at `rdPtr` in returndata.\\n    function readUint256(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int8 at `rdPtr` in returndata.\\n    function readInt8(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int8 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int16 at `rdPtr` in returndata.\\n    function readInt16(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int16 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int24 at `rdPtr` in returndata.\\n    function readInt24(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int24 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int32 at `rdPtr` in returndata.\\n    function readInt32(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int32 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int40 at `rdPtr` in returndata.\\n    function readInt40(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int40 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int48 at `rdPtr` in returndata.\\n    function readInt48(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int48 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int56 at `rdPtr` in returndata.\\n    function readInt56(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int56 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int64 at `rdPtr` in returndata.\\n    function readInt64(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int64 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int72 at `rdPtr` in returndata.\\n    function readInt72(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int72 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int80 at `rdPtr` in returndata.\\n    function readInt80(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int80 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int88 at `rdPtr` in returndata.\\n    function readInt88(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int88 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int96 at `rdPtr` in returndata.\\n    function readInt96(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int96 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int104 at `rdPtr` in returndata.\\n    function readInt104(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int104 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int112 at `rdPtr` in returndata.\\n    function readInt112(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int112 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int120 at `rdPtr` in returndata.\\n    function readInt120(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int120 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int128 at `rdPtr` in returndata.\\n    function readInt128(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int128 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int136 at `rdPtr` in returndata.\\n    function readInt136(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int136 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int144 at `rdPtr` in returndata.\\n    function readInt144(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int144 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int152 at `rdPtr` in returndata.\\n    function readInt152(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int152 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int160 at `rdPtr` in returndata.\\n    function readInt160(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int160 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int168 at `rdPtr` in returndata.\\n    function readInt168(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int168 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int176 at `rdPtr` in returndata.\\n    function readInt176(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int176 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int184 at `rdPtr` in returndata.\\n    function readInt184(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int184 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int192 at `rdPtr` in returndata.\\n    function readInt192(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int192 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int200 at `rdPtr` in returndata.\\n    function readInt200(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int200 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int208 at `rdPtr` in returndata.\\n    function readInt208(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int208 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int216 at `rdPtr` in returndata.\\n    function readInt216(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int216 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int224 at `rdPtr` in returndata.\\n    function readInt224(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int224 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int232 at `rdPtr` in returndata.\\n    function readInt232(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int232 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int240 at `rdPtr` in returndata.\\n    function readInt240(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int240 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int248 at `rdPtr` in returndata.\\n    function readInt248(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int248 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int256 at `rdPtr` in returndata.\\n    function readInt256(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int256 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, 0x20)\\n            value := mload(0)\\n        }\\n    }\\n}\\n\\nlibrary MemoryReaders {\\n    /// @dev Reads the memory pointer at `mPtr` in memory.\\n    function readMemoryPointer(\\n        MemoryPointer mPtr\\n    ) internal pure returns (MemoryPointer value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads value at `mPtr` & applies a mask to return only last 4 bytes\\n    function readMaskedUint256(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint256 value) {\\n        value = mPtr.readUint256() & OffsetOrLengthMask;\\n    }\\n\\n    /// @dev Reads the bool at `mPtr` in memory.\\n    function readBool(MemoryPointer mPtr) internal pure returns (bool value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the address at `mPtr` in memory.\\n    function readAddress(\\n        MemoryPointer mPtr\\n    ) internal pure returns (address value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes1 at `mPtr` in memory.\\n    function readBytes1(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes1 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes2 at `mPtr` in memory.\\n    function readBytes2(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes2 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes3 at `mPtr` in memory.\\n    function readBytes3(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes3 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes4 at `mPtr` in memory.\\n    function readBytes4(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes4 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes5 at `mPtr` in memory.\\n    function readBytes5(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes5 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes6 at `mPtr` in memory.\\n    function readBytes6(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes6 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes7 at `mPtr` in memory.\\n    function readBytes7(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes7 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes8 at `mPtr` in memory.\\n    function readBytes8(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes8 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes9 at `mPtr` in memory.\\n    function readBytes9(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes9 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes10 at `mPtr` in memory.\\n    function readBytes10(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes10 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes11 at `mPtr` in memory.\\n    function readBytes11(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes11 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes12 at `mPtr` in memory.\\n    function readBytes12(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes12 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes13 at `mPtr` in memory.\\n    function readBytes13(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes13 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes14 at `mPtr` in memory.\\n    function readBytes14(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes14 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes15 at `mPtr` in memory.\\n    function readBytes15(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes15 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes16 at `mPtr` in memory.\\n    function readBytes16(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes16 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes17 at `mPtr` in memory.\\n    function readBytes17(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes17 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes18 at `mPtr` in memory.\\n    function readBytes18(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes18 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes19 at `mPtr` in memory.\\n    function readBytes19(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes19 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes20 at `mPtr` in memory.\\n    function readBytes20(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes20 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes21 at `mPtr` in memory.\\n    function readBytes21(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes21 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes22 at `mPtr` in memory.\\n    function readBytes22(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes22 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes23 at `mPtr` in memory.\\n    function readBytes23(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes23 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes24 at `mPtr` in memory.\\n    function readBytes24(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes24 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes25 at `mPtr` in memory.\\n    function readBytes25(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes25 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes26 at `mPtr` in memory.\\n    function readBytes26(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes26 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes27 at `mPtr` in memory.\\n    function readBytes27(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes27 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes28 at `mPtr` in memory.\\n    function readBytes28(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes28 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes29 at `mPtr` in memory.\\n    function readBytes29(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes29 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes30 at `mPtr` in memory.\\n    function readBytes30(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes30 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes31 at `mPtr` in memory.\\n    function readBytes31(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes31 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes32 at `mPtr` in memory.\\n    function readBytes32(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes32 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint8 at `mPtr` in memory.\\n    function readUint8(MemoryPointer mPtr) internal pure returns (uint8 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint16 at `mPtr` in memory.\\n    function readUint16(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint16 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint24 at `mPtr` in memory.\\n    function readUint24(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint24 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint32 at `mPtr` in memory.\\n    function readUint32(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint32 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint40 at `mPtr` in memory.\\n    function readUint40(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint40 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint48 at `mPtr` in memory.\\n    function readUint48(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint48 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint56 at `mPtr` in memory.\\n    function readUint56(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint56 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint64 at `mPtr` in memory.\\n    function readUint64(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint64 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint72 at `mPtr` in memory.\\n    function readUint72(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint72 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint80 at `mPtr` in memory.\\n    function readUint80(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint80 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint88 at `mPtr` in memory.\\n    function readUint88(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint88 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint96 at `mPtr` in memory.\\n    function readUint96(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint96 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint104 at `mPtr` in memory.\\n    function readUint104(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint104 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint112 at `mPtr` in memory.\\n    function readUint112(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint112 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint120 at `mPtr` in memory.\\n    function readUint120(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint120 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint128 at `mPtr` in memory.\\n    function readUint128(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint128 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint136 at `mPtr` in memory.\\n    function readUint136(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint136 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint144 at `mPtr` in memory.\\n    function readUint144(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint144 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint152 at `mPtr` in memory.\\n    function readUint152(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint152 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint160 at `mPtr` in memory.\\n    function readUint160(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint160 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint168 at `mPtr` in memory.\\n    function readUint168(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint168 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint176 at `mPtr` in memory.\\n    function readUint176(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint176 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint184 at `mPtr` in memory.\\n    function readUint184(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint184 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint192 at `mPtr` in memory.\\n    function readUint192(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint192 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint200 at `mPtr` in memory.\\n    function readUint200(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint200 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint208 at `mPtr` in memory.\\n    function readUint208(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint208 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint216 at `mPtr` in memory.\\n    function readUint216(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint216 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint224 at `mPtr` in memory.\\n    function readUint224(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint224 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint232 at `mPtr` in memory.\\n    function readUint232(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint232 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint240 at `mPtr` in memory.\\n    function readUint240(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint240 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint248 at `mPtr` in memory.\\n    function readUint248(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint248 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint256 at `mPtr` in memory.\\n    function readUint256(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int8 at `mPtr` in memory.\\n    function readInt8(MemoryPointer mPtr) internal pure returns (int8 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int16 at `mPtr` in memory.\\n    function readInt16(MemoryPointer mPtr) internal pure returns (int16 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int24 at `mPtr` in memory.\\n    function readInt24(MemoryPointer mPtr) internal pure returns (int24 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int32 at `mPtr` in memory.\\n    function readInt32(MemoryPointer mPtr) internal pure returns (int32 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int40 at `mPtr` in memory.\\n    function readInt40(MemoryPointer mPtr) internal pure returns (int40 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int48 at `mPtr` in memory.\\n    function readInt48(MemoryPointer mPtr) internal pure returns (int48 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int56 at `mPtr` in memory.\\n    function readInt56(MemoryPointer mPtr) internal pure returns (int56 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int64 at `mPtr` in memory.\\n    function readInt64(MemoryPointer mPtr) internal pure returns (int64 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int72 at `mPtr` in memory.\\n    function readInt72(MemoryPointer mPtr) internal pure returns (int72 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int80 at `mPtr` in memory.\\n    function readInt80(MemoryPointer mPtr) internal pure returns (int80 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int88 at `mPtr` in memory.\\n    function readInt88(MemoryPointer mPtr) internal pure returns (int88 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int96 at `mPtr` in memory.\\n    function readInt96(MemoryPointer mPtr) internal pure returns (int96 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int104 at `mPtr` in memory.\\n    function readInt104(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int104 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int112 at `mPtr` in memory.\\n    function readInt112(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int112 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int120 at `mPtr` in memory.\\n    function readInt120(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int120 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int128 at `mPtr` in memory.\\n    function readInt128(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int128 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int136 at `mPtr` in memory.\\n    function readInt136(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int136 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int144 at `mPtr` in memory.\\n    function readInt144(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int144 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int152 at `mPtr` in memory.\\n    function readInt152(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int152 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int160 at `mPtr` in memory.\\n    function readInt160(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int160 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int168 at `mPtr` in memory.\\n    function readInt168(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int168 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int176 at `mPtr` in memory.\\n    function readInt176(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int176 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int184 at `mPtr` in memory.\\n    function readInt184(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int184 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int192 at `mPtr` in memory.\\n    function readInt192(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int192 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int200 at `mPtr` in memory.\\n    function readInt200(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int200 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int208 at `mPtr` in memory.\\n    function readInt208(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int208 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int216 at `mPtr` in memory.\\n    function readInt216(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int216 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int224 at `mPtr` in memory.\\n    function readInt224(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int224 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int232 at `mPtr` in memory.\\n    function readInt232(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int232 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int240 at `mPtr` in memory.\\n    function readInt240(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int240 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int248 at `mPtr` in memory.\\n    function readInt248(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int248 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int256 at `mPtr` in memory.\\n    function readInt256(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int256 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n}\\n\\nlibrary MemoryWriters {\\n    /// @dev Writes `valuePtr` to memory at `mPtr`.\\n    function write(MemoryPointer mPtr, MemoryPointer valuePtr) internal pure {\\n        assembly {\\n            mstore(mPtr, valuePtr)\\n        }\\n    }\\n\\n    /// @dev Writes a boolean `value` to `mPtr` in memory.\\n    function write(MemoryPointer mPtr, bool value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n\\n    /// @dev Writes an address `value` to `mPtr` in memory.\\n    function write(MemoryPointer mPtr, address value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n\\n    /// @dev Writes a bytes32 `value` to `mPtr` in memory.\\n    /// Separate name to disambiguate literal write parameters.\\n    function writeBytes32(MemoryPointer mPtr, bytes32 value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n\\n    /// @dev Writes a uint256 `value` to `mPtr` in memory.\\n    function write(MemoryPointer mPtr, uint256 value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n\\n    /// @dev Writes an int256 `value` to `mPtr` in memory.\\n    /// Separate name to disambiguate literal write parameters.\\n    function writeInt(MemoryPointer mPtr, int256 value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ConsiderationConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/*\\n * -------------------------- Disambiguation & Other Notes ---------------------\\n *    - The term \\\"head\\\" is used as it is in the documentation for ABI encoding,\\n *      but only in reference to dynamic types, i.e. it always refers to the\\n *      offset or pointer to the body of a dynamic type. In calldata, the head\\n *      is always an offset (relative to the parent object), while in memory,\\n *      the head is always the pointer to the body. More information found here:\\n *      https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#argument-encoding\\n *        - Note that the length of an array is separate from and precedes the\\n *          head of the array.\\n *\\n *    - The term \\\"body\\\" is used in place of the term \\\"head\\\" used in the ABI\\n *      documentation. It refers to the start of the data for a dynamic type,\\n *      e.g. the first word of a struct or the first word of the first element\\n *      in an array.\\n *\\n *    - The term \\\"pointer\\\" is used to describe the absolute position of a value\\n *      and never an offset relative to another value.\\n *        - The suffix \\\"_ptr\\\" refers to a memory pointer.\\n *        - The suffix \\\"_cdPtr\\\" refers to a calldata pointer.\\n *\\n *    - The term \\\"offset\\\" is used to describe the position of a value relative\\n *      to some parent value. For example, OrderParameters_conduit_offset is the\\n *      offset to the \\\"conduit\\\" value in the OrderParameters struct relative to\\n *      the start of the body.\\n *        - Note: Offsets are used to derive pointers.\\n *\\n *    - Some structs have pointers defined for all of their fields in this file.\\n *      Lines which are commented out are fields that are not used in the\\n *      codebase but have been left in for readability.\\n */\\n\\n// Declare constants for name, version, and reentrancy sentinel values.\\n\\n// Name is right padded, so it touches the length which is left padded. This\\n// enables writing both values at once. Length goes at byte 95 in memory, and\\n// name fills bytes 96-109, so both values can be written left-padded to 77.\\nuint256 constant NameLengthPtr = 77;\\nuint256 constant NameWithLength = 0x0d436F6E73696465726174696F6E;\\n\\nuint256 constant information_version_offset = 0;\\nuint256 constant information_version_cd_offset = 0x60;\\nuint256 constant information_domainSeparator_offset = 0x20;\\nuint256 constant information_conduitController_offset = 0x40;\\nuint256 constant information_versionLengthPtr = 0x63;\\nuint256 constant information_versionWithLength = 0x03312e32; // 1.2\\nuint256 constant information_length = 0xa0;\\n\\nuint256 constant _NOT_ENTERED = 1;\\nuint256 constant _ENTERED = 2;\\nuint256 constant _ENTERED_AND_ACCEPTING_NATIVE_TOKENS = 3;\\n\\nuint256 constant Offset_fulfillAdvancedOrder_criteriaResolvers = 0x20;\\n\\nuint256 constant Offset_fulfillAvailableOrders_offerFulfillments = 0x20;\\nuint256 constant Offset_fulfillAvailableOrders_considerationFulfillments = 0x40;\\n\\nuint256 constant Offset_fulfillAvailableAdvancedOrders_criteriaResolvers = 0x20;\\nuint256 constant Offset_fulfillAvailableAdvancedOrders_offerFulfillments = 0x40;\\nuint256 constant Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts = (\\n    0x60\\n);\\n\\nuint256 constant Offset_matchOrders_fulfillments = 0x20;\\n\\nuint256 constant Offset_matchAdvancedOrders_criteriaResolvers = 0x20;\\nuint256 constant Offset_matchAdvancedOrders_fulfillments = 0x40;\\n\\n// Common Offsets\\n// Offsets for identically positioned fields shared by:\\n// OfferItem, ConsiderationItem, SpentItem, ReceivedItem\\n\\nuint256 constant Selector_length = 4;\\n\\nuint256 constant Common_token_offset = 0x20;\\nuint256 constant Common_identifier_offset = 0x40;\\nuint256 constant Common_amount_offset = 0x60;\\nuint256 constant Common_endAmount_offset = 0x80;\\n\\nuint256 constant SpentItem_size = 0x80;\\nuint256 constant SpentItem_size_shift = 7;\\n\\nuint256 constant OfferItem_size = 0xa0;\\nuint256 constant OfferItem_size_with_length = 0xc0;\\n\\nuint256 constant ReceivedItem_size = 0xa0;\\nuint256 constant ReceivedItem_amount_offset = 0x60;\\nuint256 constant ReceivedItem_recipient_offset = 0x80;\\n\\nuint256 constant ReceivedItem_CommonParams_size = 0x60;\\n\\nuint256 constant ConsiderationItem_size = 0xc0;\\nuint256 constant ConsiderationItem_size_with_length = 0xe0;\\n\\nuint256 constant ConsiderationItem_recipient_offset = 0xa0;\\n// Store the same constant in an abbreviated format for a line length fix.\\nuint256 constant ConsiderItem_recipient_offset = 0xa0;\\n\\nuint256 constant Execution_offerer_offset = 0x20;\\nuint256 constant Execution_conduit_offset = 0x40;\\n\\nuint256 constant Panic_arithmetic = 0x11;\\nuint256 constant Panic_resource = 0x41;\\n\\nuint256 constant OrderParameters_offerer_offset = 0x00;\\nuint256 constant OrderParameters_zone_offset = 0x20;\\nuint256 constant OrderParameters_offer_head_offset = 0x40;\\nuint256 constant OrderParameters_consideration_head_offset = 0x60;\\nuint256 constant OrderParameters_orderType_offset = 0x80;\\nuint256 constant OrderParameters_startTime_offset = 0xa0;\\nuint256 constant OrderParameters_endTime_offset = 0xc0;\\nuint256 constant OrderParameters_zoneHash_offset = 0xe0;\\nuint256 constant OrderParameters_salt_offset = 0x100;\\nuint256 constant OrderParameters_conduit_offset = 0x120;\\nuint256 constant OrderParameters_counter_offset = 0x140;\\n\\nuint256 constant Fulfillment_itemIndex_offset = 0x20;\\n\\nuint256 constant AdvancedOrder_head_size = 0xa0;\\nuint256 constant AdvancedOrder_numerator_offset = 0x20;\\nuint256 constant AdvancedOrder_denominator_offset = 0x40;\\nuint256 constant AdvancedOrder_signature_offset = 0x60;\\nuint256 constant AdvancedOrder_extraData_offset = 0x80;\\n\\nuint256 constant OrderStatus_ValidatedAndNotCancelled = 1;\\nuint256 constant OrderStatus_filledNumerator_offset = 0x10;\\nuint256 constant OrderStatus_filledDenominator_offset = 0x88;\\n\\nuint256 constant AlmostOneWord = 0x1f;\\nuint256 constant OneWord = 0x20;\\nuint256 constant TwoWords = 0x40;\\nuint256 constant ThreeWords = 0x60;\\nuint256 constant FourWords = 0x80;\\nuint256 constant FiveWords = 0xa0;\\n\\nuint256 constant OneWordShift = 5;\\nuint256 constant TwoWordsShift = 6;\\n\\nuint256 constant AlmostTwoWords = 0x3f;\\nuint256 constant OnlyFullWordMask = 0xffffffe0;\\n\\nuint256 constant FreeMemoryPointerSlot = 0x40;\\nuint256 constant ZeroSlot = 0x60;\\nuint256 constant DefaultFreeMemoryPointer = 0x80;\\n\\nuint256 constant Slot0x80 = 0x80;\\nuint256 constant Slot0xA0 = 0xa0;\\n\\nuint256 constant BasicOrder_endAmount_cdPtr = 0x104;\\nuint256 constant BasicOrder_common_params_size = 0xa0;\\nuint256 constant BasicOrder_considerationHashesArray_ptr = 0x160;\\n\\nuint256 constant BasicOrder_receivedItemByteMap = (\\n    0x0000010102030000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant BasicOrder_offeredItemByteMap = (\\n    0x0203020301010000000000000000000000000000000000000000000000000000\\n);\\n\\nbytes32 constant OrdersMatchedTopic0 = 0x4b9f2d36e1b4c93de62cc077b00b1a91d84b6c31b4a14e012718dcca230689e7;\\n\\nuint256 constant EIP712_Order_size = 0x180;\\nuint256 constant EIP712_OfferItem_size = 0xc0;\\nuint256 constant EIP712_ConsiderationItem_size = 0xe0;\\nuint256 constant AdditionalRecipient_size = 0x40;\\nuint256 constant AdditionalRecipient_size_shift = 6;\\n\\nuint256 constant EIP712_DomainSeparator_offset = 0x02;\\nuint256 constant EIP712_OrderHash_offset = 0x22;\\nuint256 constant EIP712_DigestPayload_size = 0x42;\\n\\nuint256 constant EIP712_domainData_nameHash_offset = 0x20;\\nuint256 constant EIP712_domainData_versionHash_offset = 0x40;\\nuint256 constant EIP712_domainData_chainId_offset = 0x60;\\nuint256 constant EIP712_domainData_verifyingContract_offset = 0x80;\\nuint256 constant EIP712_domainData_size = 0xa0;\\n\\n// Minimum BulkOrder proof size: 64 bytes for signature + 3 for key + 32 for 1\\n// sibling. Maximum BulkOrder proof size: 65 bytes for signature + 3 for key +\\n// 768 for 24 siblings.\\n\\nuint256 constant BulkOrderProof_minSize = 0x63;\\nuint256 constant BulkOrderProof_rangeSize = 0x2e2;\\nuint256 constant BulkOrderProof_lengthAdjustmentBeforeMask = 0x1d;\\nuint256 constant BulkOrderProof_lengthRangeAfterMask = 0x2;\\nuint256 constant BulkOrderProof_keyShift = 0xe8;\\nuint256 constant BulkOrderProof_keySize = 0x3;\\n\\nuint256 constant receivedItemsHash_ptr = 0x60;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  data for OrderFulfilled\\n *\\n *   event OrderFulfilled(\\n *     bytes32 orderHash,\\n *     address indexed offerer,\\n *     address indexed zone,\\n *     address fulfiller,\\n *     SpentItem[] offer,\\n *       > (itemType, token, id, amount)\\n *     ReceivedItem[] consideration\\n *       > (itemType, token, id, amount, recipient)\\n *   )\\n *\\n *  - 0x00: orderHash\\n *  - 0x20: fulfiller\\n *  - 0x40: offer offset (0x80)\\n *  - 0x60: consideration offset (0x120)\\n *  - 0x80: offer.length (1)\\n *  - 0xa0: offerItemType\\n *  - 0xc0: offerToken\\n *  - 0xe0: offerIdentifier\\n *  - 0x100: offerAmount\\n *  - 0x120: consideration.length (1 + additionalRecipients.length)\\n *  - 0x140: considerationItemType\\n *  - 0x160: considerationToken\\n *  - 0x180: considerationIdentifier\\n *  - 0x1a0: considerationAmount\\n *  - 0x1c0: considerationRecipient\\n *  - ...\\n */\\n\\n// Minimum length of the OrderFulfilled event data.\\n// Must be added to the size of the ReceivedItem array for additionalRecipients\\n// (0xa0 * additionalRecipients.length) to calculate full size of the buffer.\\nuint256 constant OrderFulfilled_baseSize = 0x1e0;\\nuint256 constant OrderFulfilled_selector = (\\n    0x9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31\\n);\\n\\n// Minimum offset in memory to OrderFulfilled event data.\\n// Must be added to the size of the EIP712 hash array for additionalRecipients\\n// (32 * additionalRecipients.length) to calculate the pointer to event data.\\nuint256 constant OrderFulfilled_baseOffset = 0x180;\\nuint256 constant OrderFulfilled_consideration_length_baseOffset = 0x2a0;\\nuint256 constant OrderFulfilled_offer_length_baseOffset = 0x200;\\n\\n// Related constants used for restricted order checks on basic orders.\\n\\naddress constant IdentityPrecompile = address(4);\\nuint256 constant OrderFulfilled_baseDataSize = 0x160;\\nuint256 constant ValidateOrder_offerDataOffset = 0x184;\\n\\nuint256 constant RatifyOrder_offerDataOffset = 0xc4;\\n\\n// uint256 constant OrderFulfilled_orderHash_offset = 0x00;\\nuint256 constant OrderFulfilled_fulfiller_offset = 0x20;\\nuint256 constant OrderFulfilled_offer_head_offset = 0x40;\\nuint256 constant OrderFulfilled_offer_body_offset = 0x80;\\nuint256 constant OrderFulfilled_consideration_head_offset = 0x60;\\nuint256 constant OrderFulfilled_consideration_body_offset = 0x120;\\n\\n// BasicOrderParameters\\nuint256 constant BasicOrder_parameters_cdPtr = 0x04;\\nuint256 constant BasicOrder_considerationToken_cdPtr = 0x24;\\n// uint256 constant BasicOrder_considerationIdentifier_cdPtr = 0x44;\\nuint256 constant BasicOrder_considerationAmount_cdPtr = 0x64;\\nuint256 constant BasicOrder_offerer_cdPtr = 0x84;\\nuint256 constant BasicOrder_zone_cdPtr = 0xa4;\\nuint256 constant BasicOrder_offerToken_cdPtr = 0xc4;\\n// uint256 constant BasicOrder_offerIdentifier_cdPtr = 0xe4;\\nuint256 constant BasicOrder_offerAmount_cdPtr = 0x104;\\nuint256 constant BasicOrder_basicOrderType_cdPtr = 0x124;\\nuint256 constant BasicOrder_startTime_cdPtr = 0x144;\\n// uint256 constant BasicOrder_endTime_cdPtr = 0x164;\\n// uint256 constant BasicOrder_zoneHash_cdPtr = 0x184;\\n// uint256 constant BasicOrder_salt_cdPtr = 0x1a4;\\nuint256 constant BasicOrder_offererConduit_cdPtr = 0x1c4;\\nuint256 constant BasicOrder_fulfillerConduit_cdPtr = 0x1e4;\\nuint256 constant BasicOrder_totalOriginalAdditionalRecipients_cdPtr = 0x204;\\nuint256 constant BasicOrder_additionalRecipients_head_cdPtr = 0x224;\\nuint256 constant BasicOrder_signature_cdPtr = 0x244;\\nuint256 constant BasicOrder_additionalRecipients_length_cdPtr = 0x264;\\nuint256 constant BasicOrder_additionalRecipients_data_cdPtr = 0x284;\\n\\nuint256 constant BasicOrder_parameters_ptr = 0x20;\\n\\nuint256 constant BasicOrder_basicOrderType_range = 0x18; // 24 values\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  EIP712 data for ConsiderationItem\\n *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\\n *   - 0xa0: itemType\\n *   - 0xc0: token\\n *   - 0xe0: identifier\\n *   - 0x100: startAmount\\n *   - 0x120: endAmount\\n *   - 0x140: recipient\\n */\\nuint256 constant BasicOrder_considerationItem_typeHash_ptr = 0x80; // memoryPtr\\nuint256 constant BasicOrder_considerationItem_itemType_ptr = 0xa0;\\nuint256 constant BasicOrder_considerationItem_token_ptr = 0xc0;\\nuint256 constant BasicOrder_considerationItem_identifier_ptr = 0xe0;\\nuint256 constant BasicOrder_considerationItem_startAmount_ptr = 0x100;\\nuint256 constant BasicOrder_considerationItem_endAmount_ptr = 0x120;\\n// uint256 constant BasicOrder_considerationItem_recipient_ptr = 0x140;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  EIP712 data for OfferItem\\n *   - 0x80:  OfferItem EIP-712 typehash (constant)\\n *   - 0xa0:  itemType\\n *   - 0xc0:  token\\n *   - 0xe0:  identifier (reused for offeredItemsHash)\\n *   - 0x100: startAmount\\n *   - 0x120: endAmount\\n */\\nuint256 constant BasicOrder_offerItem_typeHash_ptr = DefaultFreeMemoryPointer;\\nuint256 constant BasicOrder_offerItem_itemType_ptr = 0xa0;\\nuint256 constant BasicOrder_offerItem_token_ptr = 0xc0;\\n// uint256 constant BasicOrder_offerItem_identifier_ptr = 0xe0;\\n// uint256 constant BasicOrder_offerItem_startAmount_ptr = 0x100;\\nuint256 constant BasicOrder_offerItem_endAmount_ptr = 0x120;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  EIP712 data for Order\\n *   - 0x80:   Order EIP-712 typehash (constant)\\n *   - 0xa0:   orderParameters.offerer\\n *   - 0xc0:   orderParameters.zone\\n *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\\n *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\\n *   - 0x120:  orderType\\n *   - 0x140:  startTime\\n *   - 0x160:  endTime\\n *   - 0x180:  zoneHash\\n *   - 0x1a0:  salt\\n *   - 0x1c0:  conduit\\n *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\\n */\\nuint256 constant BasicOrder_order_typeHash_ptr = 0x80;\\nuint256 constant BasicOrder_order_offerer_ptr = 0xa0;\\n// uint256 constant BasicOrder_order_zone_ptr = 0xc0;\\nuint256 constant BasicOrder_order_offerHashes_ptr = 0xe0;\\nuint256 constant BasicOrder_order_considerationHashes_ptr = 0x100;\\nuint256 constant BasicOrder_order_orderType_ptr = 0x120;\\nuint256 constant BasicOrder_order_startTime_ptr = 0x140;\\n// uint256 constant BasicOrder_order_endTime_ptr = 0x160;\\n// uint256 constant BasicOrder_order_zoneHash_ptr = 0x180;\\n// uint256 constant BasicOrder_order_salt_ptr = 0x1a0;\\n// uint256 constant BasicOrder_order_conduitKey_ptr = 0x1c0;\\nuint256 constant BasicOrder_order_counter_ptr = 0x1e0;\\nuint256 constant BasicOrder_additionalRecipients_head_ptr = 0x240;\\nuint256 constant BasicOrder_signature_ptr = 0x260;\\nuint256 constant BasicOrder_startTimeThroughZoneHash_size = 0x60;\\n\\nuint256 constant ContractOrder_orderHash_offerer_shift = 0x60;\\n\\nuint256 constant Counter_blockhash_shift = 0x80;\\n\\n// Signature-related\\nbytes32 constant EIP2098_allButHighestBitMask = (\\n    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n);\\nbytes32 constant ECDSA_twentySeventhAndTwentyEighthBytesSet = (\\n    0x0000000000000000000000000000000000000000000000000000000101000000\\n);\\nuint256 constant ECDSA_MaxLength = 65;\\nuint256 constant ECDSA_signature_s_offset = 0x40;\\nuint256 constant ECDSA_signature_v_offset = 0x60;\\n\\nbytes32 constant EIP1271_isValidSignature_selector = (\\n    0x1626ba7e00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant EIP1271_isValidSignature_signatureHead_negativeOffset = 0x20;\\nuint256 constant EIP1271_isValidSignature_digest_negativeOffset = 0x40;\\nuint256 constant EIP1271_isValidSignature_selector_negativeOffset = 0x44;\\nuint256 constant EIP1271_isValidSignature_calldata_baseLength = 0x64;\\n\\nuint256 constant EIP1271_isValidSignature_signature_head_offset = 0x40;\\n\\nuint256 constant EIP_712_PREFIX = (\\n    0x1901000000000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant ExtraGasBuffer = 0x20;\\nuint256 constant CostPerWord = 3;\\nuint256 constant MemoryExpansionCoefficientShift = 9;\\n\\nuint256 constant Create2AddressDerivation_ptr = 0x0b;\\nuint256 constant Create2AddressDerivation_length = 0x55;\\n\\nuint256 constant MaskOverByteTwelve = (\\n    0x0000000000000000000000ff0000000000000000000000000000000000000000\\n);\\n\\nuint256 constant MaskOverLastTwentyBytes = (\\n    0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\\n);\\n\\nuint256 constant MaskOverFirstFourBytes = (\\n    0xffffffff00000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant Conduit_execute_signature = (\\n    0x4ce34aa200000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant MaxUint8 = 0xff;\\nuint256 constant MaxUint120 = 0xffffffffffffffffffffffffffffff;\\n\\nuint256 constant Conduit_execute_ConduitTransfer_ptr = 0x20;\\nuint256 constant Conduit_execute_ConduitTransfer_length = 0x01;\\n\\nuint256 constant Conduit_execute_ConduitTransfer_offset_ptr = 0x04;\\nuint256 constant Conduit_execute_ConduitTransfer_length_ptr = 0x24;\\nuint256 constant Conduit_execute_transferItemType_ptr = 0x44;\\nuint256 constant Conduit_execute_transferToken_ptr = 0x64;\\nuint256 constant Conduit_execute_transferFrom_ptr = 0x84;\\nuint256 constant Conduit_execute_transferTo_ptr = 0xa4;\\nuint256 constant Conduit_execute_transferIdentifier_ptr = 0xc4;\\nuint256 constant Conduit_execute_transferAmount_ptr = 0xe4;\\n\\nuint256 constant OneConduitExecute_size = 0x104;\\n\\n// Sentinel value to indicate that the conduit accumulator is not armed.\\nuint256 constant AccumulatorDisarmed = 0x20;\\nuint256 constant AccumulatorArmed = 0x40;\\nuint256 constant Accumulator_conduitKey_ptr = 0x20;\\nuint256 constant Accumulator_selector_ptr = 0x40;\\nuint256 constant Accumulator_array_offset_ptr = 0x44;\\nuint256 constant Accumulator_array_length_ptr = 0x64;\\n\\nuint256 constant Accumulator_itemSizeOffsetDifference = 0x3c;\\n\\nuint256 constant Accumulator_array_offset = 0x20;\\nuint256 constant Conduit_transferItem_size = 0xc0;\\nuint256 constant Conduit_transferItem_token_ptr = 0x20;\\nuint256 constant Conduit_transferItem_from_ptr = 0x40;\\nuint256 constant Conduit_transferItem_to_ptr = 0x60;\\nuint256 constant Conduit_transferItem_identifier_ptr = 0x80;\\nuint256 constant Conduit_transferItem_amount_ptr = 0xa0;\\n\\nuint256 constant Ecrecover_precompile = 1;\\nuint256 constant Ecrecover_args_size = 0x80;\\nuint256 constant Signature_lower_v = 27;\\n\\n// Bitmask that only gives a non-zero value if masked with a non-match selector.\\nuint256 constant NonMatchSelector_MagicMask = (\\n    0x4000000000000000000000000000000000000000000000000000000000\\n);\\n\\n// First bit indicates that a NATIVE offer items has been used and the 231th bit\\n// indicates that a non match selector has been called.\\nuint256 constant NonMatchSelector_InvalidErrorValue = (\\n    0x4000000000000000000000000000000000000000000000000000000001\\n);\\n\\nuint256 constant IsValidOrder_signature = (\\n    0x0e1d31dc00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant IsValidOrder_sig_ptr = 0x0;\\nuint256 constant IsValidOrder_orderHash_ptr = 0x04;\\nuint256 constant IsValidOrder_caller_ptr = 0x24;\\nuint256 constant IsValidOrder_offerer_ptr = 0x44;\\nuint256 constant IsValidOrder_zoneHash_ptr = 0x64;\\nuint256 constant IsValidOrder_length = 0x84; // 4 + 32 * 4 == 132\\n\\nuint256 constant Error_selector_offset = 0x1c;\\n\\n/*\\n *  error MissingFulfillmentComponentOnAggregation(uint8 side)\\n *    - Defined in FulfillmentApplicationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: side\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant MissingFulfillmentComponentOnAggregation_error_selector = (\\n    0x375c24c1\\n);\\nuint256 constant MissingFulfillmentComponentOnAggregation_error_side_ptr = 0x20;\\nuint256 constant MissingFulfillmentComponentOnAggregation_error_length = 0x24;\\n\\n/*\\n *  error OfferAndConsiderationRequiredOnFulfillment()\\n *    - Defined in FulfillmentApplicationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_selector = (\\n    0x98e9db6e\\n);\\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_length = 0x04;\\n\\n/*\\n *  error MismatchedFulfillmentOfferAndConsiderationComponents(\\n *      uint256 fulfillmentIndex\\n *  )\\n *    - Defined in FulfillmentApplicationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: fulfillmentIndex\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant MismatchedFulfillmentOfferAndConsiderationComponents_error_selector = 0xbced929d;\\nuint256 constant MismatchedFulfillmentOfferAndConsiderationComponents_error_fulfillmentIndex_ptr = 0x20;\\nuint256 constant MismatchedFulfillmentOfferAndConsiderationComponents_error_length = 0x24;\\n\\n/*\\n *  error InvalidFulfillmentComponentData()\\n *    - Defined in FulfillmentApplicationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InvalidFulfillmentComponentData_error_selector = 0x7fda7279;\\nuint256 constant InvalidFulfillmentComponentData_error_length = 0x04;\\n\\n/*\\n *  error InexactFraction()\\n *    - Defined in AmountDerivationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InexactFraction_error_selector = 0xc63cf089;\\nuint256 constant InexactFraction_error_length = 0x04;\\n\\n/*\\n *  error OrderCriteriaResolverOutOfRange(uint8 side)\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: side\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant OrderCriteriaResolverOutOfRange_error_selector = 0x133c37c6;\\nuint256 constant OrderCriteriaResolverOutOfRange_error_side_ptr = 0x20;\\nuint256 constant OrderCriteriaResolverOutOfRange_error_length = 0x24;\\n\\n/*\\n *  error UnresolvedOfferCriteria(uint256 orderIndex, uint256 offerIndex)\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderIndex\\n *    - 0x40: offerIndex\\n * Revert buffer is memory[0x1c:0x60]\\n */\\nuint256 constant UnresolvedOfferCriteria_error_selector = 0xd6929332;\\nuint256 constant UnresolvedOfferCriteria_error_orderIndex_ptr = 0x20;\\nuint256 constant UnresolvedOfferCriteria_error_offerIndex_ptr = 0x40;\\nuint256 constant UnresolvedOfferCriteria_error_length = 0x44;\\n\\n/*\\n *  error UnresolvedConsiderationCriteria(uint256 orderIndex, uint256 considerationIndex)\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderIndex\\n *    - 0x40: considerationIndex\\n * Revert buffer is memory[0x1c:0x60]\\n */\\nuint256 constant UnresolvedConsiderationCriteria_error_selector = 0xa8930e9a;\\nuint256 constant UnresolvedConsiderationCriteria_error_orderIndex_ptr = 0x20;\\nuint256 constant UnresolvedConsiderationCriteria_error_considerationIndex_ptr = 0x40;\\nuint256 constant UnresolvedConsiderationCriteria_error_length = 0x44;\\n\\n/*\\n *  error OfferCriteriaResolverOutOfRange()\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant OfferCriteriaResolverOutOfRange_error_selector = 0xbfb3f8ce;\\nuint256 constant OfferCriteriaResolverOutOfRange_error_length = 0x04;\\n\\n/*\\n *  error ConsiderationCriteriaResolverOutOfRange()\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant ConsiderationCriteriaResolverOutOfRange_error_selector = 0x6088d7de;\\nuint256 constant ConsiderationCriteriaResolverOutOfRange_err_selector = 0x6088d7de;\\nuint256 constant ConsiderationCriteriaResolverOutOfRange_error_length = 0x04;\\n\\n/*\\n *  error CriteriaNotEnabledForItem()\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant CriteriaNotEnabledForItem_error_selector = 0x94eb6af6;\\nuint256 constant CriteriaNotEnabledForItem_error_length = 0x04;\\n\\n/*\\n *  error InvalidProof()\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InvalidProof_error_selector = 0x09bde339;\\nuint256 constant InvalidProof_error_length = 0x04;\\n\\n/*\\n *  error InvalidRestrictedOrder(bytes32 orderHash)\\n *    - Defined in ZoneInteractionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderHash\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant InvalidRestrictedOrder_error_selector = 0xfb5014fc;\\nuint256 constant InvalidRestrictedOrder_error_orderHash_ptr = 0x20;\\nuint256 constant InvalidRestrictedOrder_error_length = 0x24;\\n\\n/*\\n *  error InvalidContractOrder(bytes32 orderHash)\\n *    - Defined in ZoneInteractionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderHash\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant InvalidContractOrder_error_selector = 0x93979285;\\nuint256 constant InvalidContractOrder_error_orderHash_ptr = 0x20;\\nuint256 constant InvalidContractOrder_error_length = 0x24;\\n\\n/*\\n *  error BadSignatureV(uint8 v)\\n *    - Defined in SignatureVerificationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: v\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant BadSignatureV_error_selector = 0x1f003d0a;\\nuint256 constant BadSignatureV_error_v_ptr = 0x20;\\nuint256 constant BadSignatureV_error_length = 0x24;\\n\\n/*\\n *  error InvalidSigner()\\n *    - Defined in SignatureVerificationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InvalidSigner_error_selector = 0x815e1d64;\\nuint256 constant InvalidSigner_error_length = 0x04;\\n\\n/*\\n *  error InvalidSignature()\\n *    - Defined in SignatureVerificationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InvalidSignature_error_selector = 0x8baa579f;\\nuint256 constant InvalidSignature_error_length = 0x04;\\n\\n/*\\n *  error BadContractSignature()\\n *    - Defined in SignatureVerificationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant BadContractSignature_error_selector = 0x4f7fb80d;\\nuint256 constant BadContractSignature_error_length = 0x04;\\n\\n/*\\n *  error InvalidERC721TransferAmount(uint256 amount)\\n *    - Defined in TokenTransferrerErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: amount\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant InvalidERC721TransferAmount_error_selector = 0x69f95827;\\nuint256 constant InvalidERC721TransferAmount_error_amount_ptr = 0x20;\\nuint256 constant InvalidERC721TransferAmount_error_length = 0x24;\\n\\n/*\\n *  error MissingItemAmount()\\n *    - Defined in TokenTransferrerErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant MissingItemAmount_error_selector = 0x91b3e514;\\nuint256 constant MissingItemAmount_error_length = 0x04;\\n\\n/*\\n *  error UnusedItemParameters()\\n *    - Defined in TokenTransferrerErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant UnusedItemParameters_error_selector = 0x6ab37ce7;\\nuint256 constant UnusedItemParameters_error_length = 0x04;\\n\\n/*\\n *  error BadReturnValueFromERC20OnTransfer(address token, address from, address to, uint256 amount)\\n *    - Defined in TokenTransferrerErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: token\\n *    - 0x40: from\\n *    - 0x60: to\\n *    - 0x80: amount\\n * Revert buffer is memory[0x1c:0xa0]\\n */\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_selector = 0x98891923;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x20;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x40;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x60;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x80;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\\n\\n/*\\n *  error NoContract(address account)\\n *    - Defined in TokenTransferrerErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: account\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant NoContract_error_selector = 0x5f15d672;\\nuint256 constant NoContract_error_account_ptr = 0x20;\\nuint256 constant NoContract_error_length = 0x24;\\n\\n/*\\n *  error Invalid1155BatchTransferEncoding()\\n *    - Defined in TokenTransferrerErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant Invalid1155BatchTransferEncoding_error_selector = 0xeba2084c;\\nuint256 constant Invalid1155BatchTransferEncoding_error_length = 0x04;\\n\\n/*\\n *  error NoReentrantCalls()\\n *    - Defined in ReentrancyErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant NoReentrantCalls_error_selector = 0x7fa8a987;\\nuint256 constant NoReentrantCalls_error_length = 0x04;\\n\\n/*\\n *  error OrderAlreadyFilled(bytes32 orderHash)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderHash\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant OrderAlreadyFilled_error_selector = 0x10fda3e1;\\nuint256 constant OrderAlreadyFilled_error_orderHash_ptr = 0x20;\\nuint256 constant OrderAlreadyFilled_error_length = 0x24;\\n\\n/*\\n *  error InvalidTime(uint256 startTime, uint256 endTime)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: startTime\\n *    - 0x40: endTime\\n * Revert buffer is memory[0x1c:0x60]\\n */\\nuint256 constant InvalidTime_error_selector = 0x21ccfeb7;\\nuint256 constant InvalidTime_error_startTime_ptr = 0x20;\\nuint256 constant InvalidTime_error_endTime_ptr = 0x40;\\nuint256 constant InvalidTime_error_length = 0x44;\\n\\n/*\\n *  error InvalidConduit(bytes32 conduitKey, address conduit)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: conduitKey\\n *    - 0x40: conduit\\n * Revert buffer is memory[0x1c:0x60]\\n */\\nuint256 constant InvalidConduit_error_selector = 0x1cf99b26;\\nuint256 constant InvalidConduit_error_conduitKey_ptr = 0x20;\\nuint256 constant InvalidConduit_error_conduit_ptr = 0x40;\\nuint256 constant InvalidConduit_error_length = 0x44;\\n\\n/*\\n *  error MissingOriginalConsiderationItems()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant MissingOriginalConsiderationItems_error_selector = 0x466aa616;\\nuint256 constant MissingOriginalConsiderationItems_error_length = 0x04;\\n\\n/*\\n *  error InvalidCallToConduit(address conduit)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: conduit\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant InvalidCallToConduit_error_selector = 0xd13d53d4;\\nuint256 constant InvalidCallToConduit_error_conduit_ptr = 0x20;\\nuint256 constant InvalidCallToConduit_error_length = 0x24;\\n\\n/*\\n *  error ConsiderationNotMet(uint256 orderIndex, uint256 considerationIndex, uint256 shortfallAmount)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderIndex\\n *    - 0x40: considerationIndex\\n *    - 0x60: shortfallAmount\\n * Revert buffer is memory[0x1c:0x80]\\n */\\nuint256 constant ConsiderationNotMet_error_selector = 0xa5f54208;\\nuint256 constant ConsiderationNotMet_error_orderIndex_ptr = 0x20;\\nuint256 constant ConsiderationNotMet_error_considerationIndex_ptr = 0x40;\\nuint256 constant ConsiderationNotMet_error_shortfallAmount_ptr = 0x60;\\nuint256 constant ConsiderationNotMet_error_length = 0x64;\\n\\n/*\\n *  error InsufficientEtherSupplied()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InsufficientEtherSupplied_error_selector = 0x1a783b8d;\\nuint256 constant InsufficientEtherSupplied_error_length = 0x04;\\n\\n/*\\n *  error EtherTransferGenericFailure(address account, uint256 amount)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: account\\n *    - 0x40: amount\\n * Revert buffer is memory[0x1c:0x60]\\n */\\nuint256 constant EtherTransferGenericFailure_error_selector = 0x470c7c1d;\\nuint256 constant EtherTransferGenericFailure_error_account_ptr = 0x20;\\nuint256 constant EtherTransferGenericFailure_error_amount_ptr = 0x40;\\nuint256 constant EtherTransferGenericFailure_error_length = 0x44;\\n\\n/*\\n *  error PartialFillsNotEnabledForOrder()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant PartialFillsNotEnabledForOrder_error_selector = 0xa11b63ff;\\nuint256 constant PartialFillsNotEnabledForOrder_error_length = 0x04;\\n\\n/*\\n *  error OrderIsCancelled(bytes32 orderHash)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderHash\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant OrderIsCancelled_error_selector = 0x1a515574;\\nuint256 constant OrderIsCancelled_error_orderHash_ptr = 0x20;\\nuint256 constant OrderIsCancelled_error_length = 0x24;\\n\\n/*\\n *  error OrderPartiallyFilled(bytes32 orderHash)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderHash\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant OrderPartiallyFilled_error_selector = 0xee9e0e63;\\nuint256 constant OrderPartiallyFilled_error_orderHash_ptr = 0x20;\\nuint256 constant OrderPartiallyFilled_error_length = 0x24;\\n\\n/*\\n *  error CannotCancelOrder()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant CannotCancelOrder_error_selector = 0xfed398fc;\\nuint256 constant CannotCancelOrder_error_length = 0x04;\\n\\n/*\\n *  error BadFraction()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant BadFraction_error_selector = 0x5a052b32;\\nuint256 constant BadFraction_error_length = 0x04;\\n\\n/*\\n *  error InvalidMsgValue(uint256 value)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: value\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant InvalidMsgValue_error_selector = 0xa61be9f0;\\nuint256 constant InvalidMsgValue_error_value_ptr = 0x20;\\nuint256 constant InvalidMsgValue_error_length = 0x24;\\n\\n/*\\n *  error InvalidBasicOrderParameterEncoding()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InvalidBasicOrderParameterEncoding_error_selector = 0x39f3e3fd;\\nuint256 constant InvalidBasicOrderParameterEncoding_error_length = 0x04;\\n\\n/*\\n *  error NoSpecifiedOrdersAvailable()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant NoSpecifiedOrdersAvailable_error_selector = 0xd5da9a1b;\\nuint256 constant NoSpecifiedOrdersAvailable_error_length = 0x04;\\n\\n/*\\n *  error InvalidNativeOfferItem()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InvalidNativeOfferItem_error_selector = 0x12d3f5a3;\\nuint256 constant InvalidNativeOfferItem_error_length = 0x04;\\n\\n/*\\n *  error ConsiderationLengthNotEqualToTotalOriginal()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_selector = (\\n    0x2165628a\\n);\\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_length = 0x04;\\n\\n/*\\n *  error Panic(uint256 code)\\n *    - Built-in Solidity error\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: code\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant Panic_error_selector = 0x4e487b71;\\nuint256 constant Panic_error_code_ptr = 0x20;\\nuint256 constant Panic_error_length = 0x24;\\n\\n/**\\n * @dev Selector and offsets for generateOrder\\n *\\n * function generateOrder(\\n *   address fulfiller,\\n *   SpentItem[] calldata minimumReceived,\\n *   SpentItem[] calldata maximumSpent,\\n *   bytes calldata context\\n * )\\n */\\nuint256 constant generateOrder_selector = 0x98919765;\\nuint256 constant generateOrder_selector_offset = 0x1c;\\nuint256 constant generateOrder_head_offset = 0x04;\\nuint256 constant generateOrder_minimumReceived_head_offset = 0x20;\\nuint256 constant generateOrder_maximumSpent_head_offset = 0x40;\\nuint256 constant generateOrder_context_head_offset = 0x60;\\nuint256 constant generateOrder_base_tail_offset = 0x80;\\n\\nuint256 constant ratifyOrder_selector = 0xf4dd92ce;\\nuint256 constant ratifyOrder_selector_offset = 0x1c;\\nuint256 constant ratifyOrder_head_offset = 0x04;\\nuint256 constant ratifyOrder_offer_head_offset = 0x00;\\nuint256 constant ratifyOrder_consideration_head_offset = 0x20;\\nuint256 constant ratifyOrder_context_head_offset = 0x40;\\nuint256 constant ratifyOrder_orderHashes_head_offset = 0x60;\\nuint256 constant ratifyOrder_contractNonce_offset = 0x80;\\nuint256 constant ratifyOrder_base_tail_offset = 0xa0;\\n\\nuint256 constant validateOrder_selector = 0x17b1f942;\\nuint256 constant validateOrder_selector_offset = 0x1c;\\nuint256 constant validateOrder_head_offset = 0x04;\\nuint256 constant validateOrder_zoneParameters_offset = 0x20;\\n\\nuint256 constant ZoneParameters_orderHash_offset = 0x00;\\nuint256 constant ZoneParameters_fulfiller_offset = 0x20;\\nuint256 constant ZoneParameters_offerer_offset = 0x40;\\nuint256 constant ZoneParameters_offer_head_offset = 0x60;\\nuint256 constant ZoneParameters_consideration_head_offset = 0x80;\\nuint256 constant ZoneParameters_extraData_head_offset = 0xa0;\\nuint256 constant ZoneParameters_orderHashes_head_offset = 0xc0;\\nuint256 constant ZoneParameters_startTime_offset = 0xe0;\\nuint256 constant ZoneParameters_endTime_offset = 0x100;\\nuint256 constant ZoneParameters_zoneHash_offset = 0x120;\\nuint256 constant ZoneParameters_base_tail_offset = 0x140;\\nuint256 constant ZoneParameters_selectorAndPointer_length = 0x24;\\nuint256 constant ZoneParameters_basicOrderFixedElements_length = 0x64;\\n\\n// ConsiderationDecoder Constants\\nuint256 constant BasicOrderParameters_head_size = 0x0240;\\nuint256 constant BasicOrderParameters_fixed_segment_0 = 0x0200;\\nuint256 constant BasicOrderParameters_additionalRecipients_offset = 0x0200;\\nuint256 constant BasicOrderParameters_signature_offset = 0x0220;\\n\\nuint256 constant OrderParameters_head_size = 0x0160;\\nuint256 constant OrderParameters_totalOriginalConsiderationItems_offset = (\\n    0x0140\\n);\\nuint256 constant AdvancedOrderPlusOrderParameters_head_size = 0x0200;\\n\\nuint256 constant Order_signature_offset = 0x20;\\nuint256 constant Order_head_size = 0x40;\\n\\nuint256 constant AdvancedOrder_fixed_segment_0 = 0x40;\\n\\nuint256 constant CriteriaResolver_head_size = 0xa0;\\nuint256 constant CriteriaResolver_fixed_segment_0 = 0x80;\\nuint256 constant CriteriaResolver_criteriaProof_offset = 0x80;\\n\\nuint256 constant FulfillmentComponent_mem_tail_size = 0x40;\\nuint256 constant FulfillmentComponent_mem_tail_size_shift = 6;\\nuint256 constant Fulfillment_head_size = 0x40;\\nuint256 constant Fulfillment_considerationComponents_offset = 0x20;\\n\\nuint256 constant OrderComponents_OrderParameters_common_head_size = 0x0140;\\n\"\r\n    },\r\n    \"contracts/lib/ConsiderationEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n// prettier-ignore\\nenum OrderType {\\n    // 0: no partial fills, anyone can execute\\n    FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    PARTIAL_RESTRICTED,\\n\\n    // 4: contract order type\\n    CONTRACT\\n}\\n\\n// prettier-ignore\\nenum BasicOrderType {\\n    // 0: no partial fills, anyone can execute\\n    ETH_TO_ERC721_FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    ETH_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 4: no partial fills, anyone can execute\\n    ETH_TO_ERC1155_FULL_OPEN,\\n\\n    // 5: partial fills supported, anyone can execute\\n    ETH_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 6: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 7: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 8: no partial fills, anyone can execute\\n    ERC20_TO_ERC721_FULL_OPEN,\\n\\n    // 9: partial fills supported, anyone can execute\\n    ERC20_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 10: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 11: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 12: no partial fills, anyone can execute\\n    ERC20_TO_ERC1155_FULL_OPEN,\\n\\n    // 13: partial fills supported, anyone can execute\\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 14: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 15: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 16: no partial fills, anyone can execute\\n    ERC721_TO_ERC20_FULL_OPEN,\\n\\n    // 17: partial fills supported, anyone can execute\\n    ERC721_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 18: no partial fills, only offerer or zone can execute\\n    ERC721_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 19: partial fills supported, only offerer or zone can execute\\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\\n\\n    // 20: no partial fills, anyone can execute\\n    ERC1155_TO_ERC20_FULL_OPEN,\\n\\n    // 21: partial fills supported, anyone can execute\\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 22: no partial fills, only offerer or zone can execute\\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 23: partial fills supported, only offerer or zone can execute\\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\\n}\\n\\n// prettier-ignore\\nenum BasicOrderRouteType {\\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\\n    ETH_TO_ERC721,\\n\\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\\n    ETH_TO_ERC1155,\\n\\n    // 2: provide ERC20 item to receive offered ERC721 item.\\n    ERC20_TO_ERC721,\\n\\n    // 3: provide ERC20 item to receive offered ERC1155 item.\\n    ERC20_TO_ERC1155,\\n\\n    // 4: provide ERC721 item to receive offered ERC20 item.\\n    ERC721_TO_ERC20,\\n\\n    // 5: provide ERC1155 item to receive offered ERC20 item.\\n    ERC1155_TO_ERC20\\n}\\n\\n// prettier-ignore\\nenum ItemType {\\n    // 0: ETH on mainnet, MATIC on polygon, etc.\\n    NATIVE,\\n\\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\\n    ERC20,\\n\\n    // 2: ERC721 items\\n    ERC721,\\n\\n    // 3: ERC1155 items\\n    ERC1155,\\n\\n    // 4: ERC721 items where a number of tokenIds are supported\\n    ERC721_WITH_CRITERIA,\\n\\n    // 5: ERC1155 items where a number of ids are supported\\n    ERC1155_WITH_CRITERIA\\n}\\n\\n// prettier-ignore\\nenum Side {\\n    // 0: Items that can be spent\\n    OFFER,\\n\\n    // 1: Items that must be received\\n    CONSIDERATION\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OrderFulfiller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { ItemType, OrderType } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    OfferItem,\\n    ConsiderationItem,\\n    SpentItem,\\n    ReceivedItem,\\n    OrderParameters,\\n    Order,\\n    AdvancedOrder,\\n    CriteriaResolver\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { BasicOrderFulfiller } from \\\"./BasicOrderFulfiller.sol\\\";\\n\\nimport { CriteriaResolution } from \\\"./CriteriaResolution.sol\\\";\\n\\nimport { AmountDeriver } from \\\"./AmountDeriver.sol\\\";\\n\\nimport \\\"./ConsiderationErrors.sol\\\";\\n\\n/**\\n * @title OrderFulfiller\\n * @author 0age\\n * @notice OrderFulfiller contains logic related to order fulfillment where a\\n *         single order is being fulfilled and where basic order fulfillment is\\n *         not available as an option.\\n */\\ncontract OrderFulfiller is\\n    BasicOrderFulfiller,\\n    CriteriaResolution,\\n    AmountDeriver\\n{\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(\\n        address conduitController\\n    ) BasicOrderFulfiller(conduitController) {}\\n\\n    /**\\n     * @dev Internal function to validate an order and update its status, adjust\\n     *      prices based on current time, apply criteria resolvers, determine\\n     *      what portion to fill, and transfer relevant tokens.\\n     *\\n     * @param advancedOrder       The order to fulfill as well as the fraction\\n     *                            to fill. Note that all offer and consideration\\n     *                            components must divide with no remainder for\\n     *                            the partial fill to be valid.\\n     * @param criteriaResolvers   An array where each element contains a\\n     *                            reference to a specific offer or\\n     *                            consideration, a token identifier, and a proof\\n     *                            that the supplied token identifier is\\n     *                            contained in the order's merkle root. Note\\n     *                            that a criteria of zero indicates that any\\n     *                            (transferable) token identifier is valid and\\n     *                            that no proof needs to be supplied.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     * @param recipient           The intended recipient for all received items.\\n     *\\n     * @return A boolean indicating whether the order has been fulfilled.\\n     */\\n    function _validateAndFulfillAdvancedOrder(\\n        AdvancedOrder memory advancedOrder,\\n        CriteriaResolver[] memory criteriaResolvers,\\n        bytes32 fulfillerConduitKey,\\n        address recipient\\n    ) internal returns (bool) {\\n        // Ensure this function cannot be triggered during a reentrant call.\\n        _setReentrancyGuard(\\n            // Native tokens accepted during execution for contract order types.\\n            advancedOrder.parameters.orderType == OrderType.CONTRACT\\n        );\\n\\n        // Validate order, update status, and determine fraction to fill.\\n        (\\n            bytes32 orderHash,\\n            uint256 fillNumerator,\\n            uint256 fillDenominator\\n        ) = _validateOrderAndUpdateStatus(advancedOrder, true);\\n\\n        // Create an array with length 1 containing the order.\\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](1);\\n\\n        // Populate the order as the first and only element of the new array.\\n        advancedOrders[0] = advancedOrder;\\n\\n        // Apply criteria resolvers using generated orders and details arrays.\\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\\n\\n        // Retrieve the order parameters after applying criteria resolvers.\\n        OrderParameters memory orderParameters = advancedOrders[0].parameters;\\n\\n        // Perform each item transfer with the appropriate fractional amount.\\n        _applyFractionsAndTransferEach(\\n            orderParameters,\\n            fillNumerator,\\n            fillDenominator,\\n            fulfillerConduitKey,\\n            recipient\\n        );\\n\\n        // Declare empty bytes32 array and populate with the order hash.\\n        bytes32[] memory orderHashes = new bytes32[](1);\\n        orderHashes[0] = orderHash;\\n\\n        // Ensure restricted orders have a valid submitter or pass a zone check.\\n        _assertRestrictedAdvancedOrderValidity(\\n            advancedOrders[0],\\n            orderHashes,\\n            orderHash\\n        );\\n\\n        // Emit an event signifying that the order has been fulfilled.\\n        _emitOrderFulfilledEvent(\\n            orderHash,\\n            orderParameters.offerer,\\n            orderParameters.zone,\\n            recipient,\\n            orderParameters.offer,\\n            orderParameters.consideration\\n        );\\n\\n        // Clear the reentrancy guard.\\n        _clearReentrancyGuard();\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer each item contained in a given single\\n     *      order fulfillment after applying a respective fraction to the amount\\n     *      being transferred.\\n     *\\n     * @param orderParameters     The parameters for the fulfilled order.\\n     * @param numerator           A value indicating the portion of the order\\n     *                            that should be filled.\\n     * @param denominator         A value indicating the total order size.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     * @param recipient           The intended recipient for all received items.\\n     */\\n    function _applyFractionsAndTransferEach(\\n        OrderParameters memory orderParameters,\\n        uint256 numerator,\\n        uint256 denominator,\\n        bytes32 fulfillerConduitKey,\\n        address recipient\\n    ) internal {\\n        // Read start time & end time from order parameters and place on stack.\\n        uint256 startTime = orderParameters.startTime;\\n        uint256 endTime = orderParameters.endTime;\\n\\n        // Initialize an accumulator array. From this point forward, no new\\n        // memory regions can be safely allocated until the accumulator is no\\n        // longer being utilized, as the accumulator operates in an open-ended\\n        // fashion from this memory pointer; existing memory may still be\\n        // accessed and modified, however.\\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\\n\\n        // As of solidity 0.6.0, inline assembly cannot directly access function\\n        // definitions, but can still access locally scoped function variables.\\n        // This means that a local variable to reference the internal function\\n        // definition (using the same type), along with a local variable with\\n        // the desired type, must first be created. Then, the original function\\n        // pointer can be recast to the desired type.\\n\\n        /**\\n         * Repurpose existing OfferItem memory regions on the offer array for\\n         * the order by overriding the _transfer function pointer to accept a\\n         * modified OfferItem argument in place of the usual ReceivedItem:\\n         *\\n         *   ========= OfferItem ==========   ====== ReceivedItem ======\\n         *   ItemType itemType; ------------> ItemType itemType;\\n         *   address token; ----------------> address token;\\n         *   uint256 identifierOrCriteria; -> uint256 identifier;\\n         *   uint256 startAmount; ----------> uint256 amount;\\n         *   uint256 endAmount; ------------> address recipient;\\n         */\\n\\n        // Declare a nested scope to minimize stack depth.\\n        unchecked {\\n            // Read offer array length from memory and place on stack.\\n            uint256 totalOfferItems = orderParameters.offer.length;\\n\\n            // Create a variable to indicate whether the order has any\\n            // native offer items\\n            uint256 anyNativeItems;\\n\\n            // Iterate over each offer on the order.\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            for (uint256 i = 0; i < totalOfferItems; ++i) {\\n                // Retrieve the offer item.\\n                OfferItem memory offerItem = orderParameters.offer[i];\\n\\n                // Offer items for the native token can not be received outside\\n                // of a match order function except as part of a contract order.\\n                {\\n                    ItemType itemType = offerItem.itemType;\\n                    assembly {\\n                        anyNativeItems := or(anyNativeItems, iszero(itemType))\\n                    }\\n                }\\n\\n                // Declare an additional nested scope to minimize stack depth.\\n                {\\n                    // Apply fill fraction to get offer item amount to transfer.\\n                    uint256 amount = _applyFraction(\\n                        offerItem.startAmount,\\n                        offerItem.endAmount,\\n                        numerator,\\n                        denominator,\\n                        startTime,\\n                        endTime,\\n                        false\\n                    );\\n\\n                    // Utilize assembly to set overloaded offerItem arguments.\\n                    assembly {\\n                        // Write new fractional amount to startAmount as amount.\\n                        mstore(\\n                            add(offerItem, ReceivedItem_amount_offset),\\n                            amount\\n                        )\\n\\n                        // Write recipient to endAmount.\\n                        mstore(\\n                            add(offerItem, ReceivedItem_recipient_offset),\\n                            recipient\\n                        )\\n                    }\\n                }\\n\\n                // Transfer the item from the offerer to the recipient.\\n                _toOfferItemInput(_transfer)(\\n                    offerItem,\\n                    orderParameters.offerer,\\n                    orderParameters.conduitKey,\\n                    accumulator\\n                );\\n            }\\n\\n            // If non-contract order has native offer items, throw InvalidNativeOfferItem.\\n            {\\n                OrderType orderType = orderParameters.orderType;\\n                uint256 invalidNativeOfferItem;\\n                assembly {\\n                    invalidNativeOfferItem := and(\\n                        lt(orderType, 4),\\n                        anyNativeItems\\n                    )\\n                }\\n                if (invalidNativeOfferItem != 0) {\\n                    _revertInvalidNativeOfferItem();\\n                }\\n            }\\n        }\\n\\n        // Declare a variable for the available native token balance.\\n        uint256 nativeTokenBalance;\\n\\n        /**\\n         * Repurpose existing ConsiderationItem memory regions on the\\n         * consideration array for the order by overriding the _transfer\\n         * function pointer to accept a modified ConsiderationItem argument in\\n         * place of the usual ReceivedItem:\\n         *\\n         *   ====== ConsiderationItem =====   ====== ReceivedItem ======\\n         *   ItemType itemType; ------------> ItemType itemType;\\n         *   address token; ----------------> address token;\\n         *   uint256 identifierOrCriteria;--> uint256 identifier;\\n         *   uint256 startAmount; ----------> uint256 amount;\\n         *   uint256 endAmount;        /----> address recipient;\\n         *   address recipient; ------/\\n         */\\n\\n        // Declare a nested scope to minimize stack depth.\\n        unchecked {\\n            // Read consideration array length from memory and place on stack.\\n            uint256 totalConsiderationItems = orderParameters\\n                .consideration\\n                .length;\\n\\n            // Iterate over each consideration item on the order.\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            for (uint256 i = 0; i < totalConsiderationItems; ++i) {\\n                // Retrieve the consideration item.\\n                ConsiderationItem memory considerationItem = (\\n                    orderParameters.consideration[i]\\n                );\\n\\n                // Apply fraction & derive considerationItem amount to transfer.\\n                uint256 amount = _applyFraction(\\n                    considerationItem.startAmount,\\n                    considerationItem.endAmount,\\n                    numerator,\\n                    denominator,\\n                    startTime,\\n                    endTime,\\n                    true\\n                );\\n\\n                // Use assembly to set overloaded considerationItem arguments.\\n                assembly {\\n                    // Write derived fractional amount to startAmount as amount.\\n                    mstore(\\n                        add(considerationItem, ReceivedItem_amount_offset),\\n                        amount\\n                    )\\n\\n                    // Write original recipient to endAmount as recipient.\\n                    mstore(\\n                        add(considerationItem, ReceivedItem_recipient_offset),\\n                        mload(\\n                            add(\\n                                considerationItem,\\n                                ConsiderationItem_recipient_offset\\n                            )\\n                        )\\n                    )\\n                }\\n\\n                // Reduce available value if offer spent ETH or a native token.\\n                if (considerationItem.itemType == ItemType.NATIVE) {\\n                    // Get the current available balance of native tokens.\\n                    assembly {\\n                        nativeTokenBalance := selfbalance()\\n                    }\\n\\n                    // Ensure that sufficient native tokens are still available.\\n                    if (amount > nativeTokenBalance) {\\n                        _revertInsufficientEtherSupplied();\\n                    }\\n                }\\n\\n                // Transfer item from caller to recipient specified by the item.\\n                _toConsiderationItemInput(_transfer)(\\n                    considerationItem,\\n                    msg.sender,\\n                    fulfillerConduitKey,\\n                    accumulator\\n                );\\n            }\\n        }\\n\\n        // Trigger any remaining accumulated transfers via call to the conduit.\\n        _triggerIfArmed(accumulator);\\n\\n        // Determine whether any native token balance remains.\\n        assembly {\\n            nativeTokenBalance := selfbalance()\\n        }\\n\\n        // Return any remaining native token balance to the caller.\\n        if (nativeTokenBalance != 0) {\\n            _transferNativeTokens(payable(msg.sender), nativeTokenBalance);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to emit an OrderFulfilled event. OfferItems are\\n     *      translated into SpentItems and ConsiderationItems are translated\\n     *      into ReceivedItems.\\n     *\\n     * @param orderHash     The order hash.\\n     * @param offerer       The offerer for the order.\\n     * @param zone          The zone for the order.\\n     * @param recipient     The recipient of the order, or the null address if\\n     *                      the order was fulfilled via order matching.\\n     * @param offer         The offer items for the order.\\n     * @param consideration The consideration items for the order.\\n     */\\n    function _emitOrderFulfilledEvent(\\n        bytes32 orderHash,\\n        address offerer,\\n        address zone,\\n        address recipient,\\n        OfferItem[] memory offer,\\n        ConsiderationItem[] memory consideration\\n    ) internal {\\n        // Cast already-modified offer memory region as spent items.\\n        SpentItem[] memory spentItems;\\n        assembly {\\n            spentItems := offer\\n        }\\n\\n        // Cast already-modified consideration memory region as received items.\\n        ReceivedItem[] memory receivedItems;\\n        assembly {\\n            receivedItems := consideration\\n        }\\n\\n        // Emit an event signifying that the order has been fulfilled.\\n        emit OrderFulfilled(\\n            orderHash,\\n            offerer,\\n            zone,\\n            recipient,\\n            spentItems,\\n            receivedItems\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/FulfillmentApplier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { ItemType, Side } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    OfferItem,\\n    ConsiderationItem,\\n    ReceivedItem,\\n    OrderParameters,\\n    AdvancedOrder,\\n    Execution,\\n    FulfillmentComponent\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport \\\"./ConsiderationErrors.sol\\\";\\n\\nimport {\\n    FulfillmentApplicationErrors\\n} from \\\"../interfaces/FulfillmentApplicationErrors.sol\\\";\\n\\n/**\\n * @title FulfillmentApplier\\n * @author 0age\\n * @notice FulfillmentApplier contains logic related to applying fulfillments,\\n *         both as part of order matching (where offer items are matched to\\n *         consideration items) as well as fulfilling available orders (where\\n *         order items and consideration items are independently aggregated).\\n */\\ncontract FulfillmentApplier is FulfillmentApplicationErrors {\\n    /**\\n     * @dev Internal pure function to match offer items to consideration items\\n     *      on a group of orders via a supplied fulfillment.\\n     *\\n     * @param advancedOrders          The orders to match.\\n     * @param offerComponents         An array designating offer components to\\n     *                                match to consideration components.\\n     * @param considerationComponents An array designating consideration\\n     *                                components to match to offer components.\\n     *                                Note that each consideration amount must\\n     *                                be zero in order for the match operation\\n     *                                to be valid.\\n     * @param fulfillmentIndex        The index of the fulfillment being\\n     *                                applied.\\n     *\\n     * @return execution The transfer performed as a result of the fulfillment.\\n     */\\n    function _applyFulfillment(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[] memory offerComponents,\\n        FulfillmentComponent[] memory considerationComponents,\\n        uint256 fulfillmentIndex\\n    ) internal pure returns (Execution memory execution) {\\n        // Ensure 1+ of both offer and consideration components are supplied.\\n        if (\\n            offerComponents.length == 0 || considerationComponents.length == 0\\n        ) {\\n            _revertOfferAndConsiderationRequiredOnFulfillment();\\n        }\\n\\n        // Declare a new Execution struct.\\n        Execution memory considerationExecution;\\n\\n        // Validate & aggregate consideration items to new Execution object.\\n        _aggregateValidFulfillmentConsiderationItems(\\n            advancedOrders,\\n            considerationComponents,\\n            considerationExecution\\n        );\\n\\n        // Retrieve the consideration item from the execution struct.\\n        ReceivedItem memory considerationItem = considerationExecution.item;\\n\\n        // Skip aggregating offer items if no consideration items are available.\\n        if (considerationItem.amount == 0) {\\n            // Set the offerer and recipient to null address if execution\\n            // amount is zero. This will cause the execution item to be skipped.\\n            considerationExecution.offerer = address(0);\\n            considerationExecution.item.recipient = payable(0);\\n            return considerationExecution;\\n        }\\n\\n        // Recipient does not need to be specified because it will always be set\\n        // to that of the consideration.\\n        // Validate & aggregate offer items to Execution object.\\n        _aggregateValidFulfillmentOfferItems(\\n            advancedOrders,\\n            offerComponents,\\n            execution\\n        );\\n\\n        // Ensure offer and consideration share types, tokens and identifiers.\\n        if (\\n            execution.item.itemType != considerationItem.itemType ||\\n            execution.item.token != considerationItem.token ||\\n            execution.item.identifier != considerationItem.identifier\\n        ) {\\n            _revertMismatchedFulfillmentOfferAndConsiderationComponents(\\n                fulfillmentIndex\\n            );\\n        }\\n\\n        // If total consideration amount exceeds the offer amount...\\n        if (considerationItem.amount > execution.item.amount) {\\n            // Retrieve the first consideration component from the fulfillment.\\n            FulfillmentComponent memory targetComponent = (\\n                considerationComponents[0]\\n            );\\n\\n            // Skip underflow check as the conditional being true implies that\\n            // considerationItem.amount > execution.item.amount.\\n            unchecked {\\n                // Add excess consideration item amount to original order array.\\n                advancedOrders[targetComponent.orderIndex]\\n                    .parameters\\n                    .consideration[targetComponent.itemIndex]\\n                    .startAmount = (considerationItem.amount -\\n                    execution.item.amount);\\n            }\\n        } else {\\n            // Retrieve the first offer component from the fulfillment.\\n            FulfillmentComponent memory targetComponent = offerComponents[0];\\n\\n            // Skip underflow check as the conditional being false implies that\\n            // execution.item.amount >= considerationItem.amount.\\n            unchecked {\\n                // Add excess offer item amount to the original array of orders.\\n                advancedOrders[targetComponent.orderIndex]\\n                    .parameters\\n                    .offer[targetComponent.itemIndex]\\n                    .startAmount = (execution.item.amount -\\n                    considerationItem.amount);\\n            }\\n\\n            // Reduce total offer amount to equal the consideration amount.\\n            execution.item.amount = considerationItem.amount;\\n        }\\n\\n        // Reuse consideration recipient.\\n        execution.item.recipient = considerationItem.recipient;\\n\\n        // Return the final execution that will be triggered for relevant items.\\n        return execution; // Execution(considerationItem, offerer, conduitKey);\\n    }\\n\\n    /**\\n     * @dev Internal view function to aggregate offer or consideration items\\n     *      from a group of orders into a single execution via a supplied array\\n     *      of fulfillment components. Items that are not available to aggregate\\n     *      will not be included in the aggregated execution.\\n     *\\n     * @param advancedOrders        The orders to aggregate.\\n     * @param side                  The side (i.e. offer or consideration).\\n     * @param fulfillmentComponents An array designating item components to\\n     *                              aggregate if part of an available order.\\n     * @param fulfillerConduitKey   A bytes32 value indicating what conduit, if\\n     *                              any, to source the fulfiller's token\\n     *                              approvals from. The zero hash signifies that\\n     *                              no conduit should be used, with approvals\\n     *                              set directly on this contract.\\n     * @param recipient             The intended recipient for all received\\n     *                              items.\\n     *\\n     * @return execution The transfer performed as a result of the fulfillment.\\n     */\\n    function _aggregateAvailable(\\n        AdvancedOrder[] memory advancedOrders,\\n        Side side,\\n        FulfillmentComponent[] memory fulfillmentComponents,\\n        bytes32 fulfillerConduitKey,\\n        address recipient\\n    ) internal view returns (Execution memory execution) {\\n        // Skip overflow / underflow checks; conditions checked or unreachable.\\n        unchecked {\\n            // Retrieve fulfillment components array length and place on stack.\\n            // Ensure at least one fulfillment component has been supplied.\\n            if (fulfillmentComponents.length == 0) {\\n                _revertMissingFulfillmentComponentOnAggregation(side);\\n            }\\n\\n            // If the fulfillment components are offer components...\\n            if (side == Side.OFFER) {\\n                // Set the supplied recipient on the execution item.\\n                execution.item.recipient = payable(recipient);\\n\\n                // Return execution for aggregated items provided by offerer.\\n                _aggregateValidFulfillmentOfferItems(\\n                    advancedOrders,\\n                    fulfillmentComponents,\\n                    execution\\n                );\\n            } else {\\n                // Otherwise, fulfillment components are consideration\\n                // components. Return execution for aggregated items provided by\\n                // the fulfiller.\\n                _aggregateValidFulfillmentConsiderationItems(\\n                    advancedOrders,\\n                    fulfillmentComponents,\\n                    execution\\n                );\\n\\n                // Set the caller as the offerer on the execution.\\n                execution.offerer = msg.sender;\\n\\n                // Set fulfiller conduit key as the conduit key on execution.\\n                execution.conduitKey = fulfillerConduitKey;\\n            }\\n\\n            // Set the offerer and recipient to null address if execution\\n            // amount is zero. This will cause the execution item to be skipped.\\n            if (execution.item.amount == 0) {\\n                execution.offerer = address(0);\\n                execution.item.recipient = payable(0);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to aggregate a group of offer items using\\n     *      supplied directives on which component items are candidates for\\n     *      aggregation, skipping items on orders that are not available.\\n     *\\n     * @param advancedOrders  The orders to aggregate offer items from.\\n     * @param offerComponents An array of FulfillmentComponent structs\\n     *                        indicating the order index and item index of each\\n     *                        candidate offer item for aggregation.\\n     * @param execution       The execution to apply the aggregation to.\\n     */\\n    function _aggregateValidFulfillmentOfferItems(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[] memory offerComponents,\\n        Execution memory execution\\n    ) internal pure {\\n        assembly {\\n            // Declare a variable for the final aggregated item amount.\\n            let amount\\n\\n            // Declare a variable to track errors encountered with amount.\\n            let errorBuffer\\n\\n            // Declare a variable for the hash of itemType, token, identifier\\n            let dataHash\\n\\n            for {\\n                // Create variable to track position in offerComponents head.\\n                let fulfillmentHeadPtr := offerComponents\\n\\n                // Get position one word past last element in head of array.\\n                let endPtr := add(\\n                    offerComponents,\\n                    shl(OneWordShift, mload(offerComponents))\\n                )\\n            } lt(fulfillmentHeadPtr, endPtr) {\\n\\n            } {\\n                // Increment position in considerationComponents head.\\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\\n\\n                // Retrieve the order index using the fulfillment pointer.\\n                let orderIndex := mload(mload(fulfillmentHeadPtr))\\n\\n                // Ensure that the order index is not out of range.\\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\\n                    throwInvalidFulfillmentComponentData()\\n                }\\n\\n                // Read advancedOrders[orderIndex] pointer from its array head.\\n                let orderPtr := mload(\\n                    // Calculate head position of advancedOrders[orderIndex].\\n                    add(\\n                        add(advancedOrders, OneWord),\\n                        shl(OneWordShift, orderIndex)\\n                    )\\n                )\\n\\n                // Read the pointer to OrderParameters from the AdvancedOrder.\\n                let paramsPtr := mload(orderPtr)\\n\\n                // Retrieve item index using an offset of fulfillment pointer.\\n                let itemIndex := mload(\\n                    add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\\n                )\\n\\n                let offerItemPtr\\n                {\\n                    // Load the offer array pointer.\\n                    let offerArrPtr := mload(\\n                        add(paramsPtr, OrderParameters_offer_head_offset)\\n                    )\\n\\n                    // If the offer item index is out of range or the numerator\\n                    // is zero, skip this item.\\n                    if or(\\n                        iszero(lt(itemIndex, mload(offerArrPtr))),\\n                        iszero(\\n                            mload(add(orderPtr, AdvancedOrder_numerator_offset))\\n                        )\\n                    ) {\\n                        continue\\n                    }\\n\\n                    // Retrieve offer item pointer using the item index.\\n                    offerItemPtr := mload(\\n                        add(\\n                            // Get pointer to beginning of receivedItem.\\n                            add(offerArrPtr, OneWord),\\n                            // Calculate offset to pointer for desired order.\\n                            shl(OneWordShift, itemIndex)\\n                        )\\n                    )\\n                }\\n\\n                // Declare a separate scope for the amount update.\\n                {\\n                    // Retrieve amount pointer using consideration item pointer.\\n                    let amountPtr := add(offerItemPtr, Common_amount_offset)\\n\\n                    // Add offer item amount to execution amount.\\n                    let newAmount := add(amount, mload(amountPtr))\\n\\n                    // Update error buffer:\\n                    // 1 = zero amount, 2 = overflow, 3 = both.\\n                    errorBuffer := or(\\n                        errorBuffer,\\n                        or(\\n                            shl(1, lt(newAmount, amount)),\\n                            iszero(mload(amountPtr))\\n                        )\\n                    )\\n\\n                    // Update the amount to the new, summed amount.\\n                    amount := newAmount\\n\\n                    // Zero out amount on original item to indicate it is spent.\\n                    mstore(amountPtr, 0)\\n                }\\n\\n                // Retrieve ReceivedItem pointer from Execution.\\n                let receivedItem := mload(execution)\\n\\n                // Check if this is the first valid fulfillment item\\n                switch iszero(dataHash)\\n                case 1 {\\n                    // On first valid item, populate the received item in\\n                    // memory for later comparison.\\n\\n                    // Set the item type on the received item.\\n                    mstore(receivedItem, mload(offerItemPtr))\\n\\n                    // Set the token on the received item.\\n                    mstore(\\n                        add(receivedItem, Common_token_offset),\\n                        mload(add(offerItemPtr, Common_token_offset))\\n                    )\\n\\n                    // Set the identifier on the received item.\\n                    mstore(\\n                        add(receivedItem, Common_identifier_offset),\\n                        mload(add(offerItemPtr, Common_identifier_offset))\\n                    )\\n\\n                    // Set offerer on returned execution using order pointer.\\n                    mstore(\\n                        add(execution, Execution_offerer_offset),\\n                        mload(paramsPtr)\\n                    )\\n\\n                    // Set execution conduitKey via order pointer offset.\\n                    mstore(\\n                        add(execution, Execution_conduit_offset),\\n                        mload(add(paramsPtr, OrderParameters_conduit_offset))\\n                    )\\n\\n                    // Calculate the hash of (itemType, token, identifier).\\n                    dataHash := keccak256(\\n                        receivedItem,\\n                        ReceivedItem_CommonParams_size\\n                    )\\n\\n                    // If component index > 0, swap component pointer with\\n                    // pointer to first component so that any remainder after\\n                    // fulfillment can be added back to the first item.\\n                    let firstFulfillmentHeadPtr := add(offerComponents, OneWord)\\n                    if xor(firstFulfillmentHeadPtr, fulfillmentHeadPtr) {\\n                        let firstFulfillmentPtr := mload(\\n                            firstFulfillmentHeadPtr\\n                        )\\n                        let fulfillmentPtr := mload(fulfillmentHeadPtr)\\n                        mstore(firstFulfillmentHeadPtr, fulfillmentPtr)\\n                    }\\n                }\\n                default {\\n                    // Compare every subsequent item to the first\\n                    if or(\\n                        or(\\n                            // The offerer must match on both items.\\n                            xor(\\n                                mload(paramsPtr),\\n                                mload(\\n                                    add(execution, Execution_offerer_offset)\\n                                )\\n                            ),\\n                            // The conduit key must match on both items.\\n                            xor(\\n                                mload(\\n                                    add(\\n                                        paramsPtr,\\n                                        OrderParameters_conduit_offset\\n                                    )\\n                                ),\\n                                mload(\\n                                    add(execution, Execution_conduit_offset)\\n                                )\\n                            )\\n                        ),\\n                        // The itemType, token, and identifier must match.\\n                        xor(\\n                            dataHash,\\n                            keccak256(\\n                                offerItemPtr,\\n                                ReceivedItem_CommonParams_size\\n                            )\\n                        )\\n                    ) {\\n                        // Throw if any of the requirements are not met.\\n                        throwInvalidFulfillmentComponentData()\\n                    }\\n                }\\n            }\\n\\n            // Write final amount to execution.\\n            mstore(add(mload(execution), Common_amount_offset), amount)\\n\\n            // Determine whether the error buffer contains a nonzero error code.\\n            if errorBuffer {\\n                // If errorBuffer is 1, an item had an amount of zero.\\n                if eq(errorBuffer, 1) {\\n                    // Store left-padded selector with push4 (reduces bytecode)\\n                    // mem[28:32] = selector\\n                    mstore(0, MissingItemAmount_error_selector)\\n\\n                    // revert(abi.encodeWithSignature(\\\"MissingItemAmount()\\\"))\\n                    revert(\\n                        Error_selector_offset,\\n                        MissingItemAmount_error_length\\n                    )\\n                }\\n\\n                // If errorBuffer is not 1 or 0, the sum overflowed.\\n                // Panic!\\n                throwOverflow()\\n            }\\n\\n            // Declare function for reverts on invalid fulfillment data.\\n            function throwInvalidFulfillmentComponentData() {\\n                // Store left-padded selector (uses push4 and reduces code size)\\n                mstore(0, InvalidFulfillmentComponentData_error_selector)\\n\\n                // revert(abi.encodeWithSignature(\\n                //     \\\"InvalidFulfillmentComponentData()\\\"\\n                // ))\\n                revert(\\n                    Error_selector_offset,\\n                    InvalidFulfillmentComponentData_error_length\\n                )\\n            }\\n\\n            // Declare function for reverts due to arithmetic overflows.\\n            function throwOverflow() {\\n                // Store the Panic error signature.\\n                mstore(0, Panic_error_selector)\\n                // Store the arithmetic (0x11) panic code.\\n                mstore(Panic_error_code_ptr, Panic_arithmetic)\\n                // revert(abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x11))\\n                revert(Error_selector_offset, Panic_error_length)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to aggregate a group of consideration items\\n     *      using supplied directives on which component items are candidates\\n     *      for aggregation, skipping items on orders that are not available.\\n     *      Note that this function depends on memory layout affected by an\\n     *      earlier call to _validateOrdersAndPrepareToFulfill.  The memory for\\n     *      the consideration arrays needs to be updated before calling\\n     *      _aggregateValidFulfillmentConsiderationItems.\\n     *      _validateOrdersAndPrepareToFulfill is called in _matchAdvancedOrders\\n     *      and _fulfillAvailableAdvancedOrders in the current version.\\n     *\\n     * @param advancedOrders          The orders to aggregate consideration\\n     *                                items from.\\n     * @param considerationComponents An array of FulfillmentComponent structs\\n     *                                indicating the order index and item index\\n     *                                of each candidate consideration item for\\n     *                                aggregation.\\n     * @param execution               The execution to apply the aggregation to.\\n     */\\n    function _aggregateValidFulfillmentConsiderationItems(\\n        AdvancedOrder[] memory advancedOrders,\\n        FulfillmentComponent[] memory considerationComponents,\\n        Execution memory execution\\n    ) internal pure {\\n        // Utilize assembly in order to efficiently aggregate the items.\\n        assembly {\\n            // Declare a variable for the final aggregated item amount.\\n            let amount\\n\\n            // Create variable to track errors encountered with amount.\\n            let errorBuffer\\n\\n            // Declare variable for hash(itemType, token, identifier, recipient)\\n            let dataHash\\n\\n            for {\\n                // Track position in considerationComponents head.\\n                let fulfillmentHeadPtr := considerationComponents\\n\\n                // Get position one word past last element in head of array.\\n                let endPtr := add(\\n                    considerationComponents,\\n                    shl(OneWordShift, mload(considerationComponents))\\n                )\\n            } lt(fulfillmentHeadPtr, endPtr) {\\n\\n            } {\\n                // Increment position in considerationComponents head.\\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\\n\\n                // Retrieve the order index using the fulfillment pointer.\\n                let orderIndex := mload(mload(fulfillmentHeadPtr))\\n\\n                // Ensure that the order index is not out of range.\\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\\n                    throwInvalidFulfillmentComponentData()\\n                }\\n\\n                // Read advancedOrders[orderIndex] pointer from its array head.\\n                let orderPtr := mload(\\n                    // Calculate head position of advancedOrders[orderIndex].\\n                    add(\\n                        add(advancedOrders, OneWord),\\n                        shl(OneWordShift, orderIndex)\\n                    )\\n                )\\n\\n                // Retrieve item index using an offset of fulfillment pointer.\\n                let itemIndex := mload(\\n                    add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\\n                )\\n\\n                let considerationItemPtr\\n                {\\n                    // Load consideration array pointer.\\n                    let considerationArrPtr := mload(\\n                        add(\\n                            // Read OrderParameters pointer from AdvancedOrder.\\n                            mload(orderPtr),\\n                            OrderParameters_consideration_head_offset\\n                        )\\n                    )\\n\\n                    // If the consideration item index is out of range or the\\n                    // numerator is zero, skip this item.\\n                    if or(\\n                        iszero(lt(itemIndex, mload(considerationArrPtr))),\\n                        iszero(\\n                            mload(add(orderPtr, AdvancedOrder_numerator_offset))\\n                        )\\n                    ) {\\n                        continue\\n                    }\\n\\n                    // Retrieve consideration item pointer using the item index.\\n                    considerationItemPtr := mload(\\n                        add(\\n                            // Get pointer to beginning of receivedItem.\\n                            add(considerationArrPtr, OneWord),\\n                            // Calculate offset to pointer for desired order.\\n                            shl(OneWordShift, itemIndex)\\n                        )\\n                    )\\n                }\\n\\n                // Declare a separate scope for the amount update\\n                {\\n                    // Retrieve amount pointer using consideration item pointer.\\n                    let amountPtr := add(\\n                        considerationItemPtr,\\n                        Common_amount_offset\\n                    )\\n\\n                    // Add consideration item amount to execution amount.\\n                    let newAmount := add(amount, mload(amountPtr))\\n\\n                    // Update error buffer:\\n                    // 1 = zero amount, 2 = overflow, 3 = both.\\n                    errorBuffer := or(\\n                        errorBuffer,\\n                        or(\\n                            shl(1, lt(newAmount, amount)),\\n                            iszero(mload(amountPtr))\\n                        )\\n                    )\\n\\n                    // Update the amount to the new, summed amount.\\n                    amount := newAmount\\n\\n                    // Zero out original item amount to indicate it is credited.\\n                    mstore(amountPtr, 0)\\n                }\\n\\n                // Retrieve ReceivedItem pointer from Execution.\\n                let receivedItem := mload(execution)\\n\\n                switch iszero(dataHash)\\n                case 1 {\\n                    // On first valid item, populate the received item in\\n                    // memory for later comparison.\\n\\n                    // Set the item type on the received item.\\n                    mstore(receivedItem, mload(considerationItemPtr))\\n\\n                    // Set the token on the received item.\\n                    mstore(\\n                        add(receivedItem, Common_token_offset),\\n                        mload(add(considerationItemPtr, Common_token_offset))\\n                    )\\n\\n                    // Set the identifier on the received item.\\n                    mstore(\\n                        add(receivedItem, Common_identifier_offset),\\n                        mload(\\n                            add(considerationItemPtr, Common_identifier_offset)\\n                        )\\n                    )\\n\\n                    // Set the recipient on the received item.\\n                    // Note that this depends on the memory layout affected by\\n                    // _validateOrdersAndPrepareToFulfill.\\n                    mstore(\\n                        add(receivedItem, ReceivedItem_recipient_offset),\\n                        mload(\\n                            add(\\n                                considerationItemPtr,\\n                                ReceivedItem_recipient_offset\\n                            )\\n                        )\\n                    )\\n\\n                    // Calculate the hash of (itemType, token, identifier,\\n                    // recipient). This is run after amount is set to zero, so\\n                    // there will be one blank word after identifier included in\\n                    // the hash buffer.\\n                    dataHash := keccak256(\\n                        considerationItemPtr,\\n                        ReceivedItem_size\\n                    )\\n\\n                    // If component index > 0, swap component pointer with\\n                    // pointer to first component so that any remainder after\\n                    // fulfillment can be added back to the first item.\\n                    let firstFulfillmentHeadPtr := add(\\n                        considerationComponents,\\n                        OneWord\\n                    )\\n                    if xor(firstFulfillmentHeadPtr, fulfillmentHeadPtr) {\\n                        let firstFulfillmentPtr := mload(\\n                            firstFulfillmentHeadPtr\\n                        )\\n                        let fulfillmentPtr := mload(fulfillmentHeadPtr)\\n                        mstore(firstFulfillmentHeadPtr, fulfillmentPtr)\\n                    }\\n                }\\n                default {\\n                    // Compare every subsequent item to the first\\n                    // The itemType, token, identifier and recipient must match.\\n                    if xor(\\n                        dataHash,\\n                        // Calculate the hash of (itemType, token, identifier,\\n                        // recipient). This is run after amount is set to zero,\\n                        // so there will be one blank word after identifier\\n                        // included in the hash buffer.\\n                        keccak256(considerationItemPtr, ReceivedItem_size)\\n                    ) {\\n                        // Throw if any of the requirements are not met.\\n                        throwInvalidFulfillmentComponentData()\\n                    }\\n                }\\n            }\\n\\n            // Retrieve ReceivedItem pointer from Execution.\\n            let receivedItem := mload(execution)\\n\\n            // Write final amount to execution.\\n            mstore(add(receivedItem, Common_amount_offset), amount)\\n\\n            // Determine whether the error buffer contains a nonzero error code.\\n            if errorBuffer {\\n                // If errorBuffer is 1, an item had an amount of zero.\\n                if eq(errorBuffer, 1) {\\n                    // Store left-padded selector with push4, mem[28:32]\\n                    mstore(0, MissingItemAmount_error_selector)\\n\\n                    // revert(abi.encodeWithSignature(\\\"MissingItemAmount()\\\"))\\n                    revert(\\n                        Error_selector_offset,\\n                        MissingItemAmount_error_length\\n                    )\\n                }\\n\\n                // If errorBuffer is not 1 or 0, `amount` overflowed.\\n                // Panic!\\n                throwOverflow()\\n            }\\n\\n            // Declare function for reverts on invalid fulfillment data.\\n            function throwInvalidFulfillmentComponentData() {\\n                // Store the InvalidFulfillmentComponentData error signature.\\n                mstore(0, InvalidFulfillmentComponentData_error_selector)\\n\\n                // Return, supplying InvalidFulfillmentComponentData signature.\\n                revert(\\n                    Error_selector_offset,\\n                    InvalidFulfillmentComponentData_error_length\\n                )\\n            }\\n\\n            // Declare function for reverts due to arithmetic overflows.\\n            function throwOverflow() {\\n                // Store the Panic error signature.\\n                mstore(0, Panic_error_selector)\\n                // Store the arithmetic (0x11) panic code.\\n                mstore(Panic_error_code_ptr, Panic_arithmetic)\\n                // revert(abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x11))\\n                revert(Error_selector_offset, Panic_error_length)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ConsiderationErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { Side } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @dev Reverts the current transaction with a \\\"BadFraction\\\" error message.\\n */\\nfunction _revertBadFraction() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, BadFraction_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"BadFraction()\\\"))\\n        revert(Error_selector_offset, BadFraction_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with a \\\"ConsiderationNotMet\\\" error\\n *      message, including the provided order index, consideration index, and\\n *      shortfall amount.\\n *\\n * @param orderIndex         The index of the order that did not meet the\\n *                           consideration criteria.\\n * @param considerationIndex The index of the consideration item that did not\\n *                           meet its criteria.\\n * @param shortfallAmount    The amount by which the consideration criteria were\\n *                           not met.\\n */\\nfunction _revertConsiderationNotMet(\\n    uint256 orderIndex,\\n    uint256 considerationIndex,\\n    uint256 shortfallAmount\\n) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, ConsiderationNotMet_error_selector)\\n\\n        // Store arguments.\\n        mstore(ConsiderationNotMet_error_orderIndex_ptr, orderIndex)\\n        mstore(\\n            ConsiderationNotMet_error_considerationIndex_ptr,\\n            considerationIndex\\n        )\\n        mstore(ConsiderationNotMet_error_shortfallAmount_ptr, shortfallAmount)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"ConsiderationNotMet(uint256,uint256,uint256)\\\",\\n        //     orderIndex,\\n        //     considerationIndex,\\n        //     shortfallAmount\\n        // ))\\n        revert(Error_selector_offset, ConsiderationNotMet_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with a \\\"CriteriaNotEnabledForItem\\\" error\\n *      message.\\n */\\nfunction _revertCriteriaNotEnabledForItem() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, CriteriaNotEnabledForItem_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"CriteriaNotEnabledForItem()\\\"))\\n        revert(Error_selector_offset, CriteriaNotEnabledForItem_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InsufficientEtherSupplied\\\"\\n *      error message.\\n */\\nfunction _revertInsufficientEtherSupplied() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InsufficientEtherSupplied_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"InsufficientEtherSupplied()\\\"))\\n        revert(Error_selector_offset, InsufficientEtherSupplied_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an\\n *      \\\"InvalidBasicOrderParameterEncoding\\\" error message.\\n */\\nfunction _revertInvalidBasicOrderParameterEncoding() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidBasicOrderParameterEncoding_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"InvalidBasicOrderParameterEncoding()\\\"\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            InvalidBasicOrderParameterEncoding_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidCallToConduit\\\" error\\n *      message, including the provided address of the conduit that was called\\n *      improperly.\\n *\\n * @param conduit The address of the conduit that was called improperly.\\n */\\nfunction _revertInvalidCallToConduit(address conduit) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidCallToConduit_error_selector)\\n\\n        // Store argument.\\n        mstore(InvalidCallToConduit_error_conduit_ptr, conduit)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"InvalidCallToConduit(address)\\\",\\n        //     conduit\\n        // ))\\n        revert(Error_selector_offset, InvalidCallToConduit_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"CannotCancelOrder\\\" error\\n *      message.\\n */\\nfunction _revertCannotCancelOrder() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, CannotCancelOrder_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"CannotCancelOrder()\\\"))\\n        revert(Error_selector_offset, CannotCancelOrder_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidConduit\\\" error message,\\n *      including the provided key and address of the invalid conduit.\\n *\\n * @param conduitKey    The key of the invalid conduit.\\n * @param conduit       The address of the invalid conduit.\\n */\\nfunction _revertInvalidConduit(bytes32 conduitKey, address conduit) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidConduit_error_selector)\\n\\n        // Store arguments.\\n        mstore(InvalidConduit_error_conduitKey_ptr, conduitKey)\\n        mstore(InvalidConduit_error_conduit_ptr, conduit)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"InvalidConduit(bytes32,address)\\\",\\n        //     conduitKey,\\n        //     conduit\\n        // ))\\n        revert(Error_selector_offset, InvalidConduit_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidERC721TransferAmount\\\"\\n *      error message.\\n *\\n * @param amount The invalid amount.\\n */\\nfunction _revertInvalidERC721TransferAmount(uint256 amount) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidERC721TransferAmount_error_selector)\\n\\n        // Store argument.\\n        mstore(InvalidERC721TransferAmount_error_amount_ptr, amount)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"InvalidERC721TransferAmount(uint256)\\\",\\n        //     amount\\n        // ))\\n        revert(Error_selector_offset, InvalidERC721TransferAmount_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidMsgValue\\\" error message,\\n *      including the invalid value that was sent in the transaction's\\n *      `msg.value` field.\\n *\\n * @param value The invalid value that was sent in the transaction's `msg.value`\\n *              field.\\n */\\nfunction _revertInvalidMsgValue(uint256 value) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidMsgValue_error_selector)\\n\\n        // Store argument.\\n        mstore(InvalidMsgValue_error_value_ptr, value)\\n\\n        // revert(abi.encodeWithSignature(\\\"InvalidMsgValue(uint256)\\\", value))\\n        revert(Error_selector_offset, InvalidMsgValue_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidNativeOfferItem\\\" error\\n *      message.\\n */\\nfunction _revertInvalidNativeOfferItem() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidNativeOfferItem_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"InvalidNativeOfferItem()\\\"))\\n        revert(Error_selector_offset, InvalidNativeOfferItem_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidProof\\\" error message.\\n */\\nfunction _revertInvalidProof() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidProof_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"InvalidProof()\\\"))\\n        revert(Error_selector_offset, InvalidProof_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidContractOrder\\\" error\\n *      message.\\n *\\n * @param orderHash The hash of the contract order that caused the error.\\n */\\nfunction _revertInvalidContractOrder(bytes32 orderHash) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidContractOrder_error_selector)\\n\\n        // Store arguments.\\n        mstore(InvalidContractOrder_error_orderHash_ptr, orderHash)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"InvalidContractOrder(bytes32)\\\",\\n        //     orderHash\\n        // ))\\n        revert(Error_selector_offset, InvalidContractOrder_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidTime\\\" error message.\\n *\\n * @param startTime       The time at which the order becomes active.\\n * @param endTime         The time at which the order becomes inactive.\\n */\\nfunction _revertInvalidTime(uint256 startTime, uint256 endTime) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidTime_error_selector)\\n\\n        // Store arguments.\\n        mstore(InvalidTime_error_startTime_ptr, startTime)\\n        mstore(InvalidTime_error_endTime_ptr, endTime)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"InvalidTime(uint256,uint256)\\\",\\n        //     startTime,\\n        //     endTime\\n        // ))\\n        revert(Error_selector_offset, InvalidTime_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a\\n *      \\\"MismatchedFulfillmentOfferAndConsiderationComponents\\\" error message.\\n *\\n * @param fulfillmentIndex         The index of the fulfillment that caused the\\n *                                 error.\\n */\\nfunction _revertMismatchedFulfillmentOfferAndConsiderationComponents(\\n    uint256 fulfillmentIndex\\n) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(\\n            0,\\n            MismatchedFulfillmentOfferAndConsiderationComponents_error_selector\\n        )\\n\\n        // Store argument.\\n        mstore(\\n            MismatchedFulfillmentOfferAndConsiderationComponents_error_fulfillmentIndex_ptr,\\n            fulfillmentIndex\\n        )\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"MismatchedFulfillmentOfferAndConsiderationComponents(uint256)\\\",\\n        //     fulfillmentIndex\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            MismatchedFulfillmentOfferAndConsiderationComponents_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"MissingFulfillmentComponentOnAggregation\\\"\\n *       error message.\\n *\\n * @param side The side of the fulfillment component that is missing (0 for\\n *             offer, 1 for consideration).\\n *\\n */\\nfunction _revertMissingFulfillmentComponentOnAggregation(Side side) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, MissingFulfillmentComponentOnAggregation_error_selector)\\n\\n        // Store argument.\\n        mstore(MissingFulfillmentComponentOnAggregation_error_side_ptr, side)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"MissingFulfillmentComponentOnAggregation(uint8)\\\",\\n        //     side\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            MissingFulfillmentComponentOnAggregation_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"MissingOriginalConsiderationItems\\\" error\\n *      message.\\n */\\nfunction _revertMissingOriginalConsiderationItems() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, MissingOriginalConsiderationItems_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"MissingOriginalConsiderationItems()\\\"\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            MissingOriginalConsiderationItems_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"NoReentrantCalls\\\" error message.\\n */\\nfunction _revertNoReentrantCalls() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, NoReentrantCalls_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"NoReentrantCalls()\\\"))\\n        revert(Error_selector_offset, NoReentrantCalls_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"NoSpecifiedOrdersAvailable\\\" error message.\\n */\\nfunction _revertNoSpecifiedOrdersAvailable() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, NoSpecifiedOrdersAvailable_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"NoSpecifiedOrdersAvailable()\\\"))\\n        revert(Error_selector_offset, NoSpecifiedOrdersAvailable_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"OfferAndConsiderationRequiredOnFulfillment\\\"\\n *      error message.\\n */\\nfunction _revertOfferAndConsiderationRequiredOnFulfillment() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, OfferAndConsiderationRequiredOnFulfillment_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"OfferAndConsiderationRequiredOnFulfillment()\\\"\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            OfferAndConsiderationRequiredOnFulfillment_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"OrderAlreadyFilled\\\" error message.\\n *\\n * @param orderHash The hash of the order that has already been filled.\\n */\\nfunction _revertOrderAlreadyFilled(bytes32 orderHash) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, OrderAlreadyFilled_error_selector)\\n\\n        // Store argument.\\n        mstore(OrderAlreadyFilled_error_orderHash_ptr, orderHash)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"OrderAlreadyFilled(bytes32)\\\",\\n        //     orderHash\\n        // ))\\n        revert(Error_selector_offset, OrderAlreadyFilled_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"OrderCriteriaResolverOutOfRange\\\" error\\n *      message.\\n *\\n * @param side The side of the criteria that is missing (0 for offer, 1 for\\n *             consideration).\\n *\\n */\\nfunction _revertOrderCriteriaResolverOutOfRange(Side side) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, OrderCriteriaResolverOutOfRange_error_selector)\\n\\n        // Store argument.\\n        mstore(OrderCriteriaResolverOutOfRange_error_side_ptr, side)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"OrderCriteriaResolverOutOfRange(uint8)\\\",\\n        //     side\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            OrderCriteriaResolverOutOfRange_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"OrderIsCancelled\\\" error message.\\n *\\n * @param orderHash The hash of the order that has already been cancelled.\\n */\\nfunction _revertOrderIsCancelled(bytes32 orderHash) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, OrderIsCancelled_error_selector)\\n\\n        // Store argument.\\n        mstore(OrderIsCancelled_error_orderHash_ptr, orderHash)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"OrderIsCancelled(bytes32)\\\",\\n        //     orderHash\\n        // ))\\n        revert(Error_selector_offset, OrderIsCancelled_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"OrderPartiallyFilled\\\" error message.\\n *\\n * @param orderHash The hash of the order that has already been partially\\n *                  filled.\\n */\\nfunction _revertOrderPartiallyFilled(bytes32 orderHash) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, OrderPartiallyFilled_error_selector)\\n\\n        // Store argument.\\n        mstore(OrderPartiallyFilled_error_orderHash_ptr, orderHash)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"OrderPartiallyFilled(bytes32)\\\",\\n        //     orderHash\\n        // ))\\n        revert(Error_selector_offset, OrderPartiallyFilled_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"PartialFillsNotEnabledForOrder\\\" error message.\\n */\\nfunction _revertPartialFillsNotEnabledForOrder() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, PartialFillsNotEnabledForOrder_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"PartialFillsNotEnabledForOrder()\\\"))\\n        revert(\\n            Error_selector_offset,\\n            PartialFillsNotEnabledForOrder_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"UnresolvedConsiderationCriteria\\\" error\\n *      message.\\n */\\nfunction _revertUnresolvedConsiderationCriteria(\\n    uint256 orderIndex,\\n    uint256 considerationIndex\\n) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, UnresolvedConsiderationCriteria_error_selector)\\n\\n        // Store arguments.\\n        mstore(UnresolvedConsiderationCriteria_error_orderIndex_ptr, orderIndex)\\n        mstore(\\n            UnresolvedConsiderationCriteria_error_considerationIndex_ptr,\\n            considerationIndex\\n        )\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"UnresolvedConsiderationCriteria(uint256, uint256)\\\",\\n        //     orderIndex,\\n        //     considerationIndex\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            UnresolvedConsiderationCriteria_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"UnresolvedOfferCriteria\\\" error message.\\n */\\nfunction _revertUnresolvedOfferCriteria(\\n    uint256 orderIndex,\\n    uint256 offerIndex\\n) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, UnresolvedOfferCriteria_error_selector)\\n\\n        // Store arguments.\\n        mstore(UnresolvedOfferCriteria_error_orderIndex_ptr, orderIndex)\\n        mstore(UnresolvedOfferCriteria_error_offerIndex_ptr, offerIndex)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"UnresolvedOfferCriteria(uint256, uint256)\\\",\\n        //     orderIndex,\\n        //     offerIndex\\n        // ))\\n        revert(Error_selector_offset, UnresolvedOfferCriteria_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"UnusedItemParameters\\\" error message.\\n */\\nfunction _revertUnusedItemParameters() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, UnusedItemParameters_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"UnusedItemParameters()\\\"))\\n        revert(Error_selector_offset, UnusedItemParameters_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"ConsiderationLengthNotEqualToTotalOriginal\\\"\\n *      error message.\\n */\\nfunction _revertConsiderationLengthNotEqualToTotalOriginal() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, ConsiderationLengthNotEqualToTotalOriginal_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"ConsiderationLengthNotEqualToTotalOriginal()\\\"\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            ConsiderationLengthNotEqualToTotalOriginal_error_length\\n        )\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/BasicOrderFulfiller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport {\\n    OrderType,\\n    ItemType,\\n    BasicOrderRouteType\\n} from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    AdditionalRecipient,\\n    BasicOrderParameters,\\n    OfferItem,\\n    ConsiderationItem,\\n    SpentItem,\\n    ReceivedItem\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { OrderValidator } from \\\"./OrderValidator.sol\\\";\\n\\nimport \\\"./ConsiderationErrors.sol\\\";\\n\\n/**\\n * @title BasicOrderFulfiller\\n * @author 0age\\n * @notice BasicOrderFulfiller contains functionality for fulfilling \\\"basic\\\"\\n *         orders with minimal overhead. See documentation for details on what\\n *         qualifies as a basic order.\\n */\\ncontract BasicOrderFulfiller is OrderValidator {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) OrderValidator(conduitController) {}\\n\\n    /**\\n     * @dev Internal function to fulfill an order offering an ERC20, ERC721, or\\n     *      ERC1155 item by supplying Ether (or other native tokens), ERC20\\n     *      tokens, an ERC721 item, or an ERC1155 item as consideration. Six\\n     *      permutations are supported: Native token to ERC721, Native token to\\n     *      ERC1155, ERC20 to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and\\n     *      ERC1155 to ERC20 (with native tokens supplied as msg.value). For an\\n     *      order to be eligible for fulfillment via this method, it must\\n     *      contain a single offer item (though that item may have a greater\\n     *      amount if the item is not an ERC721). An arbitrary number of\\n     *      \\\"additional recipients\\\" may also be supplied which will each receive\\n     *      native tokens or ERC20 items from the fulfiller as consideration.\\n     *      Refer to the documentation for a more comprehensive summary of how\\n     *      to utilize this method and what orders are compatible with it.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer and the fulfiller must first approve\\n     *                   this contract (or their chosen conduit if indicated)\\n     *                   before any tokens can be transferred. Also note that\\n     *                   contract recipients of ERC1155 consideration items must\\n     *                   implement `onERC1155Received` in order to receive those\\n     *                   items.\\n     *\\n     * @return A boolean indicating whether the order has been fulfilled.\\n     */\\n    function _validateAndFulfillBasicOrder(\\n        BasicOrderParameters calldata parameters\\n    ) internal returns (bool) {\\n        // Declare enums for order type & route to extract from basicOrderType.\\n        BasicOrderRouteType route;\\n        OrderType orderType;\\n\\n        // Declare additional recipient item type to derive from the route type.\\n        ItemType additionalRecipientsItemType;\\n\\n        bytes32 orderHash;\\n\\n        // Utilize assembly to extract the order type and the basic order route.\\n        assembly {\\n            // Read basicOrderType from calldata.\\n            let basicOrderType := calldataload(BasicOrder_basicOrderType_cdPtr)\\n\\n            // Mask all but 2 least-significant bits to derive the order type.\\n            orderType := and(basicOrderType, 3)\\n\\n            // Divide basicOrderType by four to derive the route.\\n            route := shr(2, basicOrderType)\\n\\n            // If route > 1 additionalRecipient items are ERC20 (1) else Eth (0)\\n            additionalRecipientsItemType := gt(route, 1)\\n        }\\n\\n        {\\n            // Declare temporary variable for enforcing payable status.\\n            bool correctPayableStatus;\\n\\n            // Utilize assembly to compare the route to the callvalue.\\n            assembly {\\n                // route 0 and 1 are payable, otherwise route is not payable.\\n                correctPayableStatus := eq(\\n                    additionalRecipientsItemType,\\n                    iszero(callvalue())\\n                )\\n            }\\n\\n            // Revert if msg.value has not been supplied as part of payable\\n            // routes or has been supplied as part of non-payable routes.\\n            if (!correctPayableStatus) {\\n                _revertInvalidMsgValue(msg.value);\\n            }\\n        }\\n\\n        // Declare more arguments that will be derived from route and calldata.\\n        address additionalRecipientsToken;\\n        ItemType offeredItemType;\\n        bool offerTypeIsAdditionalRecipientsType;\\n\\n        // Declare scope for received item type to manage stack pressure.\\n        {\\n            ItemType receivedItemType;\\n\\n            // Utilize assembly to retrieve function arguments and cast types.\\n            assembly {\\n                // Check if offered item type == additional recipient item type.\\n                offerTypeIsAdditionalRecipientsType := gt(route, 3)\\n\\n                // If route > 3 additionalRecipientsToken is at 0xc4 else 0x24.\\n                additionalRecipientsToken := calldataload(\\n                    add(\\n                        BasicOrder_considerationToken_cdPtr,\\n                        mul(\\n                            offerTypeIsAdditionalRecipientsType,\\n                            BasicOrder_common_params_size\\n                        )\\n                    )\\n                )\\n\\n                // If route > 2, receivedItemType is route - 2. If route is 2,\\n                // the receivedItemType is ERC20 (1). Otherwise, it is Eth (0).\\n                receivedItemType := byte(route, BasicOrder_receivedItemByteMap)\\n\\n                // If route > 3, offeredItemType is ERC20 (1). Route is 2 or 3,\\n                // offeredItemType = route. Route is 0 or 1, it is route + 2.\\n                offeredItemType := byte(route, BasicOrder_offeredItemByteMap)\\n            }\\n\\n            // Derive & validate order using parameters and update order status.\\n            orderHash = _prepareBasicFulfillmentFromCalldata(\\n                parameters,\\n                orderType,\\n                receivedItemType,\\n                additionalRecipientsItemType,\\n                additionalRecipientsToken,\\n                offeredItemType\\n            );\\n        }\\n\\n        // Declare conduitKey argument used by transfer functions.\\n        bytes32 conduitKey;\\n\\n        // Utilize assembly to derive conduit (if relevant) based on route.\\n        assembly {\\n            // use offerer conduit for routes 0-3, fulfiller conduit otherwise.\\n            conduitKey := calldataload(\\n                add(\\n                    BasicOrder_offererConduit_cdPtr,\\n                    shl(OneWordShift, offerTypeIsAdditionalRecipientsType)\\n                )\\n            )\\n        }\\n\\n        // Transfer tokens based on the route.\\n        if (additionalRecipientsItemType == ItemType.NATIVE) {\\n            // Ensure neither the token nor the identifier parameters are set.\\n            if (\\n                (uint160(parameters.considerationToken) |\\n                    parameters.considerationIdentifier) != 0\\n            ) {\\n                _revertUnusedItemParameters();\\n            }\\n\\n            // Transfer the ERC721 or ERC1155 item, bypassing the accumulator.\\n            _transferIndividual721Or1155Item(\\n                offeredItemType,\\n                parameters.offerToken,\\n                parameters.offerer,\\n                msg.sender,\\n                parameters.offerIdentifier,\\n                parameters.offerAmount,\\n                conduitKey\\n            );\\n\\n            // Transfer native to recipients, return excess to caller & wrap up.\\n            _transferNativeTokensAndFinalize(\\n                parameters.considerationAmount,\\n                parameters.offerer\\n            );\\n        } else {\\n            // Initialize an accumulator array. From this point forward, no new\\n            // memory regions can be safely allocated until the accumulator is\\n            // no longer being utilized, as the accumulator operates in an\\n            // open-ended fashion from this memory pointer; existing memory may\\n            // still be accessed and modified, however.\\n            bytes memory accumulator = new bytes(AccumulatorDisarmed);\\n\\n            // Choose transfer method for ERC721 or ERC1155 item based on route.\\n            if (route == BasicOrderRouteType.ERC20_TO_ERC721) {\\n                // Transfer ERC721 to caller using offerer's conduit preference.\\n                _transferERC721(\\n                    parameters.offerToken,\\n                    parameters.offerer,\\n                    msg.sender,\\n                    parameters.offerIdentifier,\\n                    parameters.offerAmount,\\n                    conduitKey,\\n                    accumulator\\n                );\\n            } else if (route == BasicOrderRouteType.ERC20_TO_ERC1155) {\\n                // Transfer ERC1155 to caller with offerer's conduit preference.\\n                _transferERC1155(\\n                    parameters.offerToken,\\n                    parameters.offerer,\\n                    msg.sender,\\n                    parameters.offerIdentifier,\\n                    parameters.offerAmount,\\n                    conduitKey,\\n                    accumulator\\n                );\\n            } else if (route == BasicOrderRouteType.ERC721_TO_ERC20) {\\n                // Transfer ERC721 to offerer using caller's conduit preference.\\n                _transferERC721(\\n                    parameters.considerationToken,\\n                    msg.sender,\\n                    parameters.offerer,\\n                    parameters.considerationIdentifier,\\n                    parameters.considerationAmount,\\n                    conduitKey,\\n                    accumulator\\n                );\\n            } else {\\n                // route == BasicOrderRouteType.ERC1155_TO_ERC20\\n\\n                // Transfer ERC1155 to offerer with caller's conduit preference.\\n                _transferERC1155(\\n                    parameters.considerationToken,\\n                    msg.sender,\\n                    parameters.offerer,\\n                    parameters.considerationIdentifier,\\n                    parameters.considerationAmount,\\n                    conduitKey,\\n                    accumulator\\n                );\\n            }\\n\\n            // Transfer ERC20 tokens to all recipients and wrap up.\\n            _transferERC20AndFinalize(\\n                parameters.offerer,\\n                parameters,\\n                offerTypeIsAdditionalRecipientsType,\\n                accumulator\\n            );\\n\\n            // Trigger any remaining accumulated transfers via call to conduit.\\n            _triggerIfArmed(accumulator);\\n        }\\n\\n        // Determine whether order is restricted and, if so, that it is valid.\\n        _assertRestrictedBasicOrderValidity(orderHash, orderType, parameters);\\n\\n        // Clear the reentrancy guard.\\n        _clearReentrancyGuard();\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function to prepare fulfillment of a basic order with\\n     *      manual calldata and memory access. This calculates the order hash,\\n     *      emits an OrderFulfilled event, and asserts basic order validity.\\n     *      Note that calldata offsets must be validated as this function\\n     *      accesses constant calldata pointers for dynamic types that match\\n     *      default ABI encoding, but valid ABI encoding can use arbitrary\\n     *      offsets. Checking that the offsets were produced by default encoding\\n     *      will ensure that other functions using Solidity's calldata accessors\\n     *      (which calculate pointers from the stored offsets) are reading the\\n     *      same data as the order hash is derived from. Also note that this\\n     *      function accesses memory directly.\\n     *\\n     * @param parameters                   The parameters of the basic order.\\n     * @param orderType                    The order type.\\n     * @param receivedItemType             The item type of the initial\\n     *                                     consideration item on the order.\\n     * @param additionalRecipientsItemType The item type of any additional\\n     *                                     consideration item on the order.\\n     * @param additionalRecipientsToken    The ERC20 token contract address (if\\n     *                                     applicable) for any additional\\n     *                                     consideration item on the order.\\n     * @param offeredItemType              The item type of the offered item on\\n     *                                     the order.\\n     * @return orderHash The calculated order hash.\\n     */\\n    function _prepareBasicFulfillmentFromCalldata(\\n        BasicOrderParameters calldata parameters,\\n        OrderType orderType,\\n        ItemType receivedItemType,\\n        ItemType additionalRecipientsItemType,\\n        address additionalRecipientsToken,\\n        ItemType offeredItemType\\n    ) internal returns (bytes32 orderHash) {\\n        // Ensure this function cannot be triggered during a reentrant call.\\n        _setReentrancyGuard(false); // Native tokens rejected during execution.\\n\\n        // Ensure current timestamp falls between order start time and end time.\\n        _verifyTime(parameters.startTime, parameters.endTime, true);\\n\\n        // Verify that calldata offsets for all dynamic types were produced by\\n        // default encoding. This ensures that the constants used for calldata\\n        // pointers to dynamic types are the same as those calculated by\\n        // Solidity using their offsets. Also verify that the basic order type\\n        // is within range.\\n        _assertValidBasicOrderParameters();\\n\\n        {\\n            // Retrieve total number of additional recipients & place on stack.\\n            uint256 totalAdditionalRecipients;\\n            assembly {\\n                totalAdditionalRecipients := calldataload(\\n                    BasicOrder_additionalRecipients_length_cdPtr\\n                )\\n            }\\n\\n            // Ensure consideration array length is not less than original.\\n            _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\\n                totalAdditionalRecipients,\\n                parameters.totalOriginalAdditionalRecipients\\n            );\\n        }\\n\\n        {\\n            /**\\n             * First, handle consideration items. Memory Layout:\\n             *  0x60: final hash of the array of consideration item hashes\\n             *  0x80-0x160: reused space for EIP712 hashing of each item\\n             *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\\n             *   - 0xa0: itemType\\n             *   - 0xc0: token\\n             *   - 0xe0: identifier\\n             *   - 0x100: startAmount\\n             *   - 0x120: endAmount\\n             *   - 0x140: recipient\\n             *  0x160-END_ARR: array of consideration item hashes\\n             *   - 0x160: primary consideration item EIP712 hash\\n             *   - 0x180-END_ARR: additional recipient item EIP712 hashes\\n             *  END_ARR: beginning of data for OrderFulfilled event\\n             *   - END_ARR + 0x120: length of ReceivedItem array\\n             *   - END_ARR + 0x140: beginning of data for first ReceivedItem\\n             * (Note: END_ARR = 0x180 + RECIPIENTS_LENGTH * 0x20)\\n             */\\n\\n            // Load consideration item typehash from runtime and place on stack.\\n            bytes32 typeHash = _CONSIDERATION_ITEM_TYPEHASH;\\n\\n            // Utilize assembly to enable reuse of memory regions and use\\n            // constant pointers when possible.\\n            assembly {\\n                /*\\n                 * 1. Calculate the EIP712 ConsiderationItem hash for the\\n                 * primary consideration item of the basic order.\\n                 */\\n\\n                // Write ConsiderationItem type hash and item type to memory.\\n                mstore(BasicOrder_considerationItem_typeHash_ptr, typeHash)\\n                mstore(\\n                    BasicOrder_considerationItem_itemType_ptr,\\n                    receivedItemType\\n                )\\n\\n                // Copy calldata region with (token, identifier, amount) from\\n                // BasicOrderParameters to ConsiderationItem. The\\n                // considerationAmount is written to startAmount and endAmount\\n                // as basic orders do not have dynamic amounts.\\n                calldatacopy(\\n                    BasicOrder_considerationItem_token_ptr,\\n                    BasicOrder_considerationToken_cdPtr,\\n                    ThreeWords\\n                )\\n\\n                // Copy calldata region with considerationAmount and offerer\\n                // from BasicOrderParameters to endAmount and recipient in\\n                // ConsiderationItem.\\n                calldatacopy(\\n                    BasicOrder_considerationItem_endAmount_ptr,\\n                    BasicOrder_considerationAmount_cdPtr,\\n                    TwoWords\\n                )\\n\\n                // Calculate EIP712 ConsiderationItem hash and store it in the\\n                // array of EIP712 consideration hashes.\\n                mstore(\\n                    BasicOrder_considerationHashesArray_ptr,\\n                    keccak256(\\n                        BasicOrder_considerationItem_typeHash_ptr,\\n                        EIP712_ConsiderationItem_size\\n                    )\\n                )\\n\\n                /*\\n                 * 2. Write a ReceivedItem struct for the primary consideration\\n                 * item to the consideration array in OrderFulfilled.\\n                 */\\n\\n                // Get the length of the additional recipients array.\\n                let totalAdditionalRecipients := calldataload(\\n                    BasicOrder_additionalRecipients_length_cdPtr\\n                )\\n\\n                // Calculate pointer to length of OrderFulfilled consideration\\n                // array.\\n                let eventConsiderationArrPtr := add(\\n                    OrderFulfilled_consideration_length_baseOffset,\\n                    shl(OneWordShift, totalAdditionalRecipients)\\n                )\\n\\n                // Set the length of the consideration array to the number of\\n                // additional recipients, plus one for the primary consideration\\n                // item.\\n                mstore(\\n                    eventConsiderationArrPtr,\\n                    add(totalAdditionalRecipients, 1)\\n                )\\n\\n                // Overwrite the consideration array pointer so it points to the\\n                // body of the first element\\n                eventConsiderationArrPtr := add(\\n                    eventConsiderationArrPtr,\\n                    OneWord\\n                )\\n\\n                // Set itemType at start of the ReceivedItem memory region.\\n                mstore(eventConsiderationArrPtr, receivedItemType)\\n\\n                // Copy calldata region (token, identifier, amount & recipient)\\n                // from BasicOrderParameters to ReceivedItem memory.\\n                calldatacopy(\\n                    add(eventConsiderationArrPtr, Common_token_offset),\\n                    BasicOrder_considerationToken_cdPtr,\\n                    FourWords\\n                )\\n\\n                /*\\n                 * 3. Calculate EIP712 ConsiderationItem hashes for original\\n                 * additional recipients and add a ReceivedItem for each to the\\n                 * consideration array in the OrderFulfilled event. The original\\n                 * additional recipients are all the consideration items signed\\n                 * by the offerer aside from the primary consideration items of\\n                 * the order. Uses memory region from 0x80-0x160 as a buffer for\\n                 * calculating EIP712 ConsiderationItem hashes.\\n                 */\\n\\n                // Put pointer to consideration hashes array on the stack.\\n                // This will be updated as each additional recipient is hashed\\n                let\\n                    considerationHashesPtr\\n                := BasicOrder_considerationHashesArray_ptr\\n\\n                // Write item type, token, & identifier for additional recipient\\n                // to memory region for hashing EIP712 ConsiderationItem; these\\n                // values will be reused for each recipient.\\n                mstore(\\n                    BasicOrder_considerationItem_itemType_ptr,\\n                    additionalRecipientsItemType\\n                )\\n                mstore(\\n                    BasicOrder_considerationItem_token_ptr,\\n                    additionalRecipientsToken\\n                )\\n                mstore(BasicOrder_considerationItem_identifier_ptr, 0)\\n\\n                // Read length of the additionalRecipients array from calldata\\n                // and iterate.\\n                totalAdditionalRecipients := calldataload(\\n                    BasicOrder_totalOriginalAdditionalRecipients_cdPtr\\n                )\\n                let i := 0\\n                // prettier-ignore\\n                for {} lt(i, totalAdditionalRecipients) {\\n                    i := add(i, 1)\\n                } {\\n                    /*\\n                     * Calculate EIP712 ConsiderationItem hash for recipient.\\n                     */\\n\\n                    // Retrieve calldata pointer for additional recipient.\\n                    let additionalRecipientCdPtr := add(\\n                        BasicOrder_additionalRecipients_data_cdPtr,\\n                        mul(AdditionalRecipient_size, i)\\n                    )\\n\\n                    // Copy startAmount from calldata to the ConsiderationItem\\n                    // struct.\\n                    calldatacopy(\\n                        BasicOrder_considerationItem_startAmount_ptr,\\n                        additionalRecipientCdPtr,\\n                        OneWord\\n                    )\\n\\n                    // Copy endAmount and recipient from calldata to the\\n                    // ConsiderationItem struct.\\n                    calldatacopy(\\n                        BasicOrder_considerationItem_endAmount_ptr,\\n                        additionalRecipientCdPtr,\\n                        AdditionalRecipient_size\\n                    )\\n\\n                    // Add 1 word to the pointer as part of each loop to reduce\\n                    // operations needed to get local offset into the array.\\n                    considerationHashesPtr := add(\\n                        considerationHashesPtr,\\n                        OneWord\\n                    )\\n\\n                    // Calculate EIP712 ConsiderationItem hash and store it in\\n                    // the array of consideration hashes.\\n                    mstore(\\n                        considerationHashesPtr,\\n                        keccak256(\\n                            BasicOrder_considerationItem_typeHash_ptr,\\n                            EIP712_ConsiderationItem_size\\n                        )\\n                    )\\n\\n                    /*\\n                     * Write ReceivedItem to OrderFulfilled data.\\n                     */\\n\\n                    // At this point, eventConsiderationArrPtr points to the\\n                    // beginning of the ReceivedItem struct of the previous\\n                    // element in the array. Increase it by the size of the\\n                    // struct to arrive at the pointer for the current element.\\n                    eventConsiderationArrPtr := add(\\n                        eventConsiderationArrPtr,\\n                        ReceivedItem_size\\n                    )\\n\\n                    // Write itemType to the ReceivedItem struct.\\n                    mstore(\\n                        eventConsiderationArrPtr,\\n                        additionalRecipientsItemType\\n                    )\\n\\n                    // Write token to the next word of the ReceivedItem struct.\\n                    mstore(\\n                        add(eventConsiderationArrPtr, OneWord),\\n                        additionalRecipientsToken\\n                    )\\n\\n                    // Copy endAmount & recipient words to ReceivedItem struct.\\n                    calldatacopy(\\n                        add(\\n                            eventConsiderationArrPtr,\\n                            ReceivedItem_amount_offset\\n                        ),\\n                        additionalRecipientCdPtr,\\n                        TwoWords\\n                    )\\n                }\\n\\n                /*\\n                 * 4. Hash packed array of ConsiderationItem EIP712 hashes:\\n                 *   `keccak256(abi.encodePacked(receivedItemHashes))`\\n                 * Note that it is set at 0x60 — all other memory begins at\\n                 * 0x80. 0x60 is the \\\"zero slot\\\" and will be restored at the end\\n                 * of the assembly section and before required by the compiler.\\n                 */\\n                mstore(\\n                    receivedItemsHash_ptr,\\n                    keccak256(\\n                        BasicOrder_considerationHashesArray_ptr,\\n                        shl(OneWordShift, add(totalAdditionalRecipients, 1))\\n                    )\\n                )\\n\\n                /*\\n                 * 5. Add a ReceivedItem for each tip to the consideration array\\n                 * in the OrderFulfilled event. The tips are all the\\n                 * consideration items that were not signed by the offerer and\\n                 * were provided by the fulfiller.\\n                 */\\n\\n                // Overwrite length to length of the additionalRecipients array.\\n                totalAdditionalRecipients := calldataload(\\n                    BasicOrder_additionalRecipients_length_cdPtr\\n                )\\n                // prettier-ignore\\n                for {} lt(i, totalAdditionalRecipients) {\\n                    i := add(i, 1)\\n                } {\\n                    // Retrieve calldata pointer for additional recipient.\\n                    let additionalRecipientCdPtr := add(\\n                        BasicOrder_additionalRecipients_data_cdPtr,\\n                        mul(AdditionalRecipient_size, i)\\n                    )\\n\\n                    // At this point, eventConsiderationArrPtr points to the\\n                    // beginning of the ReceivedItem struct of the previous\\n                    // element in the array. Increase it by the size of the\\n                    // struct to arrive at the pointer for the current element.\\n                    eventConsiderationArrPtr := add(\\n                        eventConsiderationArrPtr,\\n                        ReceivedItem_size\\n                    )\\n\\n                    // Write itemType to the ReceivedItem struct.\\n                    mstore(\\n                        eventConsiderationArrPtr,\\n                        additionalRecipientsItemType\\n                    )\\n\\n                    // Write token to the next word of the ReceivedItem struct.\\n                    mstore(\\n                        add(eventConsiderationArrPtr, OneWord),\\n                        additionalRecipientsToken\\n                    )\\n\\n                    // Copy endAmount & recipient words to ReceivedItem struct.\\n                    calldatacopy(\\n                        add(\\n                            eventConsiderationArrPtr,\\n                            ReceivedItem_amount_offset\\n                        ),\\n                        additionalRecipientCdPtr,\\n                        TwoWords\\n                    )\\n                }\\n            }\\n        }\\n\\n        {\\n            /**\\n             * Next, handle offered items. Memory Layout:\\n             *  EIP712 data for OfferItem\\n             *   - 0x80:  OfferItem EIP-712 typehash (constant)\\n             *   - 0xa0:  itemType\\n             *   - 0xc0:  token\\n             *   - 0xe0:  identifier (reused for offeredItemsHash)\\n             *   - 0x100: startAmount\\n             *   - 0x120: endAmount\\n             */\\n\\n            // Place offer item typehash on the stack.\\n            bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\\n\\n            // Utilize assembly to enable reuse of memory regions when possible.\\n            assembly {\\n                /*\\n                 * 1. Calculate OfferItem EIP712 hash\\n                 */\\n\\n                // Write the OfferItem typeHash to memory.\\n                mstore(BasicOrder_offerItem_typeHash_ptr, typeHash)\\n\\n                // Write the OfferItem item type to memory.\\n                mstore(BasicOrder_offerItem_itemType_ptr, offeredItemType)\\n\\n                // Copy calldata region with (offerToken, offerIdentifier,\\n                // offerAmount) from OrderParameters to (token, identifier,\\n                // startAmount) in OfferItem struct. The offerAmount is written\\n                // to startAmount and endAmount as basic orders do not have\\n                // dynamic amounts.\\n                calldatacopy(\\n                    BasicOrder_offerItem_token_ptr,\\n                    BasicOrder_offerToken_cdPtr,\\n                    ThreeWords\\n                )\\n\\n                // Copy offerAmount from calldata to endAmount in OfferItem\\n                // struct.\\n                calldatacopy(\\n                    BasicOrder_offerItem_endAmount_ptr,\\n                    BasicOrder_offerAmount_cdPtr,\\n                    OneWord\\n                )\\n\\n                // Compute EIP712 OfferItem hash, write result to scratch space:\\n                //   `keccak256(abi.encode(offeredItem))`\\n                mstore(\\n                    0,\\n                    keccak256(\\n                        BasicOrder_offerItem_typeHash_ptr,\\n                        EIP712_OfferItem_size\\n                    )\\n                )\\n\\n                /*\\n                 * 2. Calculate hash of array of EIP712 hashes and write the\\n                 * result to the corresponding OfferItem struct:\\n                 *   `keccak256(abi.encodePacked(offerItemHashes))`\\n                 */\\n                mstore(BasicOrder_order_offerHashes_ptr, keccak256(0, OneWord))\\n\\n                /*\\n                 * 3. Write SpentItem to offer array in OrderFulfilled event.\\n                 */\\n                let eventConsiderationArrPtr := add(\\n                    OrderFulfilled_offer_length_baseOffset,\\n                    shl(\\n                        OneWordShift,\\n                        calldataload(\\n                            BasicOrder_additionalRecipients_length_cdPtr\\n                        )\\n                    )\\n                )\\n\\n                // Set a length of 1 for the offer array.\\n                mstore(eventConsiderationArrPtr, 1)\\n\\n                // Write itemType to the SpentItem struct.\\n                mstore(add(eventConsiderationArrPtr, OneWord), offeredItemType)\\n\\n                // Copy calldata region with (offerToken, offerIdentifier,\\n                // offerAmount) from OrderParameters to (token, identifier,\\n                // amount) in SpentItem struct.\\n                calldatacopy(\\n                    add(eventConsiderationArrPtr, AdditionalRecipient_size),\\n                    BasicOrder_offerToken_cdPtr,\\n                    ThreeWords\\n                )\\n            }\\n        }\\n\\n        {\\n            /**\\n             * Once consideration items and offer items have been handled,\\n             * derive the final order hash. Memory Layout:\\n             *  0x80-0x1c0: EIP712 data for order\\n             *   - 0x80:   Order EIP-712 typehash (constant)\\n             *   - 0xa0:   orderParameters.offerer\\n             *   - 0xc0:   orderParameters.zone\\n             *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\\n             *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\\n             *   - 0x120:  orderParameters.basicOrderType (% 4 = orderType)\\n             *   - 0x140:  orderParameters.startTime\\n             *   - 0x160:  orderParameters.endTime\\n             *   - 0x180:  orderParameters.zoneHash\\n             *   - 0x1a0:  orderParameters.salt\\n             *   - 0x1c0:  orderParameters.conduitKey\\n             *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\\n             */\\n\\n            // Read the offerer from calldata and place on the stack.\\n            address offerer;\\n            assembly {\\n                offerer := calldataload(BasicOrder_offerer_cdPtr)\\n            }\\n\\n            // Read offerer's current counter from storage and place on stack.\\n            uint256 counter = _getCounter(offerer);\\n\\n            // Load order typehash from runtime code and place on stack.\\n            bytes32 typeHash = _ORDER_TYPEHASH;\\n\\n            assembly {\\n                // Set the OrderItem typeHash in memory.\\n                mstore(BasicOrder_order_typeHash_ptr, typeHash)\\n\\n                // Copy offerer and zone from OrderParameters in calldata to the\\n                // Order struct.\\n                calldatacopy(\\n                    BasicOrder_order_offerer_ptr,\\n                    BasicOrder_offerer_cdPtr,\\n                    TwoWords\\n                )\\n\\n                // Copy receivedItemsHash from zero slot to the Order struct.\\n                mstore(\\n                    BasicOrder_order_considerationHashes_ptr,\\n                    mload(receivedItemsHash_ptr)\\n                )\\n\\n                // Write the supplied orderType to the Order struct.\\n                mstore(BasicOrder_order_orderType_ptr, orderType)\\n\\n                // Copy startTime, endTime, zoneHash, salt & conduit from\\n                // calldata to the Order struct.\\n                calldatacopy(\\n                    BasicOrder_order_startTime_ptr,\\n                    BasicOrder_startTime_cdPtr,\\n                    FiveWords\\n                )\\n\\n                // Write offerer's counter, retrieved from storage, to struct.\\n                mstore(BasicOrder_order_counter_ptr, counter)\\n\\n                // Compute the EIP712 Order hash.\\n                orderHash := keccak256(\\n                    BasicOrder_order_typeHash_ptr,\\n                    EIP712_Order_size\\n                )\\n            }\\n        }\\n\\n        assembly {\\n            /**\\n             * After the order hash has been derived, emit OrderFulfilled event:\\n             *   event OrderFulfilled(\\n             *     bytes32 orderHash,\\n             *     address indexed offerer,\\n             *     address indexed zone,\\n             *     address fulfiller,\\n             *     SpentItem[] offer,\\n             *       > (itemType, token, id, amount)\\n             *     ReceivedItem[] consideration\\n             *       > (itemType, token, id, amount, recipient)\\n             *   )\\n             * topic0 - OrderFulfilled event signature\\n             * topic1 - offerer\\n             * topic2 - zone\\n             * data:\\n             *  - 0x00: orderHash\\n             *  - 0x20: fulfiller\\n             *  - 0x40: offer arr ptr (0x80)\\n             *  - 0x60: consideration arr ptr (0x120)\\n             *  - 0x80: offer arr len (1)\\n             *  - 0xa0: offer.itemType\\n             *  - 0xc0: offer.token\\n             *  - 0xe0: offer.identifier\\n             *  - 0x100: offer.amount\\n             *  - 0x120: 1 + recipients.length\\n             *  - 0x140: recipient 0\\n             */\\n\\n            // Derive pointer to start of OrderFulfilled event data\\n            let eventDataPtr := add(\\n                OrderFulfilled_baseOffset,\\n                shl(\\n                    OneWordShift,\\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr)\\n                )\\n            )\\n\\n            // Write the order hash to the head of the event's data region.\\n            mstore(eventDataPtr, orderHash)\\n\\n            // Write the fulfiller (i.e. the caller) next for receiver argument.\\n            mstore(add(eventDataPtr, OrderFulfilled_fulfiller_offset), caller())\\n\\n            // Write the SpentItem and ReceivedItem array offsets (constants).\\n            mstore(\\n                // SpentItem array offset\\n                add(eventDataPtr, OrderFulfilled_offer_head_offset),\\n                OrderFulfilled_offer_body_offset\\n            )\\n            mstore(\\n                // ReceivedItem array offset\\n                add(eventDataPtr, OrderFulfilled_consideration_head_offset),\\n                OrderFulfilled_consideration_body_offset\\n            )\\n\\n            // Derive total data size including SpentItem and ReceivedItem data.\\n            // SpentItem portion is already included in the baseSize constant,\\n            // as there can only be one element in the array.\\n            let dataSize := add(\\n                OrderFulfilled_baseSize,\\n                mul(\\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr),\\n                    ReceivedItem_size\\n                )\\n            )\\n\\n            // Emit OrderFulfilled log with three topics (the event signature\\n            // as well as the two indexed arguments, the offerer and the zone).\\n            log3(\\n                // Supply the pointer for event data in memory.\\n                eventDataPtr,\\n                // Supply the size of event data in memory.\\n                dataSize,\\n                // Supply the OrderFulfilled event signature.\\n                OrderFulfilled_selector,\\n                // Supply the first topic (the offerer).\\n                calldataload(BasicOrder_offerer_cdPtr),\\n                // Supply the second topic (the zone).\\n                calldataload(BasicOrder_zone_cdPtr)\\n            )\\n\\n            // Restore the zero slot.\\n            mstore(ZeroSlot, 0)\\n\\n            // Update the free memory pointer so that event data is persisted.\\n            mstore(FreeMemoryPointerSlot, add(eventDataPtr, dataSize))\\n        }\\n\\n        // Verify and update the status of the derived order.\\n        _validateBasicOrderAndUpdateStatus(\\n            orderHash,\\n            parameters.offerer,\\n            parameters.signature\\n        );\\n\\n        // Return the derived order hash.\\n        return orderHash;\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer Ether (or other native tokens) to a\\n     *      given recipient as part of basic order fulfillment. Note that\\n     *      conduits are not utilized for native tokens as the transferred\\n     *      amount must be provided as msg.value. Also note that this function\\n     *      may only be safely called as part of basic orders, as it assumes a\\n     *      specific calldata encoding structure that must first be validated.\\n     *\\n     * @param amount The amount to transfer.\\n     * @param to     The recipient of the native token transfer.\\n     */\\n    function _transferNativeTokensAndFinalize(\\n        uint256 amount,\\n        address payable to\\n    ) internal {\\n        // Put native token value supplied by the caller on the stack.\\n        uint256 nativeTokensRemaining = msg.value;\\n\\n        // Retrieve total size of additional recipients data and place on stack.\\n        uint256 totalAdditionalRecipientsDataSize;\\n        assembly {\\n            totalAdditionalRecipientsDataSize := shl(\\n                AdditionalRecipient_size_shift,\\n                calldataload(BasicOrder_additionalRecipients_length_cdPtr)\\n            )\\n        }\\n\\n        uint256 additionalRecipientAmount;\\n        address payable recipient;\\n\\n        // Skip overflow check as for loop is indexed starting at zero.\\n        unchecked {\\n            // Iterate over additional recipient data by two-word element.\\n            for (\\n                uint256 i = 0;\\n                i < totalAdditionalRecipientsDataSize;\\n                i += AdditionalRecipient_size\\n            ) {\\n                assembly {\\n                    // Retrieve calldata pointer for additional recipient.\\n                    let additionalRecipientCdPtr := add(\\n                        BasicOrder_additionalRecipients_data_cdPtr,\\n                        i\\n                    )\\n\\n                    additionalRecipientAmount := calldataload(\\n                        additionalRecipientCdPtr\\n                    )\\n                    recipient := calldataload(\\n                        add(OneWord, additionalRecipientCdPtr)\\n                    )\\n                }\\n\\n                // Ensure that sufficient native tokens are available.\\n                if (additionalRecipientAmount > nativeTokensRemaining) {\\n                    _revertInsufficientEtherSupplied();\\n                }\\n\\n                // Reduce native token value available. Skip underflow check as\\n                // subtracted value is confirmed above as less than remaining.\\n                nativeTokensRemaining -= additionalRecipientAmount;\\n\\n                // Transfer native tokens to the additional recipient.\\n                _transferNativeTokens(recipient, additionalRecipientAmount);\\n            }\\n        }\\n\\n        // Ensure that sufficient native tokens are still available.\\n        if (amount > nativeTokensRemaining) {\\n            _revertInsufficientEtherSupplied();\\n        }\\n\\n        // Transfer native tokens to the offerer.\\n        _transferNativeTokens(to, amount);\\n\\n        // If any native tokens remain after transfers, return to the caller.\\n        if (nativeTokensRemaining > amount) {\\n            // Skip underflow check as nativeTokensRemaining > amount.\\n            unchecked {\\n                // Transfer remaining native tokens to the caller.\\n                _transferNativeTokens(\\n                    payable(msg.sender),\\n                    nativeTokensRemaining - amount\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens to a given recipient as\\n     *      part of basic order fulfillment. Note that this function may only be\\n     *      safely called as part of basic orders, as it assumes a specific\\n     *      calldata encoding structure that must first be validated.\\n     *\\n     * @param offerer     The offerer of the fulfiller order.\\n     * @param parameters  The basic order parameters.\\n     * @param fromOfferer A boolean indicating whether to decrement amount from\\n     *                    the offered amount.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _transferERC20AndFinalize(\\n        address offerer,\\n        BasicOrderParameters calldata parameters,\\n        bool fromOfferer,\\n        bytes memory accumulator\\n    ) internal {\\n        // Declare from and to variables determined by fromOfferer value.\\n        address from;\\n        address to;\\n\\n        // Declare token and amount variables determined by fromOfferer value.\\n        address token;\\n        uint256 amount;\\n\\n        // Declare and check identifier variable within an isolated scope.\\n        {\\n            // Declare identifier variable determined by fromOfferer value.\\n            uint256 identifier;\\n\\n            // Set ERC20 token transfer variables based on fromOfferer boolean.\\n            if (fromOfferer) {\\n                // Use offerer as from value and msg.sender as to value.\\n                from = offerer;\\n                to = msg.sender;\\n\\n                // Use offer token and related values if token is from offerer.\\n                token = parameters.offerToken;\\n                identifier = parameters.offerIdentifier;\\n                amount = parameters.offerAmount;\\n            } else {\\n                // Use msg.sender as from value and offerer as to value.\\n                from = msg.sender;\\n                to = offerer;\\n\\n                // Otherwise, use consideration token and related values.\\n                token = parameters.considerationToken;\\n                identifier = parameters.considerationIdentifier;\\n                amount = parameters.considerationAmount;\\n            }\\n\\n            // Ensure that no identifier is supplied.\\n            if (identifier != 0) {\\n                _revertUnusedItemParameters();\\n            }\\n        }\\n\\n        // Determine the appropriate conduit to utilize.\\n        bytes32 conduitKey;\\n\\n        // Utilize assembly to derive conduit (if relevant) based on route.\\n        assembly {\\n            // Use offerer conduit if fromOfferer, fulfiller conduit otherwise.\\n            conduitKey := calldataload(\\n                sub(\\n                    BasicOrder_fulfillerConduit_cdPtr,\\n                    shl(OneWordShift, fromOfferer)\\n                )\\n            )\\n        }\\n\\n        // Retrieve total size of additional recipients data and place on stack.\\n        uint256 totalAdditionalRecipientsDataSize;\\n        assembly {\\n            totalAdditionalRecipientsDataSize := shl(\\n                AdditionalRecipient_size_shift,\\n                calldataload(BasicOrder_additionalRecipients_length_cdPtr)\\n            )\\n        }\\n\\n        uint256 additionalRecipientAmount;\\n        address recipient;\\n\\n        // Iterate over each additional recipient.\\n        for (uint256 i = 0; i < totalAdditionalRecipientsDataSize; ) {\\n            assembly {\\n                // Retrieve calldata pointer for additional recipient.\\n                let additionalRecipientCdPtr := add(\\n                    BasicOrder_additionalRecipients_data_cdPtr,\\n                    i\\n                )\\n\\n                additionalRecipientAmount := calldataload(\\n                    additionalRecipientCdPtr\\n                )\\n                recipient := calldataload(\\n                    add(OneWord, additionalRecipientCdPtr)\\n                )\\n            }\\n\\n            // Decrement the amount to transfer to fulfiller if indicated.\\n            if (fromOfferer) {\\n                amount -= additionalRecipientAmount;\\n            }\\n\\n            // Transfer ERC20 tokens to additional recipient given approval.\\n            _transferERC20(\\n                token,\\n                from,\\n                recipient,\\n                additionalRecipientAmount,\\n                conduitKey,\\n                accumulator\\n            );\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                i += AdditionalRecipient_size;\\n            }\\n        }\\n\\n        // Transfer ERC20 token amount (from account must have proper approval).\\n        _transferERC20(token, from, to, amount, conduitKey, accumulator);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/CriteriaResolution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { ItemType, Side } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    OfferItem,\\n    ConsiderationItem,\\n    OrderParameters,\\n    AdvancedOrder,\\n    CriteriaResolver,\\n    MemoryPointer\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport \\\"./ConsiderationErrors.sol\\\";\\n\\nimport \\\"../helpers/PointerLibraries.sol\\\";\\n\\nimport {\\n    CriteriaResolutionErrors\\n} from \\\"../interfaces/CriteriaResolutionErrors.sol\\\";\\n\\n/**\\n * @title CriteriaResolution\\n * @author 0age\\n * @notice CriteriaResolution contains a collection of pure functions related to\\n *         resolving criteria-based items.\\n */\\ncontract CriteriaResolution is CriteriaResolutionErrors {\\n    /**\\n     * @dev Internal pure function to apply criteria resolvers containing\\n     *      specific token identifiers and associated proofs to order items.\\n     *\\n     * @param advancedOrders     The orders to apply criteria resolvers to.\\n     * @param criteriaResolvers  An array where each element contains a\\n     *                           reference to a specific order as well as that\\n     *                           order's offer or consideration, a token\\n     *                           identifier, and a proof that the supplied token\\n     *                           identifier is contained in the order's merkle\\n     *                           root. Note that a root of zero indicates that\\n     *                           any transferable token identifier is valid and\\n     *                           that no proof needs to be supplied.\\n     */\\n    function _applyCriteriaResolvers(\\n        AdvancedOrder[] memory advancedOrders,\\n        CriteriaResolver[] memory criteriaResolvers\\n    ) internal pure {\\n        // Skip overflow checks as all for loops are indexed starting at zero.\\n        unchecked {\\n            // Retrieve length of criteria resolvers array and place on stack.\\n            uint256 totalCriteriaResolvers = criteriaResolvers.length;\\n\\n            // Retrieve length of orders array and place on stack.\\n            uint256 totalAdvancedOrders = advancedOrders.length;\\n\\n            // Iterate over each criteria resolver.\\n            for (uint256 i = 0; i < totalCriteriaResolvers; ++i) {\\n                // Retrieve the criteria resolver.\\n                CriteriaResolver memory criteriaResolver = (\\n                    criteriaResolvers[i]\\n                );\\n\\n                // Read the order index from memory and place it on the stack.\\n                uint256 orderIndex = criteriaResolver.orderIndex;\\n\\n                // Ensure that the order index is in range.\\n                if (orderIndex >= totalAdvancedOrders) {\\n                    _revertOrderCriteriaResolverOutOfRange(\\n                        criteriaResolver.side\\n                    );\\n                }\\n\\n                // Retrieve the referenced advanced order.\\n                AdvancedOrder memory advancedOrder = advancedOrders[orderIndex];\\n\\n                // Skip criteria resolution for order if not fulfilled.\\n                if (advancedOrder.numerator == 0) {\\n                    continue;\\n                }\\n\\n                // Retrieve the parameters for the order.\\n                OrderParameters memory orderParameters = (\\n                    advancedOrder.parameters\\n                );\\n\\n                {\\n                    // Get a pointer to the list of items to give to\\n                    // _updateCriteriaItem. If the resolver refers to a\\n                    // consideration item, this array pointer will be replaced\\n                    // with the consideration array.\\n                    OfferItem[] memory items = orderParameters.offer;\\n\\n                    // Read component index from memory and place it on stack.\\n                    uint256 componentIndex = criteriaResolver.index;\\n\\n                    // Get error selector for `OfferCriteriaResolverOutOfRange`.\\n                    uint256 errorSelector = (\\n                        OfferCriteriaResolverOutOfRange_error_selector\\n                    );\\n\\n                    // If the resolver refers to a consideration item...\\n                    if (criteriaResolver.side != Side.OFFER) {\\n                        // Get the pointer to `orderParameters.consideration`\\n                        // Using the array directly has a significant impact on\\n                        // the optimized compiler output.\\n                        MemoryPointer considerationPtr = orderParameters\\n                            .toMemoryPointer()\\n                            .pptr(OrderParameters_consideration_head_offset);\\n\\n                        // Replace the items pointer with a pointer to the\\n                        // consideration array.\\n                        assembly {\\n                            items := considerationPtr\\n                        }\\n\\n                        // Replace the error selector with the selector for\\n                        // `ConsiderationCriteriaResolverOutOfRange`.\\n                        errorSelector = (\\n                            ConsiderationCriteriaResolverOutOfRange_err_selector\\n                        );\\n                    }\\n\\n                    // Ensure that the component index is in range.\\n                    if (componentIndex >= items.length) {\\n                        assembly {\\n                            mstore(0, errorSelector)\\n                            revert(Error_selector_offset, Selector_length)\\n                        }\\n                    }\\n\\n                    // Apply the criteria resolver to the item in question.\\n                    _updateCriteriaItem(\\n                        items,\\n                        componentIndex,\\n                        criteriaResolver\\n                    );\\n                }\\n            }\\n\\n            // Iterate over each advanced order.\\n            for (uint256 i = 0; i < totalAdvancedOrders; ++i) {\\n                // Retrieve the advanced order.\\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\\n\\n                // Skip criteria resolution for order if not fulfilled.\\n                if (advancedOrder.numerator == 0) {\\n                    continue;\\n                }\\n\\n                // Retrieve the parameters for the order.\\n                OrderParameters memory orderParameters = (\\n                    advancedOrder.parameters\\n                );\\n\\n                // Read consideration length from memory and place on stack.\\n                uint256 totalItems = orderParameters.consideration.length;\\n\\n                // Iterate over each consideration item on the order.\\n                for (uint256 j = 0; j < totalItems; ++j) {\\n                    // Ensure item type no longer indicates criteria usage.\\n                    if (\\n                        _isItemWithCriteria(\\n                            orderParameters.consideration[j].itemType\\n                        )\\n                    ) {\\n                        _revertUnresolvedConsiderationCriteria(i, j);\\n                    }\\n                }\\n\\n                // Read offer length from memory and place on stack.\\n                totalItems = orderParameters.offer.length;\\n\\n                // Iterate over each offer item on the order.\\n                for (uint256 j = 0; j < totalItems; ++j) {\\n                    // Ensure item type no longer indicates criteria usage.\\n                    if (\\n                        _isItemWithCriteria(orderParameters.offer[j].itemType)\\n                    ) {\\n                        _revertUnresolvedOfferCriteria(i, j);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to update a criteria item.\\n     *\\n     * @param offer             The offer containing the item to update.\\n     * @param componentIndex    The index of the item to update.\\n     * @param criteriaResolver  The criteria resolver to use to update the item.\\n     */\\n    function _updateCriteriaItem(\\n        OfferItem[] memory offer,\\n        uint256 componentIndex,\\n        CriteriaResolver memory criteriaResolver\\n    ) internal pure {\\n        // Retrieve relevant item using the component index.\\n        OfferItem memory offerItem = offer[componentIndex];\\n\\n        // Read item type and criteria from memory & place on stack.\\n        ItemType itemType = offerItem.itemType;\\n\\n        // Ensure the specified item type indicates criteria usage.\\n        if (!_isItemWithCriteria(itemType)) {\\n            _revertCriteriaNotEnabledForItem();\\n        }\\n\\n        uint256 identifierOrCriteria = offerItem.identifierOrCriteria;\\n\\n        // If criteria is not 0 (i.e. a collection-wide criteria-based item)...\\n        if (identifierOrCriteria != uint256(0)) {\\n            // Verify identifier inclusion in criteria root using proof.\\n            _verifyProof(\\n                criteriaResolver.identifier,\\n                identifierOrCriteria,\\n                criteriaResolver.criteriaProof\\n            );\\n        } else if (criteriaResolver.criteriaProof.length != 0) {\\n            // Revert if non-empty proof is supplied for a collection-wide item.\\n            _revertInvalidProof();\\n        }\\n\\n        // Update item type to remove criteria usage.\\n        // Use assembly to operate on ItemType enum as a number.\\n        ItemType newItemType;\\n        assembly {\\n            // Item type 4 becomes 2 and item type 5 becomes 3.\\n            newItemType := sub(3, eq(itemType, 4))\\n        }\\n        offerItem.itemType = newItemType;\\n\\n        // Update identifier w/ supplied identifier.\\n        offerItem.identifierOrCriteria = criteriaResolver.identifier;\\n    }\\n\\n    /**\\n     * @dev Internal pure function to check whether a given item type represents\\n     *      a criteria-based ERC721 or ERC1155 item (e.g. an item that can be\\n     *      resolved to one of a number of different identifiers at the time of\\n     *      order fulfillment).\\n     *\\n     * @param itemType The item type in question.\\n     *\\n     * @return withCriteria A boolean indicating that the item type in question\\n     *                      represents a criteria-based item.\\n     */\\n    function _isItemWithCriteria(\\n        ItemType itemType\\n    ) internal pure returns (bool withCriteria) {\\n        // ERC721WithCriteria is ItemType 4. ERC1155WithCriteria is ItemType 5.\\n        assembly {\\n            withCriteria := gt(itemType, 3)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to ensure that a given element is contained\\n     *      in a merkle root via a supplied proof.\\n     *\\n     * @param leaf  The element for which to prove inclusion.\\n     * @param root  The merkle root that inclusion will be proved against.\\n     * @param proof The merkle proof.\\n     */\\n    function _verifyProof(\\n        uint256 leaf,\\n        uint256 root,\\n        bytes32[] memory proof\\n    ) internal pure {\\n        // Declare a variable that will be used to determine proof validity.\\n        bool isValid;\\n\\n        // Utilize assembly to efficiently verify the proof against the root.\\n        assembly {\\n            // Store the leaf at the beginning of scratch space.\\n            mstore(0, leaf)\\n\\n            // Derive the hash of the leaf to use as the initial proof element.\\n            let computedHash := keccak256(0, OneWord)\\n\\n            // Get memory start location of the first element in proof array.\\n            let data := add(proof, OneWord)\\n\\n            // Iterate over each proof element to compute the root hash.\\n            for {\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                let end := add(data, shl(OneWordShift, mload(proof)))\\n            } lt(data, end) {\\n                // Increment by one word at a time.\\n                data := add(data, OneWord)\\n            } {\\n                // Get the proof element.\\n                let loadedData := mload(data)\\n\\n                // Sort proof elements and place them in scratch space.\\n                // Slot of `computedHash` in scratch space.\\n                // If the condition is true: 0x20, otherwise: 0x00.\\n                let scratch := shl(OneWordShift, gt(computedHash, loadedData))\\n\\n                // Store elements to hash contiguously in scratch space. Scratch\\n                // space is 64 bytes (0x00 - 0x3f) & both elements are 32 bytes.\\n                mstore(scratch, computedHash)\\n                mstore(xor(scratch, OneWord), loadedData)\\n\\n                // Derive the updated hash.\\n                computedHash := keccak256(0, TwoWords)\\n            }\\n\\n            // Compare the final hash to the supplied root.\\n            isValid := eq(computedHash, root)\\n        }\\n\\n        // Revert if computed hash does not equal supplied root.\\n        if (!isValid) {\\n            _revertInvalidProof();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AmountDeriver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {\\n    AmountDerivationErrors\\n} from \\\"../interfaces/AmountDerivationErrors.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title AmountDeriver\\n * @author 0age\\n * @notice AmountDeriver contains view and pure functions related to deriving\\n *         item amounts based on partial fill quantity and on linear\\n *         interpolation based on current time when the start amount and end\\n *         amount differ.\\n */\\ncontract AmountDeriver is AmountDerivationErrors {\\n    /**\\n     * @dev Internal view function to derive the current amount of a given item\\n     *      based on the current price, the starting price, and the ending\\n     *      price. If the start and end prices differ, the current price will be\\n     *      interpolated on a linear basis. Note that this function expects that\\n     *      the startTime parameter of orderParameters is not greater than the\\n     *      current block timestamp and that the endTime parameter is greater\\n     *      than the current block timestamp. If this condition is not upheld,\\n     *      duration / elapsed / remaining variables will underflow.\\n     *\\n     * @param startAmount The starting amount of the item.\\n     * @param endAmount   The ending amount of the item.\\n     * @param startTime   The starting time of the order.\\n     * @param endTime     The end time of the order.\\n     * @param roundUp     A boolean indicating whether the resultant amount\\n     *                    should be rounded up or down.\\n     *\\n     * @return amount The current amount.\\n     */\\n    function _locateCurrentAmount(\\n        uint256 startAmount,\\n        uint256 endAmount,\\n        uint256 startTime,\\n        uint256 endTime,\\n        bool roundUp\\n    ) internal view returns (uint256 amount) {\\n        // Only modify end amount if it doesn't already equal start amount.\\n        if (startAmount != endAmount) {\\n            // Declare variables to derive in the subsequent unchecked scope.\\n            uint256 duration;\\n            uint256 elapsed;\\n            uint256 remaining;\\n\\n            // Skip underflow checks as startTime <= block.timestamp < endTime.\\n            unchecked {\\n                // Derive the duration for the order and place it on the stack.\\n                duration = endTime - startTime;\\n\\n                // Derive time elapsed since the order started & place on stack.\\n                elapsed = block.timestamp - startTime;\\n\\n                // Derive time remaining until order expires and place on stack.\\n                remaining = duration - elapsed;\\n            }\\n\\n            // Aggregate new amounts weighted by time with rounding factor.\\n            uint256 totalBeforeDivision = ((startAmount * remaining) +\\n                (endAmount * elapsed));\\n\\n            // Use assembly to combine operations and skip divide-by-zero check.\\n            assembly {\\n                // Multiply by iszero(iszero(totalBeforeDivision)) to ensure\\n                // amount is set to zero if totalBeforeDivision is zero,\\n                // as intermediate overflow can occur if it is zero.\\n                amount := mul(\\n                    iszero(iszero(totalBeforeDivision)),\\n                    // Subtract 1 from the numerator and add 1 to the result if\\n                    // roundUp is true to get the proper rounding direction.\\n                    // Division is performed with no zero check as duration\\n                    // cannot be zero as long as startTime < endTime.\\n                    add(\\n                        div(sub(totalBeforeDivision, roundUp), duration),\\n                        roundUp\\n                    )\\n                )\\n            }\\n\\n            // Return the current amount.\\n            return amount;\\n        }\\n\\n        // Return the original amount as startAmount == endAmount.\\n        return endAmount;\\n    }\\n\\n    /**\\n     * @dev Internal pure function to return a fraction of a given value and to\\n     *      ensure the resultant value does not have any fractional component.\\n     *      Note that this function assumes that zero will never be supplied as\\n     *      the denominator parameter; invalid / undefined behavior will result\\n     *      should a denominator of zero be provided.\\n     *\\n     * @param numerator   A value indicating the portion of the order that\\n     *                    should be filled.\\n     * @param denominator A value indicating the total size of the order. Note\\n     *                    that this value cannot be equal to zero.\\n     * @param value       The value for which to compute the fraction.\\n     *\\n     * @return newValue The value after applying the fraction.\\n     */\\n    function _getFraction(\\n        uint256 numerator,\\n        uint256 denominator,\\n        uint256 value\\n    ) internal pure returns (uint256 newValue) {\\n        // Return value early in cases where the fraction resolves to 1.\\n        if (numerator == denominator) {\\n            return value;\\n        }\\n\\n        // Ensure fraction can be applied to the value with no remainder. Note\\n        // that the denominator cannot be zero.\\n        assembly {\\n            // Ensure new value contains no remainder via mulmod operator.\\n            // Credit to @hrkrshnn + @axic for proposing this optimal solution.\\n            if mulmod(value, numerator, denominator) {\\n                // Store left-padded selector with push4, mem[28:32] = selector\\n                mstore(0, InexactFraction_error_selector)\\n\\n                // revert(abi.encodeWithSignature(\\\"InexactFraction()\\\"))\\n                revert(Error_selector_offset, InexactFraction_error_length)\\n            }\\n        }\\n\\n        // Multiply the numerator by the value and ensure no overflow occurs.\\n        uint256 valueTimesNumerator = value * numerator;\\n\\n        // Divide and check for remainder. Note that denominator cannot be zero.\\n        assembly {\\n            // Perform division without zero check.\\n            newValue := div(valueTimesNumerator, denominator)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to apply a fraction to a consideration\\n     * or offer item.\\n     *\\n     * @param startAmount     The starting amount of the item.\\n     * @param endAmount       The ending amount of the item.\\n     * @param numerator       A value indicating the portion of the order that\\n     *                        should be filled.\\n     * @param denominator     A value indicating the total size of the order.\\n     * @param startTime       The starting time of the order.\\n     * @param endTime         The end time of the order.\\n     * @param roundUp         A boolean indicating whether the resultant\\n     *                        amount should be rounded up or down.\\n     *\\n     * @return amount The received item to transfer with the final amount.\\n     */\\n    function _applyFraction(\\n        uint256 startAmount,\\n        uint256 endAmount,\\n        uint256 numerator,\\n        uint256 denominator,\\n        uint256 startTime,\\n        uint256 endTime,\\n        bool roundUp\\n    ) internal view returns (uint256 amount) {\\n        // If start amount equals end amount, apply fraction to end amount.\\n        if (startAmount == endAmount) {\\n            // Apply fraction to end amount.\\n            amount = _getFraction(numerator, denominator, endAmount);\\n        } else {\\n            // Otherwise, apply fraction to both and interpolated final amount.\\n            amount = _locateCurrentAmount(\\n                _getFraction(numerator, denominator, startAmount),\\n                _getFraction(numerator, denominator, endAmount),\\n                startTime,\\n                endTime,\\n                roundUp\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ConduitInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\n/**\\n * @title ConduitInterface\\n * @author 0age\\n * @notice ConduitInterface contains all external function interfaces, events,\\n *         and errors for conduit contracts.\\n */\\ninterface ConduitInterface {\\n    /**\\n     * @dev Revert with an error when attempting to execute transfers using a\\n     *      caller that does not have an open channel.\\n     */\\n    error ChannelClosed(address channel);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update a channel to the\\n     *      current status of that channel.\\n     */\\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute a transfer for an\\n     *      item that does not have an ERC20/721/1155 item type.\\n     */\\n    error InvalidItemType();\\n\\n    /**\\n     * @dev Revert with an error when attempting to update the status of a\\n     *      channel from a caller that is not the conduit controller.\\n     */\\n    error InvalidController();\\n\\n    /**\\n     * @dev Emit an event whenever a channel is opened or closed.\\n     *\\n     * @param channel The channel that has been updated.\\n     * @param open    A boolean indicating whether the conduit is open or not.\\n     */\\n    event ChannelUpdated(address indexed channel, bool open);\\n\\n    /**\\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\\n     *         with an open channel can call this function.\\n     *\\n     * @param transfers The ERC20/721/1155 transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function execute(\\n        ConduitTransfer[] calldata transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\\n     *         open channel can call this function.\\n     *\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\\n     *         a caller with an open channel can call this function.\\n     *\\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata standardTransfers,\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Open or close a given channel. Only callable by the controller.\\n     *\\n     * @param channel The channel to open or close.\\n     * @param isOpen  The status of the channel (either open or closed).\\n     */\\n    function updateChannel(address channel, bool isOpen) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OrderValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { OrderType, ItemType } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    OrderParameters,\\n    Order,\\n    AdvancedOrder,\\n    OrderComponents,\\n    OrderStatus,\\n    CriteriaResolver,\\n    OfferItem,\\n    ConsiderationItem,\\n    SpentItem,\\n    ReceivedItem\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport \\\"./ConsiderationErrors.sol\\\";\\n\\nimport { Executor } from \\\"./Executor.sol\\\";\\n\\nimport { ZoneInteraction } from \\\"./ZoneInteraction.sol\\\";\\n\\nimport {\\n    ContractOffererInterface\\n} from \\\"../interfaces/ContractOffererInterface.sol\\\";\\n\\nimport {\\n    MemoryPointer,\\n    getFreeMemoryPointer\\n} from \\\"../helpers/PointerLibraries.sol\\\";\\n\\n/**\\n * @title OrderValidator\\n * @author 0age\\n * @notice OrderValidator contains functionality related to validating orders\\n *         and updating their status.\\n */\\ncontract OrderValidator is Executor, ZoneInteraction {\\n    // Track status of each order (validated, cancelled, and fraction filled).\\n    mapping(bytes32 => OrderStatus) private _orderStatus;\\n\\n    // Track nonces for contract offerers.\\n    mapping(address => uint256) internal _contractNonces;\\n\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) Executor(conduitController) {}\\n\\n    /**\\n     * @dev Internal function to verify and update the status of a basic order.\\n     *\\n     * @param orderHash The hash of the order.\\n     * @param offerer   The offerer of the order.\\n     * @param signature A signature from the offerer indicating that the order\\n     *                  has been approved.\\n     */\\n    function _validateBasicOrderAndUpdateStatus(\\n        bytes32 orderHash,\\n        address offerer,\\n        bytes memory signature\\n    ) internal {\\n        // Retrieve the order status for the given order hash.\\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\\n\\n        // Ensure order is fillable and is not cancelled.\\n        _verifyOrderStatus(\\n            orderHash,\\n            orderStatus,\\n            true, // Only allow unused orders when fulfilling basic orders.\\n            true // Signifies to revert if the order is invalid.\\n        );\\n\\n        // If the order is not already validated, verify the supplied signature.\\n        if (!orderStatus.isValidated) {\\n            _verifySignature(offerer, orderHash, signature);\\n        }\\n\\n        // Update order status as fully filled, packing struct values.\\n        orderStatus.isValidated = true;\\n        orderStatus.isCancelled = false;\\n        orderStatus.numerator = 1;\\n        orderStatus.denominator = 1;\\n    }\\n\\n    /**\\n     * @dev Internal function to validate an order, determine what portion to\\n     *      fill, and update its status. The desired fill amount is supplied as\\n     *      a fraction, as is the returned amount to fill.\\n     *\\n     * @param advancedOrder     The order to fulfill as well as the fraction to\\n     *                          fill. Note that all offer and consideration\\n     *                          amounts must divide with no remainder in order\\n     *                          for a partial fill to be valid.\\n     * @param revertOnInvalid   A boolean indicating whether to revert if the\\n     *                          order is invalid due to the time or status.\\n     *\\n     * @return orderHash      The order hash.\\n     * @return numerator      A value indicating the portion of the order that\\n     *                        will be filled.\\n     * @return denominator    A value indicating the total size of the order.\\n     */\\n    function _validateOrderAndUpdateStatus(\\n        AdvancedOrder memory advancedOrder,\\n        bool revertOnInvalid\\n    )\\n        internal\\n        returns (bytes32 orderHash, uint256 numerator, uint256 denominator)\\n    {\\n        // Retrieve the parameters for the order.\\n        OrderParameters memory orderParameters = advancedOrder.parameters;\\n\\n        // Ensure current timestamp falls between order start time and end time.\\n        if (\\n            !_verifyTime(\\n                orderParameters.startTime,\\n                orderParameters.endTime,\\n                revertOnInvalid\\n            )\\n        ) {\\n            // Assuming an invalid time and no revert, return zeroed out values.\\n            return (bytes32(0), 0, 0);\\n        }\\n\\n        // Read numerator and denominator from memory and place on the stack.\\n        // Note that overflowed values are masked.\\n        assembly {\\n            numerator := and(\\n                mload(add(advancedOrder, AdvancedOrder_numerator_offset)),\\n                MaxUint120\\n            )\\n\\n            denominator := and(\\n                mload(add(advancedOrder, AdvancedOrder_denominator_offset)),\\n                MaxUint120\\n            )\\n        }\\n\\n        // Declare variable for tracking the validity of the supplied fraction.\\n        bool invalidFraction;\\n\\n        // If the order is a contract order, return the generated order.\\n        if (orderParameters.orderType == OrderType.CONTRACT) {\\n            // Ensure that the numerator and denominator are both equal to 1.\\n            assembly {\\n                // (1 ^ nd =/= 0) => (nd =/= 1) => (n =/= 1) || (d =/= 1)\\n                // It's important that the values are 120-bit masked before\\n                // multiplication is applied. Otherwise, the last implication\\n                // above is not correct (mod 2^256).\\n                invalidFraction := xor(mul(numerator, denominator), 1)\\n            }\\n\\n            // Revert if the supplied numerator and denominator are not valid.\\n            if (invalidFraction) {\\n                _revertBadFraction();\\n            }\\n\\n            // Return the generated order based on the order params and the\\n            // provided extra data. If revertOnInvalid is true, the function\\n            // will revert if the input is invalid.\\n            return\\n                _getGeneratedOrder(\\n                    orderParameters,\\n                    advancedOrder.extraData,\\n                    revertOnInvalid\\n                );\\n        }\\n\\n        // Ensure numerator does not exceed denominator and is not zero.\\n        assembly {\\n            invalidFraction := or(gt(numerator, denominator), iszero(numerator))\\n        }\\n\\n        // Revert if the supplied numerator and denominator are not valid.\\n        if (invalidFraction) {\\n            _revertBadFraction();\\n        }\\n\\n        // If attempting partial fill (n < d) check order type & ensure support.\\n        if (\\n            _doesNotSupportPartialFills(\\n                orderParameters.orderType,\\n                numerator,\\n                denominator\\n            )\\n        ) {\\n            // Revert if partial fill was attempted on an unsupported order.\\n            _revertPartialFillsNotEnabledForOrder();\\n        }\\n\\n        // Retrieve current counter & use it w/ parameters to derive order hash.\\n        orderHash = _assertConsiderationLengthAndGetOrderHash(orderParameters);\\n\\n        // Retrieve the order status using the derived order hash.\\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\\n\\n        // Ensure order is fillable and is not cancelled.\\n        if (\\n            !_verifyOrderStatus(\\n                orderHash,\\n                orderStatus,\\n                false, // Allow partially used orders to be filled.\\n                revertOnInvalid\\n            )\\n        ) {\\n            // Assuming an invalid order status and no revert, return zero fill.\\n            return (orderHash, 0, 0);\\n        }\\n\\n        // If the order is not already validated, verify the supplied signature.\\n        if (!orderStatus.isValidated) {\\n            _verifySignature(\\n                orderParameters.offerer,\\n                orderHash,\\n                advancedOrder.signature\\n            );\\n        }\\n\\n        assembly {\\n            let orderStatusSlot := orderStatus.slot\\n            // Read filled amount as numerator and denominator and put on stack.\\n            let filledNumerator := sload(orderStatusSlot)\\n            let filledDenominator := shr(\\n                OrderStatus_filledDenominator_offset,\\n                filledNumerator\\n            )\\n\\n            for {\\n\\n            } 1 {\\n\\n            } {\\n                if iszero(filledDenominator) {\\n                    filledNumerator := numerator\\n\\n                    break\\n                }\\n\\n                // Shift and mask to calculate the current filled numerator.\\n                filledNumerator := and(\\n                    shr(OrderStatus_filledNumerator_offset, filledNumerator),\\n                    MaxUint120\\n                )\\n\\n                // If denominator of 1 supplied, fill entire remaining amount.\\n                if eq(denominator, 1) {\\n                    numerator := sub(filledDenominator, filledNumerator)\\n                    denominator := filledDenominator\\n                    filledNumerator := filledDenominator\\n\\n                    break\\n                }\\n\\n                // If supplied denominator equals to the current one:\\n                if eq(denominator, filledDenominator) {\\n                    // Increment the filled numerator by the new numerator.\\n                    filledNumerator := add(numerator, filledNumerator)\\n\\n                    // Once adjusted, if current + supplied numerator exceeds\\n                    // the denominator:\\n                    let carry := mul(\\n                        sub(filledNumerator, denominator),\\n                        gt(filledNumerator, denominator)\\n                    )\\n\\n                    numerator := sub(numerator, carry)\\n\\n                    filledNumerator := sub(filledNumerator, carry)\\n\\n                    break\\n                }\\n\\n                // Otherwise, if supplied denominator differs from current one:\\n                filledNumerator := mul(filledNumerator, denominator)\\n                numerator := mul(numerator, filledDenominator)\\n                denominator := mul(denominator, filledDenominator)\\n\\n                // Increment the filled numerator by the new numerator.\\n                filledNumerator := add(numerator, filledNumerator)\\n\\n                // Once adjusted, if current + supplied numerator exceeds\\n                // denominator:\\n                let carry := mul(\\n                    sub(filledNumerator, denominator),\\n                    gt(filledNumerator, denominator)\\n                )\\n\\n                numerator := sub(numerator, carry)\\n\\n                filledNumerator := sub(filledNumerator, carry)\\n\\n                // Check filledNumerator and denominator for uint120 overflow.\\n                if or(\\n                    gt(filledNumerator, MaxUint120),\\n                    gt(denominator, MaxUint120)\\n                ) {\\n                    // Derive greatest common divisor using euclidean algorithm.\\n                    function gcd(_a, _b) -> out {\\n                        for {\\n\\n                        } _b {\\n\\n                        } {\\n                            let _c := _b\\n                            _b := mod(_a, _c)\\n                            _a := _c\\n                        }\\n                        out := _a\\n                    }\\n                    let scaleDown := gcd(\\n                        numerator,\\n                        gcd(filledNumerator, denominator)\\n                    )\\n\\n                    // Ensure that the divisor is at least one.\\n                    let safeScaleDown := add(scaleDown, iszero(scaleDown))\\n\\n                    // Scale all fractional values down by gcd.\\n                    numerator := div(numerator, safeScaleDown)\\n                    filledNumerator := div(filledNumerator, safeScaleDown)\\n                    denominator := div(denominator, safeScaleDown)\\n\\n                    // Perform the overflow check a second time.\\n                    if or(\\n                        gt(filledNumerator, MaxUint120),\\n                        gt(denominator, MaxUint120)\\n                    ) {\\n                        // Store the Panic error signature.\\n                        mstore(0, Panic_error_selector)\\n                        // Store the arithmetic (0x11) panic code.\\n                        mstore(Panic_error_code_ptr, Panic_arithmetic)\\n\\n                        // revert(abi.encodeWithSignature(\\n                        //     \\\"Panic(uint256)\\\", 0x11\\n                        // ))\\n                        revert(Error_selector_offset, Panic_error_length)\\n                    }\\n                }\\n\\n                break\\n            }\\n\\n            // Update order status and fill amount, packing struct values.\\n            // [denominator: 15 bytes] [numerator: 15 bytes]\\n            // [isCancelled: 1 byte] [isValidated: 1 byte]\\n            sstore(\\n                orderStatusSlot,\\n                or(\\n                    OrderStatus_ValidatedAndNotCancelled,\\n                    or(\\n                        shl(\\n                            OrderStatus_filledNumerator_offset,\\n                            filledNumerator\\n                        ),\\n                        shl(OrderStatus_filledDenominator_offset, denominator)\\n                    )\\n                )\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to check the compatibility of two offer\\n     *      or consideration items for contract orders.  Note that the itemType\\n     *      and identifier are reset in cases where criteria = 0 (collection-\\n     *      wide offers), which means that a contract offerer has full latitude\\n     *      to choose any identifier it wants mid-flight, in contrast to the\\n     *      normal behavior, where the fulfiller can pick which identifier to\\n     *      receive by providing a CriteriaResolver.\\n     *\\n     * @param originalItem The original offer or consideration item.\\n     * @param newItem      The new offer or consideration item.\\n     *\\n     * @return isInvalid Error buffer indicating if items are incompatible.\\n     */\\n    function _compareItems(\\n        MemoryPointer originalItem,\\n        MemoryPointer newItem\\n    ) internal pure returns (uint256 isInvalid) {\\n        assembly {\\n            let itemType := mload(originalItem)\\n            let identifier := mload(add(originalItem, Common_identifier_offset))\\n\\n            // Set returned identifier for criteria-based items w/ criteria = 0.\\n            if and(gt(itemType, 3), iszero(identifier)) {\\n                // replace item type\\n                itemType := sub(3, eq(itemType, 4))\\n                identifier := mload(add(newItem, Common_identifier_offset))\\n            }\\n\\n            let originalAmount := mload(add(originalItem, Common_amount_offset))\\n            let newAmount := mload(add(newItem, Common_amount_offset))\\n\\n            isInvalid := iszero(\\n                and(\\n                    // originalItem.token == newItem.token &&\\n                    // originalItem.itemType == newItem.itemType\\n                    and(\\n                        eq(\\n                            mload(add(originalItem, Common_token_offset)),\\n                            mload(add(newItem, Common_token_offset))\\n                        ),\\n                        eq(itemType, mload(newItem))\\n                    ),\\n                    // originalItem.identifier == newItem.identifier &&\\n                    // originalItem.startAmount == originalItem.endAmount\\n                    and(\\n                        eq(\\n                            identifier,\\n                            mload(add(newItem, Common_identifier_offset))\\n                        ),\\n                        eq(\\n                            originalAmount,\\n                            mload(add(originalItem, Common_endAmount_offset))\\n                        )\\n                    )\\n                )\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to check the compatibility of two recipients\\n     *      on consideration items for contract orders. This check is skipped if\\n     *      no recipient is originally supplied.\\n     *\\n     * @param originalRecipient The original consideration item recipient.\\n     * @param newRecipient      The new consideration item recipient.\\n     *\\n     * @return isInvalid Error buffer indicating if recipients are incompatible.\\n     */\\n    function _checkRecipients(\\n        address originalRecipient,\\n        address newRecipient\\n    ) internal pure returns (uint256 isInvalid) {\\n        assembly {\\n            isInvalid := iszero(\\n                or(\\n                    iszero(originalRecipient),\\n                    eq(newRecipient, originalRecipient)\\n                )\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to generate a contract order. When a\\n     *      collection-wide criteria-based item (criteria = 0) is provided as an\\n     *      input to a contract order, the contract offerer has full latitude to\\n     *      choose any identifier it wants mid-flight, which differs from the\\n     *      usual behavior.  For regular criteria-based orders with\\n     *      identifierOrCriteria = 0, the fulfiller can pick which identifier to\\n     *      receive by providing a CriteriaResolver. For contract offers with\\n     *      identifierOrCriteria = 0, Seaport does not expect a corresponding\\n     *      CriteriaResolver, and will revert if one is provided.\\n     *\\n     * @param orderParameters The parameters for the order.\\n     * @param context         The context for generating the order.\\n     * @param revertOnInvalid Whether to revert on invalid input.\\n     *\\n     * @return orderHash   The order hash.\\n     * @return numerator   The numerator.\\n     * @return denominator The denominator.\\n     */\\n    function _getGeneratedOrder(\\n        OrderParameters memory orderParameters,\\n        bytes memory context,\\n        bool revertOnInvalid\\n    )\\n        internal\\n        returns (bytes32 orderHash, uint256 numerator, uint256 denominator)\\n    {\\n        // Ensure that consideration array length is equal to the total original\\n        // consideration items value.\\n        if (\\n            orderParameters.consideration.length !=\\n            orderParameters.totalOriginalConsiderationItems\\n        ) {\\n            _revertConsiderationLengthNotEqualToTotalOriginal();\\n        }\\n\\n        {\\n            address offerer = orderParameters.offerer;\\n            bool success;\\n            (MemoryPointer cdPtr, uint256 size) = _encodeGenerateOrder(\\n                orderParameters,\\n                context\\n            );\\n            assembly {\\n                success := call(gas(), offerer, 0, cdPtr, size, 0, 0)\\n            }\\n\\n            {\\n                // Note: overflow impossible; nonce can't increment that high.\\n                uint256 contractNonce;\\n                unchecked {\\n                    // Note: nonce will be incremented even for skipped orders,\\n                    // and  even if generateOrder's return data does not satisfy\\n                    // all the constraints. This is the case when errorBuffer\\n                    // !=0 and revertOnInvalid == false.\\n                    contractNonce = _contractNonces[offerer]++;\\n                }\\n\\n                assembly {\\n                    // Shift offerer address up 96 bytes and combine with nonce.\\n                    orderHash := xor(\\n                        contractNonce,\\n                        shl(ContractOrder_orderHash_offerer_shift, offerer)\\n                    )\\n                }\\n            }\\n\\n            // Revert or skip if the call to generate the contract order failed.\\n            if (!success) {\\n                return _revertOrReturnEmpty(revertOnInvalid, orderHash);\\n            }\\n        }\\n\\n        // Decode the returned contract order and/or update the error buffer.\\n        (\\n            uint256 errorBuffer,\\n            OfferItem[] memory offer,\\n            ConsiderationItem[] memory consideration\\n        ) = _convertGetGeneratedOrderResult(_decodeGenerateOrderReturndata)();\\n\\n        // Revert or skip if the returndata could not be decoded correctly.\\n        if (errorBuffer != 0) {\\n            return _revertOrReturnEmpty(revertOnInvalid, orderHash);\\n        }\\n\\n        {\\n            // Designate lengths.\\n            uint256 originalOfferLength = orderParameters.offer.length;\\n            uint256 newOfferLength = offer.length;\\n\\n            // Explicitly specified offer items cannot be removed.\\n            if (originalOfferLength > newOfferLength) {\\n                return _revertOrReturnEmpty(revertOnInvalid, orderHash);\\n            }\\n\\n            // Iterate over each specified offer (e.g. minimumReceived) item.\\n            for (uint256 i = 0; i < originalOfferLength; ) {\\n                // Retrieve the pointer to the originally supplied item.\\n                MemoryPointer mPtrOriginal = orderParameters\\n                    .offer[i]\\n                    .toMemoryPointer();\\n\\n                // Retrieve the pointer to the newly returned item.\\n                MemoryPointer mPtrNew = offer[i].toMemoryPointer();\\n\\n                // Compare the items and update the error buffer accordingly.\\n                errorBuffer |=\\n                    _cast(\\n                        mPtrOriginal\\n                            .offset(Common_amount_offset)\\n                            .readUint256() >\\n                            mPtrNew.offset(Common_amount_offset).readUint256()\\n                    ) |\\n                    _compareItems(mPtrOriginal, mPtrNew);\\n\\n                // Increment the array (cannot overflow as index starts at 0).\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            // Assign the returned offer item in place of the original item.\\n            orderParameters.offer = offer;\\n        }\\n\\n        {\\n            // Designate lengths & memory locations.\\n            ConsiderationItem[] memory originalConsiderationArray = (\\n                orderParameters.consideration\\n            );\\n            uint256 newConsiderationLength = consideration.length;\\n\\n            // New consideration items cannot be created.\\n            if (newConsiderationLength > originalConsiderationArray.length) {\\n                return _revertOrReturnEmpty(revertOnInvalid, orderHash);\\n            }\\n\\n            // Iterate over returned consideration & do not exceed maximumSpent.\\n            for (uint256 i = 0; i < newConsiderationLength; ) {\\n                // Retrieve the pointer to the originally supplied item.\\n                MemoryPointer mPtrOriginal = originalConsiderationArray[i]\\n                    .toMemoryPointer();\\n\\n                // Retrieve the pointer to the newly returned item.\\n                MemoryPointer mPtrNew = consideration[i].toMemoryPointer();\\n\\n                // Compare the items and update the error buffer accordingly\\n                // and ensure that the recipients are equal when provided.\\n                errorBuffer |=\\n                    _cast(\\n                        mPtrNew.offset(Common_amount_offset).readUint256() >\\n                            mPtrOriginal\\n                                .offset(Common_amount_offset)\\n                                .readUint256()\\n                    ) |\\n                    _compareItems(mPtrOriginal, mPtrNew) |\\n                    _checkRecipients(\\n                        mPtrOriginal\\n                            .offset(ConsiderItem_recipient_offset)\\n                            .readAddress(),\\n                        mPtrNew\\n                            .offset(ConsiderItem_recipient_offset)\\n                            .readAddress()\\n                    );\\n\\n                // Increment the array (cannot overflow as index starts at 0).\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n\\n            // Assign returned consideration item in place of the original item.\\n            orderParameters.consideration = consideration;\\n        }\\n\\n        // Revert or skip if any item comparison failed.\\n        if (errorBuffer != 0) {\\n            return _revertOrReturnEmpty(revertOnInvalid, orderHash);\\n        }\\n\\n        // Return order hash and full fill amount (numerator & denominator = 1).\\n        return (orderHash, 1, 1);\\n    }\\n\\n    /**\\n     * @dev Internal function to cancel an arbitrary number of orders. Note that\\n     *      only the offerer or the zone of a given order may cancel it. Callers\\n     *      should ensure that the intended order was cancelled by calling\\n     *      `getOrderStatus` and confirming that `isCancelled` returns `true`.\\n     *      Also note that contract orders are not cancellable.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders were\\n     *                   successfully cancelled.\\n     */\\n    function _cancel(\\n        OrderComponents[] calldata orders\\n    ) internal returns (bool cancelled) {\\n        // Ensure that the reentrancy guard is not currently set.\\n        _assertNonReentrant();\\n\\n        // Declare variables outside of the loop.\\n        OrderStatus storage orderStatus;\\n\\n        // Declare a variable for tracking invariants in the loop.\\n        bool anyInvalidCallerOrContractOrder;\\n\\n        // Skip overflow check as for loop is indexed starting at zero.\\n        unchecked {\\n            // Read length of the orders array from memory and place on stack.\\n            uint256 totalOrders = orders.length;\\n\\n            // Iterate over each order.\\n            for (uint256 i = 0; i < totalOrders; ) {\\n                // Retrieve the order.\\n                OrderComponents calldata order = orders[i];\\n\\n                address offerer = order.offerer;\\n                address zone = order.zone;\\n                OrderType orderType = order.orderType;\\n\\n                assembly {\\n                    // If caller is neither the offerer nor zone, or a contract\\n                    // order is present, flag anyInvalidCallerOrContractOrder.\\n                    anyInvalidCallerOrContractOrder := or(\\n                        anyInvalidCallerOrContractOrder,\\n                        // orderType == CONTRACT ||\\n                        // !(caller == offerer || caller == zone)\\n                        or(\\n                            eq(orderType, 4),\\n                            iszero(\\n                                or(eq(caller(), offerer), eq(caller(), zone))\\n                            )\\n                        )\\n                    )\\n                }\\n\\n                bytes32 orderHash = _deriveOrderHash(\\n                    _toOrderParametersReturnType(\\n                        _decodeOrderComponentsAsOrderParameters\\n                    )(order.toCalldataPointer()),\\n                    order.counter\\n                );\\n\\n                // Retrieve the order status using the derived order hash.\\n                orderStatus = _orderStatus[orderHash];\\n\\n                // Update the order status as not valid and cancelled.\\n                orderStatus.isValidated = false;\\n                orderStatus.isCancelled = true;\\n\\n                // Emit an event signifying that the order has been cancelled.\\n                emit OrderCancelled(orderHash, offerer, zone);\\n\\n                // Increment counter inside body of loop for gas efficiency.\\n                ++i;\\n            }\\n        }\\n\\n        if (anyInvalidCallerOrContractOrder) {\\n            _revertCannotCancelOrder();\\n        }\\n\\n        // Return a boolean indicating that orders were successfully cancelled.\\n        cancelled = true;\\n    }\\n\\n    /**\\n     * @dev Internal function to validate an arbitrary number of orders, thereby\\n     *      registering their signatures as valid and allowing the fulfiller to\\n     *      skip signature verification on fulfillment. Note that validated\\n     *      orders may still be unfulfillable due to invalid item amounts or\\n     *      other factors; callers should determine whether validated orders are\\n     *      fulfillable by simulating the fulfillment call prior to execution.\\n     *      Also note that anyone can validate a signed order, but only the\\n     *      offerer can validate an order without supplying a signature.\\n     *\\n     * @param orders The orders to validate.\\n     *\\n     * @return validated A boolean indicating whether the supplied orders were\\n     *                   successfully validated.\\n     */\\n    function _validate(\\n        Order[] memory orders\\n    ) internal returns (bool validated) {\\n        // Ensure that the reentrancy guard is not currently set.\\n        _assertNonReentrant();\\n\\n        // Declare variables outside of the loop.\\n        OrderStatus storage orderStatus;\\n        bytes32 orderHash;\\n        address offerer;\\n\\n        // Skip overflow check as for loop is indexed starting at zero.\\n        unchecked {\\n            // Read length of the orders array from memory and place on stack.\\n            uint256 totalOrders = orders.length;\\n\\n            // Iterate over each order.\\n            for (uint256 i = 0; i < totalOrders; ++i) {\\n                // Retrieve the order.\\n                Order memory order = orders[i];\\n\\n                // Retrieve the order parameters.\\n                OrderParameters memory orderParameters = order.parameters;\\n\\n                // Skip contract orders.\\n                if (orderParameters.orderType == OrderType.CONTRACT) {\\n                    continue;\\n                }\\n\\n                // Move offerer from memory to the stack.\\n                offerer = orderParameters.offerer;\\n\\n                // Get current counter & use it w/ params to derive order hash.\\n                orderHash = _assertConsiderationLengthAndGetOrderHash(\\n                    orderParameters\\n                );\\n\\n                // Retrieve the order status using the derived order hash.\\n                orderStatus = _orderStatus[orderHash];\\n\\n                // Ensure order is fillable and retrieve the filled amount.\\n                _verifyOrderStatus(\\n                    orderHash,\\n                    orderStatus,\\n                    false, // Signifies that partially filled orders are valid.\\n                    true // Signifies to revert if the order is invalid.\\n                );\\n\\n                // If the order has not already been validated...\\n                if (!orderStatus.isValidated) {\\n                    // Ensure that consideration array length is equal to the\\n                    // total original consideration items value.\\n                    if (\\n                        orderParameters.consideration.length !=\\n                        orderParameters.totalOriginalConsiderationItems\\n                    ) {\\n                        _revertConsiderationLengthNotEqualToTotalOriginal();\\n                    }\\n\\n                    // Verify the supplied signature.\\n                    _verifySignature(offerer, orderHash, order.signature);\\n\\n                    // Update order status to mark the order as valid.\\n                    orderStatus.isValidated = true;\\n\\n                    // Emit an event signifying the order has been validated.\\n                    emit OrderValidated(orderHash, orderParameters);\\n                }\\n            }\\n        }\\n\\n        // Return a boolean indicating that orders were successfully validated.\\n        validated = true;\\n    }\\n\\n    /**\\n     * @dev Internal view function to retrieve the status of a given order by\\n     *      hash, including whether the order has been cancelled or validated\\n     *      and the fraction of the order that has been filled.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function _getOrderStatus(\\n        bytes32 orderHash\\n    )\\n        internal\\n        view\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        )\\n    {\\n        // Retrieve the order status using the order hash.\\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\\n\\n        // Return the fields on the order status.\\n        return (\\n            orderStatus.isValidated,\\n            orderStatus.isCancelled,\\n            orderStatus.numerator,\\n            orderStatus.denominator\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal pure function to either revert or return an empty tuple\\n     *      depending on the value of `revertOnInvalid`.\\n     *\\n     * @param revertOnInvalid   Whether to revert on invalid input.\\n     * @param contractOrderHash The contract order hash.\\n     *\\n     * @return orderHash   The order hash.\\n     * @return numerator   The numerator.\\n     * @return denominator The denominator.\\n     */\\n    function _revertOrReturnEmpty(\\n        bool revertOnInvalid,\\n        bytes32 contractOrderHash\\n    )\\n        internal\\n        pure\\n        returns (bytes32 orderHash, uint256 numerator, uint256 denominator)\\n    {\\n        if (!revertOnInvalid) {\\n            return (contractOrderHash, 0, 0);\\n        }\\n\\n        _revertInvalidContractOrder(contractOrderHash);\\n    }\\n\\n    /**\\n     * @dev Internal pure function to check whether a given order type indicates\\n     *      that partial fills are not supported (e.g. only \\\"full fills\\\" are\\n     *      allowed for the order in question).\\n     *\\n     * @param orderType   The order type in question.\\n     * @param numerator   The numerator in question.\\n     * @param denominator The denominator in question.\\n     *\\n     * @return isFullOrder A boolean indicating whether the order type only\\n     *                     supports full fills.\\n     */\\n    function _doesNotSupportPartialFills(\\n        OrderType orderType,\\n        uint256 numerator,\\n        uint256 denominator\\n    ) internal pure returns (bool isFullOrder) {\\n        // The \\\"full\\\" order types are even, while \\\"partial\\\" order types are odd.\\n        // Bitwise and by 1 is equivalent to modulo by 2, but 2 gas cheaper. The\\n        // check is only necessary if numerator is less than denominator.\\n        assembly {\\n            // Equivalent to `uint256(orderType) & 1 == 0`.\\n            isFullOrder := and(\\n                lt(numerator, denominator),\\n                iszero(and(orderType, 1))\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { ConduitItemType } from \\\"./ConduitEnums.sol\\\";\\n\\nstruct ConduitTransfer {\\n    ConduitItemType itemType;\\n    address token;\\n    address from;\\n    address to;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\nstruct ConduitBatch1155Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256[] ids;\\n    uint256[] amounts;\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nenum ConduitItemType {\\n    NATIVE, // unused\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Executor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport { ConduitItemType } from \\\"../conduit/lib/ConduitEnums.sol\\\";\\n\\nimport { ItemType } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport { ReceivedItem } from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { Verifiers } from \\\"./Verifiers.sol\\\";\\n\\nimport { TokenTransferrer } from \\\"./TokenTransferrer.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\nimport \\\"./ConsiderationErrors.sol\\\";\\n\\n/**\\n * @title Executor\\n * @author 0age\\n * @notice Executor contains functions related to processing executions (i.e.\\n *         transferring items, either directly or via conduits).\\n */\\ncontract Executor is Verifiers, TokenTransferrer {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) Verifiers(conduitController) {}\\n\\n    /**\\n     * @dev Internal function to transfer a given item, either directly or via\\n     *      a corresponding conduit.\\n     *\\n     * @param item        The item to transfer, including an amount and a\\n     *                    recipient.\\n     * @param from        The account supplying the item.\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _transfer(\\n        ReceivedItem memory item,\\n        address from,\\n        bytes32 conduitKey,\\n        bytes memory accumulator\\n    ) internal {\\n        // If the item type indicates Ether or a native token...\\n        if (item.itemType == ItemType.NATIVE) {\\n            // Ensure neither the token nor the identifier parameters are set.\\n            if ((uint160(item.token) | item.identifier) != 0) {\\n                _revertUnusedItemParameters();\\n            }\\n\\n            // transfer the native tokens to the recipient.\\n            _transferNativeTokens(item.recipient, item.amount);\\n        } else if (item.itemType == ItemType.ERC20) {\\n            // Ensure that no identifier is supplied.\\n            if (item.identifier != 0) {\\n                _revertUnusedItemParameters();\\n            }\\n\\n            // Transfer ERC20 tokens from the source to the recipient.\\n            _transferERC20(\\n                item.token,\\n                from,\\n                item.recipient,\\n                item.amount,\\n                conduitKey,\\n                accumulator\\n            );\\n        } else if (item.itemType == ItemType.ERC721) {\\n            // Transfer ERC721 token from the source to the recipient.\\n            _transferERC721(\\n                item.token,\\n                from,\\n                item.recipient,\\n                item.identifier,\\n                item.amount,\\n                conduitKey,\\n                accumulator\\n            );\\n        } else {\\n            // Transfer ERC1155 token from the source to the recipient.\\n            _transferERC1155(\\n                item.token,\\n                from,\\n                item.recipient,\\n                item.identifier,\\n                item.amount,\\n                conduitKey,\\n                accumulator\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer an individual ERC721 or ERC1155 item\\n     *      from a given originator to a given recipient. The accumulator will\\n     *      be bypassed, meaning that this function should be utilized in cases\\n     *      where multiple item transfers can be accumulated into a single\\n     *      conduit call. Sufficient approvals must be set, either on the\\n     *      respective conduit or on this contract itself.\\n     *\\n     * @param itemType   The type of item to transfer, either ERC721 or ERC1155.\\n     * @param token      The token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The tokenId to transfer.\\n     * @param amount     The amount to transfer.\\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\\n     *                   if any, to source token approvals from. The zero hash\\n     *                   signifies that no conduit should be used, with direct\\n     *                   approvals set on this contract.\\n     */\\n    function _transferIndividual721Or1155Item(\\n        ItemType itemType,\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount,\\n        bytes32 conduitKey\\n    ) internal {\\n        // Determine if the transfer is to be performed via a conduit.\\n        if (conduitKey != bytes32(0)) {\\n            // Use free memory pointer as calldata offset for the conduit call.\\n            uint256 callDataOffset;\\n\\n            // Utilize assembly to place each argument in free memory.\\n            assembly {\\n                // Retrieve the free memory pointer and use it as the offset.\\n                callDataOffset := mload(FreeMemoryPointerSlot)\\n\\n                // Write ConduitInterface.execute.selector to memory.\\n                mstore(callDataOffset, Conduit_execute_signature)\\n\\n                // Write the offset to the ConduitTransfer array in memory.\\n                mstore(\\n                    add(\\n                        callDataOffset,\\n                        Conduit_execute_ConduitTransfer_offset_ptr\\n                    ),\\n                    Conduit_execute_ConduitTransfer_ptr\\n                )\\n\\n                // Write the length of the ConduitTransfer array to memory.\\n                mstore(\\n                    add(\\n                        callDataOffset,\\n                        Conduit_execute_ConduitTransfer_length_ptr\\n                    ),\\n                    Conduit_execute_ConduitTransfer_length\\n                )\\n\\n                // Write the item type to memory.\\n                mstore(\\n                    add(callDataOffset, Conduit_execute_transferItemType_ptr),\\n                    itemType\\n                )\\n\\n                // Write the token to memory.\\n                mstore(\\n                    add(callDataOffset, Conduit_execute_transferToken_ptr),\\n                    token\\n                )\\n\\n                // Write the transfer source to memory.\\n                mstore(\\n                    add(callDataOffset, Conduit_execute_transferFrom_ptr),\\n                    from\\n                )\\n\\n                // Write the transfer recipient to memory.\\n                mstore(add(callDataOffset, Conduit_execute_transferTo_ptr), to)\\n\\n                // Write the token identifier to memory.\\n                mstore(\\n                    add(callDataOffset, Conduit_execute_transferIdentifier_ptr),\\n                    identifier\\n                )\\n\\n                // Write the transfer amount to memory.\\n                mstore(\\n                    add(callDataOffset, Conduit_execute_transferAmount_ptr),\\n                    amount\\n                )\\n            }\\n\\n            // Perform the call to the conduit.\\n            _callConduitUsingOffsets(\\n                conduitKey,\\n                callDataOffset,\\n                OneConduitExecute_size\\n            );\\n        } else {\\n            // Otherwise, determine whether it is an ERC721 or ERC1155 item.\\n            if (itemType == ItemType.ERC721) {\\n                // Ensure that exactly one 721 item is being transferred.\\n                if (amount != 1) {\\n                    _revertInvalidERC721TransferAmount(amount);\\n                }\\n\\n                // Perform transfer via the token contract directly.\\n                _performERC721Transfer(token, from, to, identifier);\\n            } else {\\n                // Perform transfer via the token contract directly.\\n                _performERC1155Transfer(token, from, to, identifier, amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer Ether or other native tokens to a\\n     *      given recipient.\\n     *\\n     * @param to     The recipient of the transfer.\\n     * @param amount The amount to transfer.\\n     */\\n    function _transferNativeTokens(\\n        address payable to,\\n        uint256 amount\\n    ) internal {\\n        // Ensure that the supplied amount is non-zero.\\n        _assertNonZeroAmount(amount);\\n\\n        // Declare a variable indicating whether the call was successful or not.\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        // If the call fails...\\n        if (!success) {\\n            // Revert and pass the revert reason along if one was returned.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // Otherwise, revert with a generic error message.\\n            assembly {\\n                // Store left-padded selector with push4, mem[28:32] = selector\\n                mstore(0, EtherTransferGenericFailure_error_selector)\\n                mstore(EtherTransferGenericFailure_error_account_ptr, to)\\n                mstore(EtherTransferGenericFailure_error_amount_ptr, amount)\\n\\n                // revert(abi.encodeWithSignature(\\n                //   \\\"EtherTransferGenericFailure(address,uint256)\\\", to, amount)\\n                // )\\n                revert(\\n                    Error_selector_offset,\\n                    EtherTransferGenericFailure_error_length\\n                )\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens from a given originator\\n     *      to a given recipient using a given conduit if applicable. Sufficient\\n     *      approvals must be set on this contract or on a respective conduit.\\n     *\\n     * @param token       The ERC20 token to transfer.\\n     * @param from        The originator of the transfer.\\n     * @param to          The recipient of the transfer.\\n     * @param amount      The amount to transfer.\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _transferERC20(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes32 conduitKey,\\n        bytes memory accumulator\\n    ) internal {\\n        // Ensure that the supplied amount is non-zero.\\n        _assertNonZeroAmount(amount);\\n\\n        // Trigger accumulated transfers if the conduits differ.\\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\\n\\n        // If no conduit has been specified...\\n        if (conduitKey == bytes32(0)) {\\n            // Perform the token transfer directly.\\n            _performERC20Transfer(token, from, to, amount);\\n        } else {\\n            // Insert the call to the conduit into the accumulator.\\n            _insert(\\n                conduitKey,\\n                accumulator,\\n                ConduitItemType.ERC20,\\n                token,\\n                from,\\n                to,\\n                uint256(0),\\n                amount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer a single ERC721 token from a given\\n     *      originator to a given recipient. Sufficient approvals must be set,\\n     *      either on the respective conduit or on this contract itself.\\n     *\\n     * @param token       The ERC721 token to transfer.\\n     * @param from        The originator of the transfer.\\n     * @param to          The recipient of the transfer.\\n     * @param identifier  The tokenId to transfer (must be 1 for ERC721).\\n     * @param amount      The amount to transfer.\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _transferERC721(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount,\\n        bytes32 conduitKey,\\n        bytes memory accumulator\\n    ) internal {\\n        // Trigger accumulated transfers if the conduits differ.\\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\\n\\n        // If no conduit has been specified...\\n        if (conduitKey == bytes32(0)) {\\n            // Ensure that exactly one 721 item is being transferred.\\n            if (amount != 1) {\\n                _revertInvalidERC721TransferAmount(amount);\\n            }\\n\\n            // Perform transfer via the token contract directly.\\n            _performERC721Transfer(token, from, to, identifier);\\n        } else {\\n            // Insert the call to the conduit into the accumulator.\\n            _insert(\\n                conduitKey,\\n                accumulator,\\n                ConduitItemType.ERC721,\\n                token,\\n                from,\\n                to,\\n                identifier,\\n                amount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given originator\\n     *      to a given recipient. Sufficient approvals must be set, either on\\n     *      the respective conduit or on this contract itself.\\n     *\\n     * @param token       The ERC1155 token to transfer.\\n     * @param from        The originator of the transfer.\\n     * @param to          The recipient of the transfer.\\n     * @param identifier  The id to transfer.\\n     * @param amount      The amount to transfer.\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _transferERC1155(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount,\\n        bytes32 conduitKey,\\n        bytes memory accumulator\\n    ) internal {\\n        // Ensure that the supplied amount is non-zero.\\n        _assertNonZeroAmount(amount);\\n\\n        // Trigger accumulated transfers if the conduits differ.\\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\\n\\n        // If no conduit has been specified...\\n        if (conduitKey == bytes32(0)) {\\n            // Perform transfer via the token contract directly.\\n            _performERC1155Transfer(token, from, to, identifier, amount);\\n        } else {\\n            // Insert the call to the conduit into the accumulator.\\n            _insert(\\n                conduitKey,\\n                accumulator,\\n                ConduitItemType.ERC1155,\\n                token,\\n                from,\\n                to,\\n                identifier,\\n                amount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to trigger a call to the conduit currently held by\\n     *      the accumulator if the accumulator contains item transfers (i.e. it\\n     *      is \\\"armed\\\") and the supplied conduit key does not match the key held\\n     *      by the accumulator.\\n     *\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     */\\n    function _triggerIfArmedAndNotAccumulatable(\\n        bytes memory accumulator,\\n        bytes32 conduitKey\\n    ) internal {\\n        // Retrieve the current conduit key from the accumulator.\\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\\n\\n        // Perform conduit call if the set key does not match the supplied key.\\n        if (accumulatorConduitKey != conduitKey) {\\n            _triggerIfArmed(accumulator);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to trigger a call to the conduit currently held by\\n     *      the accumulator if the accumulator contains item transfers (i.e. it\\n     *      is \\\"armed\\\").\\n     *\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _triggerIfArmed(bytes memory accumulator) internal {\\n        // Exit if the accumulator is not \\\"armed\\\".\\n        if (accumulator.length != AccumulatorArmed) {\\n            return;\\n        }\\n\\n        // Retrieve the current conduit key from the accumulator.\\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\\n\\n        // Perform conduit call.\\n        _trigger(accumulatorConduitKey, accumulator);\\n    }\\n\\n    /**\\n     * @dev Internal function to trigger a call to the conduit corresponding to\\n     *      a given conduit key, supplying all accumulated item transfers. The\\n     *      accumulator will be \\\"disarmed\\\" and reset in the process.\\n     *\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     */\\n    function _trigger(bytes32 conduitKey, bytes memory accumulator) internal {\\n        // Declare variables for offset in memory & size of calldata to conduit.\\n        uint256 callDataOffset;\\n        uint256 callDataSize;\\n\\n        // Call the conduit with all the accumulated transfers.\\n        assembly {\\n            // Call begins at third word; the first is length or \\\"armed\\\" status,\\n            // and the second is the current conduit key.\\n            callDataOffset := add(accumulator, TwoWords)\\n\\n            // 68 + items * 192\\n            callDataSize := add(\\n                Accumulator_array_offset_ptr,\\n                mul(\\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\\n                    Conduit_transferItem_size\\n                )\\n            )\\n        }\\n\\n        // Call conduit derived from conduit key & supply accumulated transfers.\\n        _callConduitUsingOffsets(conduitKey, callDataOffset, callDataSize);\\n\\n        // Reset accumulator length to signal that it is now \\\"disarmed\\\".\\n        assembly {\\n            mstore(accumulator, AccumulatorDisarmed)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to perform a call to the conduit corresponding to\\n     *      a given conduit key based on the offset and size of the calldata in\\n     *      question in memory.\\n     *\\n     * @param conduitKey     A bytes32 value indicating what corresponding\\n     *                       conduit, if any, to source token approvals from.\\n     *                       The zero hash signifies that no conduit should be\\n     *                       used, with direct approvals set on this contract.\\n     * @param callDataOffset The memory pointer where calldata is contained.\\n     * @param callDataSize   The size of calldata in memory.\\n     */\\n    function _callConduitUsingOffsets(\\n        bytes32 conduitKey,\\n        uint256 callDataOffset,\\n        uint256 callDataSize\\n    ) internal {\\n        // Derive the address of the conduit using the conduit key.\\n        address conduit = _deriveConduit(conduitKey);\\n\\n        bool success;\\n        bytes4 result;\\n\\n        // call the conduit.\\n        assembly {\\n            // Ensure first word of scratch space is empty.\\n            mstore(0, 0)\\n\\n            // Perform call, placing first word of return data in scratch space.\\n            success := call(\\n                gas(),\\n                conduit,\\n                0,\\n                callDataOffset,\\n                callDataSize,\\n                0,\\n                OneWord\\n            )\\n\\n            // Take value from scratch space and place it on the stack.\\n            result := mload(0)\\n        }\\n\\n        // If the call failed...\\n        if (!success) {\\n            // Pass along whatever revert reason was given by the conduit.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // Otherwise, revert with a generic error.\\n            _revertInvalidCallToConduit(conduit);\\n        }\\n\\n        // Ensure result was extracted and matches EIP-1271 magic value.\\n        if (result != ConduitInterface.execute.selector) {\\n            _revertInvalidConduit(conduitKey, conduit);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to retrieve the current conduit key set for\\n     *      the accumulator.\\n     *\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     *\\n     * @return accumulatorConduitKey The conduit key currently set for the\\n     *                               accumulator.\\n     */\\n    function _getAccumulatorConduitKey(\\n        bytes memory accumulator\\n    ) internal pure returns (bytes32 accumulatorConduitKey) {\\n        // Retrieve the current conduit key from the accumulator.\\n        assembly {\\n            accumulatorConduitKey := mload(\\n                add(accumulator, Accumulator_conduitKey_ptr)\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to place an item transfer into an accumulator\\n     *      that collects a series of transfers to execute against a given\\n     *      conduit in a single call.\\n     *\\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\\n     *                    if any, to source token approvals from. The zero hash\\n     *                    signifies that no conduit should be used, with direct\\n     *                    approvals set on this contract.\\n     * @param accumulator An open-ended array that collects transfers to execute\\n     *                    against a given conduit in a single call.\\n     * @param itemType    The type of the item to transfer.\\n     * @param token       The token to transfer.\\n     * @param from        The originator of the transfer.\\n     * @param to          The recipient of the transfer.\\n     * @param identifier  The tokenId to transfer.\\n     * @param amount      The amount to transfer.\\n     */\\n    function _insert(\\n        bytes32 conduitKey,\\n        bytes memory accumulator,\\n        ConduitItemType itemType,\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    ) internal pure {\\n        uint256 elements;\\n        // \\\"Arm\\\" and prime accumulator if it's not already armed. The sentinel\\n        // value is held in the length of the accumulator array.\\n        if (accumulator.length == AccumulatorDisarmed) {\\n            elements = 1;\\n            bytes4 selector = ConduitInterface.execute.selector;\\n            assembly {\\n                mstore(accumulator, AccumulatorArmed) // \\\"arm\\\" the accumulator.\\n                mstore(add(accumulator, Accumulator_conduitKey_ptr), conduitKey)\\n                mstore(add(accumulator, Accumulator_selector_ptr), selector)\\n                mstore(\\n                    add(accumulator, Accumulator_array_offset_ptr),\\n                    Accumulator_array_offset\\n                )\\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\\n            }\\n        } else {\\n            // Otherwise, increase the number of elements by one.\\n            assembly {\\n                elements := add(\\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\\n                    1\\n                )\\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\\n            }\\n        }\\n\\n        // Insert the item.\\n        assembly {\\n            let itemPointer := sub(\\n                add(accumulator, mul(elements, Conduit_transferItem_size)),\\n                Accumulator_itemSizeOffsetDifference\\n            )\\n            mstore(itemPointer, itemType)\\n            mstore(add(itemPointer, Conduit_transferItem_token_ptr), token)\\n            mstore(add(itemPointer, Conduit_transferItem_from_ptr), from)\\n            mstore(add(itemPointer, Conduit_transferItem_to_ptr), to)\\n            mstore(\\n                add(itemPointer, Conduit_transferItem_identifier_ptr),\\n                identifier\\n            )\\n            mstore(add(itemPointer, Conduit_transferItem_amount_ptr), amount)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ZoneInteraction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { OrderType } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    AdvancedOrder,\\n    OrderParameters,\\n    BasicOrderParameters\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { ZoneInteractionErrors } from \\\"../interfaces/ZoneInteractionErrors.sol\\\";\\n\\nimport { LowLevelHelpers } from \\\"./LowLevelHelpers.sol\\\";\\n\\nimport \\\"./ConsiderationEncoder.sol\\\";\\n\\n/**\\n * @title ZoneInteraction\\n * @author 0age\\n * @notice ZoneInteraction contains logic related to interacting with zones.\\n */\\ncontract ZoneInteraction is\\n    ConsiderationEncoder,\\n    ZoneInteractionErrors,\\n    LowLevelHelpers\\n{\\n    /**\\n     * @dev Internal function to determine if an order has a restricted order\\n     *      type and, if so, to ensure that either the zone is the caller or\\n     *      that a call to `validateOrder` on the zone returns a magic value\\n     *      indicating that the order is currently valid. Note that contract\\n     *      orders are not accessible via the basic fulfillment method.\\n     *\\n     * @param orderHash  The hash of the order.\\n     * @param orderType  The order type.\\n     * @param parameters The parameters of the basic order.\\n     */\\n    function _assertRestrictedBasicOrderValidity(\\n        bytes32 orderHash,\\n        OrderType orderType,\\n        BasicOrderParameters calldata parameters\\n    ) internal {\\n        // Order type 2-3 require zone be caller or zone to approve.\\n        // Note that in cases where fulfiller == zone, the restricted order\\n        // validation will be skipped.\\n        if (_isRestrictedAndCallerNotZone(orderType, parameters.zone)) {\\n            // Encode the `validateOrder` call in memory.\\n            (MemoryPointer callData, uint256 size) = _encodeValidateBasicOrder(\\n                orderHash,\\n                parameters\\n            );\\n\\n            // Perform `validateOrder` call and ensure magic value was returned.\\n            _callAndCheckStatus(\\n                parameters.zone,\\n                orderHash,\\n                callData,\\n                size,\\n                InvalidRestrictedOrder_error_selector\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to determine the post-execution validity of\\n     *      restricted and contract orders. Restricted orders where the caller\\n     *      is not the zone must successfully call `validateOrder` with the\\n     *      correct magic value returned. Contract orders must successfully call\\n     *      `ratifyOrder` with the correct magic value returned.\\n     *\\n     * @param advancedOrder The advanced order in question.\\n     * @param orderHashes   The order hashes of each order included as part of\\n     *                      the current fulfillment.\\n     * @param orderHash     The hash of the order.\\n     */\\n    function _assertRestrictedAdvancedOrderValidity(\\n        AdvancedOrder memory advancedOrder,\\n        bytes32[] memory orderHashes,\\n        bytes32 orderHash\\n    ) internal {\\n        // Declare variables that will be assigned based on the order type.\\n        address target;\\n        uint256 errorSelector;\\n        MemoryPointer callData;\\n        uint256 size;\\n\\n        // Retrieve the parameters of the order in question.\\n        OrderParameters memory parameters = advancedOrder.parameters;\\n\\n        // OrderType 2-3 require zone to be caller or approve via validateOrder.\\n        if (\\n            _isRestrictedAndCallerNotZone(parameters.orderType, parameters.zone)\\n        ) {\\n            // Encode the `validateOrder` call in memory.\\n            (callData, size) = _encodeValidateOrder(\\n                orderHash,\\n                parameters,\\n                advancedOrder.extraData,\\n                orderHashes\\n            );\\n\\n            // Set the target to the zone.\\n            target = parameters.zone;\\n\\n            // Set the restricted-order-specific error selector.\\n            errorSelector = InvalidRestrictedOrder_error_selector;\\n        } else if (parameters.orderType == OrderType.CONTRACT) {\\n            // Encode the `ratifyOrder` call in memory.\\n            (callData, size) = _encodeRatifyOrder(\\n                orderHash,\\n                parameters,\\n                advancedOrder.extraData,\\n                orderHashes\\n            );\\n\\n            // Set the target to the offerer.\\n            target = parameters.offerer;\\n\\n            // Set the contract-order-specific error selector.\\n            errorSelector = InvalidContractOrder_error_selector;\\n        } else {\\n            return;\\n        }\\n\\n        // Perform call and ensure a corresponding magic value was returned.\\n        _callAndCheckStatus(target, orderHash, callData, size, errorSelector);\\n    }\\n\\n    /**\\n     * @dev Determines whether the specified order type is restricted and the\\n     *      caller is not the specified zone.\\n     *\\n     * @param orderType     The type of the order to check.\\n     * @param zone          The address of the zone to check against.\\n     *\\n     * @return mustValidate True if the order type is restricted and the caller\\n     *                      is not the specified zone, false otherwise.\\n     */\\n    function _isRestrictedAndCallerNotZone(\\n        OrderType orderType,\\n        address zone\\n    ) internal view returns (bool mustValidate) {\\n        assembly {\\n            mustValidate := and(\\n                or(eq(orderType, 2), eq(orderType, 3)),\\n                iszero(eq(caller(), zone))\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Calls the specified target with the given data and checks the status\\n     *      of the call. Revert reasons will be \\\"bubbled up\\\" if one is returned,\\n     *      otherwise reverting calls will throw a generic error based on the\\n     *      supplied error handler.\\n     *\\n     * @param target        The address of the contract to call.\\n     * @param orderHash     The hash of the order associated with the call.\\n     * @param callData      The data to pass to the contract call.\\n     * @param size          The size of calldata.\\n     * @param errorSelector The error handling function to call if the call\\n     *                      fails or the magic value does not match.\\n     */\\n    function _callAndCheckStatus(\\n        address target,\\n        bytes32 orderHash,\\n        MemoryPointer callData,\\n        uint256 size,\\n        uint256 errorSelector\\n    ) internal {\\n        bool success;\\n        bool magicMatch;\\n        assembly {\\n            // Get magic value from the selector at start of provided calldata.\\n            let magic := and(mload(callData), MaskOverFirstFourBytes)\\n\\n            // Clear the start of scratch space.\\n            mstore(0, 0)\\n\\n            // Perform call, placing result in the first word of scratch space.\\n            success := call(gas(), target, 0, callData, size, 0, OneWord)\\n\\n            // Determine if returned magic value matches the calldata selector.\\n            magicMatch := eq(magic, mload(0))\\n        }\\n\\n        // Revert if the call was not successful.\\n        if (!success) {\\n            // Revert and pass reason along if one was returned.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // If no reason was returned, revert with supplied error selector.\\n            assembly {\\n                mstore(0, errorSelector)\\n                mstore(InvalidRestrictedOrder_error_orderHash_ptr, orderHash)\\n                revert(\\n                    Error_selector_offset,\\n                    InvalidRestrictedOrder_error_length\\n                )\\n            }\\n        }\\n\\n        // Revert if the correct magic value was not returned.\\n        if (!magicMatch) {\\n            // Revert with a generic error message.\\n            assembly {\\n                mstore(0, errorSelector)\\n                mstore(InvalidRestrictedOrder_error_orderHash_ptr, orderHash)\\n                revert(\\n                    Error_selector_offset,\\n                    InvalidRestrictedOrder_error_length\\n                )\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ContractOffererInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { SpentItem, ReceivedItem } from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\ninterface ContractOffererInterface {\\n    function generateOrder(\\n        address fulfiller,\\n        SpentItem[] calldata minimumReceived,\\n        SpentItem[] calldata maximumSpent,\\n        bytes calldata context // encoded based on the schemaID\\n    )\\n        external\\n        returns (SpentItem[] memory offer, ReceivedItem[] memory consideration);\\n\\n    function ratifyOrder(\\n        SpentItem[] calldata offer,\\n        ReceivedItem[] calldata consideration,\\n        bytes calldata context, // encoded based on the schemaID\\n        bytes32[] calldata orderHashes,\\n        uint256 contractNonce\\n    ) external returns (bytes4 ratifyOrderMagicValue);\\n\\n    function previewOrder(\\n        address caller,\\n        address fulfiller,\\n        SpentItem[] calldata minimumReceived,\\n        SpentItem[] calldata maximumSpent,\\n        bytes calldata context // encoded based on the schemaID\\n    )\\n        external\\n        view\\n        returns (SpentItem[] memory offer, ReceivedItem[] memory consideration);\\n\\n    function getMetadata()\\n        external\\n        view\\n        returns (\\n            uint256 schemaID, // maps to a Seaport standard's ID\\n            string memory name,\\n            bytes memory metadata // decoded based on the schemaID\\n        );\\n\\n    // Additional functions and/or events based on schemaID\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Verifiers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { OrderStatus } from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { Assertions } from \\\"./Assertions.sol\\\";\\n\\nimport { SignatureVerification } from \\\"./SignatureVerification.sol\\\";\\n\\nimport \\\"./ConsiderationErrors.sol\\\";\\n\\n/**\\n * @title Verifiers\\n * @author 0age\\n * @notice Verifiers contains functions for performing verifications.\\n */\\ncontract Verifiers is Assertions, SignatureVerification {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) Assertions(conduitController) {}\\n\\n    /**\\n     * @dev Internal view function to ensure that the current time falls within\\n     *      an order's valid timespan.\\n     *\\n     * @param startTime       The time at which the order becomes active.\\n     * @param endTime         The time at which the order becomes inactive.\\n     * @param revertOnInvalid A boolean indicating whether to revert if the\\n     *                        order is not active.\\n     *\\n     * @return valid A boolean indicating whether the order is active.\\n     */\\n    function _verifyTime(\\n        uint256 startTime,\\n        uint256 endTime,\\n        bool revertOnInvalid\\n    ) internal view returns (bool valid) {\\n        // Mark as valid if order has started and has not already ended.\\n        assembly {\\n            valid := and(\\n                iszero(gt(startTime, timestamp())),\\n                gt(endTime, timestamp())\\n            )\\n        }\\n\\n        // Only revert on invalid if revertOnInvalid has been supplied as true.\\n        if (revertOnInvalid && !valid) {\\n            _revertInvalidTime(startTime, endTime);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to verify the signature of an order. An\\n     *      ERC-1271 fallback will be attempted if either the signature length\\n     *      is not 64 or 65 bytes or if the recovered signer does not match the\\n     *      supplied offerer. Note that in cases where a 64 or 65 byte signature\\n     *      is supplied, only standard ECDSA signatures that recover to a\\n     *      non-zero address are supported.\\n     *\\n     * @param offerer   The offerer for the order.\\n     * @param orderHash The order hash.\\n     * @param signature A signature from the offerer indicating that the order\\n     *                  has been approved.\\n     */\\n    function _verifySignature(\\n        address offerer,\\n        bytes32 orderHash,\\n        bytes memory signature\\n    ) internal view {\\n        // Skip signature verification if the offerer is the caller.\\n        if (_unmaskedAddressComparison(offerer, msg.sender)) {\\n            return;\\n        }\\n\\n        bytes32 domainSeparator = _domainSeparator();\\n\\n        // Derive original EIP-712 digest using domain separator and order hash.\\n        bytes32 originalDigest = _deriveEIP712Digest(\\n            domainSeparator,\\n            orderHash\\n        );\\n\\n        uint256 originalSignatureLength = signature.length;\\n\\n        bytes32 digest;\\n        if (_isValidBulkOrderSize(originalSignatureLength)) {\\n            // Rederive order hash and digest using bulk order proof.\\n            (orderHash) = _computeBulkOrderProof(signature, orderHash);\\n            digest = _deriveEIP712Digest(domainSeparator, orderHash);\\n        } else {\\n            digest = originalDigest;\\n        }\\n\\n        // Ensure that the signature for the digest is valid for the offerer.\\n        _assertValidSignature(\\n            offerer,\\n            digest,\\n            originalDigest,\\n            originalSignatureLength,\\n            signature\\n        );\\n    }\\n\\n    /**\\n     * @dev Determines whether the specified bulk order size is valid.\\n     *\\n     * @param signatureLength The signature length of the bulk order to check.\\n     *\\n     * @return validLength True if bulk order size is valid, false otherwise.\\n     */\\n    function _isValidBulkOrderSize(\\n        uint256 signatureLength\\n    ) internal pure returns (bool validLength) {\\n        // Utilize assembly to validate the length; the equivalent logic is\\n        // (64 + x) + 3 + 32y where (0 <= x <= 1) and (1 <= y <= 24).\\n        assembly {\\n            validLength := and(\\n                lt(\\n                    sub(signatureLength, BulkOrderProof_minSize),\\n                    BulkOrderProof_rangeSize\\n                ),\\n                lt(\\n                    and(\\n                        add(\\n                            signatureLength,\\n                            BulkOrderProof_lengthAdjustmentBeforeMask\\n                        ),\\n                        AlmostOneWord\\n                    ),\\n                    BulkOrderProof_lengthRangeAfterMask\\n                )\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the bulk order hash for the specified proof and leaf.\\n     *\\n     * @param proofAndSignature  The proof and signature of the bulk order.\\n     * @param leaf               The leaf of the bulk order tree.\\n     *\\n     * @return bulkOrderHash     The bulk order hash.\\n     */\\n    function _computeBulkOrderProof(\\n        bytes memory proofAndSignature,\\n        bytes32 leaf\\n    ) internal view returns (bytes32 bulkOrderHash) {\\n        // Declare arguments for the root hash and the height of the proof.\\n        bytes32 root;\\n        uint256 height;\\n\\n        // Utilize assembly to efficiently derive the root hash using the proof.\\n        assembly {\\n            // Retrieve the length of the proof, key, and signature combined.\\n            let fullLength := mload(proofAndSignature)\\n\\n            // If proofAndSignature has odd length, it is a compact signature\\n            // with 64 bytes.\\n            let signatureLength := sub(ECDSA_MaxLength, and(fullLength, 1))\\n\\n            // Derive height (or depth of tree) with signature and proof length.\\n            height := shr(OneWordShift, sub(fullLength, signatureLength))\\n\\n            // Update the length in memory to only include the signature.\\n            mstore(proofAndSignature, signatureLength)\\n\\n            // Derive the pointer for the key using the signature length.\\n            let keyPtr := add(proofAndSignature, add(OneWord, signatureLength))\\n\\n            // Retrieve the three-byte key using the derived pointer.\\n            let key := shr(BulkOrderProof_keyShift, mload(keyPtr))\\n\\n            /// Retrieve pointer to first proof element by applying a constant\\n            // for the key size to the derived key pointer.\\n            let proof := add(keyPtr, BulkOrderProof_keySize)\\n\\n            // Compute level 1.\\n            let scratchPtr1 := shl(OneWordShift, and(key, 1))\\n            mstore(scratchPtr1, leaf)\\n            mstore(xor(scratchPtr1, OneWord), mload(proof))\\n\\n            // Compute remaining proofs.\\n            for {\\n                let i := 1\\n            } lt(i, height) {\\n                i := add(i, 1)\\n            } {\\n                proof := add(proof, OneWord)\\n                let scratchPtr := shl(OneWordShift, and(shr(i, key), 1))\\n                mstore(scratchPtr, keccak256(0, TwoWords))\\n                mstore(xor(scratchPtr, OneWord), mload(proof))\\n            }\\n\\n            // Compute root hash.\\n            root := keccak256(0, TwoWords)\\n        }\\n\\n        // Retrieve appropriate typehash from runtime storage based on height.\\n        bytes32 rootTypeHash = _lookupBulkOrderTypehash(height);\\n\\n        // Use the typehash and the root hash to derive final bulk order hash.\\n        assembly {\\n            mstore(0, rootTypeHash)\\n            mstore(OneWord, root)\\n            bulkOrderHash := keccak256(0, TwoWords)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to validate that a given order is fillable\\n     *      and not cancelled based on the order status.\\n     *\\n     * @param orderHash       The order hash.\\n     * @param orderStatus     The status of the order, including whether it has\\n     *                        been cancelled and the fraction filled.\\n     * @param onlyAllowUnused A boolean flag indicating whether partial fills\\n     *                        are supported by the calling function.\\n     * @param revertOnInvalid A boolean indicating whether to revert if the\\n     *                        order has been cancelled or filled beyond the\\n     *                        allowable amount.\\n     *\\n     * @return valid          A boolean indicating whether the order is valid.\\n     */\\n    function _verifyOrderStatus(\\n        bytes32 orderHash,\\n        OrderStatus storage orderStatus,\\n        bool onlyAllowUnused,\\n        bool revertOnInvalid\\n    ) internal view returns (bool valid) {\\n        // Ensure that the order has not been cancelled.\\n        if (orderStatus.isCancelled) {\\n            // Only revert if revertOnInvalid has been supplied as true.\\n            if (revertOnInvalid) {\\n                _revertOrderIsCancelled(orderHash);\\n            }\\n\\n            // Return false as the order status is invalid.\\n            return false;\\n        }\\n\\n        // Read order status numerator from storage and place on stack.\\n        uint256 orderStatusNumerator = orderStatus.numerator;\\n\\n        // If the order is not entirely unused...\\n        if (orderStatusNumerator != 0) {\\n            // ensure the order has not been partially filled when not allowed.\\n            if (onlyAllowUnused) {\\n                // Always revert on partial fills when onlyAllowUnused is true.\\n                _revertOrderPartiallyFilled(orderHash);\\n            }\\n            // Otherwise, ensure that order has not been entirely filled.\\n            else if (orderStatusNumerator >= orderStatus.denominator) {\\n                // Only revert if revertOnInvalid has been supplied as true.\\n                if (revertOnInvalid) {\\n                    _revertOrderAlreadyFilled(orderHash);\\n                }\\n\\n                // Return false as the order status is invalid.\\n                return false;\\n            }\\n        }\\n\\n        // Return true as the order status is valid.\\n        valid = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/TokenTransferrer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"./TokenTransferrerConstants.sol\\\";\\n\\nimport {\\n    TokenTransferrerErrors\\n} from \\\"../interfaces/TokenTransferrerErrors.sol\\\";\\n\\nimport { ConduitBatch1155Transfer } from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\n/**\\n * @title TokenTransferrer\\n * @author 0age\\n * @custom:coauthor d1ll0n\\n * @custom:coauthor transmissions11\\n * @notice TokenTransferrer is a library for performing optimized ERC20, ERC721,\\n *         ERC1155, and batch ERC1155 transfers, used by both Seaport as well as\\n *         by conduits deployed by the ConduitController. Use great caution when\\n *         considering these functions for use in other codebases, as there are\\n *         significant side effects and edge cases that need to be thoroughly\\n *         understood and carefully addressed.\\n */\\ncontract TokenTransferrer is TokenTransferrerErrors {\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens from a given originator\\n     *      to a given recipient. Sufficient approvals must be set on the\\n     *      contract performing the transfer.\\n     *\\n     * @param token      The ERC20 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performERC20Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC20 token transfer.\\n        assembly {\\n            // The free memory pointer memory slot will be used when populating\\n            // call data for the transfer; read the value and restore it later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write call data into memory, starting with function selector.\\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\\n            mstore(ERC20_transferFrom_from_ptr, from)\\n            mstore(ERC20_transferFrom_to_ptr, to)\\n            mstore(ERC20_transferFrom_amount_ptr, amount)\\n\\n            // Make call & copy up to 32 bytes of return data to scratch space.\\n            // Scratch space does not need to be cleared ahead of time, as the\\n            // subsequent check will ensure that either at least a full word of\\n            // return data is received (in which case it will be overwritten) or\\n            // that no data is received (in which case scratch space will be\\n            // ignored) on a successful call to the given token.\\n            let callStatus := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC20_transferFrom_sig_ptr,\\n                ERC20_transferFrom_length,\\n                0,\\n                OneWord\\n            )\\n\\n            // Determine whether transfer was successful using status & result.\\n            let success := and(\\n                // Set success to whether the call reverted, if not check it\\n                // either returned exactly 1 (can't just be non-zero data), or\\n                // had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                callStatus\\n            )\\n\\n            // Handle cases where either the transfer failed or no data was\\n            // returned. Group these, as most transfers will succeed with data.\\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\\n            // but after it's inverted for JUMPI this expression is cheaper.\\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\\n                // If the token has no code or the transfer failed: Equivalent\\n                // to `or(iszero(success), iszero(extcodesize(token)))` but\\n                // after it's inverted for JUMPI this expression is cheaper.\\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\\n                    // If the transfer failed:\\n                    if iszero(success) {\\n                        // If it was due to a revert:\\n                        if iszero(callStatus) {\\n                            // If it returned a message, bubble it up as long as\\n                            // sufficient gas remains to do so:\\n                            if returndatasize() {\\n                                // Ensure that sufficient gas is available to\\n                                // copy returndata while expanding memory where\\n                                // necessary. Start by computing the word size\\n                                // of returndata and allocated memory. Round up\\n                                // to the nearest full word.\\n                                let returnDataWords := shr(\\n                                    OneWordShift,\\n                                    add(returndatasize(), AlmostOneWord)\\n                                )\\n\\n                                // Note: use the free memory pointer in place of\\n                                // msize() to work around a Yul warning that\\n                                // prevents accessing msize directly when the IR\\n                                // pipeline is activated.\\n                                let msizeWords := shr(OneWordShift, memPointer)\\n\\n                                // Next, compute the cost of the returndatacopy.\\n                                let cost := mul(CostPerWord, returnDataWords)\\n\\n                                // Then, compute cost of new memory allocation.\\n                                if gt(returnDataWords, msizeWords) {\\n                                    cost := add(\\n                                        cost,\\n                                        add(\\n                                            mul(\\n                                                sub(\\n                                                    returnDataWords,\\n                                                    msizeWords\\n                                                ),\\n                                                CostPerWord\\n                                            ),\\n                                            shr(\\n                                                MemoryExpansionCoefficientShift,\\n                                                sub(\\n                                                    mul(\\n                                                        returnDataWords,\\n                                                        returnDataWords\\n                                                    ),\\n                                                    mul(msizeWords, msizeWords)\\n                                                )\\n                                            )\\n                                        )\\n                                    )\\n                                }\\n\\n                                // Finally, add a small constant and compare to\\n                                // gas remaining; bubble up the revert data if\\n                                // enough gas is still available.\\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\\n                                    // Copy returndata to memory; overwrite\\n                                    // existing memory.\\n                                    returndatacopy(0, 0, returndatasize())\\n\\n                                    // Revert, specifying memory region with\\n                                    // copied returndata.\\n                                    revert(0, returndatasize())\\n                                }\\n                            }\\n\\n                            // Store left-padded selector with push4, mem[28:32]\\n                            mstore(\\n                                0,\\n                                TokenTransferGenericFailure_error_selector\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_token_ptr,\\n                                token\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_from_ptr,\\n                                from\\n                            )\\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                            mstore(\\n                                TokenTransferGenericFailure_err_identifier_ptr,\\n                                0\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_amount_ptr,\\n                                amount\\n                            )\\n\\n                            // revert(abi.encodeWithSignature(\\n                            //     \\\"TokenTransferGenericFailure(\\n                            //         address,address,address,uint256,uint256\\n                            //     )\\\", token, from, to, identifier, amount\\n                            // ))\\n                            revert(\\n                                Generic_error_selector_offset,\\n                                TokenTransferGenericFailure_error_length\\n                            )\\n                        }\\n\\n                        // Otherwise revert with a message about the token\\n                        // returning false or non-compliant return values.\\n\\n                        // Store left-padded selector with push4, mem[28:32]\\n                        mstore(\\n                            0,\\n                            BadReturnValueFromERC20OnTransfer_error_selector\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\\n                            token\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\\n                            from\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\\n                            to\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\\n                            amount\\n                        )\\n\\n                        // revert(abi.encodeWithSignature(\\n                        //     \\\"BadReturnValueFromERC20OnTransfer(\\n                        //         address,address,address,uint256\\n                        //     )\\\", token, from, to, amount\\n                        // ))\\n                        revert(\\n                            Generic_error_selector_offset,\\n                            BadReturnValueFromERC20OnTransfer_error_length\\n                        )\\n                    }\\n\\n                    // Otherwise, revert with error about token not having code:\\n                    // Store left-padded selector with push4, mem[28:32]\\n                    mstore(0, NoContract_error_selector)\\n                    mstore(NoContract_error_account_ptr, token)\\n\\n                    // revert(abi.encodeWithSignature(\\n                    //      \\\"NoContract(address)\\\", account\\n                    // ))\\n                    revert(\\n                        Generic_error_selector_offset,\\n                        NoContract_error_length\\n                    )\\n                }\\n\\n                // Otherwise, the token just returned no data despite the call\\n                // having succeeded; no need to optimize for this as it's not\\n                // technically ERC20 compliant.\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer an ERC721 token from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer. Note that this function does\\n     *      not check whether the receiver can accept the ERC721 token (i.e. it\\n     *      does not use `safeTransferFrom`).\\n     *\\n     * @param token      The ERC721 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The tokenId to transfer.\\n     */\\n    function _performERC721Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC721 token transfer.\\n        assembly {\\n            // If the token has no code, revert.\\n            if iszero(extcodesize(token)) {\\n                // Store left-padded selector with push4, mem[28:32] = selector\\n                mstore(0, NoContract_error_selector)\\n                mstore(NoContract_error_account_ptr, token)\\n\\n                // revert(abi.encodeWithSignature(\\n                //     \\\"NoContract(address)\\\", account\\n                // ))\\n                revert(Generic_error_selector_offset, NoContract_error_length)\\n            }\\n\\n            // The free memory pointer memory slot will be used when populating\\n            // call data for the transfer; read the value and restore it later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write call data to memory starting with function selector.\\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\\n            mstore(ERC721_transferFrom_from_ptr, from)\\n            mstore(ERC721_transferFrom_to_ptr, to)\\n            mstore(ERC721_transferFrom_id_ptr, identifier)\\n\\n            // Perform the call, ignoring return data.\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC721_transferFrom_sig_ptr,\\n                ERC721_transferFrom_length,\\n                0,\\n                0\\n            )\\n\\n            // If the transfer reverted:\\n            if iszero(success) {\\n                // If it returned a message, bubble it up as long as sufficient\\n                // gas remains to do so:\\n                if returndatasize() {\\n                    // Ensure that sufficient gas is available to copy\\n                    // returndata while expanding memory where necessary. Start\\n                    // by computing word size of returndata & allocated memory.\\n                    // Round up to the nearest full word.\\n                    let returnDataWords := shr(\\n                        OneWordShift,\\n                        add(returndatasize(), AlmostOneWord)\\n                    )\\n\\n                    // Note: use the free memory pointer in place of msize() to\\n                    // work around a Yul warning that prevents accessing msize\\n                    // directly when the IR pipeline is activated.\\n                    let msizeWords := shr(OneWordShift, memPointer)\\n\\n                    // Next, compute the cost of the returndatacopy.\\n                    let cost := mul(CostPerWord, returnDataWords)\\n\\n                    // Then, compute cost of new memory allocation.\\n                    if gt(returnDataWords, msizeWords) {\\n                        cost := add(\\n                            cost,\\n                            add(\\n                                mul(\\n                                    sub(returnDataWords, msizeWords),\\n                                    CostPerWord\\n                                ),\\n                                shr(\\n                                    MemoryExpansionCoefficientShift,\\n                                    sub(\\n                                        mul(returnDataWords, returnDataWords),\\n                                        mul(msizeWords, msizeWords)\\n                                    )\\n                                )\\n                            )\\n                        )\\n                    }\\n\\n                    // Finally, add a small constant and compare to gas\\n                    // remaining; bubble up the revert data if enough gas is\\n                    // still available.\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, giving memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Otherwise revert with a generic error message.\\n                // Store left-padded selector with push4, mem[28:32] = selector\\n                mstore(0, TokenTransferGenericFailure_error_selector)\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                mstore(\\n                    TokenTransferGenericFailure_error_identifier_ptr,\\n                    identifier\\n                )\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\\n\\n                // revert(abi.encodeWithSignature(\\n                //     \\\"TokenTransferGenericFailure(\\n                //         address,address,address,uint256,uint256\\n                //     )\\\", token, from, to, identifier, amount\\n                // ))\\n                revert(\\n                    Generic_error_selector_offset,\\n                    TokenTransferGenericFailure_error_length\\n                )\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer and contract recipients must\\n     *      implement the ERC1155TokenReceiver interface to indicate that they\\n     *      are willing to accept the transfer.\\n     *\\n     * @param token      The ERC1155 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The id to transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performERC1155Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\\n        assembly {\\n            // If the token has no code, revert.\\n            if iszero(extcodesize(token)) {\\n                // Store left-padded selector with push4, mem[28:32] = selector\\n                mstore(0, NoContract_error_selector)\\n                mstore(NoContract_error_account_ptr, token)\\n\\n                // revert(abi.encodeWithSignature(\\n                //     \\\"NoContract(address)\\\", account\\n                // ))\\n                revert(Generic_error_selector_offset, NoContract_error_length)\\n            }\\n\\n            // The following memory slots will be used when populating call data\\n            // for the transfer; read the values and restore them later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n            let slot0x80 := mload(Slot0x80)\\n            let slot0xA0 := mload(Slot0xA0)\\n            let slot0xC0 := mload(Slot0xC0)\\n\\n            // Write call data into memory, beginning with function selector.\\n            mstore(\\n                ERC1155_safeTransferFrom_sig_ptr,\\n                ERC1155_safeTransferFrom_signature\\n            )\\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\\n            mstore(\\n                ERC1155_safeTransferFrom_data_offset_ptr,\\n                ERC1155_safeTransferFrom_data_length_offset\\n            )\\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\\n\\n            // Perform the call, ignoring return data.\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC1155_safeTransferFrom_sig_ptr,\\n                ERC1155_safeTransferFrom_length,\\n                0,\\n                0\\n            )\\n\\n            // If the transfer reverted:\\n            if iszero(success) {\\n                // If it returned a message, bubble it up as long as sufficient\\n                // gas remains to do so:\\n                if returndatasize() {\\n                    // Ensure that sufficient gas is available to copy\\n                    // returndata while expanding memory where necessary. Start\\n                    // by computing word size of returndata & allocated memory.\\n                    // Round up to the nearest full word.\\n                    let returnDataWords := shr(\\n                        OneWordShift,\\n                        add(returndatasize(), AlmostOneWord)\\n                    )\\n\\n                    // Note: use the free memory pointer in place of msize() to\\n                    // work around a Yul warning that prevents accessing msize\\n                    // directly when the IR pipeline is activated.\\n                    let msizeWords := shr(OneWordShift, memPointer)\\n\\n                    // Next, compute the cost of the returndatacopy.\\n                    let cost := mul(CostPerWord, returnDataWords)\\n\\n                    // Then, compute cost of new memory allocation.\\n                    if gt(returnDataWords, msizeWords) {\\n                        cost := add(\\n                            cost,\\n                            add(\\n                                mul(\\n                                    sub(returnDataWords, msizeWords),\\n                                    CostPerWord\\n                                ),\\n                                shr(\\n                                    MemoryExpansionCoefficientShift,\\n                                    sub(\\n                                        mul(returnDataWords, returnDataWords),\\n                                        mul(msizeWords, msizeWords)\\n                                    )\\n                                )\\n                            )\\n                        )\\n                    }\\n\\n                    // Finally, add a small constant and compare to gas\\n                    // remaining; bubble up the revert data if enough gas is\\n                    // still available.\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, giving memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Otherwise revert with a generic error message.\\n\\n                // Store left-padded selector with push4, mem[28:32] = selector\\n                mstore(0, TokenTransferGenericFailure_error_selector)\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                mstore(\\n                    TokenTransferGenericFailure_error_identifier_ptr,\\n                    identifier\\n                )\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\\n\\n                // revert(abi.encodeWithSignature(\\n                //     \\\"TokenTransferGenericFailure(\\n                //         address,address,address,uint256,uint256\\n                //     )\\\", token, from, to, identifier, amount\\n                // ))\\n                revert(\\n                    Generic_error_selector_offset,\\n                    TokenTransferGenericFailure_error_length\\n                )\\n            }\\n\\n            mstore(Slot0x80, slot0x80) // Restore slot 0x80.\\n            mstore(Slot0xA0, slot0xA0) // Restore slot 0xA0.\\n            mstore(Slot0xC0, slot0xC0) // Restore slot 0xC0.\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer and contract recipients must\\n     *      implement the ERC1155TokenReceiver interface to indicate that they\\n     *      are willing to accept the transfer. NOTE: this function is not\\n     *      memory-safe; it will overwrite existing memory, restore the free\\n     *      memory pointer to the default value, and overwrite the zero slot.\\n     *      This function should only be called once memory is no longer\\n     *      required and when uninitialized arrays are not utilized, and memory\\n     *      should be considered fully corrupted (aside from the existence of a\\n     *      default-value free memory pointer) after calling this function.\\n     *\\n     * @param batchTransfers The group of 1155 batch transfers to perform.\\n     */\\n    function _performERC1155BatchTransfers(\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) internal {\\n        // Utilize assembly to perform optimized batch 1155 transfers.\\n        assembly {\\n            let len := batchTransfers.length\\n            // Pointer to first head in the array, which is offset to the struct\\n            // at each index. This gets incremented after each loop to avoid\\n            // multiplying by 32 to get the offset for each element.\\n            let nextElementHeadPtr := batchTransfers.offset\\n\\n            // Pointer to beginning of the head of the array. This is the\\n            // reference position each offset references. It's held static to\\n            // let each loop calculate the data position for an element.\\n            let arrayHeadPtr := nextElementHeadPtr\\n\\n            // Write the function selector, which will be reused for each call:\\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\n            mstore(\\n                ConduitBatch1155Transfer_from_offset,\\n                ERC1155_safeBatchTransferFrom_signature\\n            )\\n\\n            // Iterate over each batch transfer.\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n                i := add(i, 1)\\n            } {\\n                // Read the offset to the beginning of the element and add\\n                // it to pointer to the beginning of the array head to get\\n                // the absolute position of the element in calldata.\\n                let elementPtr := add(\\n                    arrayHeadPtr,\\n                    calldataload(nextElementHeadPtr)\\n                )\\n\\n                // Retrieve the token from calldata.\\n                let token := calldataload(elementPtr)\\n\\n                // If the token has no code, revert.\\n                if iszero(extcodesize(token)) {\\n                    // Store left-padded selector with push4, mem[28:32]\\n                    mstore(0, NoContract_error_selector)\\n                    mstore(NoContract_error_account_ptr, token)\\n\\n                    // revert(abi.encodeWithSignature(\\n                    //     \\\"NoContract(address)\\\", account\\n                    // ))\\n                    revert(\\n                        Generic_error_selector_offset,\\n                        NoContract_error_length\\n                    )\\n                }\\n\\n                // Get the total number of supplied ids.\\n                let idsLength := calldataload(\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\\n                )\\n\\n                // Determine the expected offset for the amounts array.\\n                let expectedAmountsOffset := add(\\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\\n                    shl(OneWordShift, idsLength)\\n                )\\n\\n                // Validate struct encoding.\\n                let invalidEncoding := iszero(\\n                    and(\\n                        // ids.length == amounts.length\\n                        eq(\\n                            idsLength,\\n                            calldataload(add(elementPtr, expectedAmountsOffset))\\n                        ),\\n                        and(\\n                            // ids_offset == 0xa0\\n                            eq(\\n                                calldataload(\\n                                    add(\\n                                        elementPtr,\\n                                        ConduitBatch1155Transfer_ids_head_offset\\n                                    )\\n                                ),\\n                                ConduitBatch1155Transfer_ids_length_offset\\n                            ),\\n                            // amounts_offset == 0xc0 + ids.length*32\\n                            eq(\\n                                calldataload(\\n                                    add(\\n                                        elementPtr,\\n                                        ConduitBatchTransfer_amounts_head_offset\\n                                    )\\n                                ),\\n                                expectedAmountsOffset\\n                            )\\n                        )\\n                    )\\n                )\\n\\n                // Revert with an error if the encoding is not valid.\\n                if invalidEncoding {\\n                    mstore(\\n                        Invalid1155BatchTransferEncoding_ptr,\\n                        Invalid1155BatchTransferEncoding_selector\\n                    )\\n                    revert(\\n                        Invalid1155BatchTransferEncoding_ptr,\\n                        Invalid1155BatchTransferEncoding_length\\n                    )\\n                }\\n\\n                // Update the offset position for the next loop\\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\\n\\n                // Copy the first section of calldata (before dynamic values).\\n                calldatacopy(\\n                    BatchTransfer1155Params_ptr,\\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\\n                    ConduitBatch1155Transfer_usable_head_size\\n                )\\n\\n                // Determine size of calldata required for ids and amounts. Note\\n                // that the size includes both lengths as well as the data.\\n                let idsAndAmountsSize := add(\\n                    TwoWords,\\n                    shl(TwoWordsShift, idsLength)\\n                )\\n\\n                // Update the offset for the data array in memory.\\n                mstore(\\n                    BatchTransfer1155Params_data_head_ptr,\\n                    add(\\n                        BatchTransfer1155Params_ids_length_offset,\\n                        idsAndAmountsSize\\n                    )\\n                )\\n\\n                // Set the length of the data array in memory to zero.\\n                mstore(\\n                    add(\\n                        BatchTransfer1155Params_data_length_basePtr,\\n                        idsAndAmountsSize\\n                    ),\\n                    0\\n                )\\n\\n                // Determine the total calldata size for the call to transfer.\\n                let transferDataSize := add(\\n                    BatchTransfer1155Params_calldata_baseSize,\\n                    idsAndAmountsSize\\n                )\\n\\n                // Copy second section of calldata (including dynamic values).\\n                calldatacopy(\\n                    BatchTransfer1155Params_ids_length_ptr,\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\\n                    idsAndAmountsSize\\n                )\\n\\n                // Perform the call to transfer 1155 tokens.\\n                let success := call(\\n                    gas(),\\n                    token,\\n                    0,\\n                    ConduitBatch1155Transfer_from_offset, // Data portion start.\\n                    transferDataSize, // Location of the length of callData.\\n                    0,\\n                    0\\n                )\\n\\n                // If the transfer reverted:\\n                if iszero(success) {\\n                    // If it returned a message, bubble it up as long as\\n                    // sufficient gas remains to do so:\\n                    if returndatasize() {\\n                        // Ensure that sufficient gas is available to copy\\n                        // returndata while expanding memory where necessary.\\n                        // Start by computing word size of returndata and\\n                        // allocated memory. Round up to the nearest full word.\\n                        let returnDataWords := shr(\\n                            OneWordShift,\\n                            add(returndatasize(), AlmostOneWord)\\n                        )\\n\\n                        // Note: use transferDataSize in place of msize() to\\n                        // work around a Yul warning that prevents accessing\\n                        // msize directly when the IR pipeline is activated.\\n                        // The free memory pointer is not used here because\\n                        // this function does almost all memory management\\n                        // manually and does not update it, and transferDataSize\\n                        // should be the largest memory value used (unless a\\n                        // previous batch was larger).\\n                        let msizeWords := shr(OneWordShift, transferDataSize)\\n\\n                        // Next, compute the cost of the returndatacopy.\\n                        let cost := mul(CostPerWord, returnDataWords)\\n\\n                        // Then, compute cost of new memory allocation.\\n                        if gt(returnDataWords, msizeWords) {\\n                            cost := add(\\n                                cost,\\n                                add(\\n                                    mul(\\n                                        sub(returnDataWords, msizeWords),\\n                                        CostPerWord\\n                                    ),\\n                                    shr(\\n                                        MemoryExpansionCoefficientShift,\\n                                        sub(\\n                                            mul(\\n                                                returnDataWords,\\n                                                returnDataWords\\n                                            ),\\n                                            mul(msizeWords, msizeWords)\\n                                        )\\n                                    )\\n                                )\\n                            )\\n                        }\\n\\n                        // Finally, add a small constant and compare to gas\\n                        // remaining; bubble up the revert data if enough gas is\\n                        // still available.\\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\\n                            // Copy returndata to memory; overwrite existing.\\n                            returndatacopy(0, 0, returndatasize())\\n\\n                            // Revert with memory region containing returndata.\\n                            revert(0, returndatasize())\\n                        }\\n                    }\\n\\n                    // Set the error signature.\\n                    mstore(\\n                        0,\\n                        ERC1155BatchTransferGenericFailure_error_signature\\n                    )\\n\\n                    // Write the token.\\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\\n\\n                    // Increase the offset to ids by 32.\\n                    mstore(\\n                        BatchTransfer1155Params_ids_head_ptr,\\n                        ERC1155BatchTransferGenericFailure_ids_offset\\n                    )\\n\\n                    // Increase the offset to amounts by 32.\\n                    mstore(\\n                        BatchTransfer1155Params_amounts_head_ptr,\\n                        add(\\n                            OneWord,\\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\\n                        )\\n                    )\\n\\n                    // Return modified region. The total size stays the same as\\n                    // `token` uses the same number of bytes as `data.length`.\\n                    revert(0, transferDataSize)\\n                }\\n            }\\n\\n            // Reset the free memory pointer to the default value; memory must\\n            // be assumed to be dirtied and not reused from this point forward.\\n            // Also note that the zero slot is not reset to zero, meaning empty\\n            // arrays cannot be safely created or utilized until it is restored.\\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Assertions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { OrderParameters } from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { GettersAndDerivers } from \\\"./GettersAndDerivers.sol\\\";\\n\\nimport {\\n    TokenTransferrerErrors\\n} from \\\"../interfaces/TokenTransferrerErrors.sol\\\";\\n\\nimport { CounterManager } from \\\"./CounterManager.sol\\\";\\n\\nimport \\\"./ConsiderationErrors.sol\\\";\\n\\n/**\\n * @title Assertions\\n * @author 0age\\n * @notice Assertions contains logic for making various assertions that do not\\n *         fit neatly within a dedicated semantic scope.\\n */\\ncontract Assertions is\\n    GettersAndDerivers,\\n    CounterManager,\\n    TokenTransferrerErrors\\n{\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(\\n        address conduitController\\n    ) GettersAndDerivers(conduitController) {}\\n\\n    /**\\n     * @dev Internal view function to ensure that the supplied consideration\\n     *      array length on a given set of order parameters is not less than the\\n     *      original consideration array length for that order and to retrieve\\n     *      the current counter for a given order's offerer and zone and use it\\n     *      to derive the order hash.\\n     *\\n     * @param orderParameters The parameters of the order to hash.\\n     *\\n     * @return The hash.\\n     */\\n    function _assertConsiderationLengthAndGetOrderHash(\\n        OrderParameters memory orderParameters\\n    ) internal view returns (bytes32) {\\n        // Ensure supplied consideration array length is not less than original.\\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\\n            orderParameters.consideration.length,\\n            orderParameters.totalOriginalConsiderationItems\\n        );\\n\\n        // Derive and return order hash using current counter for the offerer.\\n        return\\n            _deriveOrderHash(\\n                orderParameters,\\n                _getCounter(orderParameters.offerer)\\n            );\\n    }\\n\\n    /**\\n     * @dev Internal pure function to ensure that the supplied consideration\\n     *      array length for an order to be fulfilled is not less than the\\n     *      original consideration array length for that order.\\n     *\\n     * @param suppliedConsiderationItemTotal The number of consideration items\\n     *                                       supplied when fulfilling the order.\\n     * @param originalConsiderationItemTotal The number of consideration items\\n     *                                       supplied on initial order creation.\\n     */\\n    function _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\\n        uint256 suppliedConsiderationItemTotal,\\n        uint256 originalConsiderationItemTotal\\n    ) internal pure {\\n        // Ensure supplied consideration array length is not less than original.\\n        if (suppliedConsiderationItemTotal < originalConsiderationItemTotal) {\\n            _revertMissingOriginalConsiderationItems();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to ensure that a given item amount is not\\n     *      zero.\\n     *\\n     * @param amount The amount to check.\\n     */\\n    function _assertNonZeroAmount(uint256 amount) internal pure {\\n        assembly {\\n            if iszero(amount) {\\n                // Store left-padded selector with push4, mem[28:32] = selector\\n                mstore(0, MissingItemAmount_error_selector)\\n\\n                // revert(abi.encodeWithSignature(\\\"MissingItemAmount()\\\"))\\n                revert(Error_selector_offset, MissingItemAmount_error_length)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to validate calldata offsets for dynamic\\n     *      types in BasicOrderParameters and other parameters. This ensures\\n     *      that functions using the calldata object normally will be using the\\n     *      same data as the assembly functions and that values that are bound\\n     *      to a given range are within that range. Note that no parameters are\\n     *      supplied as all basic order functions use the same calldata\\n     *      encoding.\\n     */\\n    function _assertValidBasicOrderParameters() internal pure {\\n        // Declare a boolean designating basic order parameter offset validity.\\n        bool validOffsets;\\n\\n        // Utilize assembly in order to read offset data directly from calldata.\\n        assembly {\\n            /*\\n             * Checks:\\n             * 1. Order parameters struct offset == 0x20\\n             * 2. Additional recipients arr offset == 0x240\\n             * 3. Signature offset == 0x260 + (recipients.length * 0x40)\\n             * 4. BasicOrderType between 0 and 23 (i.e. < 24)\\n             */\\n            validOffsets := and(\\n                // Order parameters at calldata 0x04 must have offset of 0x20.\\n                eq(\\n                    calldataload(BasicOrder_parameters_cdPtr),\\n                    BasicOrder_parameters_ptr\\n                ),\\n                // Additional recipients at cd 0x224 must have offset of 0x240.\\n                eq(\\n                    calldataload(BasicOrder_additionalRecipients_head_cdPtr),\\n                    BasicOrder_additionalRecipients_head_ptr\\n                )\\n            )\\n\\n            validOffsets := and(\\n                validOffsets,\\n                eq(\\n                    // Load signature offset from calldata 0x244.\\n                    calldataload(BasicOrder_signature_cdPtr),\\n                    // Derive expected offset as start of recipients + len * 64.\\n                    add(\\n                        BasicOrder_signature_ptr,\\n                        shl(\\n                            // Each additional recipient has a length of 0x40.\\n                            AdditionalRecipient_size_shift,\\n                            // Additional recipients length at calldata 0x264.\\n                            calldataload(\\n                                BasicOrder_additionalRecipients_length_cdPtr\\n                            )\\n                        )\\n                    )\\n                )\\n            )\\n\\n            validOffsets := and(\\n                validOffsets,\\n                lt(\\n                    // BasicOrderType parameter at calldata offset 0x124.\\n                    calldataload(BasicOrder_basicOrderType_cdPtr),\\n                    // Value should be less than 24.\\n                    BasicOrder_basicOrderType_range\\n                )\\n            )\\n        }\\n\\n        // Revert with an error if basic order parameter offsets are invalid.\\n        if (!validOffsets) {\\n            _revertInvalidBasicOrderParameterEncoding();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SignatureVerification.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { EIP1271Interface } from \\\"../interfaces/EIP1271Interface.sol\\\";\\n\\nimport {\\n    SignatureVerificationErrors\\n} from \\\"../interfaces/SignatureVerificationErrors.sol\\\";\\n\\nimport { LowLevelHelpers } from \\\"./LowLevelHelpers.sol\\\";\\n\\nimport \\\"./ConsiderationErrors.sol\\\";\\n\\n/**\\n * @title SignatureVerification\\n * @author 0age\\n * @notice SignatureVerification contains logic for verifying signatures.\\n */\\ncontract SignatureVerification is SignatureVerificationErrors, LowLevelHelpers {\\n    /**\\n     * @dev Internal view function to verify the signature of an order. An\\n     *      ERC-1271 fallback will be attempted if either the signature length\\n     *      is not 64 or 65 bytes or if the recovered signer does not match the\\n     *      supplied signer.\\n     *\\n     * @param signer                  The signer for the order.\\n     * @param digest                  The digest to verify signature against.\\n     * @param originalDigest          The original digest to verify signature\\n     *                                against.\\n     * @param originalSignatureLength The original signature length.\\n     * @param signature               A signature from the signer indicating\\n     *                                that the order has been approved.\\n     */\\n    function _assertValidSignature(\\n        address signer,\\n        bytes32 digest,\\n        bytes32 originalDigest,\\n        uint256 originalSignatureLength,\\n        bytes memory signature\\n    ) internal view {\\n        // Declare value for ecrecover equality or 1271 call success status.\\n        bool success;\\n\\n        // Utilize assembly to perform optimized signature verification check.\\n        assembly {\\n            // Ensure that first word of scratch space is empty.\\n            mstore(0, 0)\\n\\n            // Get the length of the signature.\\n            let signatureLength := mload(signature)\\n\\n            // Get the pointer to the value preceding the signature length.\\n            // This will be used for temporary memory overrides - either the\\n            // signature head for isValidSignature or the digest for ecrecover.\\n            let wordBeforeSignaturePtr := sub(signature, OneWord)\\n\\n            // Cache the current value behind the signature to restore it later.\\n            let cachedWordBeforeSignature := mload(wordBeforeSignaturePtr)\\n\\n            // Declare lenDiff + recoveredSigner scope to manage stack pressure.\\n            {\\n                // Take the difference between the max ECDSA signature length\\n                // and the actual signature length. Overflow desired for any\\n                // values > 65. If the diff is not 0 or 1, it is not a valid\\n                // ECDSA signature - move on to EIP1271 check.\\n                let lenDiff := sub(ECDSA_MaxLength, signatureLength)\\n\\n                // Declare variable for recovered signer.\\n                let recoveredSigner\\n\\n                // If diff is 0 or 1, it may be an ECDSA signature.\\n                // Try to recover signer.\\n                if iszero(gt(lenDiff, 1)) {\\n                    // Read the signature `s` value.\\n                    let originalSignatureS := mload(\\n                        add(signature, ECDSA_signature_s_offset)\\n                    )\\n\\n                    // Read the first byte of the word after `s`. If the\\n                    // signature is 65 bytes, this will be the real `v` value.\\n                    // If not, it will need to be modified - doing it this way\\n                    // saves an extra condition.\\n                    let v := byte(\\n                        0,\\n                        mload(add(signature, ECDSA_signature_v_offset))\\n                    )\\n\\n                    // If lenDiff is 1, parse 64-byte signature as ECDSA.\\n                    if lenDiff {\\n                        // Extract yParity from highest bit of vs and add 27 to\\n                        // get v.\\n                        v := add(\\n                            shr(MaxUint8, originalSignatureS),\\n                            Signature_lower_v\\n                        )\\n\\n                        // Extract canonical s from vs, all but the highest bit.\\n                        // Temporarily overwrite the original `s` value in the\\n                        // signature.\\n                        mstore(\\n                            add(signature, ECDSA_signature_s_offset),\\n                            and(\\n                                originalSignatureS,\\n                                EIP2098_allButHighestBitMask\\n                            )\\n                        )\\n                    }\\n                    // Temporarily overwrite the signature length with `v` to\\n                    // conform to the expected input for ecrecover.\\n                    mstore(signature, v)\\n\\n                    // Temporarily overwrite the word before the length with\\n                    // `digest` to conform to the expected input for ecrecover.\\n                    mstore(wordBeforeSignaturePtr, digest)\\n\\n                    // Attempt to recover the signer for the given signature. Do\\n                    // not check the call status as ecrecover will return a null\\n                    // address if the signature is invalid.\\n                    pop(\\n                        staticcall(\\n                            gas(),\\n                            Ecrecover_precompile, // Call ecrecover precompile.\\n                            wordBeforeSignaturePtr, // Use data memory location.\\n                            Ecrecover_args_size, // Size of digest, v, r, and s.\\n                            0, // Write result to scratch space.\\n                            OneWord // Provide size of returned result.\\n                        )\\n                    )\\n\\n                    // Restore cached word before signature.\\n                    mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\\n\\n                    // Restore cached signature length.\\n                    mstore(signature, signatureLength)\\n\\n                    // Restore cached signature `s` value.\\n                    mstore(\\n                        add(signature, ECDSA_signature_s_offset),\\n                        originalSignatureS\\n                    )\\n\\n                    // Read the recovered signer from the buffer given as return\\n                    // space for ecrecover.\\n                    recoveredSigner := mload(0)\\n                }\\n\\n                // Set success to true if the signature provided was a valid\\n                // ECDSA signature and the signer is not the null address. Use\\n                // gt instead of direct as success is used outside of assembly.\\n                success := and(eq(signer, recoveredSigner), gt(signer, 0))\\n            }\\n\\n            // If the signature was not verified with ecrecover, try EIP1271.\\n            if iszero(success) {\\n                // Reset the original signature length.\\n                mstore(signature, originalSignatureLength)\\n\\n                // Temporarily overwrite the word before the signature length\\n                // and use it as the head of the signature input to\\n                // `isValidSignature`, which has a value of 64.\\n                mstore(\\n                    wordBeforeSignaturePtr,\\n                    EIP1271_isValidSignature_signature_head_offset\\n                )\\n\\n                // Get pointer to use for the selector of `isValidSignature`.\\n                let selectorPtr := sub(\\n                    signature,\\n                    EIP1271_isValidSignature_selector_negativeOffset\\n                )\\n\\n                // Cache the value currently stored at the selector pointer.\\n                let cachedWordOverwrittenBySelector := mload(selectorPtr)\\n\\n                // Cache the value currently stored at the digest pointer.\\n                let cachedWordOverwrittenByDigest := mload(\\n                    sub(\\n                        signature,\\n                        EIP1271_isValidSignature_digest_negativeOffset\\n                    )\\n                )\\n\\n                // Write the selector first, since it overlaps the digest.\\n                mstore(selectorPtr, EIP1271_isValidSignature_selector)\\n\\n                // Next, write the original digest.\\n                mstore(\\n                    sub(\\n                        signature,\\n                        EIP1271_isValidSignature_digest_negativeOffset\\n                    ),\\n                    originalDigest\\n                )\\n\\n                // Call signer with `isValidSignature` to validate signature.\\n                success := staticcall(\\n                    gas(),\\n                    signer,\\n                    selectorPtr,\\n                    add(\\n                        originalSignatureLength,\\n                        EIP1271_isValidSignature_calldata_baseLength\\n                    ),\\n                    0,\\n                    OneWord\\n                )\\n\\n                // Determine if the signature is valid on successful calls.\\n                if success {\\n                    // If first word of scratch space does not contain EIP-1271\\n                    // signature selector, revert.\\n                    if iszero(eq(mload(0), EIP1271_isValidSignature_selector)) {\\n                        // Revert with bad 1271 signature if signer has code.\\n                        if extcodesize(signer) {\\n                            // Bad contract signature.\\n                            // Store left-padded selector with push4, mem[28:32]\\n                            mstore(0, BadContractSignature_error_selector)\\n\\n                            // revert(abi.encodeWithSignature(\\n                            //     \\\"BadContractSignature()\\\"\\n                            // ))\\n                            revert(\\n                                Error_selector_offset,\\n                                BadContractSignature_error_length\\n                            )\\n                        }\\n\\n                        // Check if signature length was invalid.\\n                        if gt(sub(ECDSA_MaxLength, signatureLength), 1) {\\n                            // Revert with generic invalid signature error.\\n                            // Store left-padded selector with push4, mem[28:32]\\n                            mstore(0, InvalidSignature_error_selector)\\n\\n                            // revert(abi.encodeWithSignature(\\n                            //     \\\"InvalidSignature()\\\"\\n                            // ))\\n                            revert(\\n                                Error_selector_offset,\\n                                InvalidSignature_error_length\\n                            )\\n                        }\\n\\n                        // Check if v was invalid.\\n                        if and(\\n                            eq(signatureLength, ECDSA_MaxLength),\\n                            iszero(\\n                                byte(\\n                                    byte(\\n                                        0,\\n                                        mload(\\n                                            add(\\n                                                signature,\\n                                                ECDSA_signature_v_offset\\n                                            )\\n                                        )\\n                                    ),\\n                                    ECDSA_twentySeventhAndTwentyEighthBytesSet\\n                                )\\n                            )\\n                        ) {\\n                            // Revert with invalid v value.\\n                            // Store left-padded selector with push4, mem[28:32]\\n                            mstore(0, BadSignatureV_error_selector)\\n                            mstore(\\n                                BadSignatureV_error_v_ptr,\\n                                byte(\\n                                    0,\\n                                    mload(\\n                                        add(signature, ECDSA_signature_v_offset)\\n                                    )\\n                                )\\n                            )\\n\\n                            // revert(abi.encodeWithSignature(\\n                            //     \\\"BadSignatureV(uint8)\\\", v\\n                            // ))\\n                            revert(\\n                                Error_selector_offset,\\n                                BadSignatureV_error_length\\n                            )\\n                        }\\n\\n                        // Revert with generic invalid signer error message.\\n                        // Store left-padded selector with push4, mem[28:32]\\n                        mstore(0, InvalidSigner_error_selector)\\n\\n                        // revert(abi.encodeWithSignature(\\\"InvalidSigner()\\\"))\\n                        revert(\\n                            Error_selector_offset,\\n                            InvalidSigner_error_length\\n                        )\\n                    }\\n                }\\n\\n                // Restore the cached values overwritten by selector, digest and\\n                // signature head.\\n                mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\\n                mstore(selectorPtr, cachedWordOverwrittenBySelector)\\n                mstore(\\n                    sub(\\n                        signature,\\n                        EIP1271_isValidSignature_digest_negativeOffset\\n                    ),\\n                    cachedWordOverwrittenByDigest\\n                )\\n            }\\n        }\\n\\n        // If the call failed...\\n        if (!success) {\\n            // Revert and pass reason along if one was returned.\\n            _revertWithReasonIfOneIsReturned();\\n\\n            // Otherwise, revert with error indicating bad contract signature.\\n            assembly {\\n                // Store left-padded selector with push4, mem[28:32] = selector\\n                mstore(0, BadContractSignature_error_selector)\\n                // revert(abi.encodeWithSignature(\\\"BadContractSignature()\\\"))\\n                revert(Error_selector_offset, BadContractSignature_error_length)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/GettersAndDerivers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { OrderParameters } from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport { ConsiderationBase } from \\\"./ConsiderationBase.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title GettersAndDerivers\\n * @author 0age\\n * @notice ConsiderationInternal contains pure and internal view functions\\n *         related to getting or deriving various values.\\n */\\ncontract GettersAndDerivers is ConsiderationBase {\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(\\n        address conduitController\\n    ) ConsiderationBase(conduitController) {}\\n\\n    /**\\n     * @dev Internal view function to derive the order hash for a given order.\\n     *      Note that only the original consideration items are included in the\\n     *      order hash, as additional consideration items may be supplied by the\\n     *      caller.\\n     *\\n     * @param orderParameters The parameters of the order to hash.\\n     * @param counter         The counter of the order to hash.\\n     *\\n     * @return orderHash The hash.\\n     */\\n    function _deriveOrderHash(\\n        OrderParameters memory orderParameters,\\n        uint256 counter\\n    ) internal view returns (bytes32 orderHash) {\\n        // Get length of original consideration array and place it on the stack.\\n        uint256 originalConsiderationLength = (\\n            orderParameters.totalOriginalConsiderationItems\\n        );\\n\\n        /*\\n         * Memory layout for an array of structs (dynamic or not) is similar\\n         * to ABI encoding of dynamic types, with a head segment followed by\\n         * a data segment. The main difference is that the head of an element\\n         * is a memory pointer rather than an offset.\\n         */\\n\\n        // Declare a variable for the derived hash of the offer array.\\n        bytes32 offerHash;\\n\\n        // Read offer item EIP-712 typehash from runtime code & place on stack.\\n        bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\\n\\n        // Utilize assembly so that memory regions can be reused across hashes.\\n        assembly {\\n            // Retrieve the free memory pointer and place on the stack.\\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\\n\\n            // Get the pointer to the offers array.\\n            let offerArrPtr := mload(\\n                add(orderParameters, OrderParameters_offer_head_offset)\\n            )\\n\\n            // Load the length.\\n            let offerLength := mload(offerArrPtr)\\n\\n            // Set the pointer to the first offer's head.\\n            offerArrPtr := add(offerArrPtr, OneWord)\\n\\n            // Iterate over the offer items.\\n            // prettier-ignore\\n            for { let i := 0 } lt(i, offerLength) {\\n                i := add(i, 1)\\n            } {\\n                // Read the pointer to the offer data and subtract one word\\n                // to get typeHash pointer.\\n                let ptr := sub(mload(offerArrPtr), OneWord)\\n\\n                // Read the current value before the offer data.\\n                let value := mload(ptr)\\n\\n                // Write the type hash to the previous word.\\n                mstore(ptr, typeHash)\\n\\n                // Take the EIP712 hash and store it in the hash array.\\n                mstore(hashArrPtr, keccak256(ptr, EIP712_OfferItem_size))\\n\\n                // Restore the previous word.\\n                mstore(ptr, value)\\n\\n                // Increment the array pointers by one word.\\n                offerArrPtr := add(offerArrPtr, OneWord)\\n                hashArrPtr := add(hashArrPtr, OneWord)\\n            }\\n\\n            // Derive the offer hash using the hashes of each item.\\n            offerHash := keccak256(\\n                mload(FreeMemoryPointerSlot),\\n                shl(OneWordShift, offerLength)\\n            )\\n        }\\n\\n        // Declare a variable for the derived hash of the consideration array.\\n        bytes32 considerationHash;\\n\\n        // Read consideration item typehash from runtime code & place on stack.\\n        typeHash = _CONSIDERATION_ITEM_TYPEHASH;\\n\\n        // Utilize assembly so that memory regions can be reused across hashes.\\n        assembly {\\n            // Retrieve the free memory pointer and place on the stack.\\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\\n\\n            // Get the pointer to the consideration array.\\n            let considerationArrPtr := add(\\n                mload(\\n                    add(\\n                        orderParameters,\\n                        OrderParameters_consideration_head_offset\\n                    )\\n                ),\\n                OneWord\\n            )\\n\\n            // Iterate over the consideration items (not including tips).\\n            // prettier-ignore\\n            for { let i := 0 } lt(i, originalConsiderationLength) {\\n                i := add(i, 1)\\n            } {\\n                // Read the pointer to the consideration data and subtract one\\n                // word to get typeHash pointer.\\n                let ptr := sub(mload(considerationArrPtr), OneWord)\\n\\n                // Read the current value before the consideration data.\\n                let value := mload(ptr)\\n\\n                // Write the type hash to the previous word.\\n                mstore(ptr, typeHash)\\n\\n                // Take the EIP712 hash and store it in the hash array.\\n                mstore(\\n                    hashArrPtr,\\n                    keccak256(ptr, EIP712_ConsiderationItem_size)\\n                )\\n\\n                // Restore the previous word.\\n                mstore(ptr, value)\\n\\n                // Increment the array pointers by one word.\\n                considerationArrPtr := add(considerationArrPtr, OneWord)\\n                hashArrPtr := add(hashArrPtr, OneWord)\\n            }\\n\\n            // Derive the consideration hash using the hashes of each item.\\n            considerationHash := keccak256(\\n                mload(FreeMemoryPointerSlot),\\n                shl(OneWordShift, originalConsiderationLength)\\n            )\\n        }\\n\\n        // Read order item EIP-712 typehash from runtime code & place on stack.\\n        typeHash = _ORDER_TYPEHASH;\\n\\n        // Utilize assembly to access derived hashes & other arguments directly.\\n        assembly {\\n            // Retrieve pointer to the region located just behind parameters.\\n            let typeHashPtr := sub(orderParameters, OneWord)\\n\\n            // Store the value at that pointer location to restore later.\\n            let previousValue := mload(typeHashPtr)\\n\\n            // Store the order item EIP-712 typehash at the typehash location.\\n            mstore(typeHashPtr, typeHash)\\n\\n            // Retrieve the pointer for the offer array head.\\n            let offerHeadPtr := add(\\n                orderParameters,\\n                OrderParameters_offer_head_offset\\n            )\\n\\n            // Retrieve the data pointer referenced by the offer head.\\n            let offerDataPtr := mload(offerHeadPtr)\\n\\n            // Store the offer hash at the retrieved memory location.\\n            mstore(offerHeadPtr, offerHash)\\n\\n            // Retrieve the pointer for the consideration array head.\\n            let considerationHeadPtr := add(\\n                orderParameters,\\n                OrderParameters_consideration_head_offset\\n            )\\n\\n            // Retrieve the data pointer referenced by the consideration head.\\n            let considerationDataPtr := mload(considerationHeadPtr)\\n\\n            // Store the consideration hash at the retrieved memory location.\\n            mstore(considerationHeadPtr, considerationHash)\\n\\n            // Retrieve the pointer for the counter.\\n            let counterPtr := add(\\n                orderParameters,\\n                OrderParameters_counter_offset\\n            )\\n\\n            // Store the counter at the retrieved memory location.\\n            mstore(counterPtr, counter)\\n\\n            // Derive the order hash using the full range of order parameters.\\n            orderHash := keccak256(typeHashPtr, EIP712_Order_size)\\n\\n            // Restore the value previously held at typehash pointer location.\\n            mstore(typeHashPtr, previousValue)\\n\\n            // Restore offer data pointer at the offer head pointer location.\\n            mstore(offerHeadPtr, offerDataPtr)\\n\\n            // Restore consideration data pointer at the consideration head ptr.\\n            mstore(considerationHeadPtr, considerationDataPtr)\\n\\n            // Restore consideration item length at the counter pointer.\\n            mstore(counterPtr, originalConsiderationLength)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to derive the address of a given conduit\\n     *      using a corresponding conduit key.\\n     *\\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\\n     *                   if any, to source token approvals from. This value is\\n     *                   the \\\"salt\\\" parameter supplied by the deployer (i.e. the\\n     *                   conduit controller) when deploying the given conduit.\\n     *\\n     * @return conduit The address of the conduit associated with the given\\n     *                 conduit key.\\n     */\\n    function _deriveConduit(\\n        bytes32 conduitKey\\n    ) internal view returns (address conduit) {\\n        // Read conduit controller address from runtime and place on the stack.\\n        address conduitController = address(_CONDUIT_CONTROLLER);\\n\\n        // Read conduit creation code hash from runtime and place on the stack.\\n        bytes32 conduitCreationCodeHash = _CONDUIT_CREATION_CODE_HASH;\\n\\n        // Leverage scratch space to perform an efficient hash.\\n        assembly {\\n            // Retrieve the free memory pointer; it will be replaced afterwards.\\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Place the control character and the conduit controller in scratch\\n            // space; note that eleven bytes at the beginning are left unused.\\n            mstore(0, or(MaskOverByteTwelve, conduitController))\\n\\n            // Place the conduit key in the next region of scratch space.\\n            mstore(OneWord, conduitKey)\\n\\n            // Place conduit creation code hash in free memory pointer location.\\n            mstore(TwoWords, conduitCreationCodeHash)\\n\\n            // Derive conduit by hashing and applying a mask over last 20 bytes.\\n            conduit := and(\\n                // Hash the relevant region.\\n                keccak256(\\n                    // The region starts at memory pointer 11.\\n                    Create2AddressDerivation_ptr,\\n                    // The region is 85 bytes long (1 + 20 + 32 + 32).\\n                    Create2AddressDerivation_length\\n                ),\\n                // The address equals the last twenty bytes of the hash.\\n                MaskOverLastTwentyBytes\\n            )\\n\\n            // Restore the free memory pointer.\\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to get the EIP-712 domain separator. If the\\n     *      chainId matches the chainId set on deployment, the cached domain\\n     *      separator will be returned; otherwise, it will be derived from\\n     *      scratch.\\n     *\\n     * @return The domain separator.\\n     */\\n    function _domainSeparator() internal view returns (bytes32) {\\n        // prettier-ignore\\n        return block.chainid == _CHAIN_ID\\n            ? _DOMAIN_SEPARATOR\\n            : _deriveDomainSeparator();\\n    }\\n\\n    /**\\n     * @dev Internal view function to retrieve configuration information for\\n     *      this contract.\\n     *\\n     * @return The contract version.\\n     * @return The domain separator for this contract.\\n     * @return The conduit Controller set for this contract.\\n     */\\n    function _information()\\n        internal\\n        view\\n        returns (\\n            string memory /* version */,\\n            bytes32 /* domainSeparator */,\\n            address /* conduitController */\\n        )\\n    {\\n        // Derive the domain separator.\\n        bytes32 domainSeparator = _domainSeparator();\\n\\n        // Declare variable as immutables cannot be accessed within assembly.\\n        address conduitController = address(_CONDUIT_CONTROLLER);\\n\\n        // Return the version, domain separator, and conduit controller.\\n        assembly {\\n            mstore(information_version_offset, information_version_cd_offset)\\n            mstore(information_domainSeparator_offset, domainSeparator)\\n            mstore(information_conduitController_offset, conduitController)\\n            mstore(information_versionLengthPtr, information_versionWithLength)\\n            return(information_version_offset, information_length)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to efficiently derive an digest to sign for\\n     *      an order in accordance with EIP-712.\\n     *\\n     * @param domainSeparator The domain separator.\\n     * @param orderHash       The order hash.\\n     *\\n     * @return value The hash.\\n     */\\n    function _deriveEIP712Digest(\\n        bytes32 domainSeparator,\\n        bytes32 orderHash\\n    ) internal pure returns (bytes32 value) {\\n        // Leverage scratch space to perform an efficient hash.\\n        assembly {\\n            // Place the EIP-712 prefix at the start of scratch space.\\n            mstore(0, EIP_712_PREFIX)\\n\\n            // Place the domain separator in the next region of scratch space.\\n            mstore(EIP712_DomainSeparator_offset, domainSeparator)\\n\\n            // Place the order hash in scratch space, spilling into the first\\n            // two bytes of the free memory pointer — this should never be set\\n            // as memory cannot be expanded to that size, and will be zeroed out\\n            // after the hash is performed.\\n            mstore(EIP712_OrderHash_offset, orderHash)\\n\\n            // Hash the relevant region (65 bytes).\\n            value := keccak256(0, EIP712_DigestPayload_size)\\n\\n            // Clear out the dirtied bits in the memory pointer.\\n            mstore(EIP712_OrderHash_offset, 0)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TokenTransferrerErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title TokenTransferrerErrors\\n */\\ninterface TokenTransferrerErrors {\\n    /**\\n     * @dev Revert with an error when an ERC721 transfer with amount other than\\n     *      one is attempted.\\n     *\\n     * @param amount The amount of the ERC721 tokens to transfer.\\n     */\\n    error InvalidERC721TransferAmount(uint256 amount);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order where an\\n     *      item has an amount of zero.\\n     */\\n    error MissingItemAmount();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order where an\\n     *      item has unused parameters. This includes both the token and the\\n     *      identifier parameters for native transfers as well as the identifier\\n     *      parameter for ERC20 transfers. Note that the conduit does not\\n     *      perform this check, leaving it up to the calling channel to enforce\\n     *      when desired.\\n     */\\n    error UnusedItemParameters();\\n\\n    /**\\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\\n     *      transfer reverts.\\n     *\\n     * @param token      The token for which the transfer was attempted.\\n     * @param from       The source of the attempted transfer.\\n     * @param to         The recipient of the attempted transfer.\\n     * @param identifier The identifier for the attempted transfer.\\n     * @param amount     The amount for the attempted transfer.\\n     */\\n    error TokenTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\\n     *\\n     * @param token       The token for which the transfer was attempted.\\n     * @param from        The source of the attempted transfer.\\n     * @param to          The recipient of the attempted transfer.\\n     * @param identifiers The identifiers for the attempted transfer.\\n     * @param amounts     The amounts for the attempted transfer.\\n     */\\n    error ERC1155BatchTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256[] identifiers,\\n        uint256[] amounts\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\\n     *      value.\\n     *\\n     * @param token      The token for which the ERC20 transfer was attempted.\\n     * @param from       The source of the attempted ERC20 transfer.\\n     * @param to         The recipient of the attempted ERC20 transfer.\\n     * @param amount     The amount for the attempted ERC20 transfer.\\n     */\\n    error BadReturnValueFromERC20OnTransfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an account being called as an assumed\\n     *      contract does not have code and returns no data.\\n     *\\n     * @param account The account that should contain code.\\n     */\\n    error NoContract(address account);\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute an 1155 batch\\n     *      transfer using calldata not produced by default ABI encoding or with\\n     *      different lengths for ids and amounts arrays.\\n     */\\n    error Invalid1155BatchTransferEncoding();\\n}\\n\"\r\n    },\r\n    \"contracts/lib/CounterManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {\\n    ConsiderationEventsAndErrors\\n} from \\\"../interfaces/ConsiderationEventsAndErrors.sol\\\";\\n\\nimport { ReentrancyGuard } from \\\"./ReentrancyGuard.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title CounterManager\\n * @author 0age\\n * @notice CounterManager contains a storage mapping and related functionality\\n *         for retrieving and incrementing a per-offerer counter.\\n */\\ncontract CounterManager is ConsiderationEventsAndErrors, ReentrancyGuard {\\n    // Only orders signed using an offerer's current counter are fulfillable.\\n    mapping(address => uint256) private _counters;\\n\\n    /**\\n     * @dev Internal function to cancel all orders from a given offerer in bulk\\n     *      by incrementing a counter by a large, quasi-random interval. Note\\n     *      that only the offerer may increment the counter. Note that the\\n     *      counter is incremented by a large, quasi-random interval, which\\n     *      makes it infeasible to \\\"activate\\\" signed orders by incrementing the\\n     *      counter.  This activation functionality can be achieved instead with\\n     *      restricted orders or contract orders.\\n     *\\n     * @return newCounter The new counter.\\n     */\\n    function _incrementCounter() internal returns (uint256 newCounter) {\\n        // Ensure that the reentrancy guard is not currently set.\\n        _assertNonReentrant();\\n\\n        // Utilize assembly to access counters storage mapping directly. Skip\\n        // overflow check as counter cannot be incremented that far.\\n        assembly {\\n            // Use second half of previous block hash as a quasi-random number.\\n            let quasiRandomNumber := shr(\\n                Counter_blockhash_shift,\\n                blockhash(sub(number(), 1))\\n            )\\n\\n            // Write the caller to scratch space.\\n            mstore(0, caller())\\n\\n            // Write the storage slot for _counters to scratch space.\\n            mstore(OneWord, _counters.slot)\\n\\n            // Derive the storage pointer for the counter value.\\n            let storagePointer := keccak256(0, TwoWords)\\n\\n            // Derive new counter value using random number and original value.\\n            newCounter := add(quasiRandomNumber, sload(storagePointer))\\n\\n            // Store the updated counter value.\\n            sstore(storagePointer, newCounter)\\n        }\\n\\n        // Emit an event containing the new counter.\\n        emit CounterIncremented(newCounter, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Internal view function to retrieve the current counter for a given\\n     *      offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return currentCounter The current counter.\\n     */\\n    function _getCounter(\\n        address offerer\\n    ) internal view returns (uint256 currentCounter) {\\n        // Return the counter for the supplied offerer.\\n        currentCounter = _counters[offerer];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ConsiderationBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {\\n    ConduitControllerInterface\\n} from \\\"../interfaces/ConduitControllerInterface.sol\\\";\\n\\nimport {\\n    ConsiderationEventsAndErrors\\n} from \\\"../interfaces/ConsiderationEventsAndErrors.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\nimport { ConsiderationDecoder } from \\\"./ConsiderationDecoder.sol\\\";\\nimport { ConsiderationEncoder } from \\\"./ConsiderationEncoder.sol\\\";\\n\\nimport { TypehashDirectory } from \\\"./TypehashDirectory.sol\\\";\\n\\n/**\\n * @title ConsiderationBase\\n * @author 0age\\n * @notice ConsiderationBase contains immutable constants and constructor logic.\\n */\\ncontract ConsiderationBase is\\n    ConsiderationDecoder,\\n    ConsiderationEncoder,\\n    ConsiderationEventsAndErrors\\n{\\n    // Precompute hashes, original chainId, and domain separator on deployment.\\n    bytes32 internal immutable _NAME_HASH;\\n    bytes32 internal immutable _VERSION_HASH;\\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\\n    bytes32 internal immutable _OFFER_ITEM_TYPEHASH;\\n    bytes32 internal immutable _CONSIDERATION_ITEM_TYPEHASH;\\n    bytes32 internal immutable _ORDER_TYPEHASH;\\n    uint256 internal immutable _CHAIN_ID;\\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\\n\\n    // Allow for interaction with the conduit controller.\\n    ConduitControllerInterface internal immutable _CONDUIT_CONTROLLER;\\n\\n    // BulkOrder typehash storage\\n    TypehashDirectory internal immutable _BULK_ORDER_TYPEHASH_DIRECTORY;\\n\\n    // Cache the conduit creation code hash used by the conduit controller.\\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\\n\\n    /**\\n     * @dev Derive and set hashes, reference chainId, and associated domain\\n     *      separator during deployment.\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) {\\n        // Derive name and version hashes alongside required EIP-712 typehashes.\\n        (\\n            _NAME_HASH,\\n            _VERSION_HASH,\\n            _EIP_712_DOMAIN_TYPEHASH,\\n            _OFFER_ITEM_TYPEHASH,\\n            _CONSIDERATION_ITEM_TYPEHASH,\\n            _ORDER_TYPEHASH\\n        ) = _deriveTypehashes();\\n\\n        _BULK_ORDER_TYPEHASH_DIRECTORY = new TypehashDirectory();\\n\\n        // Store the current chainId and derive the current domain separator.\\n        _CHAIN_ID = block.chainid;\\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\\n\\n        // Set the supplied conduit controller.\\n        _CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\\n\\n        // Retrieve the conduit creation code hash from the supplied controller.\\n        (_CONDUIT_CREATION_CODE_HASH, ) = (\\n            _CONDUIT_CONTROLLER.getConduitCodeHashes()\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal view function to derive the EIP-712 domain separator.\\n     *\\n     * @return domainSeparator The derived domain separator.\\n     */\\n    function _deriveDomainSeparator()\\n        internal\\n        view\\n        returns (bytes32 domainSeparator)\\n    {\\n        bytes32 typehash = _EIP_712_DOMAIN_TYPEHASH;\\n        bytes32 nameHash = _NAME_HASH;\\n        bytes32 versionHash = _VERSION_HASH;\\n\\n        // Leverage scratch space and other memory to perform an efficient hash.\\n        assembly {\\n            // Retrieve the free memory pointer; it will be replaced afterwards.\\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Retrieve value at 0x80; it will also be replaced afterwards.\\n            let slot0x80 := mload(Slot0x80)\\n\\n            // Place typehash, name hash, and version hash at start of memory.\\n            mstore(0, typehash)\\n            mstore(EIP712_domainData_nameHash_offset, nameHash)\\n            mstore(EIP712_domainData_versionHash_offset, versionHash)\\n\\n            // Place chainId in the next memory location.\\n            mstore(EIP712_domainData_chainId_offset, chainid())\\n\\n            // Place the address of this contract in the next memory location.\\n            mstore(EIP712_domainData_verifyingContract_offset, address())\\n\\n            // Hash relevant region of memory to derive the domain separator.\\n            domainSeparator := keccak256(0, EIP712_domainData_size)\\n\\n            // Restore the free memory pointer.\\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n\\n            // Restore the value at 0x80.\\n            mstore(Slot0x80, slot0x80)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to retrieve the default name of this\\n     *      contract and return.\\n     *\\n     * @return The name of this contract.\\n     */\\n    function _name() internal pure virtual returns (string memory) {\\n        // Return the name of the contract.\\n        assembly {\\n            // First element is the offset for the returned string. Offset the\\n            // value in memory by one word so that the free memory pointer will\\n            // be overwritten by the next write.\\n            mstore(OneWord, OneWord)\\n\\n            // Name is right padded, so it touches the length which is left\\n            // padded. This enables writing both values at once. The free memory\\n            // pointer will be overwritten in the process.\\n            mstore(NameLengthPtr, NameWithLength)\\n\\n            // Standard ABI encoding pads returned data to the nearest word. Use\\n            // the already empty zero slot memory region for this purpose and\\n            // return the final name string, offset by the original single word.\\n            return(OneWord, ThreeWords)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to retrieve the default name of this contract\\n     *      as a string that can be used internally.\\n     *\\n     * @return The name of this contract.\\n     */\\n    function _nameString() internal pure virtual returns (string memory) {\\n        // Return the name of the contract.\\n        return \\\"Consideration\\\";\\n    }\\n\\n    /**\\n     * @dev Internal pure function to derive required EIP-712 typehashes and\\n     *      other hashes during contract creation.\\n     *\\n     * @return nameHash                  The hash of the name of the contract.\\n     * @return versionHash               The hash of the version string of the\\n     *                                   contract.\\n     * @return eip712DomainTypehash      The primary EIP-712 domain typehash.\\n     * @return offerItemTypehash         The EIP-712 typehash for OfferItem\\n     *                                   types.\\n     * @return considerationItemTypehash The EIP-712 typehash for\\n     *                                   ConsiderationItem types.\\n     * @return orderTypehash             The EIP-712 typehash for Order types.\\n     */\\n    function _deriveTypehashes()\\n        internal\\n        pure\\n        returns (\\n            bytes32 nameHash,\\n            bytes32 versionHash,\\n            bytes32 eip712DomainTypehash,\\n            bytes32 offerItemTypehash,\\n            bytes32 considerationItemTypehash,\\n            bytes32 orderTypehash\\n        )\\n    {\\n        // Derive hash of the name of the contract.\\n        nameHash = keccak256(bytes(_nameString()));\\n\\n        // Derive hash of the version string of the contract.\\n        versionHash = keccak256(bytes(\\\"1.2\\\"));\\n\\n        // Construct the OfferItem type string.\\n        // prettier-ignore\\n        bytes memory offerItemTypeString = bytes(\\n            \\\"OfferItem(\\\"\\n                \\\"uint8 itemType,\\\"\\n                \\\"address token,\\\"\\n                \\\"uint256 identifierOrCriteria,\\\"\\n                \\\"uint256 startAmount,\\\"\\n                \\\"uint256 endAmount\\\"\\n            \\\")\\\"\\n        );\\n\\n        // Construct the ConsiderationItem type string.\\n        // prettier-ignore\\n        bytes memory considerationItemTypeString = bytes(\\n            \\\"ConsiderationItem(\\\"\\n                \\\"uint8 itemType,\\\"\\n                \\\"address token,\\\"\\n                \\\"uint256 identifierOrCriteria,\\\"\\n                \\\"uint256 startAmount,\\\"\\n                \\\"uint256 endAmount,\\\"\\n                \\\"address recipient\\\"\\n            \\\")\\\"\\n        );\\n\\n        // Construct the OrderComponents type string, not including the above.\\n        // prettier-ignore\\n        bytes memory orderComponentsPartialTypeString = bytes(\\n            \\\"OrderComponents(\\\"\\n                \\\"address offerer,\\\"\\n                \\\"address zone,\\\"\\n                \\\"OfferItem[] offer,\\\"\\n                \\\"ConsiderationItem[] consideration,\\\"\\n                \\\"uint8 orderType,\\\"\\n                \\\"uint256 startTime,\\\"\\n                \\\"uint256 endTime,\\\"\\n                \\\"bytes32 zoneHash,\\\"\\n                \\\"uint256 salt,\\\"\\n                \\\"bytes32 conduitKey,\\\"\\n                \\\"uint256 counter\\\"\\n            \\\")\\\"\\n        );\\n\\n        // Construct the primary EIP-712 domain type string.\\n        // prettier-ignore\\n        eip712DomainTypehash = keccak256(\\n            bytes(\\n                \\\"EIP712Domain(\\\"\\n                    \\\"string name,\\\"\\n                    \\\"string version,\\\"\\n                    \\\"uint256 chainId,\\\"\\n                    \\\"address verifyingContract\\\"\\n                \\\")\\\"\\n            )\\n        );\\n\\n        // Derive the OfferItem type hash using the corresponding type string.\\n        offerItemTypehash = keccak256(offerItemTypeString);\\n\\n        // Derive ConsiderationItem type hash using corresponding type string.\\n        considerationItemTypehash = keccak256(considerationItemTypeString);\\n\\n        bytes memory orderTypeString = bytes.concat(\\n            orderComponentsPartialTypeString,\\n            considerationItemTypeString,\\n            offerItemTypeString\\n        );\\n\\n        // Derive OrderItem type hash via combination of relevant type strings.\\n        orderTypehash = keccak256(orderTypeString);\\n    }\\n\\n    function _lookupBulkOrderTypehash(\\n        uint256 treeHeight\\n    ) internal view returns (bytes32 typeHash) {\\n        TypehashDirectory directory = _BULK_ORDER_TYPEHASH_DIRECTORY;\\n        assembly {\\n            let typeHashOffset := add(1, shl(OneWordShift, sub(treeHeight, 1)))\\n            extcodecopy(directory, 0, typeHashOffset, OneWord)\\n            typeHash := mload(0)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ConduitControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title ConduitControllerInterface\\n * @author 0age\\n * @notice ConduitControllerInterface contains all external function interfaces,\\n *         structs, events, and errors for the conduit controller.\\n */\\ninterface ConduitControllerInterface {\\n    /**\\n     * @dev Track the conduit key, current owner, new potential owner, and open\\n     *      channels for each deployed conduit.\\n     */\\n    struct ConduitProperties {\\n        bytes32 key;\\n        address owner;\\n        address potentialOwner;\\n        address[] channels;\\n        mapping(address => uint256) channelIndexesPlusOne;\\n    }\\n\\n    /**\\n     * @dev Emit an event whenever a new conduit is created.\\n     *\\n     * @param conduit    The newly created conduit.\\n     * @param conduitKey The conduit key used to create the new conduit.\\n     */\\n    event NewConduit(address conduit, bytes32 conduitKey);\\n\\n    /**\\n     * @dev Emit an event whenever conduit ownership is transferred.\\n     *\\n     * @param conduit       The conduit for which ownership has been\\n     *                      transferred.\\n     * @param previousOwner The previous owner of the conduit.\\n     * @param newOwner      The new owner of the conduit.\\n     */\\n    event OwnershipTransferred(\\n        address indexed conduit,\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever a conduit owner registers a new potential\\n     *      owner for that conduit.\\n     *\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit using a\\n     *      conduit key where the first twenty bytes of the key do not match the\\n     *      address of the caller.\\n     */\\n    error InvalidCreator();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit when no\\n     *      initial owner address is supplied.\\n     */\\n    error InvalidInitialOwner();\\n\\n    /**\\n     * @dev Revert with an error when attempting to set a new potential owner\\n     *      that is already set.\\n     */\\n    error NewPotentialOwnerAlreadySet(\\n        address conduit,\\n        address newPotentialOwner\\n    );\\n\\n    /**\\n     * @dev Revert with an error when attempting to cancel ownership transfer\\n     *      when no new potential owner is currently set.\\n     */\\n    error NoPotentialOwnerCurrentlySet(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to interact with a conduit that\\n     *      does not yet exist.\\n     */\\n    error NoConduit();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a conduit that\\n     *      already exists.\\n     */\\n    error ConduitAlreadyExists(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update channels or transfer\\n     *      ownership of a conduit when the caller is not the owner of the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to register a new potential\\n     *      owner and supplying the null address.\\n     */\\n    error NewPotentialOwnerIsZeroAddress(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to claim ownership of a conduit\\n     *      with a caller that is not the current potential owner for the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotNewPotentialOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to retrieve a channel using an\\n     *      index that is out of range.\\n     */\\n    error ChannelOutOfRange(address conduit);\\n\\n    /**\\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\\n     *         an initial owner for the deployed conduit. Note that the first\\n     *         twenty bytes of the supplied conduit key must match the caller\\n     *         and that a new conduit cannot be created if one has already been\\n     *         deployed using the same conduit key.\\n     *\\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\\n     *                     the first twenty bytes of the conduit key must match\\n     *                     the caller of this contract.\\n     * @param initialOwner The initial owner to set for the new conduit.\\n     *\\n     * @return conduit The address of the newly deployed conduit.\\n     */\\n    function createConduit(\\n        bytes32 conduitKey,\\n        address initialOwner\\n    ) external returns (address conduit);\\n\\n    /**\\n     * @notice Open or close a channel on a given conduit, thereby allowing the\\n     *         specified account to execute transfers against that conduit.\\n     *         Extreme care must be taken when updating channels, as malicious\\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\\n     *         tokens where the token holder has granted the conduit approval.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to open or close the channel.\\n     * @param channel The channel to open or close on the conduit.\\n     * @param isOpen  A boolean indicating whether to open or close the channel.\\n     */\\n    function updateChannel(\\n        address conduit,\\n        address channel,\\n        bool isOpen\\n    ) external;\\n\\n    /**\\n     * @notice Initiate conduit ownership transfer by assigning a new potential\\n     *         owner for the given conduit. Once set, the new potential owner\\n     *         may call `acceptOwnership` to claim ownership of the conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to initiate ownership transfer.\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    function transferOwnership(\\n        address conduit,\\n        address newPotentialOwner\\n    ) external;\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any, from a conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to cancel ownership transfer.\\n     */\\n    function cancelOwnershipTransfer(address conduit) external;\\n\\n    /**\\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     *\\n     * @param conduit The conduit for which to accept ownership.\\n     */\\n    function acceptOwnership(address conduit) external;\\n\\n    /**\\n     * @notice Retrieve the current owner of a deployed conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated owner.\\n     *\\n     * @return owner The owner of the supplied conduit.\\n     */\\n    function ownerOf(address conduit) external view returns (address owner);\\n\\n    /**\\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\\n     *         lookup.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated conduit\\n     *                key.\\n     *\\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\\n     */\\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\\n\\n    /**\\n     * @notice Derive the conduit associated with a given conduit key and\\n     *         determine whether that conduit exists (i.e. whether it has been\\n     *         deployed).\\n     *\\n     * @param conduitKey The conduit key used to derive the conduit.\\n     *\\n     * @return conduit The derived address of the conduit.\\n     * @return exists  A boolean indicating whether the derived conduit has been\\n     *                 deployed or not.\\n     */\\n    function getConduit(\\n        bytes32 conduitKey\\n    ) external view returns (address conduit, bool exists);\\n\\n    /**\\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\\n     *         current owner may set a new potential owner via\\n     *         `transferOwnership` and that owner may then accept ownership of\\n     *         the conduit in question via `acceptOwnership`.\\n     *\\n     * @param conduit The conduit for which to retrieve the potential owner.\\n     *\\n     * @return potentialOwner The potential owner, if any, for the conduit.\\n     */\\n    function getPotentialOwner(\\n        address conduit\\n    ) external view returns (address potentialOwner);\\n\\n    /**\\n     * @notice Retrieve the status (either open or closed) of a given channel on\\n     *         a conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the channel status.\\n     * @param channel The channel for which to retrieve the status.\\n     *\\n     * @return isOpen The status of the channel on the given conduit.\\n     */\\n    function getChannelStatus(\\n        address conduit,\\n        address channel\\n    ) external view returns (bool isOpen);\\n\\n    /**\\n     * @notice Retrieve the total number of open channels for a given conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the total channel count.\\n     *\\n     * @return totalChannels The total number of open channels for the conduit.\\n     */\\n    function getTotalChannels(\\n        address conduit\\n    ) external view returns (uint256 totalChannels);\\n\\n    /**\\n     * @notice Retrieve an open channel at a specific index for a given conduit.\\n     *         Note that the index of a channel can change as a result of other\\n     *         channels being closed on the conduit.\\n     *\\n     * @param conduit      The conduit for which to retrieve the open channel.\\n     * @param channelIndex The index of the channel in question.\\n     *\\n     * @return channel The open channel, if any, at the specified channel index.\\n     */\\n    function getChannel(\\n        address conduit,\\n        uint256 channelIndex\\n    ) external view returns (address channel);\\n\\n    /**\\n     * @notice Retrieve all open channels for a given conduit. Note that calling\\n     *         this function for a conduit with many channels will revert with\\n     *         an out-of-gas error.\\n     *\\n     * @param conduit The conduit for which to retrieve open channels.\\n     *\\n     * @return channels An array of open channels on the given conduit.\\n     */\\n    function getChannels(\\n        address conduit\\n    ) external view returns (address[] memory channels);\\n\\n    /**\\n     * @dev Retrieve the conduit creation code and runtime code hashes.\\n     */\\n    function getConduitCodeHashes()\\n        external\\n        view\\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ConsiderationEventsAndErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    SpentItem,\\n    ReceivedItem,\\n    OrderParameters\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title ConsiderationEventsAndErrors\\n * @author 0age\\n * @notice ConsiderationEventsAndErrors contains all events and errors.\\n */\\ninterface ConsiderationEventsAndErrors {\\n    /**\\n     * @dev Emit an event whenever an order is successfully fulfilled.\\n     *\\n     * @param orderHash     The hash of the fulfilled order.\\n     * @param offerer       The offerer of the fulfilled order.\\n     * @param zone          The zone of the fulfilled order.\\n     * @param recipient     The recipient of each spent item on the fulfilled\\n     *                      order, or the null address if there is no specific\\n     *                      fulfiller (i.e. the order is part of a group of\\n     *                      orders). Defaults to the caller unless explicitly\\n     *                      specified otherwise by the fulfiller.\\n     * @param offer         The offer items spent as part of the order.\\n     * @param consideration The consideration items received as part of the\\n     *                      order along with the recipients of each item.\\n     */\\n    event OrderFulfilled(\\n        bytes32 orderHash,\\n        address indexed offerer,\\n        address indexed zone,\\n        address recipient,\\n        SpentItem[] offer,\\n        ReceivedItem[] consideration\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever an order is successfully cancelled.\\n     *\\n     * @param orderHash The hash of the cancelled order.\\n     * @param offerer   The offerer of the cancelled order.\\n     * @param zone      The zone of the cancelled order.\\n     */\\n    event OrderCancelled(\\n        bytes32 orderHash,\\n        address indexed offerer,\\n        address indexed zone\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever an order is explicitly validated. Note that\\n     *      this event will not be emitted on partial fills even though they do\\n     *      validate the order as part of partial fulfillment.\\n     *\\n     * @param orderHash        The hash of the validated order.\\n     * @param orderParameters  The parameters of the validated order.\\n     */\\n    event OrderValidated(bytes32 orderHash, OrderParameters orderParameters);\\n\\n    /**\\n     * @dev Emit an event whenever one or more orders are matched using either\\n     *      matchOrders or matchAdvancedOrders.\\n     *\\n     * @param orderHashes The order hashes of the matched orders.\\n     */\\n    event OrdersMatched(bytes32[] orderHashes);\\n\\n    /**\\n     * @dev Emit an event whenever a counter for a given offerer is incremented.\\n     *\\n     * @param newCounter The new counter for the offerer.\\n     * @param offerer    The offerer in question.\\n     */\\n    event CounterIncremented(uint256 newCounter, address indexed offerer);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order that has\\n     *      already been fully filled.\\n     *\\n     * @param orderHash The order hash on which a fill was attempted.\\n     */\\n    error OrderAlreadyFilled(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order outside the\\n     *      specified start time and end time.\\n     *\\n     * @param startTime The time at which the order becomes active.\\n     * @param endTime   The time at which the order becomes inactive.\\n     */\\n    error InvalidTime(uint256 startTime, uint256 endTime);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order referencing an\\n     *      invalid conduit (i.e. one that has not been deployed).\\n     */\\n    error InvalidConduit(bytes32 conduitKey, address conduit);\\n\\n    /**\\n     * @dev Revert with an error when an order is supplied for fulfillment with\\n     *      a consideration array that is shorter than the original array.\\n     */\\n    error MissingOriginalConsiderationItems();\\n\\n    /**\\n     * @dev Revert with an error when an order is validated and the length of\\n     *      the consideration array is not equal to the supplied total original\\n     *      consideration items value. This error is also thrown when contract\\n     *      orders supply a total original consideration items value that does\\n     *      not match the supplied consideration array length.\\n     */\\n    error ConsiderationLengthNotEqualToTotalOriginal();\\n\\n    /**\\n     * @dev Revert with an error when a call to a conduit fails with revert data\\n     *      that is too expensive to return.\\n     */\\n    error InvalidCallToConduit(address conduit);\\n\\n    /**\\n     * @dev Revert with an error if a consideration amount has not been fully\\n     *      zeroed out after applying all fulfillments.\\n     *\\n     * @param orderIndex         The index of the order with the consideration\\n     *                           item with a shortfall.\\n     * @param considerationIndex The index of the consideration item on the\\n     *                           order.\\n     * @param shortfallAmount    The unfulfilled consideration amount.\\n     */\\n    error ConsiderationNotMet(\\n        uint256 orderIndex,\\n        uint256 considerationIndex,\\n        uint256 shortfallAmount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when insufficient ether is supplied as part of\\n     *      msg.value when fulfilling orders.\\n     */\\n    error InsufficientEtherSupplied();\\n\\n    /**\\n     * @dev Revert with an error when an ether transfer reverts.\\n     */\\n    error EtherTransferGenericFailure(address account, uint256 amount);\\n\\n    /**\\n     * @dev Revert with an error when a partial fill is attempted on an order\\n     *      that does not specify partial fill support in its order type.\\n     */\\n    error PartialFillsNotEnabledForOrder();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order that has been\\n     *      cancelled.\\n     *\\n     * @param orderHash The hash of the cancelled order.\\n     */\\n    error OrderIsCancelled(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill a basic order that has\\n     *      been partially filled.\\n     *\\n     * @param orderHash The hash of the partially used order.\\n     */\\n    error OrderPartiallyFilled(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when attempting to cancel an order as a caller\\n     *      other than the indicated offerer or zone or when attempting to\\n     *      cancel a contract order.\\n     */\\n    error CannotCancelOrder();\\n\\n    /**\\n     * @dev Revert with an error when supplying a fraction with a value of zero\\n     *      for the numerator or denominator, or one where the numerator exceeds\\n     *      the denominator.\\n     */\\n    error BadFraction();\\n\\n    /**\\n     * @dev Revert with an error when a caller attempts to supply callvalue to a\\n     *      non-payable basic order route or does not supply any callvalue to a\\n     *      payable basic order route.\\n     */\\n    error InvalidMsgValue(uint256 value);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill a basic order using\\n     *      calldata not produced by default ABI encoding.\\n     */\\n    error InvalidBasicOrderParameterEncoding();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill any number of\\n     *      available orders when none are fulfillable.\\n     */\\n    error NoSpecifiedOrdersAvailable();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order with an\\n     *      offer for ETH outside of matching orders.\\n     */\\n    error InvalidNativeOfferItem();\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ConsiderationDecoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {\\n    BasicOrderParameters,\\n    Order,\\n    CriteriaResolver,\\n    AdvancedOrder,\\n    FulfillmentComponent,\\n    Execution,\\n    Fulfillment,\\n    OrderComponents,\\n    OrderParameters,\\n    SpentItem,\\n    OfferItem,\\n    ConsiderationItem,\\n    ReceivedItem\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\nimport \\\"../helpers/PointerLibraries.sol\\\";\\n\\ncontract ConsiderationDecoder {\\n    /**\\n     * @dev Takes a bytes array from calldata and copies it into memory.\\n     *\\n     * @param cdPtrLength A calldata pointer to the start of the bytes array in\\n     *                    calldata which contains the length of the array.\\n     *\\n     * @return mPtrLength A memory pointer to the start of the bytes array in\\n     *                    memory which contains the length of the array.\\n     */\\n    function _decodeBytes(\\n        CalldataPointer cdPtrLength\\n    ) internal pure returns (MemoryPointer mPtrLength) {\\n        assembly {\\n            // Get the current free memory pointer.\\n            mPtrLength := mload(FreeMemoryPointerSlot)\\n\\n            // Derive the size of the bytes array, rounding up to nearest word\\n            // and adding a word for the length field.\\n            // Note: masking `calldataload(cdPtrLength)` is redundant here.\\n            let size := add(\\n                and(\\n                    add(calldataload(cdPtrLength), AlmostOneWord),\\n                    OnlyFullWordMask\\n                ),\\n                OneWord\\n            )\\n\\n            // Copy bytes from calldata into memory based on pointers and size.\\n            calldatacopy(mPtrLength, cdPtrLength, size)\\n            // Store the masked value in memory.\\n            // Note: the value of `size` is at least 32.\\n            // So the previous line will at least write to `[mPtrLength, mPtrLength + 32)`.\\n            mstore(\\n                mPtrLength,\\n                and(calldataload(cdPtrLength), OffsetOrLengthMask)\\n            )\\n\\n            // Update free memory pointer based on the size of the bytes array.\\n            mstore(FreeMemoryPointerSlot, add(mPtrLength, size))\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes an offer array from calldata and copies it into memory.\\n     *\\n     * @param cdPtrLength A calldata pointer to the start of the offer array\\n     *                    in calldata which contains the length of the array.\\n     *\\n     * @return mPtrLength A memory pointer to the start of the offer array in\\n     *                    memory which contains the length of the array.\\n     */\\n    function _decodeOffer(\\n        CalldataPointer cdPtrLength\\n    ) internal pure returns (MemoryPointer mPtrLength) {\\n        assembly {\\n            // Retrieve length of array, masking to prevent potential overflow.\\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\\n\\n            // Get the current free memory pointer.\\n            mPtrLength := mload(FreeMemoryPointerSlot)\\n\\n            // Write the array length to memory.\\n            mstore(mPtrLength, arrLength)\\n\\n            // Derive the head by adding one word to the length pointer.\\n            let mPtrHead := add(mPtrLength, OneWord)\\n\\n            // Derive the tail by adding one word per element (note that structs\\n            // are written to memory with an offset per struct element).\\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\\n\\n            // Track the next tail, beginning with the initial tail value.\\n            let mPtrTailNext := mPtrTail\\n\\n            // Copy all offer array data into memory at the tail pointer.\\n            calldatacopy(\\n                mPtrTail,\\n                add(cdPtrLength, OneWord),\\n                mul(arrLength, OfferItem_size)\\n            )\\n\\n            // Track the next head pointer, starting with initial head value.\\n            let mPtrHeadNext := mPtrHead\\n\\n            // Iterate over each head pointer until it reaches the tail.\\n            for {\\n\\n            } lt(mPtrHeadNext, mPtrTail) {\\n\\n            } {\\n                // Write the next tail pointer to next head pointer in memory.\\n                mstore(mPtrHeadNext, mPtrTailNext)\\n\\n                // Increment the next head pointer by one word.\\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\\n\\n                // Increment the next tail pointer by the size of an offer item.\\n                mPtrTailNext := add(mPtrTailNext, OfferItem_size)\\n            }\\n\\n            // Update free memory pointer to allocate memory up to end of tail.\\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes a consideration array from calldata and copies it into memory.\\n     *\\n     * @param cdPtrLength A calldata pointer to the start of the consideration\\n     *                    array in calldata which contains the length of the\\n     *                    array.\\n     *\\n     * @return mPtrLength A memory pointer to the start of the consideration\\n     *                    array in memory which contains the length of the\\n     *                    array.\\n     */\\n    function _decodeConsideration(\\n        CalldataPointer cdPtrLength\\n    ) internal pure returns (MemoryPointer mPtrLength) {\\n        assembly {\\n            // Retrieve length of array, masking to prevent potential overflow.\\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\\n\\n            // Get the current free memory pointer.\\n            mPtrLength := mload(FreeMemoryPointerSlot)\\n\\n            // Write the array length to memory.\\n            mstore(mPtrLength, arrLength)\\n\\n            // Derive the head by adding one word to the length pointer.\\n            let mPtrHead := add(mPtrLength, OneWord)\\n\\n            // Derive the tail by adding one word per element (note that structs\\n            // are written to memory with an offset per struct element).\\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\\n\\n            // Track the next tail, beginning with the initial tail value.\\n            let mPtrTailNext := mPtrTail\\n\\n            // Copy all consideration array data into memory at tail pointer.\\n            calldatacopy(\\n                mPtrTail,\\n                add(cdPtrLength, OneWord),\\n                mul(arrLength, ConsiderationItem_size)\\n            )\\n\\n            // Track the next head pointer, starting with initial head value.\\n            let mPtrHeadNext := mPtrHead\\n\\n            // Iterate over each head pointer until it reaches the tail.\\n            for {\\n\\n            } lt(mPtrHeadNext, mPtrTail) {\\n\\n            } {\\n                // Write the next tail pointer to next head pointer in memory.\\n                mstore(mPtrHeadNext, mPtrTailNext)\\n\\n                // Increment the next head pointer by one word.\\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\\n\\n                // Increment next tail pointer by size of a consideration item.\\n                mPtrTailNext := add(mPtrTailNext, ConsiderationItem_size)\\n            }\\n\\n            // Update free memory pointer to allocate memory up to end of tail.\\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes a calldata pointer and memory pointer and copies a referenced\\n     *      OrderParameters struct and associated offer and consideration data\\n     *      to memory.\\n     *\\n     * @param cdPtr A calldata pointer for the OrderParameters struct.\\n     * @param mPtr A memory pointer to the OrderParameters struct head.\\n     */\\n    function _decodeOrderParametersTo(\\n        CalldataPointer cdPtr,\\n        MemoryPointer mPtr\\n    ) internal pure {\\n        // Copy the full OrderParameters head from calldata to memory.\\n        cdPtr.copy(mPtr, OrderParameters_head_size);\\n\\n        // Resolve the offer calldata offset, use that to decode and copy offer\\n        // from calldata, and write resultant memory offset to head in memory.\\n        mPtr.offset(OrderParameters_offer_head_offset).write(\\n            _decodeOffer(cdPtr.pptr(OrderParameters_offer_head_offset))\\n        );\\n\\n        // Resolve consideration calldata offset, use that to copy consideration\\n        // from calldata, and write resultant memory offset to head in memory.\\n        mPtr.offset(OrderParameters_consideration_head_offset).write(\\n            _decodeConsideration(\\n                cdPtr.pptr(OrderParameters_consideration_head_offset)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Takes a calldata pointer to an OrderParameters struct and copies the\\n     *      decoded struct to memory.\\n     *\\n     * @param cdPtr A calldata pointer for the OrderParameters struct.\\n     *\\n     * @return mPtr A memory pointer to the OrderParameters struct head.\\n     */\\n    function _decodeOrderParameters(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (MemoryPointer mPtr) {\\n        // Allocate required memory for the OrderParameters head (offer and\\n        // consideration are allocated independently).\\n        mPtr = malloc(OrderParameters_head_size);\\n\\n        // Decode and copy the order parameters to the newly allocated memory.\\n        _decodeOrderParametersTo(cdPtr, mPtr);\\n    }\\n\\n    /**\\n     * @dev Takes a calldata pointer to an Order struct and copies the decoded\\n     *      struct to memory.\\n     *\\n     * @param cdPtr A calldata pointer for the Order struct.\\n     *\\n     * @return mPtr A memory pointer to the Order struct head.\\n     */\\n    function _decodeOrder(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (MemoryPointer mPtr) {\\n        // Allocate required memory for the Order head (OrderParameters and\\n        // signature are allocated independently).\\n        mPtr = malloc(Order_head_size);\\n\\n        // Resolve OrderParameters calldata offset, use it to decode and copy\\n        // from calldata, and write resultant memory offset to head in memory.\\n        mPtr.write(_decodeOrderParameters(cdPtr.pptr()));\\n\\n        // Resolve signature calldata offset, use that to decode and copy from\\n        // calldata, and write resultant memory offset to head in memory.\\n        mPtr.offset(Order_signature_offset).write(\\n            _decodeBytes(cdPtr.pptr(Order_signature_offset))\\n        );\\n    }\\n\\n    /**\\n     * @dev Takes a calldata pointer to an AdvancedOrder struct and copies the\\n     *      decoded struct to memory.\\n     *\\n     * @param cdPtr A calldata pointer for the AdvancedOrder struct.\\n     *\\n     * @return mPtr A memory pointer to the AdvancedOrder struct head.\\n     */\\n    function _decodeAdvancedOrder(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (MemoryPointer mPtr) {\\n        // Allocate memory for AdvancedOrder head and OrderParameters head.\\n        mPtr = malloc(AdvancedOrderPlusOrderParameters_head_size);\\n\\n        // Use numerator + denominator calldata offset to decode and copy\\n        // from calldata and write resultant memory offset to head in memory.\\n        cdPtr.offset(AdvancedOrder_numerator_offset).copy(\\n            mPtr.offset(AdvancedOrder_numerator_offset),\\n            AdvancedOrder_fixed_segment_0\\n        );\\n\\n        // Get pointer to memory immediately after advanced order.\\n        MemoryPointer mPtrParameters = mPtr.offset(AdvancedOrder_head_size);\\n\\n        // Write pptr for advanced order parameters to memory.\\n        mPtr.write(mPtrParameters);\\n\\n        // Resolve OrderParameters calldata pointer & write to allocated region.\\n        _decodeOrderParametersTo(cdPtr.pptr(), mPtrParameters);\\n\\n        // Resolve signature calldata offset, use that to decode and copy from\\n        // calldata, and write resultant memory offset to head in memory.\\n        mPtr.offset(AdvancedOrder_signature_offset).write(\\n            _decodeBytes(cdPtr.pptr(AdvancedOrder_signature_offset))\\n        );\\n\\n        // Resolve extraData calldata offset, use that to decode and copy from\\n        // calldata, and write resultant memory offset to head in memory.\\n        mPtr.offset(AdvancedOrder_extraData_offset).write(\\n            _decodeBytes(cdPtr.pptr(AdvancedOrder_extraData_offset))\\n        );\\n    }\\n\\n    /**\\n     * @dev Allocates a single word of empty bytes in memory and returns the\\n     *      pointer to that memory region.\\n     *\\n     * @return mPtr The memory pointer to the new empty word in memory.\\n     */\\n    function _getEmptyBytesOrArray()\\n        internal\\n        pure\\n        returns (MemoryPointer mPtr)\\n    {\\n        mPtr = malloc(OneWord);\\n        mPtr.write(0);\\n    }\\n\\n    /**\\n     * @dev Takes a calldata pointer to an Order struct and copies the decoded\\n     *      struct to memory as an AdvancedOrder.\\n     *\\n     * @param cdPtr A calldata pointer for the Order struct.\\n     *\\n     * @return mPtr A memory pointer to the AdvancedOrder struct head.\\n     */\\n    function _decodeOrderAsAdvancedOrder(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (MemoryPointer mPtr) {\\n        // Allocate memory for AdvancedOrder head and OrderParameters head.\\n        mPtr = malloc(AdvancedOrderPlusOrderParameters_head_size);\\n\\n        // Get pointer to memory immediately after advanced order.\\n        MemoryPointer mPtrParameters = mPtr.offset(AdvancedOrder_head_size);\\n\\n        // Write pptr for advanced order parameters.\\n        mPtr.write(mPtrParameters);\\n\\n        // Resolve OrderParameters calldata pointer & write to allocated region.\\n        _decodeOrderParametersTo(cdPtr.pptr(), mPtrParameters);\\n\\n        // Write default Order numerator and denominator values (e.g. 1/1).\\n        mPtr.offset(AdvancedOrder_numerator_offset).write(1);\\n        mPtr.offset(AdvancedOrder_denominator_offset).write(1);\\n\\n        // Resolve signature calldata offset, use that to decode and copy from\\n        // calldata, and write resultant memory offset to head in memory.\\n        mPtr.offset(AdvancedOrder_signature_offset).write(\\n            _decodeBytes(cdPtr.pptr(Order_signature_offset))\\n        );\\n\\n        // Resolve extraData calldata offset, use that to decode and copy from\\n        // calldata, and write resultant memory offset to head in memory.\\n        mPtr.offset(AdvancedOrder_extraData_offset).write(\\n            _getEmptyBytesOrArray()\\n        );\\n    }\\n\\n    /**\\n     * @dev Takes a calldata pointer to an array of Order structs and copies the\\n     *      decoded array to memory as an array of AdvancedOrder structs.\\n     *\\n     * @param cdPtrLength A calldata pointer to the start of the orders array in\\n     *                    calldata which contains the length of the array.\\n     *\\n     * @return mPtrLength A memory pointer to the start of the array of advanced\\n     *                    orders in memory which contains length of the array.\\n     */\\n    function _decodeOrdersAsAdvancedOrders(\\n        CalldataPointer cdPtrLength\\n    ) internal pure returns (MemoryPointer mPtrLength) {\\n        // Retrieve length of array, masking to prevent potential overflow.\\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\\n\\n        unchecked {\\n            // Derive offset to the tail based on one word per array element.\\n            uint256 tailOffset = arrLength * OneWord;\\n\\n            // Add one additional word for the length and allocate memory.\\n            mPtrLength = malloc(tailOffset + OneWord);\\n\\n            // Write the length of the array to memory.\\n            mPtrLength.write(arrLength);\\n\\n            // Advance to first memory & calldata pointers (e.g. after length).\\n            MemoryPointer mPtrHead = mPtrLength.next();\\n            CalldataPointer cdPtrHead = cdPtrLength.next();\\n\\n            // Iterate over each pointer, word by word, until tail is reached.\\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\\n                // Resolve Order calldata offset, use it to decode and copy from\\n                // calldata, and write resultant AdvancedOrder offset to memory.\\n                mPtrHead.offset(offset).write(\\n                    _decodeOrderAsAdvancedOrder(cdPtrHead.pptr(offset))\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes a calldata pointer to a criteria proof, or an array bytes32\\n     *      types, and copies the decoded proof to memory.\\n     *\\n     * @param cdPtrLength A calldata pointer to the start of the criteria proof\\n     *                    in calldata which contains the length of the array.\\n     *\\n     * @return mPtrLength A memory pointer to the start of the criteria proof\\n     *                    in memory which contains length of the array.\\n     */\\n    function _decodeCriteriaProof(\\n        CalldataPointer cdPtrLength\\n    ) internal pure returns (MemoryPointer mPtrLength) {\\n        // Retrieve length of array, masking to prevent potential overflow.\\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\\n\\n        unchecked {\\n            // Derive array size based on one word per array element and length.\\n            uint256 arrSize = (arrLength + 1) * OneWord;\\n\\n            // Allocate memory equal to the array size.\\n            mPtrLength = malloc(arrSize);\\n\\n            // Copy the array from calldata into memory.\\n            cdPtrLength.copy(mPtrLength, arrSize);\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes a calldata pointer to a CriteriaResolver struct and copies the\\n     *      decoded struct to memory.\\n     *\\n     * @param cdPtr A calldata pointer for the CriteriaResolver struct.\\n     *\\n     * @return mPtr A memory pointer to the CriteriaResolver struct head.\\n     */\\n    function _decodeCriteriaResolver(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (MemoryPointer mPtr) {\\n        // Allocate required memory for the CriteriaResolver head (the criteria\\n        // proof bytes32 array is allocated independently).\\n        mPtr = malloc(CriteriaResolver_head_size);\\n\\n        // Decode and copy order index, side, index, and identifier from\\n        // calldata and write resultant memory offset to head in memory.\\n        cdPtr.copy(mPtr, CriteriaResolver_fixed_segment_0);\\n\\n        // Resolve criteria proof calldata offset, use it to decode and copy\\n        // from calldata, and write resultant memory offset to head in memory.\\n        mPtr.offset(CriteriaResolver_criteriaProof_offset).write(\\n            _decodeCriteriaProof(\\n                cdPtr.pptr(CriteriaResolver_criteriaProof_offset)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Takes an array of criteria resolvers from calldata and copies it\\n     *      into memory.\\n     *\\n     * @param cdPtrLength A calldata pointer to the start of the criteria\\n     *                    resolver array in calldata which contains the length\\n     *                    of the array.\\n     *\\n     * @return mPtrLength A memory pointer to the start of the criteria resolver\\n     *                    array in memory which contains the length of the\\n     *                    array.\\n     */\\n    function _decodeCriteriaResolvers(\\n        CalldataPointer cdPtrLength\\n    ) internal pure returns (MemoryPointer mPtrLength) {\\n        // Retrieve length of array, masking to prevent potential overflow.\\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\\n\\n        unchecked {\\n            // Derive offset to the tail based on one word per array element.\\n            uint256 tailOffset = arrLength * OneWord;\\n\\n            // Add one additional word for the length and allocate memory.\\n            mPtrLength = malloc(tailOffset + OneWord);\\n\\n            // Write the length of the array to memory.\\n            mPtrLength.write(arrLength);\\n\\n            // Advance to first memory & calldata pointers (e.g. after length).\\n            MemoryPointer mPtrHead = mPtrLength.next();\\n            CalldataPointer cdPtrHead = cdPtrLength.next();\\n\\n            // Iterate over each pointer, word by word, until tail is reached.\\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\\n                // Resolve CriteriaResolver calldata offset, use it to decode\\n                // and copy from calldata, and write resultant memory offset.\\n                mPtrHead.offset(offset).write(\\n                    _decodeCriteriaResolver(cdPtrHead.pptr(offset))\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes an array of orders from calldata and copies it into memory.\\n     *\\n     * @param cdPtrLength A calldata pointer to the start of the orders array in\\n     *                    calldata which contains the length of the array.\\n     *\\n     * @return mPtrLength A memory pointer to the start of the orders array\\n     *                    in memory which contains the length of the array.\\n     */\\n    function _decodeOrders(\\n        CalldataPointer cdPtrLength\\n    ) internal pure returns (MemoryPointer mPtrLength) {\\n        // Retrieve length of array, masking to prevent potential overflow.\\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\\n\\n        unchecked {\\n            // Derive offset to the tail based on one word per array element.\\n            uint256 tailOffset = arrLength * OneWord;\\n\\n            // Add one additional word for the length and allocate memory.\\n            mPtrLength = malloc(tailOffset + OneWord);\\n\\n            // Write the length of the array to memory.\\n            mPtrLength.write(arrLength);\\n\\n            // Advance to first memory & calldata pointers (e.g. after length).\\n            MemoryPointer mPtrHead = mPtrLength.next();\\n            CalldataPointer cdPtrHead = cdPtrLength.next();\\n\\n            // Iterate over each pointer, word by word, until tail is reached.\\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\\n                // Resolve Order calldata offset, use it to decode and copy\\n                // from calldata, and write resultant memory offset.\\n                mPtrHead.offset(offset).write(\\n                    _decodeOrder(cdPtrHead.pptr(offset))\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes an array of fulfillment components from calldata and copies it\\n     *      into memory.\\n     *\\n     * @param cdPtrLength A calldata pointer to the start of the fulfillment\\n     *                    components array in calldata which contains the length\\n     *                    of the array.\\n     *\\n     * @return mPtrLength A memory pointer to the start of the fulfillment\\n     *                    components array in memory which contains the length\\n     *                    of the array.\\n     */\\n    function _decodeFulfillmentComponents(\\n        CalldataPointer cdPtrLength\\n    ) internal pure returns (MemoryPointer mPtrLength) {\\n        assembly {\\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\\n\\n            // Get the current free memory pointer.\\n            mPtrLength := mload(FreeMemoryPointerSlot)\\n\\n            mstore(mPtrLength, arrLength)\\n            let mPtrHead := add(mPtrLength, OneWord)\\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\\n            let mPtrTailNext := mPtrTail\\n            calldatacopy(\\n                mPtrTail,\\n                add(cdPtrLength, OneWord),\\n                shl(FulfillmentComponent_mem_tail_size_shift, arrLength)\\n            )\\n            let mPtrHeadNext := mPtrHead\\n            for {\\n\\n            } lt(mPtrHeadNext, mPtrTail) {\\n\\n            } {\\n                mstore(mPtrHeadNext, mPtrTailNext)\\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\\n                mPtrTailNext := add(\\n                    mPtrTailNext,\\n                    FulfillmentComponent_mem_tail_size\\n                )\\n            }\\n\\n            // Update the free memory pointer.\\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes a nested array of fulfillment components from calldata and\\n     *      copies it into memory.\\n     *\\n     * @param cdPtrLength A calldata pointer to the start of the nested\\n     *                    fulfillment components array in calldata which\\n     *                    contains the length of the array.\\n     *\\n     * @return mPtrLength A memory pointer to the start of the nested\\n     *                    fulfillment components array in memory which\\n     *                    contains the length of the array.\\n     */\\n    function _decodeNestedFulfillmentComponents(\\n        CalldataPointer cdPtrLength\\n    ) internal pure returns (MemoryPointer mPtrLength) {\\n        // Retrieve length of array, masking to prevent potential overflow.\\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\\n\\n        unchecked {\\n            // Derive offset to the tail based on one word per array element.\\n            uint256 tailOffset = arrLength * OneWord;\\n\\n            // Add one additional word for the length and allocate memory.\\n            mPtrLength = malloc(tailOffset + OneWord);\\n\\n            // Write the length of the array to memory.\\n            mPtrLength.write(arrLength);\\n\\n            // Advance to first memory & calldata pointers (e.g. after length).\\n            MemoryPointer mPtrHead = mPtrLength.next();\\n            CalldataPointer cdPtrHead = cdPtrLength.next();\\n\\n            // Iterate over each pointer, word by word, until tail is reached.\\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\\n                // Resolve FulfillmentComponents array calldata offset, use it\\n                // to decode and copy from calldata, and write memory offset.\\n                mPtrHead.offset(offset).write(\\n                    _decodeFulfillmentComponents(cdPtrHead.pptr(offset))\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes an array of advanced orders from calldata and copies it into\\n     *      memory.\\n     *\\n     * @param cdPtrLength A calldata pointer to the start of the advanced orders\\n     *                    array in calldata which contains the length of the\\n     *                    array.\\n     *\\n     * @return mPtrLength A memory pointer to the start of the advanced orders\\n     *                    array in memory which contains the length of the\\n     *                    array.\\n     */\\n    function _decodeAdvancedOrders(\\n        CalldataPointer cdPtrLength\\n    ) internal pure returns (MemoryPointer mPtrLength) {\\n        // Retrieve length of array, masking to prevent potential overflow.\\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\\n\\n        unchecked {\\n            // Derive offset to the tail based on one word per array element.\\n            uint256 tailOffset = arrLength * OneWord;\\n\\n            // Add one additional word for the length and allocate memory.\\n            mPtrLength = malloc(tailOffset + OneWord);\\n\\n            // Write the length of the array to memory.\\n            mPtrLength.write(arrLength);\\n\\n            // Advance to first memory & calldata pointers (e.g. after length).\\n            MemoryPointer mPtrHead = mPtrLength.next();\\n            CalldataPointer cdPtrHead = cdPtrLength.next();\\n\\n            // Iterate over each pointer, word by word, until tail is reached.\\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\\n                // Resolve AdvancedOrder calldata offset, use it to decode and\\n                // copy from calldata, and write resultant memory offset.\\n                mPtrHead.offset(offset).write(\\n                    _decodeAdvancedOrder(cdPtrHead.pptr(offset))\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes a calldata pointer to a Fulfillment struct and copies the\\n     *      decoded struct to memory.\\n     *\\n     * @param cdPtr A calldata pointer for the Fulfillment struct.\\n     *\\n     * @return mPtr A memory pointer to the Fulfillment struct head.\\n     */\\n    function _decodeFulfillment(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (MemoryPointer mPtr) {\\n        // Allocate required memory for the Fulfillment head (the fulfillment\\n        // components arrays are allocated independently).\\n        mPtr = malloc(Fulfillment_head_size);\\n\\n        // Resolve offerComponents calldata offset, use it to decode and copy\\n        // from calldata, and write resultant memory offset to head in memory.\\n        mPtr.write(_decodeFulfillmentComponents(cdPtr.pptr()));\\n\\n        // Resolve considerationComponents calldata offset, use it to decode and\\n        // copy from calldata, and write resultant memory offset to memory head.\\n        mPtr.offset(Fulfillment_considerationComponents_offset).write(\\n            _decodeFulfillmentComponents(\\n                cdPtr.pptr(Fulfillment_considerationComponents_offset)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Takes an array of fulfillments from calldata and copies it into\\n     *      memory.\\n     *\\n     * @param cdPtrLength A calldata pointer to the start of the fulfillments\\n     *                    array in calldata which contains the length of the\\n     *                    array.\\n     *\\n     * @return mPtrLength A memory pointer to the start of the fulfillments\\n     *                    array in memory which contains the length of the\\n     *                    array.\\n     */\\n    function _decodeFulfillments(\\n        CalldataPointer cdPtrLength\\n    ) internal pure returns (MemoryPointer mPtrLength) {\\n        // Retrieve length of array, masking to prevent potential overflow.\\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\\n\\n        unchecked {\\n            // Derive offset to the tail based on one word per array element.\\n            uint256 tailOffset = arrLength * OneWord;\\n\\n            // Add one additional word for the length and allocate memory.\\n            mPtrLength = malloc(tailOffset + OneWord);\\n\\n            // Write the length of the array to memory.\\n            mPtrLength.write(arrLength);\\n\\n            // Advance to first memory & calldata pointers (e.g. after length).\\n            MemoryPointer mPtrHead = mPtrLength.next();\\n            CalldataPointer cdPtrHead = cdPtrLength.next();\\n\\n            // Iterate over each pointer, word by word, until tail is reached.\\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\\n                // Resolve Fulfillment calldata offset, use it to decode and\\n                // copy from calldata, and write resultant memory offset.\\n                mPtrHead.offset(offset).write(\\n                    _decodeFulfillment(cdPtrHead.pptr(offset))\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes a calldata pointer to an OrderComponents struct and copies the\\n     *      decoded struct to memory as an OrderParameters struct (with the\\n     *      totalOriginalConsiderationItems value set equal to the length of the\\n     *      supplied consideration array).\\n     *\\n     * @param cdPtr A calldata pointer for the OrderComponents struct.\\n     *\\n     * @return mPtr A memory pointer to the OrderParameters struct head.\\n     */\\n    function _decodeOrderComponentsAsOrderParameters(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (MemoryPointer mPtr) {\\n        // Allocate memory for the OrderParameters head.\\n        mPtr = malloc(OrderParameters_head_size);\\n\\n        // Copy the full OrderComponents head from calldata to memory.\\n        cdPtr.copy(mPtr, OrderComponents_OrderParameters_common_head_size);\\n\\n        // Resolve the offer calldata offset, use that to decode and copy offer\\n        // from calldata, and write resultant memory offset to head in memory.\\n        mPtr.offset(OrderParameters_offer_head_offset).write(\\n            _decodeOffer(cdPtr.pptr(OrderParameters_offer_head_offset))\\n        );\\n\\n        // Resolve consideration calldata offset, use that to copy consideration\\n        // from calldata, and write resultant memory offset to head in memory.\\n        MemoryPointer consideration = _decodeConsideration(\\n            cdPtr.pptr(OrderParameters_consideration_head_offset)\\n        );\\n        mPtr.offset(OrderParameters_consideration_head_offset).write(\\n            consideration\\n        );\\n\\n        // Write masked consideration length to totalOriginalConsiderationItems.\\n        mPtr\\n            .offset(OrderParameters_totalOriginalConsiderationItems_offset)\\n            .write(consideration.readUint256());\\n    }\\n\\n    /**\\n     * @dev Decodes the returndata from a call to generateOrder, or returns\\n     *      empty arrays and a boolean signifying that the returndata does not\\n     *      adhere to a valid encoding scheme if it cannot be decoded.\\n     *\\n     * @return invalidEncoding A boolean signifying whether the returndata has\\n     *                         an invalid encoding.\\n     * @return offer           The decoded offer array.\\n     * @return consideration   The decoded consideration array.\\n     */\\n    function _decodeGenerateOrderReturndata()\\n        internal\\n        pure\\n        returns (\\n            uint256 invalidEncoding,\\n            MemoryPointer offer,\\n            MemoryPointer consideration\\n        )\\n    {\\n        assembly {\\n            // check that returndatasize is at least 80 bytes:\\n            // offerOffset,considerationOffset,offerLength,considerationLength\\n            invalidEncoding := lt(returndatasize(), FourWords)\\n\\n            let offsetOffer\\n            let offsetConsideration\\n            let offerLength\\n            let considerationLength\\n\\n            if iszero(invalidEncoding) {\\n                // Copy first two words of calldata (the offsets to offer and\\n                // consideration array lengths) to scratch space. Multiply by\\n                // validLength to avoid panics if returndatasize is too small.\\n                returndatacopy(0, 0, TwoWords)\\n                offsetOffer := mload(0)\\n                offsetConsideration := mload(OneWord)\\n\\n                // If valid length, check that offsets are within returndata.\\n                let invalidOfferOffset := gt(offsetOffer, returndatasize())\\n                let invalidConsiderationOffset := gt(\\n                    offsetConsideration,\\n                    returndatasize()\\n                )\\n\\n                // Only proceed if length (and thus encoding) is valid so far.\\n                invalidEncoding := or(\\n                    invalidOfferOffset,\\n                    invalidConsiderationOffset\\n                )\\n                if iszero(invalidEncoding) {\\n                    // Copy length of offer array to scratch space.\\n                    returndatacopy(0, offsetOffer, OneWord)\\n                    offerLength := mload(0)\\n\\n                    // Copy length of consideration array to scratch space.\\n                    returndatacopy(OneWord, offsetConsideration, OneWord)\\n                    considerationLength := mload(OneWord)\\n\\n                    {\\n                        // Calculate total size of offer & consideration arrays.\\n                        let totalOfferSize := shl(\\n                            SpentItem_size_shift,\\n                            offerLength\\n                        )\\n                        let totalConsiderationSize := mul(\\n                            ReceivedItem_size,\\n                            considerationLength\\n                        )\\n\\n                        // Add 4 words to total size to cover the offset and\\n                        // length fields of the two arrays.\\n                        let totalSize := add(\\n                            FourWords,\\n                            add(totalOfferSize, totalConsiderationSize)\\n                        )\\n                        // Don't continue if returndatasize exceeds 65535 bytes\\n                        // or is not equal to the calculated size.\\n                        invalidEncoding := or(\\n                            gt(or(offerLength, considerationLength), 0xffff),\\n                            xor(totalSize, returndatasize())\\n                        )\\n                        // Set first word of scratch space to 0 so length of\\n                        // offer/consideration are set to 0 on invalid encoding.\\n                        mstore(0, 0)\\n                    }\\n                }\\n            }\\n\\n            if iszero(invalidEncoding) {\\n                offer := copySpentItemsAsOfferItems(\\n                    add(offsetOffer, OneWord),\\n                    offerLength\\n                )\\n\\n                consideration := copyReceivedItemsAsConsiderationItems(\\n                    add(offsetConsideration, OneWord),\\n                    considerationLength\\n                )\\n            }\\n\\n            function copySpentItemsAsOfferItems(rdPtrHead, length)\\n                -> mPtrLength\\n            {\\n                // Retrieve the current free memory pointer.\\n                mPtrLength := mload(FreeMemoryPointerSlot)\\n\\n                // Allocate memory for the array.\\n                mstore(\\n                    FreeMemoryPointerSlot,\\n                    add(\\n                        mPtrLength,\\n                        add(OneWord, mul(length, OfferItem_size_with_length))\\n                    )\\n                )\\n\\n                // Write the length of the array to the start of free memory.\\n                mstore(mPtrLength, length)\\n\\n                // Use offset from length to minimize stack depth.\\n                let headOffsetFromLength := OneWord\\n                let headSizeWithLength := shl(OneWordShift, add(1, length))\\n                let mPtrTailNext := add(mPtrLength, headSizeWithLength)\\n\\n                // Iterate over each element.\\n                for {\\n\\n                } lt(headOffsetFromLength, headSizeWithLength) {\\n\\n                } {\\n                    // Write the memory pointer to the accompanying head offset.\\n                    mstore(add(mPtrLength, headOffsetFromLength), mPtrTailNext)\\n\\n                    // Copy itemType, token, identifier and amount.\\n                    returndatacopy(mPtrTailNext, rdPtrHead, SpentItem_size)\\n\\n                    // Copy amount to endAmount.\\n                    mstore(\\n                        add(mPtrTailNext, Common_endAmount_offset),\\n                        mload(add(mPtrTailNext, Common_amount_offset))\\n                    )\\n\\n                    // Update read pointer, next tail pointer, and head offset.\\n                    rdPtrHead := add(rdPtrHead, SpentItem_size)\\n                    mPtrTailNext := add(mPtrTailNext, OfferItem_size)\\n                    headOffsetFromLength := add(headOffsetFromLength, OneWord)\\n                }\\n            }\\n\\n            function copyReceivedItemsAsConsiderationItems(rdPtrHead, length)\\n                -> mPtrLength\\n            {\\n                // Retrieve the current free memory pointer.\\n                mPtrLength := mload(FreeMemoryPointerSlot)\\n\\n                // Allocate memory for the array.\\n                mstore(\\n                    FreeMemoryPointerSlot,\\n                    add(\\n                        mPtrLength,\\n                        add(\\n                            OneWord,\\n                            mul(length, ConsiderationItem_size_with_length)\\n                        )\\n                    )\\n                )\\n\\n                // Write the length of the array to the start of free memory.\\n                mstore(mPtrLength, length)\\n\\n                // Use offset from length to minimize stack depth.\\n                let headOffsetFromLength := OneWord\\n                let headSizeWithLength := shl(OneWordShift, add(1, length))\\n                let mPtrTailNext := add(mPtrLength, headSizeWithLength)\\n\\n                // Iterate over each element.\\n                for {\\n\\n                } lt(headOffsetFromLength, headSizeWithLength) {\\n\\n                } {\\n                    // Write the memory pointer to the accompanying head offset.\\n                    mstore(add(mPtrLength, headOffsetFromLength), mPtrTailNext)\\n\\n                    // Copy itemType, token, identifier and amount.\\n                    returndatacopy(\\n                        mPtrTailNext,\\n                        rdPtrHead,\\n                        Common_endAmount_offset\\n                    )\\n\\n                    // Copy amount and recipient.\\n                    returndatacopy(\\n                        add(mPtrTailNext, Common_endAmount_offset),\\n                        add(rdPtrHead, Common_amount_offset),\\n                        TwoWords\\n                    )\\n\\n                    // Update read pointer, next tail pointer, and head offset.\\n                    rdPtrHead := add(rdPtrHead, ReceivedItem_size)\\n                    mPtrTailNext := add(mPtrTailNext, ConsiderationItem_size)\\n                    headOffsetFromLength := add(headOffsetFromLength, OneWord)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a function returning _decodeGenerateOrderReturndata types\\n     *      into a function returning offer and consideration types.\\n     *\\n     * @param inFn The input function, taking no arguments and returning an\\n     *             error buffer, spent item array, and received item array.\\n     *\\n     * @return outFn The output function, taking no arguments and returning an\\n     *               error buffer, offer array, and consideration array.\\n     */\\n    function _convertGetGeneratedOrderResult(\\n        function()\\n            internal\\n            pure\\n            returns (uint256, MemoryPointer, MemoryPointer) inFn\\n    )\\n        internal\\n        pure\\n        returns (\\n            function()\\n                internal\\n                pure\\n                returns (\\n                    uint256,\\n                    OfferItem[] memory,\\n                    ConsiderationItem[] memory\\n                ) outFn\\n        )\\n    {\\n        assembly {\\n            outFn := inFn\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a function taking ReceivedItem, address, bytes32, and bytes\\n     *      types (e.g. the _transfer function) into a function taking\\n     *      OfferItem, address, bytes32, and bytes types.\\n     *\\n     * @param inFn The input function, taking ReceivedItem, address, bytes32,\\n     *             and bytes types (e.g. the _transfer function).\\n     *\\n     * @return outFn The output function, taking OfferItem, address, bytes32,\\n     *               and bytes types.\\n     */\\n    function _toOfferItemInput(\\n        function(ReceivedItem memory, address, bytes32, bytes memory)\\n            internal inFn\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(OfferItem memory, address, bytes32, bytes memory)\\n                internal outFn\\n        )\\n    {\\n        assembly {\\n            outFn := inFn\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a function taking ReceivedItem, address, bytes32, and bytes\\n     *      types (e.g. the _transfer function) into a function taking\\n     *      ConsiderationItem, address, bytes32, and bytes types.\\n     *\\n     * @param inFn The input function, taking ReceivedItem, address, bytes32,\\n     *             and bytes types (e.g. the _transfer function).\\n     *\\n     * @return outFn The output function, taking ConsiderationItem, address,\\n     *               bytes32, and bytes types.\\n     */\\n    function _toConsiderationItemInput(\\n        function(ReceivedItem memory, address, bytes32, bytes memory)\\n            internal inFn\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(ConsiderationItem memory, address, bytes32, bytes memory)\\n                internal outFn\\n        )\\n    {\\n        assembly {\\n            outFn := inFn\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a function taking a calldata pointer and returning a memory\\n     *      pointer into a function taking that calldata pointer and returning\\n     *      an OrderParameters type.\\n     *\\n     * @param inFn The input function, taking an arbitrary calldata pointer and\\n     *             returning an arbitrary memory pointer.\\n     *\\n     * @return outFn The output function, taking an arbitrary calldata pointer\\n     *               and returning an OrderParameters type.\\n     */\\n    function _toOrderParametersReturnType(\\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(CalldataPointer)\\n                internal\\n                pure\\n                returns (OrderParameters memory) outFn\\n        )\\n    {\\n        assembly {\\n            outFn := inFn\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a function taking a calldata pointer and returning a memory\\n     *      pointer into a function taking that calldata pointer and returning\\n     *      an AdvancedOrder type.\\n     *\\n     * @param inFn The input function, taking an arbitrary calldata pointer and\\n     *             returning an arbitrary memory pointer.\\n     *\\n     * @return outFn The output function, taking an arbitrary calldata pointer\\n     *               and returning an AdvancedOrder type.\\n     */\\n    function _toAdvancedOrderReturnType(\\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(CalldataPointer)\\n                internal\\n                pure\\n                returns (AdvancedOrder memory) outFn\\n        )\\n    {\\n        assembly {\\n            outFn := inFn\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a function taking a calldata pointer and returning a memory\\n     *      pointer into a function taking that calldata pointer and returning\\n     *      a dynamic array of CriteriaResolver types.\\n     *\\n     * @param inFn The input function, taking an arbitrary calldata pointer and\\n     *             returning an arbitrary memory pointer.\\n     *\\n     * @return outFn The output function, taking an arbitrary calldata pointer\\n     *               and returning a dynamic array of CriteriaResolver types.\\n     */\\n    function _toCriteriaResolversReturnType(\\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(CalldataPointer)\\n                internal\\n                pure\\n                returns (CriteriaResolver[] memory) outFn\\n        )\\n    {\\n        assembly {\\n            outFn := inFn\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a function taking a calldata pointer and returning a memory\\n     *      pointer into a function taking that calldata pointer and returning\\n     *      a dynamic array of Order types.\\n     *\\n     * @param inFn The input function, taking an arbitrary calldata pointer and\\n     *             returning an arbitrary memory pointer.\\n     *\\n     * @return outFn The output function, taking an arbitrary calldata pointer\\n     *               and returning a dynamic array of Order types.\\n     */\\n    function _toOrdersReturnType(\\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(CalldataPointer)\\n                internal\\n                pure\\n                returns (Order[] memory) outFn\\n        )\\n    {\\n        assembly {\\n            outFn := inFn\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a function taking a calldata pointer and returning a memory\\n     *      pointer into a function taking that calldata pointer and returning\\n     *      a nested dynamic array of dynamic arrays of FulfillmentComponent\\n     *      types.\\n     *\\n     * @param inFn The input function, taking an arbitrary calldata pointer and\\n     *             returning an arbitrary memory pointer.\\n     *\\n     * @return outFn The output function, taking an arbitrary calldata pointer\\n     *               and returning a nested dynamic array of dynamic arrays of\\n     *               FulfillmentComponent types.\\n     */\\n    function _toNestedFulfillmentComponentsReturnType(\\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(CalldataPointer)\\n                internal\\n                pure\\n                returns (FulfillmentComponent[][] memory) outFn\\n        )\\n    {\\n        assembly {\\n            outFn := inFn\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a function taking a calldata pointer and returning a memory\\n     *      pointer into a function taking that calldata pointer and returning\\n     *      a dynamic array of AdvancedOrder types.\\n     *\\n     * @param inFn The input function, taking an arbitrary calldata pointer and\\n     *             returning an arbitrary memory pointer.\\n     *\\n     * @return outFn The output function, taking an arbitrary calldata pointer\\n     *               and returning a dynamic array of AdvancedOrder types.\\n     */\\n    function _toAdvancedOrdersReturnType(\\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(CalldataPointer)\\n                internal\\n                pure\\n                returns (AdvancedOrder[] memory) outFn\\n        )\\n    {\\n        assembly {\\n            outFn := inFn\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a function taking a calldata pointer and returning a memory\\n     *      pointer into a function taking that calldata pointer and returning\\n     *      a dynamic array of Fulfillment types.\\n     *\\n     * @param inFn The input function, taking an arbitrary calldata pointer and\\n     *             returning an arbitrary memory pointer.\\n     *\\n     * @return outFn The output function, taking an arbitrary calldata pointer\\n     *               and returning a dynamic array of Fulfillment types.\\n     */\\n    function _toFulfillmentsReturnType(\\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(CalldataPointer)\\n                internal\\n                pure\\n                returns (Fulfillment[] memory) outFn\\n        )\\n    {\\n        assembly {\\n            outFn := inFn\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an offer item into a received item, applying a given\\n     *      recipient.\\n     *\\n     * @param offerItem The offer item.\\n     * @param recipient The recipient.\\n     *\\n     * @return receivedItem The received item.\\n     */\\n    function _convertOfferItemToReceivedItemWithRecipient(\\n        OfferItem memory offerItem,\\n        address recipient\\n    ) internal pure returns (ReceivedItem memory receivedItem) {\\n        assembly {\\n            receivedItem := offerItem\\n            mstore(add(receivedItem, ReceivedItem_recipient_offset), recipient)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ConsiderationEncoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\nimport {\\n    BasicOrderParameters,\\n    Order,\\n    CriteriaResolver,\\n    AdvancedOrder,\\n    FulfillmentComponent,\\n    Execution,\\n    Fulfillment,\\n    OrderComponents,\\n    OrderParameters,\\n    SpentItem,\\n    ReceivedItem\\n} from \\\"./ConsiderationStructs.sol\\\";\\n\\nimport \\\"../helpers/PointerLibraries.sol\\\";\\n\\ncontract ConsiderationEncoder {\\n    /**\\n     * @dev Takes a bytes array and casts it to a memory pointer.\\n     *\\n     * @param obj A bytes array in memory.\\n     *\\n     * @return ptr A memory pointer to the start of the bytes array in memory.\\n     */\\n    function toMemoryPointer(\\n        bytes memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes an array of bytes32 types and casts it to a memory pointer.\\n     *\\n     * @param obj An array of bytes32 types in memory.\\n     *\\n     * @return ptr A memory pointer to the start of the array of bytes32 types\\n     *             in memory.\\n     */\\n    function toMemoryPointer(\\n        bytes32[] memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes a bytes array in memory and copies it to a new location in\\n     *      memory.\\n     *\\n     * @param src A memory pointer referencing the bytes array to be copied (and\\n     *            pointing to the length of the bytes array).\\n     * @param src A memory pointer referencing the location in memory to copy\\n     *            the bytes array to (and pointing to the length of the copied\\n     *            bytes array).\\n     *\\n     * @return size The size of the bytes array.\\n     */\\n    function _encodeBytes(\\n        MemoryPointer src,\\n        MemoryPointer dst\\n    ) internal view returns (uint256 size) {\\n        unchecked {\\n            // Mask the length of the bytes array to protect against overflow\\n            // and round up to the nearest word.\\n            size = (src.readUint256() + AlmostTwoWords) & OnlyFullWordMask;\\n\\n            // Copy the bytes array to the new memory location.\\n            src.copy(dst, size);\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes an OrderParameters struct and a context bytes array in memory\\n     *      and encodes it as `generateOrder` calldata.\\n     *\\n     * @param orderParameters The OrderParameters struct used to construct the\\n     *                        encoded `generateOrder` calldata.\\n     * @param context         The context bytes array used to construct the\\n     *                        encoded `generateOrder` calldata.\\n     *\\n     * @return dst  A memory pointer referencing the encoded `generateOrder`\\n     *              calldata.\\n     * @return size The size of the bytes array.\\n     */\\n    function _encodeGenerateOrder(\\n        OrderParameters memory orderParameters,\\n        bytes memory context\\n    ) internal view returns (MemoryPointer dst, uint256 size) {\\n        // Get the memory pointer for the OrderParameters struct.\\n        MemoryPointer src = orderParameters.toMemoryPointer();\\n\\n        // Get free memory pointer to write calldata to.\\n        dst = getFreeMemoryPointer();\\n\\n        // Write generateOrder selector and get pointer to start of calldata.\\n        dst.write(generateOrder_selector);\\n        dst = dst.offset(generateOrder_selector_offset);\\n\\n        // Get pointer to the beginning of the encoded data.\\n        MemoryPointer dstHead = dst.offset(generateOrder_head_offset);\\n\\n        // Write `fulfiller` to calldata.\\n        dstHead.write(msg.sender);\\n\\n        // Initialize tail offset, used to populate the minimumReceived array.\\n        uint256 tailOffset = generateOrder_base_tail_offset;\\n\\n        // Write offset to minimumReceived.\\n        dstHead.offset(generateOrder_minimumReceived_head_offset).write(\\n            tailOffset\\n        );\\n\\n        // Get memory pointer to `orderParameters.offer.length`.\\n        MemoryPointer srcOfferPointer = src\\n            .offset(OrderParameters_offer_head_offset)\\n            .readMemoryPointer();\\n\\n        // Encode the offer array as a `SpentItem[]`.\\n        uint256 minimumReceivedSize = _encodeSpentItems(\\n            srcOfferPointer,\\n            dstHead.offset(tailOffset)\\n        );\\n\\n        unchecked {\\n            // Increment tail offset, now used to populate maximumSpent array.\\n            tailOffset += minimumReceivedSize;\\n        }\\n\\n        // Write offset to maximumSpent.\\n        dstHead.offset(generateOrder_maximumSpent_head_offset).write(\\n            tailOffset\\n        );\\n\\n        // Get memory pointer to `orderParameters.consideration.length`.\\n        MemoryPointer srcConsiderationPointer = src\\n            .offset(OrderParameters_consideration_head_offset)\\n            .readMemoryPointer();\\n\\n        // Encode the consideration array as a `SpentItem[]`.\\n        uint256 maximumSpentSize = _encodeSpentItems(\\n            srcConsiderationPointer,\\n            dstHead.offset(tailOffset)\\n        );\\n\\n        unchecked {\\n            // Increment tail offset, now used to populate context array.\\n            tailOffset += maximumSpentSize;\\n        }\\n\\n        // Write offset to context.\\n        dstHead.offset(generateOrder_context_head_offset).write(tailOffset);\\n\\n        // Get memory pointer to context.\\n        MemoryPointer srcContext = toMemoryPointer(context);\\n\\n        // Encode context as a bytes array.\\n        uint256 contextSize = _encodeBytes(\\n            srcContext,\\n            dstHead.offset(tailOffset)\\n        );\\n\\n        unchecked {\\n            // Increment the tail offset, now used to determine final size.\\n            tailOffset += contextSize;\\n\\n            // Derive the final size by including the selector.\\n            size = Selector_length + tailOffset;\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes an order hash (e.g. offerer + contract nonce in the case of\\n     *      contract orders), OrderParameters struct, context bytes array, and\\n     *      array of order hashes for each order included as part of the current\\n     *      fulfillment and encodes it as `ratifyOrder` calldata.\\n     *\\n     * @param orderHash       The order hash (e.g. offerer + contract nonce).\\n     * @param orderParameters The OrderParameters struct used to construct the\\n     *                        encoded `ratifyOrder` calldata.\\n     * @param context         The context bytes array used to construct the\\n     *                        encoded `ratifyOrder` calldata.\\n     * @param orderHashes     An array of bytes32 values representing the order\\n     *                        hashes of all orders included as part of the\\n     *                        current fulfillment.\\n     *\\n     * @return dst  A memory pointer referencing the encoded `ratifyOrder`\\n     *              calldata.\\n     * @return size The size of the bytes array.\\n     */\\n    function _encodeRatifyOrder(\\n        bytes32 orderHash, // e.g. offerer + contract nonce\\n        OrderParameters memory orderParameters,\\n        bytes memory context, // encoded based on the schemaID\\n        bytes32[] memory orderHashes\\n    ) internal view returns (MemoryPointer dst, uint256 size) {\\n        // Get free memory pointer to write calldata to. This isn't allocated as\\n        // it is only used for a single function call.\\n        dst = getFreeMemoryPointer();\\n\\n        // Write ratifyOrder selector and get pointer to start of calldata.\\n        dst.write(ratifyOrder_selector);\\n        dst = dst.offset(ratifyOrder_selector_offset);\\n\\n        // Get pointer to the beginning of the encoded data.\\n        MemoryPointer dstHead = dst.offset(ratifyOrder_head_offset);\\n\\n        // Write contractNonce to calldata.\\n        dstHead.offset(ratifyOrder_contractNonce_offset).write(\\n            uint96(uint256(orderHash))\\n        );\\n\\n        // Initialize tail offset, used to populate the offer array.\\n        uint256 tailOffset = ratifyOrder_base_tail_offset;\\n        MemoryPointer src = orderParameters.toMemoryPointer();\\n\\n        // Write offset to `offer`.\\n        dstHead.write(tailOffset);\\n\\n        // Get memory pointer to `orderParameters.offer.length`.\\n        MemoryPointer srcOfferPointer = src\\n            .offset(OrderParameters_offer_head_offset)\\n            .readMemoryPointer();\\n\\n        // Encode the offer array as a `SpentItem[]`.\\n        uint256 offerSize = _encodeSpentItems(\\n            srcOfferPointer,\\n            dstHead.offset(tailOffset)\\n        );\\n\\n        unchecked {\\n            // Increment tail offset, now used to populate consideration array.\\n            tailOffset += offerSize;\\n        }\\n\\n        // Write offset to consideration.\\n        dstHead.offset(ratifyOrder_consideration_head_offset).write(tailOffset);\\n\\n        // Get pointer to `orderParameters.consideration.length`.\\n        MemoryPointer srcConsiderationPointer = src\\n            .offset(OrderParameters_consideration_head_offset)\\n            .readMemoryPointer();\\n\\n        // Encode the consideration array as a `ReceivedItem[]`.\\n        uint256 considerationSize = _encodeConsiderationAsReceivedItems(\\n            srcConsiderationPointer,\\n            dstHead.offset(tailOffset)\\n        );\\n\\n        unchecked {\\n            // Increment tail offset, now used to populate context array.\\n            tailOffset += considerationSize;\\n        }\\n\\n        // Write offset to context.\\n        dstHead.offset(ratifyOrder_context_head_offset).write(tailOffset);\\n\\n        // Encode context.\\n        uint256 contextSize = _encodeBytes(\\n            toMemoryPointer(context),\\n            dstHead.offset(tailOffset)\\n        );\\n\\n        unchecked {\\n            // Increment tail offset, now used to populate orderHashes array.\\n            tailOffset += contextSize;\\n        }\\n\\n        // Write offset to orderHashes.\\n        dstHead.offset(ratifyOrder_orderHashes_head_offset).write(tailOffset);\\n\\n        // Encode orderHashes.\\n        uint256 orderHashesSize = _encodeOrderHashes(\\n            toMemoryPointer(orderHashes),\\n            dstHead.offset(tailOffset)\\n        );\\n\\n        unchecked {\\n            // Increment the tail offset, now used to determine final size.\\n            tailOffset += orderHashesSize;\\n\\n            // Derive the final size by including the selector.\\n            size = Selector_length + tailOffset;\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes an order hash, OrderParameters struct, extraData bytes array,\\n     *      and array of order hashes for each order included as part of the\\n     *      current fulfillment and encodes it as `validateOrder` calldata.\\n     *      Note that future, new versions of this contract may end up writing\\n     *      to a memory region that might have been potentially dirtied by the\\n     *      accumulator. Since the book-keeping for the accumulator does not\\n     *      update the free memory pointer, it will be necessary to ensure that\\n     *      all bytes in the memory in the range [dst, dst+size) are fully\\n     *      updated/written to in this function.\\n     *\\n     * @param orderHash       The order hash.\\n     * @param orderParameters The OrderParameters struct used to construct the\\n     *                        encoded `validateOrder` calldata.\\n     * @param extraData       The extraData bytes array used to construct the\\n     *                        encoded `validateOrder` calldata.\\n     * @param orderHashes     An array of bytes32 values representing the order\\n     *                        hashes of all orders included as part of the\\n     *                        current fulfillment.\\n     *\\n     * @return dst  A memory pointer referencing the encoded `validateOrder`\\n     *              calldata.\\n     * @return size The size of the bytes array.\\n     */\\n    function _encodeValidateOrder(\\n        bytes32 orderHash,\\n        OrderParameters memory orderParameters,\\n        bytes memory extraData,\\n        bytes32[] memory orderHashes\\n    ) internal view returns (MemoryPointer dst, uint256 size) {\\n        // Get free memory pointer to write calldata to. This isn't allocated as\\n        // it is only used for a single function call.\\n        dst = getFreeMemoryPointer();\\n\\n        // Write validateOrder selector and get pointer to start of calldata.\\n        dst.write(validateOrder_selector);\\n        dst = dst.offset(validateOrder_selector_offset);\\n\\n        // Get pointer to the beginning of the encoded data.\\n        MemoryPointer dstHead = dst.offset(validateOrder_head_offset);\\n\\n        // Write offset to zoneParameters to start of calldata.\\n        dstHead.write(validateOrder_zoneParameters_offset);\\n\\n        // Reuse `dstHead` as pointer to zoneParameters.\\n        dstHead = dstHead.offset(validateOrder_zoneParameters_offset);\\n\\n        // Write orderHash and fulfiller to zoneParameters.\\n        dstHead.writeBytes32(orderHash);\\n        dstHead.offset(ZoneParameters_fulfiller_offset).write(msg.sender);\\n\\n        // Get the memory pointer to the order paramaters struct.\\n        MemoryPointer src = orderParameters.toMemoryPointer();\\n\\n        // Copy offerer, startTime, endTime and zoneHash to zoneParameters.\\n        dstHead.offset(ZoneParameters_offerer_offset).write(src.readUint256());\\n        dstHead.offset(ZoneParameters_startTime_offset).write(\\n            src.offset(OrderParameters_startTime_offset).readUint256()\\n        );\\n        dstHead.offset(ZoneParameters_endTime_offset).write(\\n            src.offset(OrderParameters_endTime_offset).readUint256()\\n        );\\n        dstHead.offset(ZoneParameters_zoneHash_offset).write(\\n            src.offset(OrderParameters_zoneHash_offset).readUint256()\\n        );\\n\\n        // Initialize tail offset, used to populate the offer array.\\n        uint256 tailOffset = ZoneParameters_base_tail_offset;\\n\\n        // Write offset to `offer`.\\n        dstHead.offset(ZoneParameters_offer_head_offset).write(tailOffset);\\n\\n        // Get pointer to `orderParameters.offer.length`.\\n        MemoryPointer srcOfferPointer = src\\n            .offset(OrderParameters_offer_head_offset)\\n            .readMemoryPointer();\\n\\n        // Encode the offer array as a `SpentItem[]`.\\n        uint256 offerSize = _encodeSpentItems(\\n            srcOfferPointer,\\n            dstHead.offset(tailOffset)\\n        );\\n\\n        unchecked {\\n            // Increment tail offset, now used to populate consideration array.\\n            tailOffset += offerSize;\\n        }\\n\\n        // Write offset to consideration.\\n        dstHead.offset(ZoneParameters_consideration_head_offset).write(\\n            tailOffset\\n        );\\n\\n        // Get pointer to `orderParameters.consideration.length`.\\n        MemoryPointer srcConsiderationPointer = src\\n            .offset(OrderParameters_consideration_head_offset)\\n            .readMemoryPointer();\\n\\n        // Encode the consideration array as a `ReceivedItem[]`.\\n        uint256 considerationSize = _encodeConsiderationAsReceivedItems(\\n            srcConsiderationPointer,\\n            dstHead.offset(tailOffset)\\n        );\\n\\n        unchecked {\\n            // Increment tail offset, now used to populate extraData array.\\n            tailOffset += considerationSize;\\n        }\\n\\n        // Write offset to extraData.\\n        dstHead.offset(ZoneParameters_extraData_head_offset).write(tailOffset);\\n        // Copy extraData.\\n        uint256 extraDataSize = _encodeBytes(\\n            toMemoryPointer(extraData),\\n            dstHead.offset(tailOffset)\\n        );\\n\\n        unchecked {\\n            // Increment tail offset, now used to populate orderHashes array.\\n            tailOffset += extraDataSize;\\n        }\\n\\n        // Write offset to orderHashes.\\n        dstHead.offset(ZoneParameters_orderHashes_head_offset).write(\\n            tailOffset\\n        );\\n\\n        // Encode the order hashes array.\\n        uint256 orderHashesSize = _encodeOrderHashes(\\n            toMemoryPointer(orderHashes),\\n            dstHead.offset(tailOffset)\\n        );\\n\\n        unchecked {\\n            // Increment the tail offset, now used to determine final size.\\n            tailOffset += orderHashesSize;\\n\\n            // Derive final size including selector and ZoneParameters pointer.\\n            size = ZoneParameters_selectorAndPointer_length + tailOffset;\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes an order hash and BasicOrderParameters struct (from calldata)\\n     *      and encodes it as `validateOrder` calldata.\\n     *\\n     * @param orderHash  The order hash.\\n     * @param parameters The BasicOrderParameters struct used to construct the\\n     *                   encoded `validateOrder` calldata.\\n     *\\n     * @return dst  A memory pointer referencing the encoded `validateOrder`\\n     *              calldata.\\n     * @return size The size of the bytes array.\\n     */\\n    function _encodeValidateBasicOrder(\\n        bytes32 orderHash,\\n        BasicOrderParameters calldata parameters\\n    ) internal view returns (MemoryPointer dst, uint256 size) {\\n        // Get free memory pointer to write calldata to. This isn't allocated as\\n        // it is only used for a single function call.\\n        dst = getFreeMemoryPointer();\\n\\n        // Write validateOrder selector and get pointer to start of calldata.\\n        dst.write(validateOrder_selector);\\n        dst = dst.offset(validateOrder_selector_offset);\\n\\n        // Get pointer to the beginning of the encoded data.\\n        MemoryPointer dstHead = dst.offset(validateOrder_head_offset);\\n\\n        // Write offset to zoneParameters to start of calldata.\\n        dstHead.write(validateOrder_zoneParameters_offset);\\n\\n        // Reuse `dstHead` as pointer to zoneParameters.\\n        dstHead = dstHead.offset(validateOrder_zoneParameters_offset);\\n\\n        // Write offerer, orderHash and fulfiller to zoneParameters.\\n        dstHead.writeBytes32(orderHash);\\n        dstHead.offset(ZoneParameters_fulfiller_offset).write(msg.sender);\\n        dstHead.offset(ZoneParameters_offerer_offset).write(parameters.offerer);\\n\\n        // Copy startTime, endTime and zoneHash to zoneParameters.\\n        CalldataPointer.wrap(BasicOrder_startTime_cdPtr).copy(\\n            dstHead.offset(ZoneParameters_startTime_offset),\\n            BasicOrder_startTimeThroughZoneHash_size\\n        );\\n\\n        // Initialize tail offset, used for the offer + consideration arrays.\\n        uint256 tailOffset = ZoneParameters_base_tail_offset;\\n\\n        // Write offset to offer from event data into target calldata.\\n        dstHead.offset(ZoneParameters_offer_head_offset).write(tailOffset);\\n\\n        unchecked {\\n            // Write consideration offset next (located 5 words after offer).\\n            dstHead.offset(ZoneParameters_consideration_head_offset).write(\\n                tailOffset + BasicOrder_common_params_size\\n            );\\n\\n            // Retrieve the offset to the length of additional recipients.\\n            uint256 additionalRecipientsLength = CalldataPointer\\n                .wrap(BasicOrder_additionalRecipients_length_cdPtr)\\n                .readUint256();\\n\\n            // Derive offset to event data using base offset & total recipients.\\n            uint256 offerDataOffset = OrderFulfilled_offer_length_baseOffset +\\n                additionalRecipientsLength *\\n                OneWord;\\n\\n            // Derive size of offer and consideration data.\\n            // 2 words (lengths) + 4 (offer data) + 5 (consideration 1) + 5 * ar\\n            uint256 offerAndConsiderationSize = OrderFulfilled_baseDataSize +\\n                (additionalRecipientsLength * ReceivedItem_size);\\n\\n            // Copy offer and consideration data from event data to calldata.\\n            MemoryPointer.wrap(offerDataOffset).copy(\\n                dstHead.offset(tailOffset),\\n                offerAndConsiderationSize\\n            );\\n\\n            // Increment tail offset, now used to populate extraData array.\\n            tailOffset += offerAndConsiderationSize;\\n        }\\n\\n        // Write empty bytes for extraData.\\n        dstHead.offset(ZoneParameters_extraData_head_offset).write(tailOffset);\\n        dstHead.offset(tailOffset).write(0);\\n\\n        unchecked {\\n            // Increment tail offset, now used to populate orderHashes array.\\n            tailOffset += OneWord;\\n        }\\n\\n        // Write offset to orderHashes.\\n        dstHead.offset(ZoneParameters_orderHashes_head_offset).write(\\n            tailOffset\\n        );\\n\\n        // Write length = 1 to the orderHashes array.\\n        dstHead.offset(tailOffset).write(1);\\n\\n        unchecked {\\n            // Write the single order hash to the orderHashes array.\\n            dstHead.offset(tailOffset + OneWord).writeBytes32(orderHash);\\n\\n            // Final size: selector, ZoneParameters pointer, orderHashes & tail.\\n            size = ZoneParameters_basicOrderFixedElements_length + tailOffset;\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes a memory pointer to an array of bytes32 values representing\\n     *      the order hashes included as part of the fulfillment and a memory\\n     *      pointer to a location to copy it to, and copies the source data to\\n     *      the destination in memory.\\n     *\\n     * @param srcLength A memory pointer referencing the order hashes array to\\n     *                  be copied (and pointing to the length of the array).\\n     * @param dstLength A memory pointer referencing the location in memory to\\n     *                  copy the orderHashes array to (and pointing to the\\n     *                  length of the copied array).\\n     *\\n     * @return size The size of the order hashes array (including the length).\\n     */\\n    function _encodeOrderHashes(\\n        MemoryPointer srcLength,\\n        MemoryPointer dstLength\\n    ) internal view returns (uint256 size) {\\n        // Read length of the array from source and write to destination.\\n        uint256 length = srcLength.readUint256();\\n        dstLength.write(length);\\n\\n        unchecked {\\n            // Determine head & tail size as one word per element in the array.\\n            uint256 headAndTailSize = length * OneWord;\\n\\n            // Copy the tail starting from the next element of the source to the\\n            // next element of the destination.\\n            srcLength.next().offset(headAndTailSize).copy(\\n                dstLength.next(),\\n                headAndTailSize\\n            );\\n\\n            // Set size to the length of the tail plus one word for length.\\n            size = headAndTailSize + OneWord;\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes a memory pointer to an offer or consideration array and a\\n     *      memory pointer to a location to copy it to, and copies the source\\n     *      data to the destination in memory as a SpentItem array.\\n     *\\n     * @param srcLength A memory pointer referencing the offer or consideration\\n     *                  array to be copied as a SpentItem array (and pointing to\\n     *                  the length of the original array).\\n     * @param dstLength A memory pointer referencing the location in memory to\\n     *                  copy the offer array to (and pointing to the length of\\n     *                  the copied array).\\n     *\\n     * @return size The size of the SpentItem array (including the length).\\n     */\\n    function _encodeSpentItems(\\n        MemoryPointer srcLength,\\n        MemoryPointer dstLength\\n    ) internal pure returns (uint256 size) {\\n        assembly {\\n            // Read length of the array from source and write to destination.\\n            let length := mload(srcLength)\\n            mstore(dstLength, length)\\n\\n            // Get pointer to first item's head position in the array,\\n            // containing the item's pointer in memory. The head pointer will be\\n            // incremented until it reaches the tail position (start of the\\n            // array data).\\n            let mPtrHead := add(srcLength, OneWord)\\n\\n            // Position in memory to write next item for calldata. Since\\n            // SpentItem has a fixed length, the array elements do not contain\\n            // head elements in calldata, they are concatenated together after\\n            // the array length.\\n            let cdPtrData := add(dstLength, OneWord)\\n\\n            // Pointer to end of array head in memory.\\n            let mPtrHeadEnd := add(mPtrHead, shl(OneWordShift, length))\\n\\n            for {\\n\\n            } lt(mPtrHead, mPtrHeadEnd) {\\n\\n            } {\\n                // Read pointer to data for array element from head position.\\n                let mPtrTail := mload(mPtrHead)\\n\\n                // Copy itemType, token, identifier, amount to calldata.\\n                mstore(cdPtrData, mload(mPtrTail))\\n                mstore(\\n                    add(cdPtrData, Common_token_offset),\\n                    mload(add(mPtrTail, Common_token_offset))\\n                )\\n                mstore(\\n                    add(cdPtrData, Common_identifier_offset),\\n                    mload(add(mPtrTail, Common_identifier_offset))\\n                )\\n                mstore(\\n                    add(cdPtrData, Common_amount_offset),\\n                    mload(add(mPtrTail, Common_amount_offset))\\n                )\\n\\n                mPtrHead := add(mPtrHead, OneWord)\\n                cdPtrData := add(cdPtrData, SpentItem_size)\\n            }\\n\\n            size := add(OneWord, shl(SpentItem_size_shift, length))\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes a memory pointer to an consideration array and a memory\\n     *      pointer to a location to copy it to, and copies the source data to\\n     *      the destination in memory as a ReceivedItem array.\\n     *\\n     * @param srcLength A memory pointer referencing the consideration array to\\n     *                  be copied as a ReceivedItem array (and pointing to the\\n     *                  length of the original array).\\n     * @param dstLength A memory pointer referencing the location in memory to\\n     *                  copy the consideration array to as a ReceivedItem array\\n     *                  (and pointing to the length of the new array).\\n     *\\n     * @return size The size of the ReceivedItem array (including the length).\\n     */\\n    function _encodeConsiderationAsReceivedItems(\\n        MemoryPointer srcLength,\\n        MemoryPointer dstLength\\n    ) internal view returns (uint256 size) {\\n        unchecked {\\n            // Read length of the array from source and write to destination.\\n            uint256 length = srcLength.readUint256();\\n            dstLength.write(length);\\n\\n            // Get pointer to first item's head position in the array,\\n            // containing the item's pointer in memory. The head pointer will be\\n            // incremented until it reaches the tail position (start of the\\n            // array data).\\n            MemoryPointer srcHead = srcLength.next();\\n            MemoryPointer srcHeadEnd = srcHead.offset(length * OneWord);\\n\\n            // Position in memory to write next item for calldata. Since\\n            // ReceivedItem has a fixed length, the array elements do not\\n            // contain offsets in calldata, they are concatenated together after\\n            // the array length.\\n            MemoryPointer dstHead = dstLength.next();\\n            while (srcHead.lt(srcHeadEnd)) {\\n                MemoryPointer srcTail = srcHead.pptr();\\n                srcTail.copy(dstHead, ReceivedItem_size);\\n                srcHead = srcHead.next();\\n                dstHead = dstHead.offset(ReceivedItem_size);\\n            }\\n\\n            size = OneWord + (length * ReceivedItem_size);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/TypehashDirectory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title TypehashDirectory\\n * @notice The typehash directory contains 24 bulk order EIP-712 typehashes,\\n *         depending on the height of the tree in each bulk order payload, as\\n *         its runtime code (with an invalid opcode prefix so that the contract\\n *         cannot be called normally). This runtime code is designed to be read\\n *         from by Seaport using `extcodecopy` while verifying bulk signatures.\\n */\\ncontract TypehashDirectory {\\n    // Encodes \\\"[2]\\\" for use in deriving typehashes.\\n    bytes3 internal constant twoSubstring = 0x5B325D;\\n    uint256 internal constant twoSubstringLength = 3;\\n\\n    // Dictates maximum bulk order group size; 24 => 2^24 => 16,777,216 orders.\\n    uint256 internal constant MaxTreeHeight = 24;\\n\\n    uint256 internal constant InvalidOpcode = 0xfe;\\n    uint256 internal constant OneWord = 0x20;\\n    uint256 internal constant OneWordShift = 5;\\n    uint256 internal constant AlmostOneWord = 0x1f;\\n    uint256 internal constant FreeMemoryPointerSlot = 0x40;\\n\\n    /**\\n     * @dev Derive 24 bulk order EIP-712 typehashes, one for each supported\\n     *      tree height from 1 to 24, and write them to runtime code.\\n     */\\n    constructor() {\\n        // Declare an array where each type hash will be writter.\\n        bytes32[] memory typeHashes = new bytes32[](MaxTreeHeight);\\n\\n        // Derive a string of 24 \\\"[2]\\\" substrings.\\n        bytes memory brackets = getMaxTreeBrackets(MaxTreeHeight);\\n\\n        // Derive a string of subtypes for the order parameters.\\n        bytes memory subTypes = getTreeSubTypes();\\n\\n        // Cache memory pointer before each loop so memory doesn't expand by the\\n        // full string size on each loop.\\n        uint256 freeMemoryPointer;\\n        assembly {\\n            freeMemoryPointer := mload(FreeMemoryPointerSlot)\\n        }\\n\\n        // Iterate over each tree height.\\n        for (uint256 i = 0; i < MaxTreeHeight; ) {\\n            // The actual height is one greater than its respective index.\\n            uint256 height = i + 1;\\n\\n            // Slice brackets length to size needed for `height`.\\n            assembly {\\n                mstore(brackets, mul(twoSubstringLength, height))\\n            }\\n\\n            // Encode the type string for the BulkOrder struct.\\n            bytes memory bulkOrderTypeString = bytes.concat(\\n                \\\"BulkOrder(OrderComponents\\\",\\n                brackets,\\n                \\\" tree)\\\",\\n                subTypes\\n            );\\n\\n            // Derive EIP712 type hash.\\n            bytes32 typeHash = keccak256(bulkOrderTypeString);\\n            typeHashes[i] = typeHash;\\n\\n            // Reset the free memory pointer.\\n            assembly {\\n                mstore(FreeMemoryPointerSlot, freeMemoryPointer)\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        assembly {\\n            // Overwrite length with zero to give the contract an INVALID prefix\\n            // and deploy the type hashes array as a contract.\\n            mstore(typeHashes, InvalidOpcode)\\n\\n            return(\\n                add(typeHashes, AlmostOneWord),\\n                add(shl(OneWordShift, MaxTreeHeight), 1)\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function that returns a string of \\\"[2]\\\" substrings,\\n     *      with a number of substrings equal to the provided height.\\n     *\\n     * @param maxHeight The number of \\\"[2]\\\" substrings to include.\\n     *\\n     * @return A bytes array representing the string.\\n     */\\n    function getMaxTreeBrackets(\\n        uint256 maxHeight\\n    ) internal pure returns (bytes memory) {\\n        bytes memory suffixes = new bytes(twoSubstringLength * maxHeight);\\n        assembly {\\n            // Retrieve the pointer to the array head.\\n            let ptr := add(suffixes, OneWord)\\n\\n            // Derive the terminal pointer.\\n            let endPtr := add(ptr, mul(maxHeight, twoSubstringLength))\\n\\n            // Iterate over each pointer until terminal pointer is reached.\\n            for {\\n\\n            } lt(ptr, endPtr) {\\n                ptr := add(ptr, twoSubstringLength)\\n            } {\\n                // Insert \\\"[2]\\\" substring directly at current pointer location.\\n                mstore(ptr, twoSubstring)\\n            }\\n        }\\n\\n        // Return the fully populated array of substrings.\\n        return suffixes;\\n    }\\n\\n    /**\\n     * @dev Internal pure function that returns a string of subtypes used in\\n     *      generating bulk order EIP-712 typehashes.\\n     *\\n     * @return A bytes array representing the string.\\n     */\\n    function getTreeSubTypes() internal pure returns (bytes memory) {\\n        // Construct the OfferItem type string.\\n        // prettier-ignore\\n        bytes memory offerItemTypeString = bytes(\\n                \\\"OfferItem(\\\"\\n                    \\\"uint8 itemType,\\\"\\n                    \\\"address token,\\\"\\n                    \\\"uint256 identifierOrCriteria,\\\"\\n                    \\\"uint256 startAmount,\\\"\\n                    \\\"uint256 endAmount\\\"\\n                \\\")\\\"\\n            );\\n\\n        // Construct the ConsiderationItem type string.\\n        // prettier-ignore\\n        bytes memory considerationItemTypeString = bytes(\\n                \\\"ConsiderationItem(\\\"\\n                    \\\"uint8 itemType,\\\"\\n                    \\\"address token,\\\"\\n                    \\\"uint256 identifierOrCriteria,\\\"\\n                    \\\"uint256 startAmount,\\\"\\n                    \\\"uint256 endAmount,\\\"\\n                    \\\"address recipient\\\"\\n                \\\")\\\"\\n            );\\n\\n        // Construct the OrderComponents type string, not including the above.\\n        // prettier-ignore\\n        bytes memory orderComponentsPartialTypeString = bytes(\\n                \\\"OrderComponents(\\\"\\n                    \\\"address offerer,\\\"\\n                    \\\"address zone,\\\"\\n                    \\\"OfferItem[] offer,\\\"\\n                    \\\"ConsiderationItem[] consideration,\\\"\\n                    \\\"uint8 orderType,\\\"\\n                    \\\"uint256 startTime,\\\"\\n                    \\\"uint256 endTime,\\\"\\n                    \\\"bytes32 zoneHash,\\\"\\n                    \\\"uint256 salt,\\\"\\n                    \\\"bytes32 conduitKey,\\\"\\n                    \\\"uint256 counter\\\"\\n                \\\")\\\"\\n            );\\n\\n        // Return the combined string.\\n        return\\n            abi.encodePacked(\\n                considerationItemTypeString,\\n                offerItemTypeString,\\n                orderComponentsPartialTypeString\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { ReentrancyErrors } from \\\"../interfaces/ReentrancyErrors.sol\\\";\\n\\nimport { LowLevelHelpers } from \\\"./LowLevelHelpers.sol\\\";\\n\\nimport \\\"./ConsiderationErrors.sol\\\";\\n\\n/**\\n * @title ReentrancyGuard\\n * @author 0age\\n * @notice ReentrancyGuard contains a storage variable and related functionality\\n *         for protecting against reentrancy.\\n */\\ncontract ReentrancyGuard is ReentrancyErrors, LowLevelHelpers {\\n    // Prevent reentrant calls on protected functions.\\n    uint256 private _reentrancyGuard;\\n\\n    /**\\n     * @dev Initialize the reentrancy guard during deployment.\\n     */\\n    constructor() {\\n        // Initialize the reentrancy guard in a cleared state.\\n        _reentrancyGuard = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Internal function to ensure that a sentinel value for the reentrancy\\n     *      guard is not currently set and, if not, to set a sentinel value for\\n     *      the reentrancy guard based on whether or not native tokens may be\\n     *      received during execution or not.\\n     *\\n     * @param acceptNativeTokens A boolean indicating whether native tokens may\\n     *                           be received during execution or not.\\n     */\\n    function _setReentrancyGuard(bool acceptNativeTokens) internal {\\n        // Ensure that the reentrancy guard is not already set.\\n        _assertNonReentrant();\\n\\n        // Set the reentrancy guard. A value of 2 indicates that native tokens\\n        // may not be accepted during execution, whereas a value of 3 indicates\\n        // that they will be accepted (with any remaining native tokens returned\\n        // to the caller).\\n        unchecked {\\n            _reentrancyGuard = _ENTERED + _cast(acceptNativeTokens);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to unset the reentrancy guard sentinel value.\\n     */\\n    function _clearReentrancyGuard() internal {\\n        // Clear the reentrancy guard.\\n        _reentrancyGuard = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Internal view function to ensure that a sentinel value for the\\n            reentrancy guard is not currently set.\\n     */\\n    function _assertNonReentrant() internal view {\\n        // Ensure that the reentrancy guard is not currently set.\\n        if (_reentrancyGuard != _NOT_ENTERED) {\\n            _revertNoReentrantCalls();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to ensure that the sentinel value indicating\\n     *      native tokens may be received during execution is currently set.\\n     */\\n    function _assertAcceptingNativeTokens() internal view {\\n        // Ensure that the reentrancy guard is not currently set.\\n        if (_reentrancyGuard != _ENTERED_AND_ACCEPTING_NATIVE_TOKENS) {\\n            _revertInvalidMsgValue(msg.value);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ReentrancyErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title ReentrancyErrors\\n * @author 0age\\n * @notice ReentrancyErrors contains errors related to reentrancy.\\n */\\ninterface ReentrancyErrors {\\n    /**\\n     * @dev Revert with an error when a caller attempts to reenter a protected\\n     *      function.\\n     */\\n    error NoReentrantCalls();\\n}\\n\"\r\n    },\r\n    \"contracts/lib/LowLevelHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title LowLevelHelpers\\n * @author 0age\\n * @notice LowLevelHelpers contains logic for performing various low-level\\n *         operations.\\n */\\ncontract LowLevelHelpers {\\n    /**\\n     * @dev Internal view function to revert and pass along the revert reason if\\n     *      data was returned by the last call and that the size of that data\\n     *      does not exceed the currently allocated memory size.\\n     */\\n    function _revertWithReasonIfOneIsReturned() internal view {\\n        assembly {\\n            // If it returned a message, bubble it up as long as sufficient gas\\n            // remains to do so:\\n            if returndatasize() {\\n                // Ensure that sufficient gas is available to copy returndata\\n                // while expanding memory where necessary. Start by computing\\n                // the word size of returndata and allocated memory.\\n                let returnDataWords := shr(\\n                    OneWordShift,\\n                    add(returndatasize(), AlmostOneWord)\\n                )\\n\\n                // Note: use the free memory pointer in place of msize() to work\\n                // around a Yul warning that prevents accessing msize directly\\n                // when the IR pipeline is activated.\\n                let msizeWords := shr(\\n                    OneWordShift,\\n                    mload(FreeMemoryPointerSlot)\\n                )\\n\\n                // Next, compute the cost of the returndatacopy.\\n                let cost := mul(CostPerWord, returnDataWords)\\n\\n                // Then, compute cost of new memory allocation.\\n                if gt(returnDataWords, msizeWords) {\\n                    cost := add(\\n                        cost,\\n                        add(\\n                            mul(sub(returnDataWords, msizeWords), CostPerWord),\\n                            shr(\\n                                MemoryExpansionCoefficientShift,\\n                                sub(\\n                                    mul(returnDataWords, returnDataWords),\\n                                    mul(msizeWords, msizeWords)\\n                                )\\n                            )\\n                        )\\n                    )\\n                }\\n\\n                // Finally, add a small constant and compare to gas remaining;\\n                // bubble up the revert data if enough gas is still available.\\n                if lt(add(cost, ExtraGasBuffer), gas()) {\\n                    // Copy returndata to memory; overwrite existing memory.\\n                    returndatacopy(0, 0, returndatasize())\\n\\n                    // Revert, specifying memory region with copied returndata.\\n                    revert(0, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to branchlessly select either the caller (if\\n     *      a supplied recipient is equal to zero) or the supplied recipient (if\\n     *      that recipient is a nonzero value).\\n     *\\n     * @param recipient The supplied recipient.\\n     *\\n     * @return updatedRecipient The updated recipient.\\n     */\\n    function _substituteCallerForEmptyRecipient(\\n        address recipient\\n    ) internal view returns (address updatedRecipient) {\\n        // Utilize assembly to perform a branchless operation on the recipient.\\n        assembly {\\n            // Add caller to recipient if recipient equals 0; otherwise add 0.\\n            updatedRecipient := add(recipient, mul(iszero(recipient), caller()))\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to cast a `bool` value to a `uint256` value.\\n     *\\n     * @param b The `bool` value to cast.\\n     *\\n     * @return u The `uint256` value.\\n     */\\n    function _cast(bool b) internal pure returns (uint256 u) {\\n        assembly {\\n            u := b\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to compare two addresses without first\\n     *      masking them. Note that dirty upper bits will cause otherwise equal\\n     *      addresses to be recognized as unequal.\\n     *\\n     * @param a The first address.\\n     * @param b The second address\\n     *\\n     * @return areEqual A boolean representing whether the addresses are equal.\\n     */\\n    function _unmaskedAddressComparison(\\n        address a,\\n        address b\\n    ) internal pure returns (bool areEqual) {\\n        // Utilize assembly to perform the comparison without masking.\\n        assembly {\\n            areEqual := eq(a, b)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/EIP1271Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface EIP1271Interface {\\n    function isValidSignature(\\n        bytes32 digest,\\n        bytes calldata signature\\n    ) external view returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/SignatureVerificationErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title SignatureVerificationErrors\\n * @author 0age\\n * @notice SignatureVerificationErrors contains all errors related to signature\\n *         verification.\\n */\\ninterface SignatureVerificationErrors {\\n    /**\\n     * @dev Revert with an error when a signature that does not contain a v\\n     *      value of 27 or 28 has been supplied.\\n     *\\n     * @param v The invalid v value.\\n     */\\n    error BadSignatureV(uint8 v);\\n\\n    /**\\n     * @dev Revert with an error when the signer recovered by the supplied\\n     *      signature does not match the offerer or an allowed EIP-1271 signer\\n     *      as specified by the offerer in the event they are a contract.\\n     */\\n    error InvalidSigner();\\n\\n    /**\\n     * @dev Revert with an error when a signer cannot be recovered from the\\n     *      supplied signature.\\n     */\\n    error InvalidSignature();\\n\\n    /**\\n     * @dev Revert with an error when an EIP-1271 call to an account fails.\\n     */\\n    error BadContractSignature();\\n}\\n\"\r\n    },\r\n    \"contracts/lib/TokenTransferrerConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/*\\n * -------------------------- Disambiguation & Other Notes ---------------------\\n *    - The term \\\"head\\\" is used as it is in the documentation for ABI encoding,\\n *      but only in reference to dynamic types, i.e. it always refers to the\\n *      offset or pointer to the body of a dynamic type. In calldata, the head\\n *      is always an offset (relative to the parent object), while in memory,\\n *      the head is always the pointer to the body. More information found here:\\n *      https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#argument-encoding\\n *        - Note that the length of an array is separate from and precedes the\\n *          head of the array.\\n *\\n *    - The term \\\"body\\\" is used in place of the term \\\"head\\\" used in the ABI\\n *      documentation. It refers to the start of the data for a dynamic type,\\n *      e.g. the first word of a struct or the first word of the first element\\n *      in an array.\\n *\\n *    - The term \\\"pointer\\\" is used to describe the absolute position of a value\\n *      and never an offset relative to another value.\\n *        - The suffix \\\"_ptr\\\" refers to a memory pointer.\\n *        - The suffix \\\"_cdPtr\\\" refers to a calldata pointer.\\n *\\n *    - The term \\\"offset\\\" is used to describe the position of a value relative\\n *      to some parent value. For example, OrderParameters_conduit_offset is the\\n *      offset to the \\\"conduit\\\" value in the OrderParameters struct relative to\\n *      the start of the body.\\n *        - Note: Offsets are used to derive pointers.\\n *\\n *    - Some structs have pointers defined for all of their fields in this file.\\n *      Lines which are commented out are fields that are not used in the\\n *      codebase but have been left in for readability.\\n */\\n\\nuint256 constant AlmostOneWord = 0x1f;\\nuint256 constant OneWord = 0x20;\\nuint256 constant TwoWords = 0x40;\\nuint256 constant ThreeWords = 0x60;\\n\\nuint256 constant OneWordShift = 5;\\nuint256 constant TwoWordsShift = 6;\\n\\nuint256 constant FreeMemoryPointerSlot = 0x40;\\nuint256 constant ZeroSlot = 0x60;\\nuint256 constant DefaultFreeMemoryPointer = 0x80;\\n\\nuint256 constant Slot0x80 = 0x80;\\nuint256 constant Slot0xA0 = 0xa0;\\nuint256 constant Slot0xC0 = 0xc0;\\n\\nuint256 constant Generic_error_selector_offset = 0x1c;\\n\\n// abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\")\\nuint256 constant ERC20_transferFrom_signature = (\\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\"\\n// )\\nuint256 constant ERC1155_safeTransferFrom_signature = (\\n    0xf242432a00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 196\\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\\"\\n// )\\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\\n);\\n\\nbytes4 constant ERC1155_safeBatchTransferFrom_selector = bytes4(\\n    bytes32(ERC1155_safeBatchTransferFrom_signature)\\n);\\n\\nuint256 constant ERC721_transferFrom_signature = ERC20_transferFrom_signature;\\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n/*\\n *  error NoContract(address account)\\n *    - Defined in TokenTransferrerErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x00: account\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant NoContract_error_selector = 0x5f15d672;\\nuint256 constant NoContract_error_account_ptr = 0x20;\\nuint256 constant NoContract_error_length = 0x24;\\n\\n/*\\n *  error TokenTransferGenericFailure(address token, address from, address to, uint256 identifier, uint256 amount)\\n *    - Defined in TokenTransferrerErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: token\\n *    - 0x40: from\\n *    - 0x60: to\\n *    - 0x80: identifier\\n *    - 0xa0: amount\\n * Revert buffer is memory[0x1c:0xc0]\\n */\\nuint256 constant TokenTransferGenericFailure_error_selector = 0xf486bc87;\\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x20;\\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x40;\\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x60;\\nuint256 constant TokenTransferGenericFailure_error_identifier_ptr = 0x80;\\nuint256 constant TokenTransferGenericFailure_err_identifier_ptr = 0x80;\\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0xa0;\\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\\n\\nuint256 constant ExtraGasBuffer = 0x20;\\nuint256 constant CostPerWord = 3;\\nuint256 constant MemoryExpansionCoefficientShift = 9;\\n\\n// Values are offset by 32 bytes in order to write the token to the beginning\\n// in the event of a revert\\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x64;\\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4;\\nuint256 constant BatchTransfer1155Params_calldata_baseSize = 0xc4;\\n\\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\\n\\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\\nuint256 constant BatchTransfer1155Params_amounts_length_baseOffset = 0xc0;\\nuint256 constant BatchTransfer1155Params_data_length_baseOffset = 0xe0;\\n\\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\\n\\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\\nuint256 constant ConduitBatch1155Transfer_amounts_head_offset = 0x80;\\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\\nuint256 constant ConduitBatch1155Transfer_calldata_baseSize = 0xc0;\\n\\n// Note: abbreviated version of above constant to adhere to line length limit.\\nuint256 constant ConduitBatchTransfer_amounts_head_offset = 0x80;\\n\\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\\n    0xafc445e200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\\nuint256 constant ERC1155BatchTransferGenericFailure_ids_offset = 0xc0;\\n\\n/*\\n *  error BadReturnValueFromERC20OnTransfer(address token, address from, address to, uint256 amount)\\n *    - Defined in TokenTransferrerErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x00: token\\n *    - 0x20: from\\n *    - 0x40: to\\n *    - 0x60: amount\\n * Revert buffer is memory[0x1c:0xa0]\\n */\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_selector = 0x98891923;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x20;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x40;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x60;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x80;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\\n\"\r\n    },\r\n    \"contracts/interfaces/ZoneInteractionErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title ZoneInteractionErrors\\n * @author 0age\\n * @notice ZoneInteractionErrors contains errors related to zone interaction.\\n */\\ninterface ZoneInteractionErrors {\\n    /**\\n     * @dev Revert with an error when attempting to fill an order that specifies\\n     *      a restricted submitter as its order type when not submitted by\\n     *      either the offerer or the order's zone or approved as valid by the\\n     *      zone in question via a call to `isValidOrder`.\\n     *\\n     * @param orderHash The order hash for the invalid restricted order.\\n     */\\n    error InvalidRestrictedOrder(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill a contract order that\\n     *      fails to generate an order successfully, that does not adhere to the\\n     *      requirements for minimum spent or maximum received supplied by the\\n     *      fulfiller, or that fails the post-execution `ratifyOrder` check..\\n     *\\n     * @param orderHash The order hash for the invalid contract order.\\n     */\\n    error InvalidContractOrder(bytes32 orderHash);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CriteriaResolutionErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { Side } from \\\"../lib/ConsiderationEnums.sol\\\";\\n\\n/**\\n * @title CriteriaResolutionErrors\\n * @author 0age\\n * @notice CriteriaResolutionErrors contains all errors related to criteria\\n *         resolution.\\n */\\ninterface CriteriaResolutionErrors {\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that refers\\n     *      to an order that has not been supplied.\\n     *\\n     * @param side The side of the order that was not supplied.\\n     */\\n    error OrderCriteriaResolverOutOfRange(Side side);\\n\\n    /**\\n     * @dev Revert with an error if an offer item still has unresolved criteria\\n     *      after applying all criteria resolvers.\\n     *\\n     * @param orderIndex The index of the order that contains the offer item.\\n     * @param offerIndex The index of the offer item that still has unresolved\\n     *                   criteria.\\n     */\\n    error UnresolvedOfferCriteria(uint256 orderIndex, uint256 offerIndex);\\n\\n    /**\\n     * @dev Revert with an error if a consideration item still has unresolved\\n     *      criteria after applying all criteria resolvers.\\n     *\\n     * @param orderIndex         The index of the order that contains the\\n     *                           consideration item.\\n     * @param considerationIndex The index of the consideration item that still\\n     *                           has unresolved criteria.\\n     */\\n    error UnresolvedConsiderationCriteria(\\n        uint256 orderIndex,\\n        uint256 considerationIndex\\n    );\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that refers\\n     *      to an order with an offer item that has not been supplied.\\n     */\\n    error OfferCriteriaResolverOutOfRange();\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that refers\\n     *      to an order with a consideration item that has not been supplied.\\n     */\\n    error ConsiderationCriteriaResolverOutOfRange();\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that refers\\n     *      to an order with an item that does not expect a criteria to be\\n     *      resolved.\\n     */\\n    error CriteriaNotEnabledForItem();\\n\\n    /**\\n     * @dev Revert with an error when providing a criteria resolver that\\n     *      contains an invalid proof with respect to the given item and\\n     *      chosen identifier.\\n     */\\n    error InvalidProof();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/AmountDerivationErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title AmountDerivationErrors\\n * @author 0age\\n * @notice AmountDerivationErrors contains errors related to amount derivation.\\n */\\ninterface AmountDerivationErrors {\\n    /**\\n     * @dev Revert with an error when attempting to apply a fraction as part of\\n     *      a partial fill that does not divide the target amount cleanly.\\n     */\\n    error InexactFraction();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/FulfillmentApplicationErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { Side } from \\\"../lib/ConsiderationEnums.sol\\\";\\n\\n/**\\n * @title FulfillmentApplicationErrors\\n * @author 0age\\n * @notice FulfillmentApplicationErrors contains errors related to fulfillment\\n *         application and aggregation.\\n */\\ninterface FulfillmentApplicationErrors {\\n    /**\\n     * @dev Revert with an error when a fulfillment is provided that does not\\n     *      declare at least one component as part of a call to fulfill\\n     *      available orders.\\n     */\\n    error MissingFulfillmentComponentOnAggregation(Side side);\\n\\n    /**\\n     * @dev Revert with an error when a fulfillment is provided that does not\\n     *      declare at least one offer component and at least one consideration\\n     *      component.\\n     */\\n    error OfferAndConsiderationRequiredOnFulfillment();\\n\\n    /**\\n     * @dev Revert with an error when the initial offer item named by a\\n     *      fulfillment component does not match the type, token, identifier,\\n     *      or conduit preference of the initial consideration item.\\n     *\\n     * @param fulfillmentIndex The index of the fulfillment component that\\n     *                         does not match the initial offer item.\\n     */\\n    error MismatchedFulfillmentOfferAndConsiderationComponents(\\n        uint256 fulfillmentIndex\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an order or item index are out of range\\n     *      or a fulfillment component does not match the type, token,\\n     *      identifier, or conduit preference of the initial consideration item.\\n     */\\n    error InvalidFulfillmentComponentData();\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestInvalidContractOfferer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    ERC20Interface,\\n    ERC721Interface,\\n    ERC1155Interface\\n} from \\\"../interfaces/AbridgedTokenInterfaces.sol\\\";\\n\\nimport {\\n    ContractOffererInterface\\n} from \\\"../interfaces/ContractOffererInterface.sol\\\";\\n\\nimport { ItemType } from \\\"../lib/ConsiderationEnums.sol\\\";\\n\\nimport { SpentItem, ReceivedItem } from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\nimport { TestContractOfferer } from \\\"./TestContractOfferer.sol\\\";\\n\\ncontract TestInvalidContractOfferer is TestContractOfferer {\\n    error RevertWithData(bytes revertData);\\n\\n    constructor(address seaport) TestContractOfferer(seaport) {}\\n\\n    function generateOrder(\\n        address,\\n        SpentItem[] calldata,\\n        SpentItem[] calldata,\\n        bytes calldata context\\n    )\\n        external\\n        pure\\n        override\\n        returns (SpentItem[] memory, ReceivedItem[] memory)\\n    {\\n        revert RevertWithData(context);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/AbridgedTokenInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface ERC20Interface {\\n    function transferFrom(address, address, uint256) external returns (bool);\\n\\n    function approve(address, uint256) external returns (bool);\\n}\\n\\ninterface ERC721Interface {\\n    function transferFrom(address, address, uint256) external;\\n\\n    function setApprovalForAll(address, bool) external;\\n\\n    function ownerOf(uint256) external view returns (address);\\n}\\n\\ninterface ERC1155Interface {\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n\\n    function setApprovalForAll(address, bool) external;\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestContractOfferer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    ERC20Interface,\\n    ERC721Interface,\\n    ERC1155Interface\\n} from \\\"../interfaces/AbridgedTokenInterfaces.sol\\\";\\n\\nimport {\\n    ContractOffererInterface\\n} from \\\"../interfaces/ContractOffererInterface.sol\\\";\\n\\nimport { ItemType } from \\\"../lib/ConsiderationEnums.sol\\\";\\n\\nimport { SpentItem, ReceivedItem } from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title TestContractOfferer\\n * @author 0age\\n * @notice TestContractOfferer is a maximally simple contract offerer. It offers\\n *         a single item and expects to receive back another single item, and\\n *         ignores all parameters supplied to it when previewing or generating\\n *         an order. The offered item is placed into this contract as part of\\n *         deployment and the corresponding token approvals are set for Seaport.\\n */\\ncontract TestContractOfferer is ContractOffererInterface {\\n    error OrderUnavailable();\\n\\n    address private immutable _SEAPORT;\\n\\n    SpentItem private _available;\\n    SpentItem private _required;\\n\\n    bool public ready;\\n    bool public fulfilled;\\n\\n    uint256 public extraAvailable;\\n    uint256 public extraRequired;\\n\\n    constructor(address seaport) {\\n        // Set immutable values and storage variables.\\n        _SEAPORT = seaport;\\n        fulfilled = false;\\n        ready = false;\\n        extraAvailable = 0;\\n        extraRequired = 0;\\n    }\\n\\n    receive() external payable {}\\n\\n    /// In case of criteria based orders and non-wildcard items, the member\\n    /// `available.identifier` would correspond to the `identifierOrCriteria`\\n    /// i.e., the merkle-root.\\n    /// @param identifier corresponds to the actual token-id that gets transferred.\\n    function activateWithCriteria(\\n        SpentItem memory available,\\n        SpentItem memory required,\\n        uint256 identifier\\n    ) public {\\n        if (ready || fulfilled) {\\n            revert OrderUnavailable();\\n        }\\n\\n        if (available.itemType == ItemType.ERC721_WITH_CRITERIA) {\\n            ERC721Interface token = ERC721Interface(available.token);\\n\\n            token.transferFrom(msg.sender, address(this), identifier);\\n\\n            token.setApprovalForAll(_SEAPORT, true);\\n        } else if (available.itemType == ItemType.ERC1155_WITH_CRITERIA) {\\n            ERC1155Interface token = ERC1155Interface(available.token);\\n\\n            token.safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                identifier,\\n                available.amount,\\n                \\\"\\\"\\n            );\\n\\n            token.setApprovalForAll(_SEAPORT, true);\\n        }\\n\\n        // Set storage variables.\\n        _available = available;\\n        _required = required;\\n        ready = true;\\n    }\\n\\n    function activate(\\n        SpentItem memory available,\\n        SpentItem memory required\\n    ) public payable {\\n        if (ready || fulfilled) {\\n            revert OrderUnavailable();\\n        }\\n\\n        // Retrieve the offered item and set associated approvals.\\n        if (available.itemType == ItemType.NATIVE) {\\n            available.amount = address(this).balance;\\n        } else if (available.itemType == ItemType.ERC20) {\\n            ERC20Interface token = ERC20Interface(available.token);\\n\\n            token.transferFrom(msg.sender, address(this), available.amount);\\n\\n            token.approve(_SEAPORT, available.amount);\\n        } else if (available.itemType == ItemType.ERC721) {\\n            ERC721Interface token = ERC721Interface(available.token);\\n\\n            token.transferFrom(msg.sender, address(this), available.identifier);\\n\\n            token.setApprovalForAll(_SEAPORT, true);\\n        } else if (available.itemType == ItemType.ERC1155) {\\n            ERC1155Interface token = ERC1155Interface(available.token);\\n\\n            token.safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                available.identifier,\\n                available.amount,\\n                \\\"\\\"\\n            );\\n\\n            token.setApprovalForAll(_SEAPORT, true);\\n        }\\n\\n        // Set storage variables.\\n        _available = available;\\n        _required = required;\\n        ready = true;\\n    }\\n\\n    function extendAvailable() public {\\n        if (!ready || fulfilled) {\\n            revert OrderUnavailable();\\n        }\\n\\n        extraAvailable++;\\n\\n        _available.amount /= 2;\\n    }\\n\\n    function extendRequired() public {\\n        if (!ready || fulfilled) {\\n            revert OrderUnavailable();\\n        }\\n\\n        extraRequired++;\\n    }\\n\\n    function generateOrder(\\n        address,\\n        SpentItem[] calldata,\\n        SpentItem[] calldata,\\n        bytes calldata context\\n    )\\n        external\\n        virtual\\n        override\\n        returns (SpentItem[] memory offer, ReceivedItem[] memory consideration)\\n    {\\n        // Ensure the caller is Seaport & the order has not yet been fulfilled.\\n        if (\\n            !ready || fulfilled || msg.sender != _SEAPORT || context.length != 0\\n        ) {\\n            revert OrderUnavailable();\\n        }\\n\\n        // Set the offer and consideration that were supplied during deployment.\\n        offer = new SpentItem[](1 + extraAvailable);\\n        consideration = new ReceivedItem[](1 + extraRequired);\\n\\n        for (uint256 i = 0; i < 1 + extraAvailable; ++i) {\\n            offer[i] = _available;\\n        }\\n\\n        for (uint256 i = 0; i < 1 + extraRequired; ++i) {\\n            consideration[i] = ReceivedItem({\\n                itemType: _required.itemType,\\n                token: _required.token,\\n                identifier: _required.identifier,\\n                amount: _required.amount,\\n                recipient: payable(address(this))\\n            });\\n        }\\n\\n        // Update storage to reflect that the order has been fulfilled.\\n        fulfilled = true;\\n    }\\n\\n    function previewOrder(\\n        address caller,\\n        address,\\n        SpentItem[] calldata,\\n        SpentItem[] calldata,\\n        bytes calldata context\\n    )\\n        external\\n        view\\n        override\\n        returns (SpentItem[] memory offer, ReceivedItem[] memory consideration)\\n    {\\n        // Ensure the caller is Seaport & the order has not yet been fulfilled.\\n        if (!ready || fulfilled || caller != _SEAPORT || context.length != 0) {\\n            revert OrderUnavailable();\\n        }\\n\\n        // Set the offer and consideration that were supplied during deployment.\\n        offer = new SpentItem[](1 + extraAvailable);\\n        consideration = new ReceivedItem[](1 + extraRequired);\\n\\n        for (uint256 i = 0; i < 1 + extraAvailable; ++i) {\\n            offer[i] = _available;\\n        }\\n\\n        for (uint256 i = 0; i < 1 + extraRequired; ++i) {\\n            consideration[i] = ReceivedItem({\\n                itemType: _required.itemType,\\n                token: _required.token,\\n                identifier: _required.identifier,\\n                amount: _required.amount,\\n                recipient: payable(address(this))\\n            });\\n        }\\n    }\\n\\n    function getInventory()\\n        external\\n        view\\n        returns (SpentItem[] memory offerable, SpentItem[] memory receivable)\\n    {\\n        // Set offerable and receivable supplied at deployment if unfulfilled.\\n        if (!ready || fulfilled) {\\n            offerable = new SpentItem[](0);\\n\\n            receivable = new SpentItem[](0);\\n        } else {\\n            offerable = new SpentItem[](1 + extraAvailable);\\n            for (uint256 i = 0; i < 1 + extraAvailable; ++i) {\\n                offerable[i] = _available;\\n            }\\n\\n            receivable = new SpentItem[](1 + extraRequired);\\n            for (uint256 i = 0; i < 1 + extraRequired; ++i) {\\n                receivable[i] = _required;\\n            }\\n        }\\n    }\\n\\n    function ratifyOrder(\\n        SpentItem[] calldata /* offer */,\\n        ReceivedItem[] calldata /* consideration */,\\n        bytes calldata /* context */,\\n        bytes32[] calldata /* orderHashes */,\\n        uint256 /* contractNonce */\\n    )\\n        external\\n        pure\\n        virtual\\n        override\\n        returns (bytes4 /* ratifyOrderMagicValue */)\\n    {\\n        return ContractOffererInterface.ratifyOrder.selector;\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external pure returns (bytes4) {\\n        return bytes4(0xf23a6e61);\\n    }\\n\\n    function getMetadata()\\n        external\\n        pure\\n        override\\n        returns (\\n            uint256 schemaID, // maps to a Seaport standard's ID\\n            string memory name,\\n            bytes memory metadata // decoded based on the schemaID\\n        )\\n    {\\n        return (1337, \\\"TestContractOfferer\\\", \\\"\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestInvalidContractOffererRatifyOrder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { SpentItem, ReceivedItem } from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\nimport { TestContractOfferer } from \\\"./TestContractOfferer.sol\\\";\\n\\ncontract TestInvalidContractOffererRatifyOrder is TestContractOfferer {\\n    constructor(address seaport) TestContractOfferer(seaport) {}\\n\\n    function ratifyOrder(\\n        SpentItem[] calldata,\\n        ReceivedItem[] calldata,\\n        bytes calldata,\\n        bytes32[] calldata,\\n        uint256\\n    ) external pure override returns (bytes4) {\\n        return bytes4(keccak256(\\\"throw\\\"));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/zones/interfaces/PausableZoneInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { SeaportInterface } from \\\"../../interfaces/SeaportInterface.sol\\\";\\n\\nimport {\\n    AdvancedOrder,\\n    CriteriaResolver,\\n    Order,\\n    OrderComponents,\\n    Fulfillment,\\n    Execution\\n} from \\\"../../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title  PausableZone\\n * @author cupOJoseph, BCLeFevre, ryanio\\n * @notice PausableZone is a simple zone implementation that approves every\\n *         order. It can be self-destructed by its controller to pause\\n *         restricted orders that have it set as their zone.\\n */\\ninterface PausableZoneInterface {\\n    /**\\n     * @notice Cancel an arbitrary number of orders that have agreed to use the\\n     *         contract as their zone.\\n     *\\n     * @param seaport  The Seaport address.\\n     * @param orders   The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders have\\n     *                   been successfully cancelled.\\n     */\\n    function cancelOrders(\\n        SeaportInterface seaport,\\n        OrderComponents[] calldata orders\\n    ) external returns (bool cancelled);\\n\\n    /**\\n     * @notice Execute an arbitrary number of matched orders, each with\\n     *         an arbitrary number of items for offer and consideration\\n     *         along with a set of fulfillments allocating offer components\\n     *         to consideration components.\\n     *\\n     * @param seaport      The Seaport address.\\n     * @param orders       The orders to match.\\n     * @param fulfillments An array of elements allocating offer components\\n     *                     to consideration components.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function executeMatchOrders(\\n        SeaportInterface seaport,\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Execute an arbitrary number of matched advanced orders,\\n     *         each with an arbitrary number of items for offer and\\n     *         consideration along with a set of fulfillments allocating\\n     *         offer components to consideration components.\\n     *\\n     * @param seaport           The Seaport address.\\n     * @param orders            The orders to match.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function executeMatchAdvancedOrders(\\n        SeaportInterface seaport,\\n        AdvancedOrder[] calldata orders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Pause this contract, safely stopping orders from using\\n     *         the contract as a zone. Restricted orders with this address as a\\n     *         zone will not be fulfillable unless the zone is redeployed to the\\n     *         same address.\\n     */\\n    function pause(address payee) external;\\n\\n    /**\\n     * @notice Assign the given address with the ability to operate the zone.\\n     *\\n     * @param operatorToAssign The address to assign as the operator.\\n     */\\n    function assignOperator(address operatorToAssign) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/SeaportInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    BasicOrderParameters,\\n    OrderComponents,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Execution,\\n    Order,\\n    AdvancedOrder,\\n    CriteriaResolver\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title SeaportInterface\\n * @author 0age\\n * @custom:version 1.2\\n * @notice Seaport is a generalized ETH/ERC20/ERC721/ERC1155 marketplace. It\\n *         minimizes external calls to the greatest extent possible and provides\\n *         lightweight methods for common routes as well as more flexible\\n *         methods for composing advanced orders.\\n *\\n * @dev SeaportInterface contains all external function interfaces for Seaport.\\n */\\ninterface SeaportInterface {\\n    /**\\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\\n     *         the native token for the given chain) as consideration for the\\n     *         order. An arbitrary number of \\\"additional recipients\\\" may also be\\n     *         supplied which will each receive native tokens from the fulfiller\\n     *         as consideration.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer must first approve this contract (or\\n     *                   their preferred conduit if indicated by the order) for\\n     *                   their offered ERC721 token to be transferred.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillBasicOrder(\\n        BasicOrderParameters calldata parameters\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\n     *         consideration. Note that this function does not support\\n     *         criteria-based orders or partial filling of orders (though\\n     *         filling the remainder of a partially-filled order is supported).\\n     *\\n     * @param order               The order to fulfill. Note that both the\\n     *                            offerer and the fulfiller must first approve\\n     *                            this contract (or the corresponding conduit if\\n     *                            indicated) to transfer any relevant tokens on\\n     *                            their behalf and that contracts must implement\\n     *                            `onERC1155Received` to receive ERC1155 tokens\\n     *                            as consideration.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Seaport.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillOrder(\\n        Order calldata order,\\n        bytes32 fulfillerConduitKey\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\n     *         items for offer and consideration alongside criteria resolvers\\n     *         containing specific token identifiers and associated proofs.\\n     *\\n     * @param advancedOrder       The order to fulfill along with the fraction\\n     *                            of the order to attempt to fill. Note that\\n     *                            both the offerer and the fulfiller must first\\n     *                            approve this contract (or their preferred\\n     *                            conduit if indicated by the order) to transfer\\n     *                            any relevant tokens on their behalf and that\\n     *                            contracts must implement `onERC1155Received`\\n     *                            to receive ERC1155 tokens as consideration.\\n     *                            Also note that all offer and consideration\\n     *                            components must have no remainder after\\n     *                            multiplication of the respective amount with\\n     *                            the supplied fraction for the partial fill to\\n     *                            be considered valid.\\n     * @param criteriaResolvers   An array where each element contains a\\n     *                            reference to a specific offer or\\n     *                            consideration, a token identifier, and a proof\\n     *                            that the supplied token identifier is\\n     *                            contained in the merkle root held by the item\\n     *                            in question's criteria element. Note that an\\n     *                            empty criteria indicates that any\\n     *                            (transferable) token identifier on the token\\n     *                            in question is valid and that no associated\\n     *                            proof needs to be supplied.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Seaport.\\n     * @param recipient           The intended recipient for all received items,\\n     *                            with `address(0)` indicating that the caller\\n     *                            should receive the items.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillAdvancedOrder(\\n        AdvancedOrder calldata advancedOrder,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        bytes32 fulfillerConduitKey,\\n        address recipient\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\\n     *         of items for offer and consideration. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *         Note that this function does not support criteria-based orders or\\n     *         partial filling of orders (though filling the remainder of a\\n     *         partially-filled order is supported).\\n     *\\n     * @param orders                    The orders to fulfill. Note that both\\n     *                                  the offerer and the fulfiller must first\\n     *                                  approve this contract (or the\\n     *                                  corresponding conduit if indicated) to\\n     *                                  transfer any relevant tokens on their\\n     *                                  behalf and that contracts must implement\\n     *                                  `onERC1155Received` to receive ERC1155\\n     *                                  tokens as consideration.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders. Note that unspent offer item amounts or\\n     *                         native tokens will not be reflected as part of\\n     *                         this array.\\n     */\\n    function fulfillAvailableOrders(\\n        Order[] calldata orders,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\n     *         arbitrary number of items for offer and consideration per order\\n     *         alongside criteria resolvers containing specific token\\n     *         identifiers and associated proofs. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or their preferred conduit if\\n     *                                  indicated by the order) to transfer any\\n     *                                  relevant tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` to enable receipt of\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param criteriaResolvers         An array where each element contains a\\n     *                                  reference to a specific offer or\\n     *                                  consideration, a token identifier, and a\\n     *                                  proof that the supplied token identifier\\n     *                                  is contained in the merkle root held by\\n     *                                  the item in question's criteria element.\\n     *                                  Note that an empty criteria indicates\\n     *                                  that any (transferable) token\\n     *                                  identifier on the token in question is\\n     *                                  valid and that no associated proof needs\\n     *                                  to be supplied.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param recipient                 The intended recipient for all received\\n     *                                  items, with `address(0)` indicating that\\n     *                                  the caller should receive the items.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders. Note that unspent offer item amounts or\\n     *                         native tokens will not be reflected as part of\\n     *                         this array.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] calldata advancedOrders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        address recipient,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\n     *         number of items for offer and consideration along with a set of\\n     *         fulfillments allocating offer components to consideration\\n     *         components. Note that this function does not support\\n     *         criteria-based or partial filling of orders (though filling the\\n     *         remainder of a partially-filled order is supported). Any unspent\\n     *         offer item amounts or native tokens will be transferred to the\\n     *         caller.\\n     *\\n     * @param orders       The orders to match. Note that both the offerer and\\n     *                     fulfiller on each order must first approve this\\n     *                     contract (or their conduit if indicated by the order)\\n     *                     to transfer any relevant tokens on their behalf and\\n     *                     each consideration recipient must implement\\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\\n     * @param fulfillments An array of elements allocating offer components to\\n     *                     consideration components. Note that each\\n     *                     consideration component must be fully met for the\\n     *                     match operation to be valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders. Note that unspent offer item amounts or\\n     *                    native tokens will not be reflected as part of this\\n     *                    array.\\n     */\\n    function matchOrders(\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of full or partial orders, each with an\\n     *         arbitrary number of items for offer and consideration, supplying\\n     *         criteria resolvers containing specific token identifiers and\\n     *         associated proofs as well as fulfillments allocating offer\\n     *         components to consideration components. Any unspent offer item\\n     *         amounts will be transferred to the designated recipient (with the\\n     *         null address signifying to use the caller) and any unspent native\\n     *         tokens will be returned to the caller.\\n     *\\n     * @param orders            The advanced orders to match. Note that both the\\n     *                          offerer and fulfiller on each order must first\\n     *                          approve this contract (or a preferred conduit if\\n     *                          indicated by the order) to transfer any relevant\\n     *                          tokens on their behalf and each consideration\\n     *                          recipient must implement `onERC1155Received` in\\n     *                          order to receive ERC1155 tokens. Also note that\\n     *                          the offer and consideration components for each\\n     *                          order must have no remainder after multiplying\\n     *                          the respective amount with the supplied fraction\\n     *                          in order for the group of partial fills to be\\n     *                          considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          an empty root indicates that any (transferable)\\n     *                          token identifier is valid and that no associated\\n     *                          proof needs to be supplied.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     * @param recipient         The intended recipient for all unspent offer\\n     *                          item amounts, or the caller if the null address\\n     *                          is supplied.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders. Note that unspent offer item amounts or native\\n     *                    tokens will not be reflected as part of this array.\\n     */\\n    function matchAdvancedOrders(\\n        AdvancedOrder[] calldata orders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments,\\n        address recipient\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\n     *         or the zone of a given order may cancel it. Callers should ensure\\n     *         that the intended order was cancelled by calling `getOrderStatus`\\n     *         and confirming that `isCancelled` returns `true`.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders have\\n     *                   been successfully cancelled.\\n     */\\n    function cancel(\\n        OrderComponents[] calldata orders\\n    ) external returns (bool cancelled);\\n\\n    /**\\n     * @notice Validate an arbitrary number of orders, thereby registering their\\n     *         signatures as valid and allowing the fulfiller to skip signature\\n     *         verification on fulfillment. Note that validated orders may still\\n     *         be unfulfillable due to invalid item amounts or other factors;\\n     *         callers should determine whether validated orders are fulfillable\\n     *         by simulating the fulfillment call prior to execution. Also note\\n     *         that anyone can validate a signed order, but only the offerer can\\n     *         validate an order without supplying a signature.\\n     *\\n     * @param orders The orders to validate.\\n     *\\n     * @return validated A boolean indicating whether the supplied orders have\\n     *                   been successfully validated.\\n     */\\n    function validate(\\n        Order[] calldata orders\\n    ) external returns (bool validated);\\n\\n    /**\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\n     *         by incrementing a counter. Note that only the offerer may\\n     *         increment the counter.\\n     *\\n     * @return newCounter The new counter.\\n     */\\n    function incrementCounter() external returns (uint256 newCounter);\\n\\n    /**\\n     * @notice Retrieve the order hash for a given order.\\n     *\\n     * @param order The components of the order.\\n     *\\n     * @return orderHash The order hash.\\n     */\\n    function getOrderHash(\\n        OrderComponents calldata order\\n    ) external view returns (bytes32 orderHash);\\n\\n    /**\\n     * @notice Retrieve the status of a given order by hash, including whether\\n     *         the order has been cancelled or validated and the fraction of the\\n     *         order that has been filled.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function getOrderStatus(\\n        bytes32 orderHash\\n    )\\n        external\\n        view\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        );\\n\\n    /**\\n     * @notice Retrieve the current counter for a given offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return counter The current counter.\\n     */\\n    function getCounter(\\n        address offerer\\n    ) external view returns (uint256 counter);\\n\\n    /**\\n     * @notice Retrieve configuration information for this contract.\\n     *\\n     * @return version           The contract version.\\n     * @return domainSeparator   The domain separator for this contract.\\n     * @return conduitController The conduit Controller set for this contract.\\n     */\\n    function information()\\n        external\\n        view\\n        returns (\\n            string memory version,\\n            bytes32 domainSeparator,\\n            address conduitController\\n        );\\n\\n    function getContractOffererNonce(\\n        address contractOfferer\\n    ) external view returns (uint256 nonce);\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return contractName The name of this contract.\\n     */\\n    function name() external view returns (string memory contractName);\\n}\\n\"\r\n    },\r\n    \"contracts/zones/interfaces/PausableZoneControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    Order,\\n    Fulfillment,\\n    OrderComponents,\\n    AdvancedOrder,\\n    CriteriaResolver,\\n    Execution\\n} from \\\"../../lib/ConsiderationStructs.sol\\\";\\n\\nimport { SeaportInterface } from \\\"../../interfaces/SeaportInterface.sol\\\";\\n\\n/**\\n * @title  PausableZoneController\\n * @author cupOJoseph, BCLeFevre, stuckinaboot\\n * @notice PausableZoneController enables deploying, pausing and executing\\n *         orders on PausableZones. This deployer is designed to be owned\\n *         by a gnosis safe, DAO, or trusted party.\\n */\\ninterface PausableZoneControllerInterface {\\n    /**\\n     * @notice Deploy a PausableZone to a precomputed address.\\n     *\\n     * @param salt The salt to be used to derive the zone address\\n     *\\n     * @return derivedAddress The derived address for the zone.\\n     */\\n    function createZone(bytes32 salt) external returns (address derivedAddress);\\n\\n    /**\\n     * @notice Pause orders on a given zone.\\n     *\\n     * @param zone The address of the zone to be paused.\\n     *\\n     * @return success A boolean indicating the zone has been paused.\\n     */\\n    function pause(address zone) external returns (bool success);\\n\\n    /**\\n     * @notice Cancel Seaport offers on a given zone.\\n     *\\n     * @param pausableZoneAddress The zone that manages the orders to be\\n     *                            cancelled.\\n     * @param seaportAddress      The Seaport address.\\n     * @param orders              The orders to cancel.\\n     */\\n    function cancelOrders(\\n        address pausableZoneAddress,\\n        SeaportInterface seaportAddress,\\n        OrderComponents[] calldata orders\\n    ) external;\\n\\n    /**\\n     * @notice Execute an arbitrary number of matched orders on a given zone.\\n     *\\n     * @param pausableZoneAddress The zone that manages the orders to be\\n     *                            cancelled.\\n     * @param seaportAddress      The Seaport address.\\n     * @param orders              The orders to match.\\n     * @param fulfillments        An array of elements allocating offer\\n     *                            components to consideration components.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function executeMatchOrders(\\n        address pausableZoneAddress,\\n        SeaportInterface seaportAddress,\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Execute an arbitrary number of matched advanced orders on a\\n     *         given zone.\\n     *\\n     * @param pausableZoneAddress The zone that manages the orders to be\\n     *                            cancelled.\\n     * @param seaportAddress      The Seaport address.\\n     * @param orders              The orders to match.\\n     * @param criteriaResolvers   An array where each element contains a\\n     *                            reference to a specific order as well as\\n     *                            that order's offer or consideration,\\n     *                            a token identifier, and a proof that\\n     *                            the supplied token identifier is\\n     *                            contained in the order's merkle root.\\n     * @param fulfillments        An array of elements allocating offer\\n     *                            components to consideration components.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function executeMatchAdvancedOrders(\\n        address pausableZoneAddress,\\n        SeaportInterface seaportAddress,\\n        AdvancedOrder[] calldata orders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Initiate Zone ownership transfer by assigning a new potential\\n     *         owner this contract. Once set, the new potential owner\\n     *         may call `acceptOwnership` to claim ownership.\\n     *         Only the owner in question may call this function.\\n     *\\n     * @param newPotentialOwner The address for which to initiate ownership\\n     *                          transfer to.\\n     */\\n    function transferOwnership(address newPotentialOwner) external;\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any.\\n     *         Only the owner of this contract may call this function.\\n     */\\n    function cancelOwnershipTransfer() external;\\n\\n    /**\\n     * @notice Accept ownership of this contract. Only the account that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     */\\n    function acceptOwnership() external;\\n\\n    /**\\n     * @notice Assign the given address with the ability to pause the zone.\\n     *\\n     * @param pauserToAssign The address to assign the pauser role.\\n     */\\n    function assignPauser(address pauserToAssign) external;\\n\\n    /**\\n     * @notice Assign the given address with the ability to operate the\\n     *         given zone.\\n     *\\n     * @param pausableZoneAddress The zone address to assign operator role.\\n     * @param operatorToAssign    The address to assign as operator.\\n     */\\n    function assignOperator(\\n        address pausableZoneAddress,\\n        address operatorToAssign\\n    ) external;\\n\\n    /**\\n     * @notice An external view function that returns the owner.\\n     *\\n     * @return The address of the owner.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice An external view function that return the potential owner.\\n     *\\n     * @return The address of the potential owner.\\n     */\\n    function potentialOwner() external view returns (address);\\n\\n    /**\\n     * @notice An external view function that returns the pauser.\\n     *\\n     * @return The address of the pauser.\\n     */\\n    function pauser() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/zones/PausableZoneController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { PausableZone } from \\\"./PausableZone.sol\\\";\\n\\nimport {\\n    PausableZoneControllerInterface\\n} from \\\"./interfaces/PausableZoneControllerInterface.sol\\\";\\n\\nimport {\\n    PausableZoneEventsAndErrors\\n} from \\\"./interfaces/PausableZoneEventsAndErrors.sol\\\";\\n\\nimport {\\n    Order,\\n    Fulfillment,\\n    OrderComponents,\\n    AdvancedOrder,\\n    CriteriaResolver,\\n    Execution\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\nimport { SeaportInterface } from \\\"../interfaces/SeaportInterface.sol\\\";\\n\\n/**\\n * @title  PausableZoneController\\n * @author cupOJoseph, BCLeFevre, stuckinaboot, stephankmin\\n * @notice PausableZoneController enables deploying, pausing and executing\\n *         orders on PausableZones. This deployer is designed to be owned\\n *         by a gnosis safe, DAO, or trusted party.\\n */\\ncontract PausableZoneController is\\n    PausableZoneControllerInterface,\\n    PausableZoneEventsAndErrors\\n{\\n    // Set the owner that can deploy, pause and execute orders on PausableZones.\\n    address internal _owner;\\n\\n    // Set the address of the new potential owner of the zone.\\n    address private _potentialOwner;\\n\\n    // Set the address with the ability to pause the zone.\\n    address internal _pauser;\\n\\n    // Set the immutable zone creation code hash.\\n    bytes32 public immutable zoneCreationCode;\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner or pauser.\\n     */\\n    modifier isPauser() {\\n        if (msg.sender != _pauser && msg.sender != _owner) {\\n            revert InvalidPauser();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @notice Set the owner of the controller and store\\n     *         the zone creation code.\\n     *\\n     * @param ownerAddress The deployer to be set as the owner.\\n     */\\n    constructor(address ownerAddress) {\\n        // Set the owner address as the owner.\\n        _owner = ownerAddress;\\n\\n        // Hash and store the zone creation code.\\n        zoneCreationCode = keccak256(type(PausableZone).creationCode);\\n    }\\n\\n    /**\\n     * @notice Deploy a PausableZone to a precomputed address.\\n     *\\n     * @param salt The salt to be used to derive the zone address\\n     *\\n     * @return derivedAddress The derived address for the zone.\\n     */\\n    function createZone(\\n        bytes32 salt\\n    ) external override returns (address derivedAddress) {\\n        // Ensure the caller is the owner.\\n        if (msg.sender != _owner) {\\n            revert CallerIsNotOwner();\\n        }\\n\\n        // Derive the PausableZone address.\\n        // This expression demonstrates address computation but is not required.\\n        derivedAddress = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(this),\\n                            salt,\\n                            zoneCreationCode\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Revert if a zone is currently deployed to the derived address.\\n        if (derivedAddress.code.length != 0) {\\n            revert ZoneAlreadyExists(derivedAddress);\\n        }\\n\\n        // Deploy the zone using the supplied salt.\\n        new PausableZone{ salt: salt }();\\n\\n        // Emit an event signifying that the zone was created.\\n        emit ZoneCreated(derivedAddress, salt);\\n    }\\n\\n    /**\\n     * @notice Pause orders on a given zone.\\n     *\\n     * @param zone The address of the zone to be paused.\\n     *\\n     * @return success A boolean indicating the zone has been paused.\\n     */\\n    function pause(\\n        address zone\\n    ) external override isPauser returns (bool success) {\\n        // Call pause on the given zone.\\n        PausableZone(zone).pause(msg.sender);\\n\\n        // Return a boolean indicating the pause was successful.\\n        success = true;\\n    }\\n\\n    /**\\n     * @notice Cancel Seaport orders on a given zone.\\n     *\\n     * @param pausableZoneAddress The zone that manages the\\n     * orders to be cancelled.\\n     * @param seaportAddress      The Seaport address.\\n     * @param orders              The orders to cancel.\\n     */\\n    function cancelOrders(\\n        address pausableZoneAddress,\\n        SeaportInterface seaportAddress,\\n        OrderComponents[] calldata orders\\n    ) external override {\\n        // Ensure the caller is the owner.\\n        if (msg.sender != _owner) {\\n            revert CallerIsNotOwner();\\n        }\\n\\n        // Create a zone object from the zone address.\\n        PausableZone zone = PausableZone(pausableZoneAddress);\\n\\n        // Call cancelOrders on the given zone.\\n        zone.cancelOrders(seaportAddress, orders);\\n    }\\n\\n    /**\\n     * @notice Execute an arbitrary number of matched orders on a given zone.\\n     *\\n     * @param pausableZoneAddress The zone that manages the orders\\n     * to be cancelled.\\n     * @param seaportAddress      The Seaport address.\\n     * @param orders              The orders to match.\\n     * @param fulfillments        An array of elements allocating offer\\n     *                            components to consideration components.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function executeMatchOrders(\\n        address pausableZoneAddress,\\n        SeaportInterface seaportAddress,\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable override returns (Execution[] memory executions) {\\n        // Ensure the caller is the owner.\\n        if (msg.sender != _owner) {\\n            revert CallerIsNotOwner();\\n        }\\n\\n        // Create a zone object from the zone address.\\n        PausableZone zone = PausableZone(pausableZoneAddress);\\n\\n        // Call executeMatchOrders on the given zone and return the sequence\\n        // of transfers performed as part of matching the given orders.\\n        executions = zone.executeMatchOrders{ value: msg.value }(\\n            seaportAddress,\\n            orders,\\n            fulfillments\\n        );\\n    }\\n\\n    /**\\n     * @notice Execute an arbitrary number of matched advanced orders on a given\\n     *         zone.\\n     *\\n     * @param pausableZoneAddress The zone that manages the orders to be\\n     *                            cancelled.\\n     * @param seaportAddress      The Seaport address.\\n     * @param orders              The orders to match.\\n     * @param criteriaResolvers   An array where each element contains a\\n     *                            reference to a specific order as well as that\\n     *                            order's offer or consideration, a token\\n     *                            identifier, and a proof that the supplied\\n     *                            token identifier is contained in the\\n     *                            order's merkle root.\\n     * @param fulfillments        An array of elements allocating offer\\n     *                            components to consideration components.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function executeMatchAdvancedOrders(\\n        address pausableZoneAddress,\\n        SeaportInterface seaportAddress,\\n        AdvancedOrder[] calldata orders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable override returns (Execution[] memory executions) {\\n        // Ensure the caller is the owner.\\n        if (msg.sender != _owner) {\\n            revert CallerIsNotOwner();\\n        }\\n\\n        // Create a zone object from the zone address.\\n        PausableZone zone = PausableZone(pausableZoneAddress);\\n\\n        // Call executeMatchOrders on the given zone and return the sequence\\n        // of transfers performed as part of matching the given orders.\\n        executions = zone.executeMatchAdvancedOrders{ value: msg.value }(\\n            seaportAddress,\\n            orders,\\n            criteriaResolvers,\\n            fulfillments\\n        );\\n    }\\n\\n    /**\\n     * @notice Initiate Zone ownership transfer by assigning a new potential\\n     *         owner this contract. Once set, the new potential owner\\n     *         may call `acceptOwnership` to claim ownership.\\n     *         Only the owner in question may call this function.\\n     *\\n     * @param newPotentialOwner The address for which to initiate ownership\\n     *                          transfer to.\\n     */\\n    function transferOwnership(address newPotentialOwner) external override {\\n        // Ensure the caller is the owner.\\n        if (msg.sender != _owner) {\\n            revert CallerIsNotOwner();\\n        }\\n        // Ensure the new potential owner is not an invalid address.\\n        if (newPotentialOwner == address(0)) {\\n            revert OwnerCanNotBeSetAsZero();\\n        }\\n\\n        // Emit an event indicating that the potential owner has been updated.\\n        emit PotentialOwnerUpdated(newPotentialOwner);\\n\\n        // Set the new potential owner as the potential owner.\\n        _potentialOwner = newPotentialOwner;\\n    }\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any.\\n     *         Only the owner of this contract may call this function.\\n     */\\n    function cancelOwnershipTransfer() external override {\\n        // Ensure the caller is the current owner.\\n        if (msg.sender != _owner) {\\n            revert CallerIsNotOwner();\\n        }\\n\\n        // Emit an event indicating that the potential owner has been cleared.\\n        emit PotentialOwnerUpdated(address(0));\\n\\n        // Clear the current new potential owner.\\n        delete _potentialOwner;\\n    }\\n\\n    /**\\n     * @notice Accept ownership of this contract. Only the account that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     */\\n    function acceptOwnership() external override {\\n        // Ensure the caller is the potential owner.\\n        if (msg.sender != _potentialOwner) {\\n            revert CallerIsNotPotentialOwner();\\n        }\\n\\n        // Emit an event indicating that the potential owner has been cleared.\\n        emit PotentialOwnerUpdated(address(0));\\n\\n        // Clear the current new potential owner\\n        delete _potentialOwner;\\n\\n        // Emit an event indicating ownership has been transferred.\\n        emit OwnershipTransferred(_owner, msg.sender);\\n\\n        // Set the caller as the owner of this contract.\\n        _owner = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Assign the given address with the ability to pause the zone.\\n     *\\n     * @param pauserToAssign The address to assign the pauser role.\\n     */\\n    function assignPauser(address pauserToAssign) external override {\\n        // Ensure the caller is the owner.\\n        if (msg.sender != _owner) {\\n            revert CallerIsNotOwner();\\n        }\\n        // Ensure the pauser to assign is not an invalid address.\\n        if (pauserToAssign == address(0)) {\\n            revert PauserCanNotBeSetAsZero();\\n        }\\n\\n        // Set the given account as the pauser.\\n        _pauser = pauserToAssign;\\n\\n        // Emit an event indicating the pauser has been assigned.\\n        emit PauserUpdated(pauserToAssign);\\n    }\\n\\n    /**\\n     * @notice Assign the given address with the ability to operate the\\n     *         given zone.\\n     *\\n     * @param pausableZoneAddress The zone address to assign operator role.\\n     * @param operatorToAssign    The address to assign as operator.\\n     */\\n    function assignOperator(\\n        address pausableZoneAddress,\\n        address operatorToAssign\\n    ) external override {\\n        // Ensure the caller is the owner.\\n        if (msg.sender != _owner) {\\n            revert CallerIsNotOwner();\\n        }\\n        // Create a zone object from the zone address.\\n        PausableZone zone = PausableZone(pausableZoneAddress);\\n\\n        // Call assignOperator on the zone by passing in the given\\n        // operator address.\\n        zone.assignOperator(operatorToAssign);\\n    }\\n\\n    /**\\n     * @notice An external view function that returns the owner.\\n     *\\n     * @return The address of the owner.\\n     */\\n    function owner() external view override returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @notice An external view function that return the potential owner.\\n     *\\n     * @return The address of the potential owner.\\n     */\\n    function potentialOwner() external view override returns (address) {\\n        return _potentialOwner;\\n    }\\n\\n    /**\\n     * @notice An external view function that returns the pauser.\\n     *\\n     * @return The address of the pauser.\\n     */\\n    function pauser() external view override returns (address) {\\n        return _pauser;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/zones/PausableZone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { ZoneInterface } from \\\"../interfaces/ZoneInterface.sol\\\";\\nimport { ZoneInteractionErrors } from \\\"../interfaces/ZoneInteractionErrors.sol\\\";\\n\\nimport {\\n    PausableZoneEventsAndErrors\\n} from \\\"./interfaces/PausableZoneEventsAndErrors.sol\\\";\\n\\nimport { SeaportInterface } from \\\"../interfaces/SeaportInterface.sol\\\";\\n\\nimport {\\n    AdvancedOrder,\\n    CriteriaResolver,\\n    Order,\\n    OrderComponents,\\n    Fulfillment,\\n    Execution,\\n    OfferItem,\\n    ConsiderationItem,\\n    ZoneParameters\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\nimport { PausableZoneInterface } from \\\"./interfaces/PausableZoneInterface.sol\\\";\\n\\n/**\\n * @title  PausableZone\\n * @author cupOJoseph, BCLeFevre, ryanio\\n * @notice PausableZone is a simple zone implementation that approves every\\n *         order. It can be self-destructed by its controller to pause\\n *         restricted orders that have it set as their zone. Note that this zone\\n *         cannot execute orders that return native tokens to the fulfiller.\\n */\\ncontract PausableZone is\\n    PausableZoneEventsAndErrors,\\n    ZoneInterface,\\n    PausableZoneInterface\\n{\\n    // Set an immutable controller that can pause the zone & update an operator.\\n    address internal immutable _controller;\\n\\n    // Set an operator that can instruct the zone to cancel or execute orders.\\n    address public operator;\\n\\n    /**\\n     * @dev Ensure that the caller is either the operator or controller.\\n     */\\n    modifier isOperator() {\\n        // Ensure that the caller is either the operator or the controller.\\n        if (msg.sender != operator && msg.sender != _controller) {\\n            revert InvalidOperator();\\n        }\\n\\n        // Continue with function execution.\\n        _;\\n    }\\n\\n    /**\\n     * @dev Ensure that the caller is the controller.\\n     */\\n    modifier isController() {\\n        // Ensure that the caller is the controller.\\n        if (msg.sender != _controller) {\\n            revert InvalidController();\\n        }\\n\\n        // Continue with function execution.\\n        _;\\n    }\\n\\n    /**\\n     * @notice Set the deployer as the controller of the zone.\\n     */\\n    constructor() {\\n        // Set the controller to the deployer.\\n        _controller = msg.sender;\\n\\n        // Emit an event signifying that the zone is unpaused.\\n        emit Unpaused();\\n    }\\n\\n    /**\\n     * @notice Cancel an arbitrary number of orders that have agreed to use the\\n     *         contract as their zone.\\n     *\\n     * @param seaport  The Seaport address.\\n     * @param orders   The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders have\\n     *                   been successfully cancelled.\\n     */\\n    function cancelOrders(\\n        SeaportInterface seaport,\\n        OrderComponents[] calldata orders\\n    ) external override isOperator returns (bool cancelled) {\\n        // Call cancel on Seaport and return its boolean value.\\n        cancelled = seaport.cancel(orders);\\n    }\\n\\n    /**\\n     * @notice Pause this contract, safely stopping orders from using\\n     *         the contract as a zone. Restricted orders with this address as a\\n     *         zone will not be fulfillable unless the zone is redeployed to the\\n     *         same address.\\n     */\\n    function pause(address payee) external override isController {\\n        // Emit an event signifying that the zone is paused.\\n        emit Paused();\\n\\n        // Destroy the zone, sending any ether to the transaction submitter.\\n        selfdestruct(payable(payee));\\n    }\\n\\n    /**\\n     * @notice Assign the given address with the ability to operate the zone.\\n     *\\n     * @param operatorToAssign The address to assign as the operator.\\n     */\\n    function assignOperator(\\n        address operatorToAssign\\n    ) external override isController {\\n        // Ensure the operator being assigned is not the null address.\\n        if (operatorToAssign == address(0)) {\\n            revert PauserCanNotBeSetAsZero();\\n        }\\n\\n        // Set the given address as the new operator.\\n        operator = operatorToAssign;\\n\\n        // Emit an event indicating the operator has been updated.\\n        emit OperatorUpdated(operatorToAssign);\\n    }\\n\\n    /**\\n     * @notice Execute an arbitrary number of matched orders, each with\\n     *         an arbitrary number of items for offer and consideration\\n     *         along with a set of fulfillments allocating offer components\\n     *         to consideration components. Note that this call will revert if\\n     *         excess native tokens are returned by Seaport.\\n     *\\n     * @param seaport      The Seaport address.\\n     * @param orders       The orders to match.\\n     * @param fulfillments An array of elements allocating offer components\\n     *                     to consideration components.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function executeMatchOrders(\\n        SeaportInterface seaport,\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    )\\n        external\\n        payable\\n        override\\n        isOperator\\n        returns (Execution[] memory executions)\\n    {\\n        // Call matchOrders on Seaport and return the sequence of transfers\\n        // performed as part of matching the given orders.\\n        executions = seaport.matchOrders{ value: msg.value }(\\n            orders,\\n            fulfillments\\n        );\\n    }\\n\\n    /**\\n     * @notice Execute an arbitrary number of matched advanced orders,\\n     *         each with an arbitrary number of items for offer and\\n     *         consideration along with a set of fulfillments allocating\\n     *         offer components to consideration components. Note that this call\\n     *         will revert if excess native tokens are returned by Seaport.\\n     *\\n     * @param seaport           The Seaport address.\\n     * @param orders            The orders to match.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders.\\n     */\\n    function executeMatchAdvancedOrders(\\n        SeaportInterface seaport,\\n        AdvancedOrder[] calldata orders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments\\n    )\\n        external\\n        payable\\n        override\\n        isOperator\\n        returns (Execution[] memory executions)\\n    {\\n        // Call matchAdvancedOrders on Seaport and return the sequence of\\n        // transfers performed as part of matching the given orders.\\n        executions = seaport.matchAdvancedOrders{ value: msg.value }(\\n            orders,\\n            criteriaResolvers,\\n            fulfillments,\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @notice Check if a given order including extraData is currently valid.\\n     *\\n     * @dev This function is called by Seaport whenever any extraData is\\n     *      provided by the caller.\\n     *\\n     * @custom:param zoneParameters A struct that provides context about the\\n     *                              order fulfillment and any supplied\\n     *                              extraData, as well as all order hashes\\n     *                              fulfilled in a call to a match or\\n     *                              fulfillAvailable method.\\n     *\\n     * @return validOrderMagicValue A magic value indicating if the order is\\n     *                              currently valid.\\n     */\\n    function validateOrder(\\n        ZoneParameters calldata\\n    )\\n        external\\n        pure\\n        override\\n        returns (\\n            /**\\n             * @custom:name zoneParameters\\n             */\\n            bytes4 validOrderMagicValue\\n        )\\n    {\\n        // Return the selector of isValidOrder as the magic value.\\n        validOrderMagicValue = ZoneInterface.validateOrder.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/zones/interfaces/PausableZoneEventsAndErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @notice PausableZoneEventsAndErrors contains errors and events\\n *         related to zone interaction.\\n */\\ninterface PausableZoneEventsAndErrors {\\n    /**\\n     * @dev Emit an event whenever a zone is successfully paused.\\n     */\\n    event Paused();\\n\\n    /**\\n     * @dev Emit an event whenever a zone is successfully unpaused (created).\\n     */\\n    event Unpaused();\\n\\n    /**\\n     * @dev Emit an event whenever a zone owner registers a new potential\\n     *      owner for that zone.\\n     *\\n     * @param newPotentialOwner The new potential owner of the zone.\\n     */\\n    event PotentialOwnerUpdated(address newPotentialOwner);\\n\\n    /**\\n     * @dev Emit an event whenever zone ownership is transferred.\\n     *\\n     * @param previousOwner The previous owner of the zone.\\n     * @param newOwner      The new owner of the zone.\\n     */\\n    event OwnershipTransferred(address previousOwner, address newOwner);\\n\\n    /**\\n     * @dev Emit an event whenever a new zone is created.\\n     *\\n     * @param zone The address of the zone.\\n     * @param salt The salt used to deploy the zone.\\n     */\\n    event ZoneCreated(address zone, bytes32 salt);\\n\\n    /**\\n     * @dev Emit an event whenever a zone owner assigns a new pauser\\n     *\\n     * @param newPauser The new pausear of the zone.\\n     */\\n    event PauserUpdated(address newPauser);\\n\\n    /**\\n     * @dev Emit an event whenever a zone owner assigns a new operator\\n     *\\n     * @param newOperator The new operator of the zone.\\n     */\\n    event OperatorUpdated(address newOperator);\\n\\n    /**\\n     * @dev Revert with an error when attempting to pause the zone\\n     *      while the caller is not the owner or pauser of the zone.\\n     */\\n    error InvalidPauser();\\n\\n    /**\\n     * @dev Revert with an error when attempting to call an operation\\n     *      while the caller is not the controller or operator of the zone.\\n     */\\n    error InvalidOperator();\\n\\n    /**\\n     * @dev Revert with an error when attempting to pause the zone or update the\\n     *      operator while the caller is not the controller of the zone.\\n     */\\n    error InvalidController();\\n    /**\\n     * @dev Revert with an error when attempting to deploy a zone that is\\n     *      currently deployed.\\n     */\\n    error ZoneAlreadyExists(address zone);\\n\\n    /**\\n     * @dev Revert with an error when the caller does not have the _owner role\\n     *\\n     */\\n    error CallerIsNotOwner();\\n\\n    /**\\n     * @dev Revert with an error when the caller does not have the operator role\\n     *\\n     */\\n    error CallerIsNotOperator();\\n\\n    /**\\n     * @dev Revert with an error when attempting to set the new potential owner\\n     *      as the 0 address.\\n     *\\n     */\\n    error OwnerCanNotBeSetAsZero();\\n\\n    /**\\n     * @dev Revert with an error when attempting to set the new potential pauser\\n     *      as the 0 address.\\n     *\\n     */\\n    error PauserCanNotBeSetAsZero();\\n\\n    /**\\n     * @dev Revert with an error when the caller does not have\\n     *      the potentialOwner role.\\n     */\\n    error CallerIsNotPotentialOwner();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ZoneInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { ZoneParameters } from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\ninterface ZoneInterface {\\n    function validateOrder(\\n        ZoneParameters calldata zoneParameters\\n    ) external returns (bytes4 validOrderMagicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestZone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { ZoneInterface } from \\\"../interfaces/ZoneInterface.sol\\\";\\n\\nimport {\\n    AdvancedOrder,\\n    CriteriaResolver,\\n    OfferItem,\\n    ConsiderationItem,\\n    ZoneParameters\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\ncontract TestZone is ZoneInterface {\\n    function validateOrder(\\n        ZoneParameters calldata zoneParameters\\n    ) external pure override returns (bytes4 validOrderMagicValue) {\\n        if (zoneParameters.extraData.length == 0) {\\n            if (zoneParameters.zoneHash == bytes32(uint256(1))) {\\n                revert(\\\"Revert on zone hash 1\\\");\\n            } else if (zoneParameters.zoneHash == bytes32(uint256(2))) {\\n                assembly {\\n                    revert(0, 0)\\n                }\\n            }\\n        } else if (zoneParameters.extraData.length == 4) {\\n            revert(\\\"Revert on extraData length 4\\\");\\n        } else if (zoneParameters.extraData.length == 5) {\\n            assembly {\\n                revert(0, 0)\\n            }\\n        }\\n\\n        validOrderMagicValue = zoneParameters.zoneHash != bytes32(uint256(3))\\n            ? ZoneInterface.validateOrder.selector\\n            : bytes4(0xffffffff);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestPostExecution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { ZoneInterface } from \\\"../interfaces/ZoneInterface.sol\\\";\\n\\nimport { ERC721Interface } from \\\"../interfaces/AbridgedTokenInterfaces.sol\\\";\\n\\nimport { ItemType } from \\\"../lib/ConsiderationEnums.sol\\\";\\n\\nimport {\\n    AdvancedOrder,\\n    CriteriaResolver,\\n    ReceivedItem,\\n    ZoneParameters\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\ncontract TestPostExecution is ZoneInterface {\\n    function validateOrder(\\n        ZoneParameters calldata zoneParameters\\n    ) external view override returns (bytes4 validOrderMagicValue) {\\n        if (zoneParameters.consideration.length == 0) {\\n            revert(\\\"No consideration items supplied\\\");\\n        }\\n\\n        ReceivedItem memory receivedItem = zoneParameters.consideration[0];\\n\\n        address currentOwner;\\n        try\\n            ERC721Interface(receivedItem.token).ownerOf(receivedItem.identifier)\\n        returns (address owner) {\\n            currentOwner = owner;\\n        } catch {\\n            revert(\\\"Unsupported consideration token type (must implement 721)\\\");\\n        }\\n\\n        if (receivedItem.itemType != ItemType.ERC721) {\\n            revert(\\\"Validity check performed with unsupported item type\\\");\\n        }\\n\\n        // Note that endAmount has been repurposed as recipient; this interface\\n        // still needs to be modified to return spent / received items.\\n        if (receivedItem.amount != 1) {\\n            // Note that this is currently failing in the matchOrder case.\\n            revert(\\\"Returned item amount incorrectly modified\\\");\\n        }\\n\\n        if (currentOwner != receivedItem.recipient) {\\n            revert(\\\"Validity check performed prior to execution\\\");\\n        }\\n\\n        validOrderMagicValue = ZoneInterface.validateOrder.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestBadContractOfferer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    ERC721Interface,\\n    ERC1155Interface\\n} from \\\"../interfaces/AbridgedTokenInterfaces.sol\\\";\\n\\nimport {\\n    ContractOffererInterface\\n} from \\\"../interfaces/ContractOffererInterface.sol\\\";\\n\\nimport { ItemType, Side } from \\\"../lib/ConsiderationEnums.sol\\\";\\n\\nimport { SpentItem, ReceivedItem } from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\ncontract TestBadContractOfferer is ContractOffererInterface {\\n    error IntentionalRevert();\\n\\n    address private immutable seaport;\\n    ERC721Interface token;\\n\\n    constructor(address _seaport, ERC721Interface _token) {\\n        seaport = _seaport;\\n        token = _token;\\n        ERC721Interface(token).setApprovalForAll(seaport, true);\\n    }\\n\\n    receive() external payable {}\\n\\n    /**\\n     * @dev Generates an order with the specified minimum and maximum spent items,\\n     * and the optional extra data.\\n     *\\n     * @param a               Fulfiller, unused here.\\n     * @param b               The minimum items that the caller is willing to\\n     *                        receive.\\n     * @param c               maximumSent, unused here.\\n     * @param d               context, unused here.\\n     *\\n     * @return offer         A tuple containing the offer items.\\n     * @return consideration A tuple containing the consideration items.\\n     */\\n    function generateOrder(\\n        address a,\\n        SpentItem[] calldata b,\\n        SpentItem[] calldata c,\\n        bytes calldata d\\n    )\\n        external\\n        virtual\\n        override\\n        returns (SpentItem[] memory offer, ReceivedItem[] memory consideration)\\n    {\\n        return previewOrder(a, a, b, c, d);\\n    }\\n\\n    /**\\n     * @dev Generates an order in response to a minimum received set of items.\\n     *\\n     * @param -               caller, unused here.\\n     * @param -               fulfiller, unused here.\\n     * @param minimumReceived The minimum received set.\\n     * @param -               maximumSpent, unused here.\\n     * @param -               context, unused here.\\n     *\\n     * @return offer         The offer for the order.\\n     * @return consideration The consideration for the order.\\n     */\\n    function previewOrder(\\n        address,\\n        address,\\n        SpentItem[] calldata minimumReceived,\\n        SpentItem[] calldata maximumSpent,\\n        bytes calldata\\n    )\\n        public\\n        view\\n        override\\n        returns (SpentItem[] memory offer, ReceivedItem[] memory consideration)\\n    {\\n        if (minimumReceived[0].identifier == 1) {\\n            offer = minimumReceived;\\n            consideration = new ReceivedItem[](1);\\n            consideration[0] = ReceivedItem({\\n                itemType: ItemType.NATIVE,\\n                token: address(0),\\n                identifier: 0,\\n                amount: 100,\\n                recipient: payable(address(this))\\n            });\\n            return (offer, consideration);\\n        } else if (minimumReceived[0].identifier == 2) {\\n            // return nothing\\n            assembly {\\n                return(0, 0)\\n            }\\n        } else if (minimumReceived[0].identifier == 3) {\\n            revert IntentionalRevert();\\n        } else {\\n            // return garbage\\n            bytes32 h1 = keccak256(abi.encode(minimumReceived));\\n            bytes32 h2 = keccak256(abi.encode(maximumSpent));\\n            assembly {\\n                mstore(0x00, h1)\\n                mstore(0x20, h2)\\n                return(0, 0x100)\\n            }\\n        }\\n    }\\n\\n    function ratifyOrder(\\n        SpentItem[] calldata /* offer */,\\n        ReceivedItem[] calldata /* consideration */,\\n        bytes calldata /* context */,\\n        bytes32[] calldata /* orderHashes */,\\n        uint256 /* contractNonce */\\n    ) external pure override returns (bytes4 /* ratifyOrderMagicValue */) {\\n        return TestBadContractOfferer.ratifyOrder.selector;\\n    }\\n\\n    /** @dev Returns the metadata for this contract offerer.\\n     */\\n    function getMetadata()\\n        external\\n        pure\\n        override\\n        returns (\\n            uint256 schemaID, // maps to a Seaport standard's ID\\n            string memory name,\\n            bytes memory metadata // decoded based on the schemaID\\n        )\\n    {\\n        return (1337, \\\"TestBadContractOfferer\\\", \\\"\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/ConduitControllerMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    ConduitControllerInterface\\n} from \\\"../interfaces/ConduitControllerInterface.sol\\\";\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport { ConduitController } from \\\"../conduit/ConduitController.sol\\\";\\n\\nimport { ConduitMock } from \\\"../test/ConduitMock.sol\\\";\\n\\nimport { ConduitMockInvalidMagic } from \\\"../test/ConduitMockInvalidMagic.sol\\\";\\n\\nimport {\\n    ConduitMockRevertNoReason\\n} from \\\"../test/ConduitMockRevertNoReason.sol\\\";\\n\\nimport { ConduitMockRevertBytes } from \\\"../test/ConduitMockRevertBytes.sol\\\";\\n\\ncontract ConduitControllerMock is ConduitControllerInterface {\\n    // Register keys, owners, new potential owners, and channels by conduit.\\n    mapping(address => ConduitProperties) internal _conduits;\\n\\n    // Set conduit creation code and runtime code hashes as immutable arguments.\\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\\n    bytes32 internal immutable _CONDUIT_RUNTIME_CODE_HASH;\\n\\n    uint256 private conduitNum;\\n\\n    /**\\n     * @dev Initialize contract by deploying a conduit and setting the creation\\n     *      code and runtime code hashes as immutable arguments.\\n     */\\n    constructor(uint256 _conduitNum) {\\n        conduitNum = _conduitNum;\\n\\n        bytes32 creationCodeHash;\\n        bytes32 runtimeCodeHash;\\n\\n        if (conduitNum == 0) {\\n            creationCodeHash = keccak256(type(ConduitMock).creationCode);\\n            ConduitMock zeroConduit = new ConduitMock{ salt: bytes32(0) }();\\n            runtimeCodeHash = address(zeroConduit).codehash;\\n        } else if (conduitNum == 1) {\\n            creationCodeHash = keccak256(\\n                type(ConduitMockRevertNoReason).creationCode\\n            );\\n            ConduitMockRevertNoReason zeroConduit = new ConduitMockRevertNoReason{\\n                    salt: bytes32(0)\\n                }();\\n            runtimeCodeHash = address(zeroConduit).codehash;\\n        } else if (conduitNum == 2) {\\n            creationCodeHash = keccak256(\\n                type(ConduitMockInvalidMagic).creationCode\\n            );\\n            ConduitMockInvalidMagic zeroConduit = new ConduitMockInvalidMagic{\\n                salt: bytes32(0)\\n            }();\\n            runtimeCodeHash = address(zeroConduit).codehash;\\n        } else if (conduitNum == 3) {\\n            creationCodeHash = keccak256(\\n                type(ConduitMockRevertBytes).creationCode\\n            );\\n            ConduitMockRevertBytes zeroConduit = new ConduitMockRevertBytes{\\n                salt: bytes32(0)\\n            }();\\n            runtimeCodeHash = address(zeroConduit).codehash;\\n        }\\n        _CONDUIT_CREATION_CODE_HASH = creationCodeHash;\\n        _CONDUIT_RUNTIME_CODE_HASH = runtimeCodeHash;\\n    }\\n\\n    /**\\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\\n     *         an initial owner for the deployed conduit. Note that the first\\n     *         twenty bytes of the supplied conduit key must match the caller\\n     *         and that a new conduit cannot be created if one has already been\\n     *         deployed using the same conduit key.\\n     *\\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\\n     *                     the first twenty bytes of the conduit key must match\\n     *                     the caller of this contract.\\n     * @param initialOwner The initial owner to set for the new conduit.\\n     *\\n     * @return conduit The address of the newly deployed conduit.\\n     */\\n    function createConduit(\\n        bytes32 conduitKey,\\n        address initialOwner\\n    ) external override returns (address conduit) {\\n        // Ensure that an initial owner has been supplied.\\n        if (initialOwner == address(0)) {\\n            revert InvalidInitialOwner();\\n        }\\n\\n        // If the first 20 bytes of the conduit key do not match the caller...\\n        if (address(uint160(bytes20(conduitKey))) != msg.sender) {\\n            // Revert with an error indicating that the creator is invalid.\\n            revert InvalidCreator();\\n        }\\n\\n        // Derive address from deployer, conduit key and creation code hash.\\n        conduit = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(this),\\n                            conduitKey,\\n                            _CONDUIT_CREATION_CODE_HASH\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        // If derived conduit exists, as evidenced by comparing runtime code...\\n        if (conduit.codehash == _CONDUIT_RUNTIME_CODE_HASH) {\\n            // Revert with an error indicating that the conduit already exists.\\n            revert ConduitAlreadyExists(conduit);\\n        }\\n\\n        // Deploy the conduit via CREATE2 using the conduit key as the salt.\\n        if (conduitNum == 0) {\\n            new ConduitMock{ salt: conduitKey }();\\n        } else if (conduitNum == 1) {\\n            new ConduitMockRevertNoReason{ salt: conduitKey }();\\n        } else if (conduitNum == 2) {\\n            new ConduitMockInvalidMagic{ salt: conduitKey }();\\n        } else if (conduitNum == 3) {\\n            new ConduitMockRevertBytes{ salt: conduitKey }();\\n        }\\n        // Initialize storage variable referencing conduit properties.\\n        ConduitProperties storage conduitProperties = _conduits[conduit];\\n\\n        // Set the supplied initial owner as the owner of the conduit.\\n        conduitProperties.owner = initialOwner;\\n\\n        // Set conduit key used to deploy the conduit to enable reverse lookup.\\n        conduitProperties.key = conduitKey;\\n\\n        // Emit an event indicating that the conduit has been deployed.\\n        emit NewConduit(conduit, conduitKey);\\n\\n        // Emit an event indicating that conduit ownership has been assigned.\\n        emit OwnershipTransferred(conduit, address(0), initialOwner);\\n    }\\n\\n    /**\\n     * @notice Open or close a channel on a given conduit, thereby allowing the\\n     *         specified account to execute transfers against that conduit.\\n     *         Extreme care must be taken when updating channels, as malicious\\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\\n     *         tokens where the token holder has granted the conduit approval.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to open or close the channel.\\n     * @param channel The channel to open or close on the conduit.\\n     * @param isOpen  A boolean indicating whether to open or close the channel.\\n     */\\n    function updateChannel(\\n        address conduit,\\n        address channel,\\n        bool isOpen\\n    ) external override {\\n        // Ensure the caller is the current owner of the conduit in question.\\n        _assertCallerIsConduitOwner(conduit);\\n\\n        // Call the conduit, updating the channel.\\n        ConduitInterface(conduit).updateChannel(channel, isOpen);\\n\\n        // Retrieve storage region where channels for the conduit are tracked.\\n        ConduitProperties storage conduitProperties = _conduits[conduit];\\n\\n        // Retrieve the index, if one currently exists, for the updated channel.\\n        uint256 channelIndexPlusOne = (\\n            conduitProperties.channelIndexesPlusOne[channel]\\n        );\\n\\n        // Determine whether the updated channel is already tracked as open.\\n        bool channelPreviouslyOpen = channelIndexPlusOne != 0;\\n\\n        // If the channel has been set to open and was previously closed...\\n        if (isOpen && !channelPreviouslyOpen) {\\n            // Add the channel to the channels array for the conduit.\\n            conduitProperties.channels.push(channel);\\n\\n            // Add new open channel length to associated mapping as index + 1.\\n            conduitProperties.channelIndexesPlusOne[channel] = (\\n                conduitProperties.channels.length\\n            );\\n        } else if (!isOpen && channelPreviouslyOpen) {\\n            // Set a previously open channel as closed via \\\"swap & pop\\\" method.\\n            // Decrement located index to get the index of the closed channel.\\n            uint256 removedChannelIndex;\\n\\n            // Skip underflow check as channelPreviouslyOpen being true ensures\\n            // that channelIndexPlusOne is nonzero.\\n            unchecked {\\n                removedChannelIndex = channelIndexPlusOne - 1;\\n            }\\n\\n            // Use length of channels array to determine index of last channel.\\n            uint256 finalChannelIndex = conduitProperties.channels.length - 1;\\n\\n            // If closed channel is not last channel in the channels array...\\n            if (finalChannelIndex != removedChannelIndex) {\\n                // Retrieve the final channel and place the value on the stack.\\n                address finalChannel = (\\n                    conduitProperties.channels[finalChannelIndex]\\n                );\\n\\n                // Overwrite the removed channel using the final channel value.\\n                conduitProperties.channels[removedChannelIndex] = finalChannel;\\n\\n                // Update final index in associated mapping to removed index.\\n                conduitProperties.channelIndexesPlusOne[finalChannel] = (\\n                    channelIndexPlusOne\\n                );\\n            }\\n\\n            // Remove the last channel from the channels array for the conduit.\\n            conduitProperties.channels.pop();\\n\\n            // Remove the closed channel from associated mapping of indexes.\\n            delete conduitProperties.channelIndexesPlusOne[channel];\\n        }\\n    }\\n\\n    /**\\n     * @notice Initiate conduit ownership transfer by assigning a new potential\\n     *         owner for the given conduit. Once set, the new potential owner\\n     *         may call `acceptOwnership` to claim ownership of the conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to initiate ownership transfer.\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    function transferOwnership(\\n        address conduit,\\n        address newPotentialOwner\\n    ) external override {\\n        // Ensure the caller is the current owner of the conduit in question.\\n        _assertCallerIsConduitOwner(conduit);\\n\\n        // Ensure the new potential owner is not an invalid address.\\n        if (newPotentialOwner == address(0)) {\\n            revert NewPotentialOwnerIsZeroAddress(conduit);\\n        }\\n\\n        // Ensure the new potential owner is not already set.\\n        if (newPotentialOwner == _conduits[conduit].potentialOwner) {\\n            revert NewPotentialOwnerAlreadySet(conduit, newPotentialOwner);\\n        }\\n\\n        // Emit an event indicating that the potential owner has been updated.\\n        emit PotentialOwnerUpdated(newPotentialOwner);\\n\\n        // Set the new potential owner as the potential owner of the conduit.\\n        _conduits[conduit].potentialOwner = newPotentialOwner;\\n    }\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any, from a conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to cancel ownership transfer.\\n     */\\n    function cancelOwnershipTransfer(address conduit) external override {\\n        // Ensure the caller is the current owner of the conduit in question.\\n        _assertCallerIsConduitOwner(conduit);\\n\\n        // Ensure that ownership transfer is currently possible.\\n        if (_conduits[conduit].potentialOwner == address(0)) {\\n            revert NoPotentialOwnerCurrentlySet(conduit);\\n        }\\n\\n        // Emit an event indicating that the potential owner has been cleared.\\n        emit PotentialOwnerUpdated(address(0));\\n\\n        // Clear the current new potential owner from the conduit.\\n        _conduits[conduit].potentialOwner = address(0);\\n    }\\n\\n    /**\\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     *\\n     * @param conduit The conduit for which to accept ownership.\\n     */\\n    function acceptOwnership(address conduit) external override {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // If caller does not match current potential owner of the conduit...\\n        if (msg.sender != _conduits[conduit].potentialOwner) {\\n            // Revert, indicating that caller is not current potential owner.\\n            revert CallerIsNotNewPotentialOwner(conduit);\\n        }\\n\\n        // Emit an event indicating that the potential owner has been cleared.\\n        emit PotentialOwnerUpdated(address(0));\\n\\n        // Clear the current new potential owner from the conduit.\\n        _conduits[conduit].potentialOwner = address(0);\\n\\n        // Emit an event indicating conduit ownership has been transferred.\\n        emit OwnershipTransferred(\\n            conduit,\\n            _conduits[conduit].owner,\\n            msg.sender\\n        );\\n\\n        // Set the caller as the owner of the conduit.\\n        _conduits[conduit].owner = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Retrieve the current owner of a deployed conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated owner.\\n     *\\n     * @return owner The owner of the supplied conduit.\\n     */\\n    function ownerOf(\\n        address conduit\\n    ) external view override returns (address owner) {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // Retrieve the current owner of the conduit in question.\\n        owner = _conduits[conduit].owner;\\n    }\\n\\n    /**\\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\\n     *         lookup.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated conduit\\n     *                key.\\n     *\\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\\n     */\\n    function getKey(\\n        address conduit\\n    ) external view override returns (bytes32 conduitKey) {\\n        // Attempt to retrieve a conduit key for the conduit in question.\\n        conduitKey = _conduits[conduit].key;\\n\\n        // Revert if no conduit key was located.\\n        if (conduitKey == bytes32(0)) {\\n            revert NoConduit();\\n        }\\n    }\\n\\n    /**\\n     * @notice Derive the conduit associated with a given conduit key and\\n     *         determine whether that conduit exists (i.e. whether it has been\\n     *         deployed).\\n     *\\n     * @param conduitKey The conduit key used to derive the conduit.\\n     *\\n     * @return conduit The derived address of the conduit.\\n     * @return exists  A boolean indicating whether the derived conduit has been\\n     *                 deployed or not.\\n     */\\n    function getConduit(\\n        bytes32 conduitKey\\n    ) external view override returns (address conduit, bool exists) {\\n        // Derive address from deployer, conduit key and creation code hash.\\n        conduit = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(this),\\n                            conduitKey,\\n                            _CONDUIT_CREATION_CODE_HASH\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Determine whether conduit exists by retrieving its runtime code.\\n        exists = (conduit.codehash == _CONDUIT_RUNTIME_CODE_HASH);\\n    }\\n\\n    /**\\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\\n     *         current owner may set a new potential owner via\\n     *         `transferOwnership` and that owner may then accept ownership of\\n     *         the conduit in question via `acceptOwnership`.\\n     *\\n     * @param conduit The conduit for which to retrieve the potential owner.\\n     *\\n     * @return potentialOwner The potential owner, if any, for the conduit.\\n     */\\n    function getPotentialOwner(\\n        address conduit\\n    ) external view override returns (address potentialOwner) {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // Retrieve the current potential owner of the conduit in question.\\n        potentialOwner = _conduits[conduit].potentialOwner;\\n    }\\n\\n    /**\\n     * @notice Retrieve the status (either open or closed) of a given channel on\\n     *         a conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the channel status.\\n     * @param channel The channel for which to retrieve the status.\\n     *\\n     * @return isOpen The status of the channel on the given conduit.\\n     */\\n    function getChannelStatus(\\n        address conduit,\\n        address channel\\n    ) external view override returns (bool isOpen) {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // Retrieve the current channel status for the conduit in question.\\n        isOpen = _conduits[conduit].channelIndexesPlusOne[channel] != 0;\\n    }\\n\\n    /**\\n     * @notice Retrieve the total number of open channels for a given conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the total channel count.\\n     *\\n     * @return totalChannels The total number of open channels for the conduit.\\n     */\\n    function getTotalChannels(\\n        address conduit\\n    ) external view override returns (uint256 totalChannels) {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // Retrieve the total open channel count for the conduit in question.\\n        totalChannels = _conduits[conduit].channels.length;\\n    }\\n\\n    /**\\n     * @notice Retrieve an open channel at a specific index for a given conduit.\\n     *         Note that the index of a channel can change as a result of other\\n     *         channels being closed on the conduit.\\n     *\\n     * @param conduit      The conduit for which to retrieve the open channel.\\n     * @param channelIndex The index of the channel in question.\\n     *\\n     * @return channel The open channel, if any, at the specified channel index.\\n     */\\n    function getChannel(\\n        address conduit,\\n        uint256 channelIndex\\n    ) external view override returns (address channel) {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // Retrieve the total open channel count for the conduit in question.\\n        uint256 totalChannels = _conduits[conduit].channels.length;\\n\\n        // Ensure that the supplied index is within range.\\n        if (channelIndex >= totalChannels) {\\n            revert ChannelOutOfRange(conduit);\\n        }\\n\\n        // Retrieve the channel at the given index.\\n        channel = _conduits[conduit].channels[channelIndex];\\n    }\\n\\n    /**\\n     * @notice Retrieve all open channels for a given conduit. Note that calling\\n     *         this function for a conduit with many channels will revert with\\n     *         an out-of-gas error.\\n     *\\n     * @param conduit The conduit for which to retrieve open channels.\\n     *\\n     * @return channels An array of open channels on the given conduit.\\n     */\\n    function getChannels(\\n        address conduit\\n    ) external view override returns (address[] memory channels) {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // Retrieve all of the open channels on the conduit in question.\\n        channels = _conduits[conduit].channels;\\n    }\\n\\n    /**\\n     * @dev Retrieve the conduit creation code and runtime code hashes.\\n     */\\n    function getConduitCodeHashes()\\n        external\\n        view\\n        override\\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash)\\n    {\\n        // Retrieve the conduit creation code hash from runtime.\\n        creationCodeHash = _CONDUIT_CREATION_CODE_HASH;\\n\\n        // Retrieve the conduit runtime code hash from runtime.\\n        runtimeCodeHash = _CONDUIT_RUNTIME_CODE_HASH;\\n    }\\n\\n    /**\\n     * @dev Private view function to revert if the caller is not the owner of a\\n     *      given conduit.\\n     *\\n     * @param conduit The conduit for which to assert ownership.\\n     */\\n    function _assertCallerIsConduitOwner(address conduit) private view {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // If the caller does not match the current owner of the conduit...\\n        if (msg.sender != _conduits[conduit].owner) {\\n            // Revert, indicating that the caller is not the owner.\\n            revert CallerIsNotOwner(conduit);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private view function to revert if a given conduit does not exist.\\n     *\\n     * @param conduit The conduit for which to assert existence.\\n     */\\n    function _assertConduitExists(address conduit) private view {\\n        // Attempt to retrieve a conduit key for the conduit in question.\\n        if (_conduits[conduit].key == bytes32(0)) {\\n            // Revert if no conduit key was located.\\n            revert NoConduit();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/ConduitController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    ConduitControllerInterface\\n} from \\\"../interfaces/ConduitControllerInterface.sol\\\";\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport { Conduit } from \\\"./Conduit.sol\\\";\\n\\n/**\\n * @title ConduitController\\n * @author 0age\\n * @notice ConduitController enables deploying and managing new conduits, or\\n *         contracts that allow registered callers (or open \\\"channels\\\") to\\n *         transfer approved ERC20/721/1155 tokens on their behalf.\\n */\\ncontract ConduitController is ConduitControllerInterface {\\n    // Register keys, owners, new potential owners, and channels by conduit.\\n    mapping(address => ConduitProperties) internal _conduits;\\n\\n    // Set conduit creation code and runtime code hashes as immutable arguments.\\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\\n    bytes32 internal immutable _CONDUIT_RUNTIME_CODE_HASH;\\n\\n    /**\\n     * @dev Initialize contract by deploying a conduit and setting the creation\\n     *      code and runtime code hashes as immutable arguments.\\n     */\\n    constructor() {\\n        // Derive the conduit creation code hash and set it as an immutable.\\n        _CONDUIT_CREATION_CODE_HASH = keccak256(type(Conduit).creationCode);\\n\\n        // Deploy a conduit with the zero hash as the salt.\\n        Conduit zeroConduit = new Conduit{ salt: bytes32(0) }();\\n\\n        // Retrieve the conduit runtime code hash and set it as an immutable.\\n        _CONDUIT_RUNTIME_CODE_HASH = address(zeroConduit).codehash;\\n    }\\n\\n    /**\\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\\n     *         an initial owner for the deployed conduit. Note that the first\\n     *         twenty bytes of the supplied conduit key must match the caller\\n     *         and that a new conduit cannot be created if one has already been\\n     *         deployed using the same conduit key.\\n     *\\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\\n     *                     the first twenty bytes of the conduit key must match\\n     *                     the caller of this contract.\\n     * @param initialOwner The initial owner to set for the new conduit.\\n     *\\n     * @return conduit The address of the newly deployed conduit.\\n     */\\n    function createConduit(\\n        bytes32 conduitKey,\\n        address initialOwner\\n    ) external override returns (address conduit) {\\n        // Ensure that an initial owner has been supplied.\\n        if (initialOwner == address(0)) {\\n            revert InvalidInitialOwner();\\n        }\\n\\n        // If the first 20 bytes of the conduit key do not match the caller...\\n        if (address(uint160(bytes20(conduitKey))) != msg.sender) {\\n            // Revert with an error indicating that the creator is invalid.\\n            revert InvalidCreator();\\n        }\\n\\n        // Derive address from deployer, conduit key and creation code hash.\\n        conduit = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(this),\\n                            conduitKey,\\n                            _CONDUIT_CREATION_CODE_HASH\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        // If derived conduit exists, as evidenced by comparing runtime code...\\n        if (conduit.codehash == _CONDUIT_RUNTIME_CODE_HASH) {\\n            // Revert with an error indicating that the conduit already exists.\\n            revert ConduitAlreadyExists(conduit);\\n        }\\n\\n        // Deploy the conduit via CREATE2 using the conduit key as the salt.\\n        new Conduit{ salt: conduitKey }();\\n\\n        // Initialize storage variable referencing conduit properties.\\n        ConduitProperties storage conduitProperties = _conduits[conduit];\\n\\n        // Set the supplied initial owner as the owner of the conduit.\\n        conduitProperties.owner = initialOwner;\\n\\n        // Set conduit key used to deploy the conduit to enable reverse lookup.\\n        conduitProperties.key = conduitKey;\\n\\n        // Emit an event indicating that the conduit has been deployed.\\n        emit NewConduit(conduit, conduitKey);\\n\\n        // Emit an event indicating that conduit ownership has been assigned.\\n        emit OwnershipTransferred(conduit, address(0), initialOwner);\\n    }\\n\\n    /**\\n     * @notice Open or close a channel on a given conduit, thereby allowing the\\n     *         specified account to execute transfers against that conduit.\\n     *         Extreme care must be taken when updating channels, as malicious\\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\\n     *         tokens where the token holder has granted the conduit approval.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to open or close the channel.\\n     * @param channel The channel to open or close on the conduit.\\n     * @param isOpen  A boolean indicating whether to open or close the channel.\\n     */\\n    function updateChannel(\\n        address conduit,\\n        address channel,\\n        bool isOpen\\n    ) external override {\\n        // Ensure the caller is the current owner of the conduit in question.\\n        _assertCallerIsConduitOwner(conduit);\\n\\n        // Call the conduit, updating the channel.\\n        ConduitInterface(conduit).updateChannel(channel, isOpen);\\n\\n        // Retrieve storage region where channels for the conduit are tracked.\\n        ConduitProperties storage conduitProperties = _conduits[conduit];\\n\\n        // Retrieve the index, if one currently exists, for the updated channel.\\n        uint256 channelIndexPlusOne = (\\n            conduitProperties.channelIndexesPlusOne[channel]\\n        );\\n\\n        // Determine whether the updated channel is already tracked as open.\\n        bool channelPreviouslyOpen = channelIndexPlusOne != 0;\\n\\n        // If the channel has been set to open and was previously closed...\\n        if (isOpen && !channelPreviouslyOpen) {\\n            // Add the channel to the channels array for the conduit.\\n            conduitProperties.channels.push(channel);\\n\\n            // Add new open channel length to associated mapping as index + 1.\\n            conduitProperties.channelIndexesPlusOne[channel] = (\\n                conduitProperties.channels.length\\n            );\\n        } else if (!isOpen && channelPreviouslyOpen) {\\n            // Set a previously open channel as closed via \\\"swap & pop\\\" method.\\n            // Decrement located index to get the index of the closed channel.\\n            uint256 removedChannelIndex;\\n\\n            // Skip underflow check as channelPreviouslyOpen being true ensures\\n            // that channelIndexPlusOne is nonzero.\\n            unchecked {\\n                removedChannelIndex = channelIndexPlusOne - 1;\\n            }\\n\\n            // Use length of channels array to determine index of last channel.\\n            uint256 finalChannelIndex = conduitProperties.channels.length - 1;\\n\\n            // If closed channel is not last channel in the channels array...\\n            if (finalChannelIndex != removedChannelIndex) {\\n                // Retrieve the final channel and place the value on the stack.\\n                address finalChannel = (\\n                    conduitProperties.channels[finalChannelIndex]\\n                );\\n\\n                // Overwrite the removed channel using the final channel value.\\n                conduitProperties.channels[removedChannelIndex] = finalChannel;\\n\\n                // Update final index in associated mapping to removed index.\\n                conduitProperties.channelIndexesPlusOne[finalChannel] = (\\n                    channelIndexPlusOne\\n                );\\n            }\\n\\n            // Remove the last channel from the channels array for the conduit.\\n            conduitProperties.channels.pop();\\n\\n            // Remove the closed channel from associated mapping of indexes.\\n            delete conduitProperties.channelIndexesPlusOne[channel];\\n        }\\n    }\\n\\n    /**\\n     * @notice Initiate conduit ownership transfer by assigning a new potential\\n     *         owner for the given conduit. Once set, the new potential owner\\n     *         may call `acceptOwnership` to claim ownership of the conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to initiate ownership transfer.\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    function transferOwnership(\\n        address conduit,\\n        address newPotentialOwner\\n    ) external override {\\n        // Ensure the caller is the current owner of the conduit in question.\\n        _assertCallerIsConduitOwner(conduit);\\n\\n        // Ensure the new potential owner is not an invalid address.\\n        if (newPotentialOwner == address(0)) {\\n            revert NewPotentialOwnerIsZeroAddress(conduit);\\n        }\\n\\n        // Ensure the new potential owner is not already set.\\n        if (newPotentialOwner == _conduits[conduit].potentialOwner) {\\n            revert NewPotentialOwnerAlreadySet(conduit, newPotentialOwner);\\n        }\\n\\n        // Emit an event indicating that the potential owner has been updated.\\n        emit PotentialOwnerUpdated(newPotentialOwner);\\n\\n        // Set the new potential owner as the potential owner of the conduit.\\n        _conduits[conduit].potentialOwner = newPotentialOwner;\\n    }\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any, from a conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to cancel ownership transfer.\\n     */\\n    function cancelOwnershipTransfer(address conduit) external override {\\n        // Ensure the caller is the current owner of the conduit in question.\\n        _assertCallerIsConduitOwner(conduit);\\n\\n        // Ensure that ownership transfer is currently possible.\\n        if (_conduits[conduit].potentialOwner == address(0)) {\\n            revert NoPotentialOwnerCurrentlySet(conduit);\\n        }\\n\\n        // Emit an event indicating that the potential owner has been cleared.\\n        emit PotentialOwnerUpdated(address(0));\\n\\n        // Clear the current new potential owner from the conduit.\\n        _conduits[conduit].potentialOwner = address(0);\\n    }\\n\\n    /**\\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     *\\n     * @param conduit The conduit for which to accept ownership.\\n     */\\n    function acceptOwnership(address conduit) external override {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // If caller does not match current potential owner of the conduit...\\n        if (msg.sender != _conduits[conduit].potentialOwner) {\\n            // Revert, indicating that caller is not current potential owner.\\n            revert CallerIsNotNewPotentialOwner(conduit);\\n        }\\n\\n        // Emit an event indicating that the potential owner has been cleared.\\n        emit PotentialOwnerUpdated(address(0));\\n\\n        // Clear the current new potential owner from the conduit.\\n        _conduits[conduit].potentialOwner = address(0);\\n\\n        // Emit an event indicating conduit ownership has been transferred.\\n        emit OwnershipTransferred(\\n            conduit,\\n            _conduits[conduit].owner,\\n            msg.sender\\n        );\\n\\n        // Set the caller as the owner of the conduit.\\n        _conduits[conduit].owner = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Retrieve the current owner of a deployed conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated owner.\\n     *\\n     * @return owner The owner of the supplied conduit.\\n     */\\n    function ownerOf(\\n        address conduit\\n    ) external view override returns (address owner) {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // Retrieve the current owner of the conduit in question.\\n        owner = _conduits[conduit].owner;\\n    }\\n\\n    /**\\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\\n     *         lookup.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated conduit\\n     *                key.\\n     *\\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\\n     */\\n    function getKey(\\n        address conduit\\n    ) external view override returns (bytes32 conduitKey) {\\n        // Attempt to retrieve a conduit key for the conduit in question.\\n        conduitKey = _conduits[conduit].key;\\n\\n        // Revert if no conduit key was located.\\n        if (conduitKey == bytes32(0)) {\\n            revert NoConduit();\\n        }\\n    }\\n\\n    /**\\n     * @notice Derive the conduit associated with a given conduit key and\\n     *         determine whether that conduit exists (i.e. whether it has been\\n     *         deployed).\\n     *\\n     * @param conduitKey The conduit key used to derive the conduit.\\n     *\\n     * @return conduit The derived address of the conduit.\\n     * @return exists  A boolean indicating whether the derived conduit has been\\n     *                 deployed or not.\\n     */\\n    function getConduit(\\n        bytes32 conduitKey\\n    ) external view override returns (address conduit, bool exists) {\\n        // Derive address from deployer, conduit key and creation code hash.\\n        conduit = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(this),\\n                            conduitKey,\\n                            _CONDUIT_CREATION_CODE_HASH\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Determine whether conduit exists by retrieving its runtime code.\\n        exists = (conduit.codehash == _CONDUIT_RUNTIME_CODE_HASH);\\n    }\\n\\n    /**\\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\\n     *         current owner may set a new potential owner via\\n     *         `transferOwnership` and that owner may then accept ownership of\\n     *         the conduit in question via `acceptOwnership`.\\n     *\\n     * @param conduit The conduit for which to retrieve the potential owner.\\n     *\\n     * @return potentialOwner The potential owner, if any, for the conduit.\\n     */\\n    function getPotentialOwner(\\n        address conduit\\n    ) external view override returns (address potentialOwner) {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // Retrieve the current potential owner of the conduit in question.\\n        potentialOwner = _conduits[conduit].potentialOwner;\\n    }\\n\\n    /**\\n     * @notice Retrieve the status (either open or closed) of a given channel on\\n     *         a conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the channel status.\\n     * @param channel The channel for which to retrieve the status.\\n     *\\n     * @return isOpen The status of the channel on the given conduit.\\n     */\\n    function getChannelStatus(\\n        address conduit,\\n        address channel\\n    ) external view override returns (bool isOpen) {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // Retrieve the current channel status for the conduit in question.\\n        isOpen = _conduits[conduit].channelIndexesPlusOne[channel] != 0;\\n    }\\n\\n    /**\\n     * @notice Retrieve the total number of open channels for a given conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the total channel count.\\n     *\\n     * @return totalChannels The total number of open channels for the conduit.\\n     */\\n    function getTotalChannels(\\n        address conduit\\n    ) external view override returns (uint256 totalChannels) {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // Retrieve the total open channel count for the conduit in question.\\n        totalChannels = _conduits[conduit].channels.length;\\n    }\\n\\n    /**\\n     * @notice Retrieve an open channel at a specific index for a given conduit.\\n     *         Note that the index of a channel can change as a result of other\\n     *         channels being closed on the conduit.\\n     *\\n     * @param conduit      The conduit for which to retrieve the open channel.\\n     * @param channelIndex The index of the channel in question.\\n     *\\n     * @return channel The open channel, if any, at the specified channel index.\\n     */\\n    function getChannel(\\n        address conduit,\\n        uint256 channelIndex\\n    ) external view override returns (address channel) {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // Retrieve the total open channel count for the conduit in question.\\n        uint256 totalChannels = _conduits[conduit].channels.length;\\n\\n        // Ensure that the supplied index is within range.\\n        if (channelIndex >= totalChannels) {\\n            revert ChannelOutOfRange(conduit);\\n        }\\n\\n        // Retrieve the channel at the given index.\\n        channel = _conduits[conduit].channels[channelIndex];\\n    }\\n\\n    /**\\n     * @notice Retrieve all open channels for a given conduit. Note that calling\\n     *         this function for a conduit with many channels will revert with\\n     *         an out-of-gas error.\\n     *\\n     * @param conduit The conduit for which to retrieve open channels.\\n     *\\n     * @return channels An array of open channels on the given conduit.\\n     */\\n    function getChannels(\\n        address conduit\\n    ) external view override returns (address[] memory channels) {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // Retrieve all of the open channels on the conduit in question.\\n        channels = _conduits[conduit].channels;\\n    }\\n\\n    /**\\n     * @dev Retrieve the conduit creation code and runtime code hashes.\\n     */\\n    function getConduitCodeHashes()\\n        external\\n        view\\n        override\\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash)\\n    {\\n        // Retrieve the conduit creation code hash from runtime.\\n        creationCodeHash = _CONDUIT_CREATION_CODE_HASH;\\n\\n        // Retrieve the conduit runtime code hash from runtime.\\n        runtimeCodeHash = _CONDUIT_RUNTIME_CODE_HASH;\\n    }\\n\\n    /**\\n     * @dev Private view function to revert if the caller is not the owner of a\\n     *      given conduit.\\n     *\\n     * @param conduit The conduit for which to assert ownership.\\n     */\\n    function _assertCallerIsConduitOwner(address conduit) private view {\\n        // Ensure that the conduit in question exists.\\n        _assertConduitExists(conduit);\\n\\n        // If the caller does not match the current owner of the conduit...\\n        if (msg.sender != _conduits[conduit].owner) {\\n            // Revert, indicating that the caller is not the owner.\\n            revert CallerIsNotOwner(conduit);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private view function to revert if a given conduit does not exist.\\n     *\\n     * @param conduit The conduit for which to assert existence.\\n     */\\n    function _assertConduitExists(address conduit) private view {\\n        // Attempt to retrieve a conduit key for the conduit in question.\\n        if (_conduits[conduit].key == bytes32(0)) {\\n            // Revert if no conduit key was located.\\n            revert NoConduit();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/ConduitMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport { TokenTransferrer } from \\\"../lib/TokenTransferrer.sol\\\";\\n\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\ncontract ConduitMock is ConduitInterface {\\n    constructor() {}\\n\\n    function execute(\\n        ConduitTransfer[] calldata /* transfers */\\n    ) external pure override returns (bytes4) {\\n        // Return the valid magic value.\\n        return 0x4ce34aa2;\\n    }\\n\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata /*  batch1155Transfers */\\n    ) external view override returns (bytes4 magicValue) {}\\n\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata /* standardTransfers */,\\n        ConduitBatch1155Transfer[] calldata /*  batch1155Transfers */\\n    ) external view override returns (bytes4 magicValue) {}\\n\\n    function updateChannel(address channel, bool isOpen) external override {}\\n}\\n\"\r\n    },\r\n    \"contracts/test/ConduitMockInvalidMagic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport { TokenTransferrer } from \\\"../lib/TokenTransferrer.sol\\\";\\n\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\ncontract ConduitMockInvalidMagic is ConduitInterface {\\n    constructor() {}\\n\\n    function execute(\\n        ConduitTransfer[] calldata /* transfers */\\n    ) external pure override returns (bytes4) {\\n        return 0xabcd0000;\\n    }\\n\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata /*  batch1155Transfers */\\n    ) external view override returns (bytes4 magicValue) {}\\n\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata /* standardTransfers */,\\n        ConduitBatch1155Transfer[] calldata /*  batch1155Transfers */\\n    ) external view override returns (bytes4 magicValue) {}\\n\\n    function updateChannel(address channel, bool isOpen) external override {}\\n}\\n\"\r\n    },\r\n    \"contracts/test/ConduitMockRevertNoReason.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport { TokenTransferrer } from \\\"../lib/TokenTransferrer.sol\\\";\\n\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\ncontract ConduitMockRevertNoReason is ConduitInterface {\\n    constructor() {}\\n\\n    function execute(\\n        ConduitTransfer[] calldata /* transfers */\\n    ) external pure override returns (bytes4) {\\n        // Revert without reason string.\\n        revert();\\n    }\\n\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata /*  batch1155Transfers */\\n    ) external view override returns (bytes4 magicValue) {}\\n\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata /* standardTransfers */,\\n        ConduitBatch1155Transfer[] calldata /*  batch1155Transfers */\\n    ) external view override returns (bytes4 magicValue) {}\\n\\n    function updateChannel(address channel, bool isOpen) external override {}\\n}\\n\"\r\n    },\r\n    \"contracts/test/ConduitMockRevertBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport { TokenTransferrer } from \\\"../lib/TokenTransferrer.sol\\\";\\n\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\ncontract ConduitMockRevertBytes is ConduitInterface {\\n    constructor() {}\\n\\n    error CustomError();\\n\\n    function execute(\\n        ConduitTransfer[] calldata /* transfers */\\n    ) external pure override returns (bytes4) {\\n        revert CustomError();\\n    }\\n\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata /*  batch1155Transfers */\\n    ) external view override returns (bytes4 magicValue) {}\\n\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata /* standardTransfers */,\\n        ConduitBatch1155Transfer[] calldata /*  batch1155Transfers */\\n    ) external view override returns (bytes4 magicValue) {}\\n\\n    function updateChannel(address channel, bool isOpen) external override {}\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/Conduit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport { ConduitItemType } from \\\"./lib/ConduitEnums.sol\\\";\\n\\nimport { TokenTransferrer } from \\\"../lib/TokenTransferrer.sol\\\";\\n\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"./lib/ConduitStructs.sol\\\";\\n\\nimport \\\"./lib/ConduitConstants.sol\\\";\\n\\n/**\\n * @title Conduit\\n * @author 0age\\n * @notice This contract serves as an originator for \\\"proxied\\\" transfers. Each\\n *         conduit is deployed and controlled by a \\\"conduit controller\\\" that can\\n *         add and remove \\\"channels\\\" or contracts that can instruct the conduit\\n *         to transfer approved ERC20/721/1155 tokens. *IMPORTANT NOTE: each\\n *         conduit has an owner that can arbitrarily add or remove channels, and\\n *         a malicious or negligent owner can add a channel that allows for any\\n *         approved ERC20/721/1155 tokens to be taken immediately — be extremely\\n *         cautious with what conduits you give token approvals to!*\\n */\\ncontract Conduit is ConduitInterface, TokenTransferrer {\\n    // Set deployer as an immutable controller that can update channel statuses.\\n    address private immutable _controller;\\n\\n    // Track the status of each channel.\\n    mapping(address => bool) private _channels;\\n\\n    /**\\n     * @notice Ensure that the caller is currently registered as an open channel\\n     *         on the conduit.\\n     */\\n    modifier onlyOpenChannel() {\\n        // Utilize assembly to access channel storage mapping directly.\\n        assembly {\\n            // Write the caller to scratch space.\\n            mstore(ChannelKey_channel_ptr, caller())\\n\\n            // Write the storage slot for _channels to scratch space.\\n            mstore(ChannelKey_slot_ptr, _channels.slot)\\n\\n            // Derive the position in storage of _channels[msg.sender]\\n            // and check if the stored value is zero.\\n            if iszero(\\n                sload(keccak256(ChannelKey_channel_ptr, ChannelKey_length))\\n            ) {\\n                // The caller is not an open channel; revert with\\n                // ChannelClosed(caller). First, set error signature in memory.\\n                mstore(ChannelClosed_error_ptr, ChannelClosed_error_signature)\\n\\n                // Next, set the caller as the argument.\\n                mstore(ChannelClosed_channel_ptr, caller())\\n\\n                // Finally, revert, returning full custom error with argument.\\n                revert(ChannelClosed_error_ptr, ChannelClosed_error_length)\\n            }\\n        }\\n\\n        // Continue with function execution.\\n        _;\\n    }\\n\\n    /**\\n     * @notice In the constructor, set the deployer as the controller.\\n     */\\n    constructor() {\\n        // Set the deployer as the controller.\\n        _controller = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\\n     *         with an open channel can call this function. Note that channels\\n     *         are expected to implement reentrancy protection if desired, and\\n     *         that cross-channel reentrancy may be possible if the conduit has\\n     *         multiple open channels at once. Also note that channels are\\n     *         expected to implement checks against transferring any zero-amount\\n     *         items if that constraint is desired.\\n     *\\n     * @param transfers The ERC20/721/1155 transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function execute(\\n        ConduitTransfer[] calldata transfers\\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\\n        // Retrieve the total number of transfers and place on the stack.\\n        uint256 totalStandardTransfers = transfers.length;\\n\\n        // Iterate over each transfer.\\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\\n            // Retrieve the transfer in question and perform the transfer.\\n            _transfer(transfers[i]);\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.execute.selector;\\n    }\\n\\n    /**\\n     * @notice Execute a sequence of batch 1155 item transfers. Only a caller\\n     *         with an open channel can call this function. Note that channels\\n     *         are expected to implement reentrancy protection if desired, and\\n     *         that cross-channel reentrancy may be possible if the conduit has\\n     *         multiple open channels at once. Also note that channels are\\n     *         expected to implement checks against transferring any zero-amount\\n     *         items if that constraint is desired.\\n     *\\n     * @param batchTransfers The 1155 batch item transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the item transfers were\\n     *                    performed successfully.\\n     */\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\\n        // Perform 1155 batch transfers. Note that memory should be considered\\n        // entirely corrupted from this point forward.\\n        _performERC1155BatchTransfers(batchTransfers);\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.executeBatch1155.selector;\\n    }\\n\\n    /**\\n     * @notice Execute a sequence of transfers, both single ERC20/721/1155 item\\n     *         transfers as well as batch 1155 item transfers. Only a caller\\n     *         with an open channel can call this function. Note that channels\\n     *         are expected to implement reentrancy protection if desired, and\\n     *         that cross-channel reentrancy may be possible if the conduit has\\n     *         multiple open channels at once. Also note that channels are\\n     *         expected to implement checks against transferring any zero-amount\\n     *         items if that constraint is desired.\\n     *\\n     * @param standardTransfers The ERC20/721/1155 item transfers to perform.\\n     * @param batchTransfers    The 1155 batch item transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the item transfers were\\n     *                    performed successfully.\\n     */\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata standardTransfers,\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\\n        // Retrieve the total number of transfers and place on the stack.\\n        uint256 totalStandardTransfers = standardTransfers.length;\\n\\n        // Iterate over each standard transfer.\\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\\n            // Retrieve the transfer in question and perform the transfer.\\n            _transfer(standardTransfers[i]);\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Perform 1155 batch transfers. Note that memory should be considered\\n        // entirely corrupted from this point forward aside from the free memory\\n        // pointer having the default value.\\n        _performERC1155BatchTransfers(batchTransfers);\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.executeWithBatch1155.selector;\\n    }\\n\\n    /**\\n     * @notice Open or close a given channel. Only callable by the controller.\\n     *\\n     * @param channel The channel to open or close.\\n     * @param isOpen  The status of the channel (either open or closed).\\n     */\\n    function updateChannel(address channel, bool isOpen) external override {\\n        // Ensure that the caller is the controller of this contract.\\n        if (msg.sender != _controller) {\\n            revert InvalidController();\\n        }\\n\\n        // Ensure that the channel does not already have the indicated status.\\n        if (_channels[channel] == isOpen) {\\n            revert ChannelStatusAlreadySet(channel, isOpen);\\n        }\\n\\n        // Update the status of the channel.\\n        _channels[channel] = isOpen;\\n\\n        // Emit a corresponding event.\\n        emit ChannelUpdated(channel, isOpen);\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer a given ERC20/721/1155 item. Note that\\n     *      channels are expected to implement checks against transferring any\\n     *      zero-amount items if that constraint is desired.\\n     *\\n     * @param item The ERC20/721/1155 item to transfer.\\n     */\\n    function _transfer(ConduitTransfer calldata item) internal {\\n        // Determine the transfer method based on the respective item type.\\n        if (item.itemType == ConduitItemType.ERC20) {\\n            // Transfer ERC20 token. Note that item.identifier is ignored and\\n            // therefore ERC20 transfer items are potentially malleable — this\\n            // check should be performed by the calling channel if a constraint\\n            // on item malleability is desired.\\n            _performERC20Transfer(item.token, item.from, item.to, item.amount);\\n        } else if (item.itemType == ConduitItemType.ERC721) {\\n            // Ensure that exactly one 721 item is being transferred.\\n            if (item.amount != 1) {\\n                revert InvalidERC721TransferAmount(item.amount);\\n            }\\n\\n            // Transfer ERC721 token.\\n            _performERC721Transfer(\\n                item.token,\\n                item.from,\\n                item.to,\\n                item.identifier\\n            );\\n        } else if (item.itemType == ConduitItemType.ERC1155) {\\n            // Transfer ERC1155 token.\\n            _performERC1155Transfer(\\n                item.token,\\n                item.from,\\n                item.to,\\n                item.identifier,\\n                item.amount\\n            );\\n        } else {\\n            // Throw with an error.\\n            revert InvalidItemType();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n// error ChannelClosed(address channel)\\nuint256 constant ChannelClosed_error_signature = (\\n    0x93daadf200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ChannelClosed_error_ptr = 0x00;\\nuint256 constant ChannelClosed_channel_ptr = 0x4;\\nuint256 constant ChannelClosed_error_length = 0x24;\\n\\n// For the mapping:\\n// mapping(address => bool) channels\\n// The position in storage for a particular account is:\\n// keccak256(abi.encode(account, channels.slot))\\nuint256 constant ChannelKey_channel_ptr = 0x00;\\nuint256 constant ChannelKey_slot_ptr = 0x20;\\nuint256 constant ChannelKey_length = 0x40;\\n\"\r\n    },\r\n    \"contracts/helpers/TransferHelperStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { ConduitItemType } from \\\"../conduit/lib/ConduitEnums.sol\\\";\\n\\n/**\\n * @dev A TransferHelperItem specifies the itemType (ERC20/ERC721/ERC1155),\\n *      token address, token identifier, and amount of the token to be\\n *      transferred via the TransferHelper. For ERC20 tokens, identifier\\n *      must be 0. For ERC721 tokens, amount must be 1.\\n */\\nstruct TransferHelperItem {\\n    ConduitItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev A TransferHelperItemsWithRecipient specifies the tokens to transfer\\n *      via the TransferHelper, their intended recipient, and a boolean flag\\n *      indicating whether onERC721Received should be called on a recipient\\n *      contract.\\n */\\nstruct TransferHelperItemsWithRecipient {\\n    TransferHelperItem[] items;\\n    address recipient;\\n    bool validateERC721Receiver;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TransferHelperInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    TransferHelperItemsWithRecipient\\n} from \\\"../helpers/TransferHelperStructs.sol\\\";\\n\\ninterface TransferHelperInterface {\\n    /**\\n     * @notice Transfer multiple items to a single recipient.\\n     *\\n     * @param items The items to transfer.\\n     * @param conduitKey  The key of the conduit performing the bulk transfer.\\n     */\\n    function bulkTransfer(\\n        TransferHelperItemsWithRecipient[] calldata items,\\n        bytes32 conduitKey\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { IERC721Receiver } from \\\"../interfaces/IERC721Receiver.sol\\\";\\n\\nimport \\\"./TransferHelperStructs.sol\\\";\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport {\\n    ConduitControllerInterface\\n} from \\\"../interfaces/ConduitControllerInterface.sol\\\";\\n\\nimport { Conduit } from \\\"../conduit/Conduit.sol\\\";\\n\\nimport { ConduitTransfer } from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\nimport {\\n    TransferHelperInterface\\n} from \\\"../interfaces/TransferHelperInterface.sol\\\";\\n\\nimport { TransferHelperErrors } from \\\"../interfaces/TransferHelperErrors.sol\\\";\\n\\n/**\\n * @title TransferHelper\\n * @author stephankmin, stuckinaboot, ryanio\\n * @notice TransferHelper is a utility contract for transferring\\n *         ERC20/ERC721/ERC1155 items in bulk to specific recipients.\\n */\\ncontract TransferHelper is TransferHelperInterface, TransferHelperErrors {\\n    // Allow for interaction with the conduit controller.\\n    ConduitControllerInterface internal immutable _CONDUIT_CONTROLLER;\\n\\n    // Set conduit creation code and runtime code hashes as immutable arguments.\\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\\n    bytes32 internal immutable _CONDUIT_RUNTIME_CODE_HASH;\\n\\n    /**\\n     * @dev Set the supplied conduit controller and retrieve its\\n     *      conduit creation code hash.\\n     *\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) {\\n        // Get the conduit creation code and runtime code hashes from the\\n        // supplied conduit controller and set them as an immutable.\\n        ConduitControllerInterface controller = ConduitControllerInterface(\\n            conduitController\\n        );\\n        (_CONDUIT_CREATION_CODE_HASH, _CONDUIT_RUNTIME_CODE_HASH) = controller\\n            .getConduitCodeHashes();\\n\\n        // Set the supplied conduit controller as an immutable.\\n        _CONDUIT_CONTROLLER = controller;\\n    }\\n\\n    /**\\n     * @notice Transfer multiple ERC20/ERC721/ERC1155 items to\\n     *         specified recipients.\\n     *\\n     * @param items      The items to transfer to an intended recipient.\\n     * @param conduitKey A mandatory conduit key referring to a conduit through\\n     *                   which the bulk transfer should occur.\\n     *\\n     * @return magicValue A value indicating that the transfers were successful.\\n     */\\n    function bulkTransfer(\\n        TransferHelperItemsWithRecipient[] calldata items,\\n        bytes32 conduitKey\\n    ) external override returns (bytes4 magicValue) {\\n        // Ensure that a conduit key has been supplied.\\n        if (conduitKey == bytes32(0)) {\\n            revert InvalidConduit(conduitKey, address(0));\\n        }\\n\\n        // Use conduit derived from supplied conduit key to perform transfers.\\n        _performTransfersWithConduit(items, conduitKey);\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.bulkTransfer.selector;\\n    }\\n\\n    /**\\n     * @notice Perform multiple transfers to specified recipients via the\\n     *         conduit derived from the provided conduit key.\\n     *\\n     * @param transfers  The items to transfer.\\n     * @param conduitKey The conduit key referring to the conduit through\\n     *                   which the bulk transfer should occur.\\n     */\\n    function _performTransfersWithConduit(\\n        TransferHelperItemsWithRecipient[] calldata transfers,\\n        bytes32 conduitKey\\n    ) internal {\\n        // Retrieve total number of transfers and place on stack.\\n        uint256 numTransfers = transfers.length;\\n\\n        // Derive the conduit address from the deployer, conduit key\\n        // and creation code hash.\\n        address conduit = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(_CONDUIT_CONTROLLER),\\n                            conduitKey,\\n                            _CONDUIT_CREATION_CODE_HASH\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Declare a variable to store the sum of all items across transfers.\\n        uint256 sumOfItemsAcrossAllTransfers;\\n\\n        // Skip overflow checks: all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over each transfer.\\n            for (uint256 i = 0; i < numTransfers; ++i) {\\n                // Retrieve the transfer in question.\\n                TransferHelperItemsWithRecipient calldata transfer = transfers[\\n                    i\\n                ];\\n\\n                // Increment totalItems by the number of items in the transfer.\\n                sumOfItemsAcrossAllTransfers += transfer.items.length;\\n            }\\n        }\\n\\n        // Declare a new array in memory with length totalItems to populate with\\n        // each conduit transfer.\\n        ConduitTransfer[] memory conduitTransfers = new ConduitTransfer[](\\n            sumOfItemsAcrossAllTransfers\\n        );\\n\\n        // Declare an index for storing ConduitTransfers in conduitTransfers.\\n        uint256 itemIndex;\\n\\n        // Skip overflow checks: all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over each transfer.\\n            for (uint256 i = 0; i < numTransfers; ++i) {\\n                // Retrieve the transfer in question.\\n                TransferHelperItemsWithRecipient calldata transfer = transfers[\\n                    i\\n                ];\\n\\n                // Retrieve the items of the transfer in question.\\n                TransferHelperItem[] calldata transferItems = transfer.items;\\n\\n                // Ensure recipient is not the zero address.\\n                _checkRecipientIsNotZeroAddress(transfer.recipient);\\n\\n                // Create a boolean indicating whether validateERC721Receiver\\n                // is true and recipient is a contract.\\n                bool callERC721Receiver = transfer.validateERC721Receiver &&\\n                    transfer.recipient.code.length != 0;\\n\\n                // Retrieve the total number of items in the transfer and\\n                // place on stack.\\n                uint256 numItemsInTransfer = transferItems.length;\\n\\n                // Iterate over each item in the transfer to create a\\n                // corresponding ConduitTransfer.\\n                for (uint256 j = 0; j < numItemsInTransfer; ++j) {\\n                    // Retrieve the item from the transfer.\\n                    TransferHelperItem calldata item = transferItems[j];\\n\\n                    if (item.itemType == ConduitItemType.ERC20) {\\n                        // Ensure that the identifier of an ERC20 token is 0.\\n                        if (item.identifier != 0) {\\n                            revert InvalidERC20Identifier();\\n                        }\\n                    }\\n\\n                    // If the item is an ERC721 token and\\n                    // callERC721Receiver is true...\\n                    if (item.itemType == ConduitItemType.ERC721) {\\n                        if (callERC721Receiver) {\\n                            // Check if the recipient implements\\n                            // onERC721Received for the given tokenId.\\n                            _checkERC721Receiver(\\n                                conduit,\\n                                transfer.recipient,\\n                                item.identifier\\n                            );\\n                        }\\n                    }\\n\\n                    // Create a ConduitTransfer corresponding to each\\n                    // TransferHelperItem.\\n                    conduitTransfers[itemIndex] = ConduitTransfer(\\n                        item.itemType,\\n                        item.token,\\n                        msg.sender,\\n                        transfer.recipient,\\n                        item.identifier,\\n                        item.amount\\n                    );\\n\\n                    // Increment the index for storing ConduitTransfers.\\n                    ++itemIndex;\\n                }\\n            }\\n        }\\n\\n        // Attempt the external call to transfer tokens via the derived conduit.\\n        try ConduitInterface(conduit).execute(conduitTransfers) returns (\\n            bytes4 conduitMagicValue\\n        ) {\\n            // Check if the value returned from the external call matches\\n            // the conduit `execute` selector.\\n            if (conduitMagicValue != ConduitInterface.execute.selector) {\\n                // If the external call fails, revert with the conduit key\\n                // and conduit address.\\n                revert InvalidConduit(conduitKey, conduit);\\n            }\\n        } catch Error(string memory reason) {\\n            // Catch reverts with a provided reason string and\\n            // revert with the reason, conduit key and conduit address.\\n            revert ConduitErrorRevertString(reason, conduitKey, conduit);\\n        } catch (bytes memory data) {\\n            // Conduits will throw a custom error when attempting to transfer\\n            // native token item types or an ERC721 item amount other than 1.\\n            // Bubble up these custom errors when encountered. Note that the\\n            // conduit itself will bubble up revert reasons from transfers as\\n            // well, meaning that these errors are not necessarily indicative of\\n            // an issue with the item type or amount in cases where the same\\n            // custom error signature is encountered during a conduit transfer.\\n\\n            // Set initial value of first four bytes of revert data to the mask.\\n            bytes4 customErrorSelector = bytes4(0xffffffff);\\n\\n            // Utilize assembly to read first four bytes (if present) directly.\\n            assembly {\\n                // Combine original mask with first four bytes of revert data.\\n                customErrorSelector := and(\\n                    mload(add(data, 0x20)), // Data begins after length offset.\\n                    customErrorSelector\\n                )\\n            }\\n\\n            // Pass through the custom error in question if the revert data is\\n            // the correct length and matches an expected custom error selector.\\n            if (\\n                data.length == 4 &&\\n                customErrorSelector == InvalidItemType.selector\\n            ) {\\n                // \\\"Bubble up\\\" the revert reason.\\n                assembly {\\n                    revert(add(data, 0x20), 0x04)\\n                }\\n            } else if (\\n                data.length == 36 &&\\n                customErrorSelector == InvalidERC721TransferAmount.selector\\n            ) {\\n                // \\\"Bubble up\\\" the revert reason.\\n                assembly {\\n                    revert(add(data, 0x20), 0x24)\\n                }\\n            }\\n\\n            // Catch all other reverts from the external call to the conduit and\\n            // include the conduit's raw revert reason as a data argument to a\\n            // new custom error.\\n            revert ConduitErrorRevertBytes(data, conduitKey, conduit);\\n        }\\n    }\\n\\n    /**\\n     * @notice An internal function to check if a recipient address implements\\n     *         onERC721Received for a given tokenId. Note that this check does\\n     *         not adhere to the safe transfer specification and is only meant\\n     *         to provide an additional layer of assurance that the recipient\\n     *         can receive the tokens — any hooks or post-transfer checks will\\n     *         fail and the caller will be the transfer helper rather than the\\n     *         ERC721 contract. Note that the conduit is set as the operator, as\\n     *         it will be the caller once the transfer is performed.\\n     *\\n     * @param conduit   The conduit to provide as the operator when calling\\n     *                  onERC721Received.\\n     * @param recipient The ERC721 recipient on which to call onERC721Received.\\n     * @param tokenId   The ERC721 tokenId of the token being transferred.\\n     */\\n    function _checkERC721Receiver(\\n        address conduit,\\n        address recipient,\\n        uint256 tokenId\\n    ) internal {\\n        // Check if recipient can receive ERC721 tokens.\\n        try\\n            IERC721Receiver(recipient).onERC721Received(\\n                conduit,\\n                msg.sender,\\n                tokenId,\\n                \\\"\\\"\\n            )\\n        returns (bytes4 selector) {\\n            // Check if onERC721Received selector is valid.\\n            if (selector != IERC721Receiver.onERC721Received.selector) {\\n                // Revert if recipient cannot accept\\n                // ERC721 tokens.\\n                revert InvalidERC721Recipient(recipient);\\n            }\\n        } catch (bytes memory data) {\\n            // \\\"Bubble up\\\" recipient's revert reason.\\n            revert ERC721ReceiverErrorRevertBytes(\\n                data,\\n                recipient,\\n                msg.sender,\\n                tokenId\\n            );\\n        } catch Error(string memory reason) {\\n            // \\\"Bubble up\\\" recipient's revert reason.\\n            revert ERC721ReceiverErrorRevertString(\\n                reason,\\n                recipient,\\n                msg.sender,\\n                tokenId\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice An internal function that reverts if the passed-in recipient\\n     *         is the zero address.\\n     *\\n     * @param recipient The recipient on which to perform the check.\\n     */\\n    function _checkRecipientIsNotZeroAddress(address recipient) internal pure {\\n        // Revert if the recipient is the zero address.\\n        if (recipient == address(0x0)) {\\n            revert RecipientCannotBeZeroAddress();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TransferHelperErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title TransferHelperErrors\\n */\\ninterface TransferHelperErrors {\\n    /**\\n     * @dev Revert with an error when attempting to execute transfers with a\\n     *      NATIVE itemType.\\n     */\\n    error InvalidItemType();\\n\\n    /**\\n     * @dev Revert with an error when an ERC721 transfer with amount other than\\n     *      one is attempted.\\n     *\\n     * @param amount The amount of the ERC721 tokens to transfer.\\n     */\\n    error InvalidERC721TransferAmount(uint256 amount);\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute an ERC721 transfer\\n     *      to an invalid recipient.\\n     */\\n    error InvalidERC721Recipient(address recipient);\\n\\n    /**\\n     * @dev Revert with an error when a call to an ERC721 receiver reverts with\\n     *      bytes data.\\n     */\\n    error ERC721ReceiverErrorRevertBytes(\\n        bytes reason,\\n        address receiver,\\n        address sender,\\n        uint256 identifier\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a call to an ERC721 receiver reverts with\\n     *      string reason.\\n     */\\n    error ERC721ReceiverErrorRevertString(\\n        string reason,\\n        address receiver,\\n        address sender,\\n        uint256 identifier\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an ERC20 token has an invalid identifier.\\n     */\\n    error InvalidERC20Identifier();\\n\\n    /**\\n     * @dev Revert with an error if the recipient is the zero address.\\n     */\\n    error RecipientCannotBeZeroAddress();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order referencing an\\n     *      invalid conduit (i.e. one that has not been deployed).\\n     */\\n    error InvalidConduit(bytes32 conduitKey, address conduit);\\n\\n    /**\\n     * @dev Revert with an error when a call to a conduit reverts with a\\n     *      reason string.\\n     */\\n    error ConduitErrorRevertString(\\n        string reason,\\n        bytes32 conduitKey,\\n        address conduit\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a call to a conduit reverts with bytes\\n     *      data.\\n     */\\n    error ConduitErrorRevertBytes(\\n        bytes reason,\\n        bytes32 conduitKey,\\n        address conduit\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/test/ERC721ReceiverMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\nimport { IERC721Receiver } from \\\"../interfaces/IERC721Receiver.sol\\\";\\n\\ncontract ERC721ReceiverMock is IERC721Receiver {\\n    enum Error {\\n        None,\\n        RevertWithMessage,\\n        RevertWithoutMessage,\\n        Panic\\n    }\\n\\n    bytes4 private immutable _retval;\\n    Error private immutable _error;\\n\\n    event Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes data,\\n        uint256 gas\\n    );\\n\\n    constructor(bytes4 retval, Error error) {\\n        _retval = retval;\\n        _error = error;\\n    }\\n\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public override returns (bytes4) {\\n        if (_error == Error.RevertWithMessage) {\\n            revert(\\\"ERC721ReceiverMock: reverting\\\");\\n        } else if (_error == Error.RevertWithoutMessage) {\\n            revert();\\n        } else if (_error == Error.Panic) {\\n            uint256 a = uint256(0) / uint256(0);\\n            a;\\n        }\\n        emit Received(operator, from, tokenId, data, gasleft());\\n        return _retval;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ImmutableCreate2FactoryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title ImmutableCreate2FactoryInterface\\n * @author 0age\\n * @notice This contract provides a safeCreate2 function that takes a salt value\\n *         and a block of initialization code as arguments and passes them into\\n *         inline assembly. The contract prevents redeploys by maintaining a\\n *         mapping of all contracts that have already been deployed, and\\n *         prevents frontrunning or other collisions by requiring that the first\\n *         20 bytes of the salt are equal to the address of the caller (this can\\n *         be bypassed by setting the first 20 bytes to the null address). There\\n *         is also a view function that computes the address of the contract\\n *         that will be created when submitting a given salt or nonce along with\\n *         a given block of initialization code.\\n */\\ninterface ImmutableCreate2FactoryInterface {\\n    /**\\n     * @dev Create a contract using CREATE2 by submitting a given salt or nonce\\n     *      along with the initialization code for the contract. Note that the\\n     *      first 20 bytes of the salt must match those of the calling address,\\n     *      which prevents contract creation events from being submitted by\\n     *      unintended parties.\\n     *\\n     * @param salt               The nonce that will be passed into the CREATE2\\n     *                           call.\\n     * @param initializationCode The initialization code that will be passed\\n     *                           into the CREATE2 call.\\n     *\\n     * @return deploymentAddress Address of the contract that will be created.\\n     */\\n    function safeCreate2(\\n        bytes32 salt,\\n        bytes calldata initializationCode\\n    ) external payable returns (address deploymentAddress);\\n\\n    /**\\n     * @dev Compute the address of the contract that will be created when\\n     *      submitting a given salt or nonce to the contract along with the\\n     *      contract's initialization code. The CREATE2 address is computed in\\n     *      accordance with EIP-1014, and adheres to the formula therein of\\n     *      `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]`\\n     *      when performing the computation. The computed address is then\\n     *      checked for any existing contract code - if so, the null address\\n     *      will be returned instead.\\n     *\\n     * @param salt     The nonce passed into the CREATE2 address calculation.\\n     * @param initCode The contract initialization code to be used that will be\\n     *                 passed into the CREATE2 address calculation.\\n     *\\n     * @return deploymentAddress Address of the contract that will be created,\\n     *                           or the null address if a contract already\\n     *                           exists at that address.\\n     */\\n    function findCreate2Address(\\n        bytes32 salt,\\n        bytes calldata initCode\\n    ) external view returns (address deploymentAddress);\\n\\n    /**\\n     * @dev Compute the address of the contract that will be created when\\n     *      submitting a given salt or nonce to the contract along with the\\n     *      keccak256 hash of the contract's initialization code. The CREATE2\\n     *      address is computed in accordance with EIP-1014, and adheres to the\\n     *      `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]`\\n     *      formula when performing the computation. The computed address is\\n     *      then checked for any existing contract code - if so, the null\\n     *      address will be returned instead.\\n     *\\n     * @param salt         The nonce passed into the CREATE2 address\\n     *                     calculation.\\n     * @param initCodeHash The keccak256 hash of the initialization code that\\n     *                     will be passed into the CREATE2 address calculation.\\n     *\\n     * @return deploymentAddress Address of the contract that will be created,\\n     *                           or the null address if a contract already\\n     *                           exists at that address.\\n     */\\n    function findCreate2AddressViaHash(\\n        bytes32 salt,\\n        bytes32 initCodeHash\\n    ) external view returns (address deploymentAddress);\\n\\n    /**\\n     * @dev Determine if a contract has already been deployed by the factory to\\n     *      a given address.\\n     *\\n     * @param deploymentAddress The contract address to check.\\n     *\\n     * @return True if the contract has been deployed, false otherwise.\\n     */\\n    function hasBeenDeployed(\\n        address deploymentAddress\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/test/EIP1271Wallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface ERC20ApprovalInterface {\\n    function approve(address, uint256) external returns (bool);\\n}\\n\\ninterface NFTApprovalInterface {\\n    function setApprovalForAll(address, bool) external;\\n}\\n\\ncontract EIP1271Wallet {\\n    bytes4 private constant _EIP_1271_MAGIC_VALUE = 0x1626ba7e;\\n\\n    address public immutable owner;\\n\\n    bool public showRevertMessage;\\n\\n    mapping(bytes32 => bool) public digestApproved;\\n\\n    bool public isValid;\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n        showRevertMessage = true;\\n        isValid = true;\\n    }\\n\\n    function setValid(bool valid) external {\\n        isValid = valid;\\n    }\\n\\n    function revertWithMessage(bool showMessage) external {\\n        showRevertMessage = showMessage;\\n    }\\n\\n    function registerDigest(bytes32 digest, bool approved) external {\\n        digestApproved[digest] = approved;\\n    }\\n\\n    function approveERC20(\\n        ERC20ApprovalInterface token,\\n        address operator,\\n        uint256 amount\\n    ) external {\\n        if (msg.sender != owner) {\\n            revert(\\\"Only owner\\\");\\n        }\\n\\n        token.approve(operator, amount);\\n    }\\n\\n    function approveNFT(NFTApprovalInterface token, address operator) external {\\n        if (msg.sender != owner) {\\n            revert(\\\"Only owner\\\");\\n        }\\n\\n        token.setApprovalForAll(operator, true);\\n    }\\n\\n    function isValidSignature(\\n        bytes32 digest,\\n        bytes memory signature\\n    ) external view returns (bytes4) {\\n        if (digestApproved[digest]) {\\n            return _EIP_1271_MAGIC_VALUE;\\n        }\\n\\n        // NOTE: this is obviously not secure, do not use outside of testing.\\n        if (signature.length == 64) {\\n            // All signatures of length 64 are OK as long as valid is true\\n            return isValid ? _EIP_1271_MAGIC_VALUE : bytes4(0xffffffff);\\n        }\\n\\n        if (signature.length != 65) {\\n            revert();\\n        }\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        if (\\n            uint256(s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) {\\n            revert();\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            revert();\\n        }\\n\\n        address signer = ecrecover(digest, v, r, s);\\n\\n        if (signer == address(0)) {\\n            revert();\\n        }\\n\\n        if (signer != owner) {\\n            if (showRevertMessage) {\\n                revert(\\\"BAD SIGNER\\\");\\n            }\\n\\n            revert();\\n        }\\n\\n        return isValid ? _EIP_1271_MAGIC_VALUE : bytes4(0xffffffff);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/ERC1155BatchRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ncontract ERC1155BatchRecipient {\\n    error UnexpectedBatchData();\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes memory data\\n    ) external pure returns (bytes4) {\\n        if (data.length != 0) {\\n            revert UnexpectedBatchData();\\n        }\\n        return ERC1155BatchRecipient.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/ExcessReturnDataRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\ncontract ExcessReturnDataRecipient {\\n    uint256 private revertDataSize;\\n\\n    function setRevertDataSize(uint256 size) external {\\n        revertDataSize = size;\\n    }\\n\\n    // Code created with the help of Stack Exchange question\\n    // https://ethereum.stackexchange.com/questions/8086\\n    // Question by Doug King:\\n    // https://ethereum.stackexchange.com/users/2041/doug-king\\n    // Answer by Tjaden Hess:\\n    // https://ethereum.stackexchange.com/users/131/tjaden-hess\\n    // Modified to use Yul instead of Solidity and added change of\\n    // base to convert to natural logarithm\\n    function ln(uint256 x) internal pure returns (uint256 y) {\\n        assembly {\\n            let arg := x\\n            x := sub(x, 1)\\n            x := or(x, div(x, 0x02))\\n            x := or(x, div(x, 0x04))\\n            x := or(x, div(x, 0x10))\\n            x := or(x, div(x, 0x100))\\n            x := or(x, div(x, 0x10000))\\n            x := or(x, div(x, 0x100000000))\\n            x := or(x, div(x, 0x10000000000000000))\\n            x := or(x, div(x, 0x100000000000000000000000000000000))\\n            x := add(x, 1)\\n            let m := mload(0x40)\\n            mstore(\\n                m,\\n                0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd\\n            )\\n            mstore(\\n                add(m, 0x20),\\n                0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe\\n            )\\n            mstore(\\n                add(m, 0x40),\\n                0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616\\n            )\\n            mstore(\\n                add(m, 0x60),\\n                0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff\\n            )\\n            mstore(\\n                add(m, 0x80),\\n                0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e\\n            )\\n            mstore(\\n                add(m, 0xa0),\\n                0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707\\n            )\\n            mstore(\\n                add(m, 0xc0),\\n                0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606\\n            )\\n            mstore(\\n                add(m, 0xe0),\\n                0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100\\n            )\\n            mstore(0x40, add(m, 0x100))\\n            let\\n                magic\\n            := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\\n            let\\n                shift\\n            := 0x100000000000000000000000000000000000000000000000000000000000000\\n            let a := div(mul(x, magic), shift)\\n            y := div(mload(add(m, sub(255, a))), shift)\\n            y := add(\\n                y,\\n                mul(\\n                    256,\\n                    gt(\\n                        arg,\\n                        0x8000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                )\\n            )\\n            y := mul(y, 10000000000000000)\\n            y := div(y, 14426950408889632)\\n        }\\n    }\\n\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            switch gt(y, 3)\\n            case 1 {\\n                z := y\\n                let x := div(add(y, 1), 2)\\n                for {\\n\\n                } lt(x, z) {\\n\\n                } {\\n                    z := x\\n                    x := div(add(div(y, x), x), 2)\\n                }\\n            }\\n            case 0 {\\n                z := 1\\n            }\\n        }\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external view returns (bytes4 magic) {\\n        magic = this.onERC1155Received.selector;\\n        if (revertDataSize > 0) {\\n            uint256 gasToCalculateSqrt = (54 * ln(gasleft())) + 1200;\\n            uint256 w = (sqrt(\\n                2048 * (gasleft() - gasToCalculateSqrt) + 9431040\\n            ) - 3072) / 4;\\n\\n            assembly {\\n                let size := mul(w, 32)\\n                calldatacopy(0, 0, mul(w, 32))\\n                revert(0, size)\\n            }\\n        }\\n    }\\n\\n    receive() external payable {\\n        if (revertDataSize > 0) {\\n            uint256 gasToCalculateSqrt = (54 * ln(gasleft())) + 1200;\\n            uint256 w = (sqrt(\\n                2048 * (gasleft() - gasToCalculateSqrt) + 9431040\\n            ) - 3072) / 2;\\n\\n            assembly {\\n                let size := mul(w, 32)\\n                calldatacopy(0, 0, mul(w, 32))\\n                revert(0, size)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/InvalidERC721Recipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external returns (bytes4);\\n}\\n\\ncontract InvalidERC721Recipient is IERC721Receiver {\\n    function onERC721Received(\\n        address /* operator */,\\n        address /* from */,\\n        uint256 /* tokenId */,\\n        bytes calldata /* data */\\n    ) external pure override returns (bytes4) {\\n        return 0xabcd0000;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/Reenterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ncontract Reenterer {\\n    bool public isPrepared;\\n    address public target;\\n    uint256 public msgValue;\\n    bytes public callData;\\n\\n    event Reentered(bytes returnData);\\n\\n    function prepare(\\n        address targetToUse,\\n        uint256 msgValueToUse,\\n        bytes calldata callDataToUse\\n    ) external {\\n        target = targetToUse;\\n        msgValue = msgValueToUse;\\n        callData = callDataToUse;\\n        isPrepared = true;\\n    }\\n\\n    receive() external payable {\\n        if (isPrepared) {\\n            (bool success, bytes memory returnData) = target.call{\\n                value: msgValue\\n            }(callData);\\n\\n            if (!success) {\\n                assembly {\\n                    returndatacopy(0, 0, returndatasize())\\n                    revert(0, returndatasize())\\n                }\\n            }\\n            emit Reentered(returnData);\\n\\n            isPrepared = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@rari-capital/solmate/src/tokens/ERC1155.sol\\\";\\n\\n// Used for minting test ERC1155s in our tests\\ncontract TestERC1155 is ERC1155 {\\n    function mint(\\n        address to,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) public returns (bool) {\\n        _mint(to, tokenId, amount, \\\"\\\");\\n        return true;\\n    }\\n\\n    function uri(uint256) public pure override returns (string memory) {\\n        return \\\"uri\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i = 0; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestERC1155Revert.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ncontract TestERC1155Revert {\\n    function safeTransferFrom(\\n        address /* from */,\\n        address /* to */,\\n        uint256 /* id */,\\n        uint256 /* amount */,\\n        bytes memory /* data */\\n    ) public pure {\\n        revert(\\\"Some ERC1155 revert message\\\");\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address /* from */,\\n        address /* to */,\\n        uint256[] memory /* ids */,\\n        uint256[] memory /* values */,\\n        bytes memory /* data */\\n    ) public pure {\\n        revert(\\\"Some ERC1155 revert message for batch transfers\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\n\\n// Used for minting test ERC20s in our tests\\ncontract TestERC20 is ERC20(\\\"Test20\\\", \\\"TST20\\\", 18) {\\n    bool public blocked;\\n\\n    bool public noReturnData;\\n\\n    constructor() {\\n        blocked = false;\\n        noReturnData = false;\\n    }\\n\\n    function blockTransfer(bool blocking) external {\\n        blocked = blocking;\\n    }\\n\\n    function setNoReturnData(bool noReturn) external {\\n        noReturnData = noReturn;\\n    }\\n\\n    function mint(address to, uint256 amount) external returns (bool) {\\n        _mint(to, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public override returns (bool ok) {\\n        if (blocked) {\\n            return false;\\n        }\\n\\n        super.transferFrom(from, to, amount);\\n\\n        if (noReturnData) {\\n            assembly {\\n                return(0, 0)\\n            }\\n        }\\n\\n        ok = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestERC20Revert.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\n\\ncontract TestERC20Revert is ERC20(\\\"TestRevert\\\", \\\"REVERT\\\", 18) {\\n    function mint(address to, uint256 amount) external {\\n        _mint(to, amount);\\n    }\\n\\n    function transferFrom(\\n        address /* from */,\\n        address /* to */,\\n        uint256 /* amount */\\n    ) public pure override returns (bool) {\\n        revert(\\\"Some ERC20 revert message\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestERC20Panic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\n\\ncontract TestERC20Panic is ERC20(\\\"TestPanic\\\", \\\"PANIC\\\", 18) {\\n    function mint(address to, uint256 amount) external returns (bool) {\\n        _mint(to, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address /* from */,\\n        address /* to */,\\n        uint256 /* amount */\\n    ) public pure override returns (bool) {\\n        uint256 a = uint256(0) / uint256(0);\\n        a;\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestERC20NotOk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\n\\n// Used for minting test ERC20s in our tests.\\ncontract TestERC20NotOk is ERC20(\\\"Test20NotOk\\\", \\\"TST20NO\\\", 18) {\\n    bool public notOk;\\n\\n    function mint(address to, uint256 amount) external returns (bool) {\\n        _mint(to, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address /* from */,\\n        address /* to */,\\n        uint256 /* amount */\\n    ) public pure override returns (bool) {\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport \\\"@rari-capital/solmate/src/tokens/ERC721.sol\\\";\\n\\n// Used for minting test ERC721s in our tests\\ncontract TestERC721 is ERC721(\\\"Test721\\\", \\\"TST721\\\") {\\n    function mint(address to, uint256 tokenId) public returns (bool) {\\n        _mint(to, tokenId);\\n        return true;\\n    }\\n\\n    function tokenURI(uint256) public pure override returns (string memory) {\\n        return \\\"tokenURI\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestERC721Revert.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ncontract TestERC721Revert {\\n    function transferFrom(\\n        address /* from */,\\n        address /* to */,\\n        uint256 /* amount */\\n    ) public pure {\\n        revert(\\\"Some ERC721 revert message\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 4294967295\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduitController\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadContractSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadFraction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BadReturnValueFromERC20OnTransfer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"BadSignatureV\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotCancelOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConsiderationCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConsiderationLengthNotEqualToTotalOriginal\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfallAmount\",\"type\":\"uint256\"}],\"name\":\"ConsiderationNotMet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CriteriaNotEnabledForItem\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"identifiers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"ERC1155BatchTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InexactFraction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientEtherSupplied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Invalid1155BatchTransferEncoding\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBasicOrderParameterEncoding\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidCallToConduit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidConduit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidContractOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InvalidERC721TransferAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFulfillmentComponentData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InvalidMsgValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNativeOfferItem\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidRestrictedOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSigner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fulfillmentIndex\",\"type\":\"uint256\"}],\"name\":\"MismatchedFulfillmentOfferAndConsiderationComponents\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"MissingFulfillmentComponentOnAggregation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingItemAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingOriginalConsiderationItems\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NoContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoReentrantCalls\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSpecifiedOrdersAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferAndConsiderationRequiredOnFulfillment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderAlreadyFilled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"OrderCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderIsCancelled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderPartiallyFilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartialFillsNotEnabledForOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationIndex\",\"type\":\"uint256\"}],\"name\":\"UnresolvedConsiderationCriteria\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerIndex\",\"type\":\"uint256\"}],\"name\":\"UnresolvedOfferCriteria\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnusedItemParameters\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCounter\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"CounterIncremented\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct SpentItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct ReceivedItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"}],\"name\":\"OrderFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct OrderParameters\",\"name\":\"orderParameters\",\"type\":\"tuple\"}],\"name\":\"OrderValidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"orderHashes\",\"type\":\"bytes32[]\"}],\"name\":\"OrdersMatched\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderComponents[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"fulfillAdvancedOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"\",\"type\":\"tuple[][]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumFulfilled\",\"type\":\"uint256\"}],\"name\":\"fulfillAvailableAdvancedOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"\",\"type\":\"tuple[][]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maximumFulfilled\",\"type\":\"uint256\"}],\"name\":\"fulfillAvailableOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"considerationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"considerationIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"offerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum BasicOrderType\",\"name\":\"basicOrderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"offererConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalAdditionalRecipients\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct AdditionalRecipient[]\",\"name\":\"additionalRecipients\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct BasicOrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"fulfillBasicOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"}],\"name\":\"fulfillOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractOfferer\",\"type\":\"address\"}],\"name\":\"getContractOffererNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"getCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderComponents\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"getOrderStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValidated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCancelled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalFilled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incrementCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newCounter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"information\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduitController\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"offerComponents\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"considerationComponents\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fulfillment[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"matchAdvancedOrders\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"offerComponents\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"considerationComponents\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fulfillment[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"name\":\"matchOrders\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SeaportAlphaVersion","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"00000000000000000000000000000000f9490004c11cef243f5400493c00ad63","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"none://none"}]