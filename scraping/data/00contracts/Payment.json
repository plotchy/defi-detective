[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n\r\ninterface RTCoinInterface {\r\n    \r\n\r\n    /** Functions - ERC20 */\r\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function transferFrom(address _owner, address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _amount) external returns (bool approved);\r\n\r\n    /** Getters - ERC20 */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _holder) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n    /** Getters - Custom */\r\n    function mint(address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function stakeContractAddress() external view returns (address);\r\n\r\n    function mergedMinerValidatorAddress() external view returns (address);\r\n    \r\n    /** Functions - Custom */\r\n    function freezeTransfers() external returns (bool);\r\n\r\n    function thawTransfers() external returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  // We use `pure` bbecause it promises that the value for the function depends ONLY\r\n  // on the function arguments\r\n    function mul(uint256 a, uint256 b) internal pure  returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/// @title TEMPORAL Payment Contract\r\n/// @author Postables, RTrade Technologies Ltd\r\n/// @dev We able V5 for safety features, see https://solidity.readthedocs.io/en/v0.4.24/security-considerations.html#take-warnings-seriously\r\ncontract Payments {\r\n    using SafeMath for uint256;    \r\n\r\n    // we mark as constant private to save gas\r\n    bytes constant private PREFIX = \"\\x19Ethereum Signed Message:\\n32\";\r\n    // these addresses will need to be changed before deployment, and validated after deployment\r\n    // we hardcode them for security reasons to avoid any possible risk of compromised accounts being able to change anything on this contract.\r\n    // in the event that one of the addresses is compromised, the contract will be self destructed\r\n    address constant private SIGNER = 0xa80cD01dD37c29116549AA879c44C824b703828A;\r\n    address constant private TOKENADDRESS = 0xecc043b92834c1ebDE65F2181B59597a6588D616;\r\n    address constant private HOTWALLET = 0x3eC6481365c2c2b37d7b939B5854BFB7e5e83C10;\r\n    RTCoinInterface constant private RTI = RTCoinInterface(TOKENADDRESS);\r\n    string constant public VERSION = \"production\";\r\n\r\n    address public admin;\r\n\r\n    // PaymentState will keep track of the state of a payment, nil means we havent seen th payment before\r\n    enum PaymentState{ nil, paid }\r\n    // How payments can be made, RTC or eth\r\n    enum PaymentMethod{ RTC, ETH }\r\n\r\n    struct PaymentStruct {\r\n        uint256 paymentNumber;\r\n        uint256 chargeAmountInWei;\r\n        PaymentMethod method;\r\n        PaymentState state;\r\n    }\r\n\r\n    mapping (address => uint256) public numPayments;\r\n    mapping (address => mapping(uint256 => PaymentStruct)) public payments;\r\n\r\n    event PaymentMade(address _payer, uint256 _paymentNumber, uint8 _paymentMethod, uint256 _paymentAmount);\r\n\r\n    modifier validPayment(uint256 _paymentNumber) {\r\n        require(payments[msg.sender][_paymentNumber].state == PaymentState.nil, \"payment already made\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"sender must be admin\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /** @notice Used to submit a payment for TEMPORAL uploads\r\n        * @dev Can use ERC191 or non ERC191 signed messages\r\n        * @param _h This is the message hash that has been signed\r\n        * @param _v This is pulled from the signature\r\n        * @param _r This is pulled from the signature\r\n        * @param _s This is pulled from the signature\r\n        * @param _paymentNumber This is the current payments number (how many payments the user has submitted)\r\n        * @param _paymentMethod This is the payment method (RTC, ETH) being used\r\n        * @param _chargeAmountInWei This is how much the user is to be charged\r\n        * @param _prefixed This indicates whether or not the signature was generated using ERC191 standards\r\n     */\r\n    function makePayment(\r\n        bytes32 _h,\r\n        uint8   _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint256 _paymentNumber,\r\n        uint8   _paymentMethod,\r\n        uint256 _chargeAmountInWei,\r\n        bool   _prefixed) // this allows us to sign messages on our own, without prefix https://github.com/ethereum/EIPs/issues/191\r\n        public\r\n        payable\r\n        validPayment(_paymentNumber)\r\n        returns (bool)\r\n    {\r\n        require(_paymentMethod == 0 || _paymentMethod == 1, \"invalid payment method\");\r\n        bytes32 image;\r\n        if (_prefixed) {\r\n            bytes32 preimage = generatePreimage(_paymentNumber, _chargeAmountInWei, _paymentMethod);\r\n            image = generatePrefixedPreimage(preimage);\r\n        } else {\r\n            image = generatePreimage(_paymentNumber, _chargeAmountInWei, _paymentMethod);\r\n        }\r\n        // ensure that the preimages construct properly\r\n        require(image == _h, \"reconstructed preimage does not match\");\r\n        address signer = ecrecover(_h, _v, _r, _s);\r\n        // ensure that we actually signed this message\r\n        require(signer == SIGNER, \"recovered signer does not match\");\r\n        PaymentStruct memory ps = PaymentStruct({\r\n            paymentNumber: _paymentNumber,\r\n            chargeAmountInWei: _chargeAmountInWei,\r\n            method: PaymentMethod(_paymentMethod),\r\n            state: PaymentState.paid\r\n        });\r\n        payments[msg.sender][_paymentNumber] = ps;\r\n        numPayments[msg.sender] = numPayments[msg.sender].add(1);\r\n        // if they are opting to pay in eth run this block of code, otherwise make the payment in RTC\r\n        if (PaymentMethod(_paymentMethod) == PaymentMethod.ETH) {\r\n            require(msg.value == _chargeAmountInWei, \"msg.value does not equal charge amount\");\r\n            emit PaymentMade(msg.sender, _paymentNumber, _paymentMethod, _chargeAmountInWei);\r\n            HOTWALLET.transfer(msg.value);\r\n            return true;\r\n        }\r\n        emit PaymentMade(msg.sender, _paymentNumber, _paymentMethod, _chargeAmountInWei);\r\n        require(RTI.transferFrom(msg.sender, HOTWALLET, _chargeAmountInWei), \"trasferFrom failed, most likely needs approval\");\r\n        return true;\r\n    }\r\n\r\n    /** @notice This is a helper function used to verify whether or not the provided arguments can reconstruct the message hash\r\n        * @param _h This is the message hash which is signed, and will be reconstructed\r\n        * @param _paymentNumber This is the number of payment\r\n        * @param _paymentMethod This is the payment method (RTC, ETH) being used\r\n        * @param _chargeAmountInWei This is the amount the user is to be charged\r\n        * @param _prefixed This indicates whether the message was signed according to ERC191\r\n     */\r\n    function verifyImages(\r\n        bytes32 _h,\r\n        uint256 _paymentNumber,\r\n        uint8   _paymentMethod,\r\n        uint256 _chargeAmountInWei,\r\n        bool   _prefixed)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(_paymentMethod == 0 || _paymentMethod == 1, \"invalid payment method\");\r\n        bytes32 image;\r\n        if (_prefixed) {\r\n            bytes32 preimage = generatePreimage(_paymentNumber, _chargeAmountInWei, _paymentMethod);\r\n            image = generatePrefixedPreimage(preimage);\r\n        } else {\r\n            image = generatePreimage(_paymentNumber, _chargeAmountInWei, _paymentMethod);\r\n        }\r\n        return image == _h;\r\n    }\r\n\r\n    /** @notice This is a helper function which can be used to verify the signer of a message\r\n        * @param _h This is the message hash that is signed\r\n        * @param _v This is pulled from the signature\r\n        * @param _r This is pulled from the signature\r\n        * @param _s This is pulled from the signature\r\n        * @param _paymentNumber This is the payment number of this particular payment\r\n        * @param _paymentMethod This is the payment method (RTC, ETH) being used\r\n        * @param _chargeAmountInWei This is the amount hte user is to be charged\r\n        * @param _prefixed This indicates whether or not the message was signed using ERC191\r\n     */\r\n    function verifySigner(\r\n        bytes32 _h,\r\n        uint8   _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint256 _paymentNumber,\r\n        uint8   _paymentMethod,\r\n        uint256 _chargeAmountInWei,\r\n        bool   _prefixed)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(_paymentMethod == 0 || _paymentMethod == 1, \"invalid payment method\");\r\n        bytes32 image;\r\n        if (_prefixed) {\r\n            bytes32 preimage = generatePreimage(_paymentNumber, _chargeAmountInWei, _paymentMethod);\r\n            image = generatePrefixedPreimage(preimage);\r\n        } else {\r\n            image = generatePreimage(_paymentNumber, _chargeAmountInWei, _paymentMethod);\r\n        }\r\n        require(image == _h, \"failed to reconstruct preimages\");\r\n        return ecrecover(_h, _v, _r, _s) == SIGNER;\r\n    }\r\n\r\n    /** @notice This is a helper function used to generate a non ERC191 signed message hash\r\n        * @param _paymentNumber This is the payment number of this payment\r\n        * @param _chargeAmountInWei This is the amount the user is to be charged\r\n        * @param _paymentMethod This is the payment method (RTC, ETH) being used\r\n     */\r\n    function generatePreimage(\r\n        uint256 _paymentNumber,\r\n        uint256 _chargeAmountInWei,\r\n        uint8   _paymentMethod)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(msg.sender, _paymentNumber, _paymentMethod, _chargeAmountInWei));\r\n    }\r\n\r\n    /** @notice This is a helper function that prepends the ERC191 signed message prefix\r\n        * @param _preimage This is the reconstructed message hash before being prepened with the ERC191 prefix\r\n     */\r\n    function generatePrefixedPreimage(bytes32 _preimage) internal pure returns (bytes32)  {\r\n        return keccak256(abi.encodePacked(PREFIX, _preimage));\r\n    }\r\n\r\n    /** @notice Used to destroy the contract\r\n     */\r\n    function goodNightSweetPrince() public onlyAdmin returns (bool) {\r\n        selfdestruct(msg.sender);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"numPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"paymentNumber\",\"type\":\"uint256\"},{\"name\":\"chargeAmountInWei\",\"type\":\"uint256\"},{\"name\":\"method\",\"type\":\"uint8\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_paymentNumber\",\"type\":\"uint256\"},{\"name\":\"_paymentMethod\",\"type\":\"uint8\"},{\"name\":\"_chargeAmountInWei\",\"type\":\"uint256\"},{\"name\":\"_prefixed\",\"type\":\"bool\"}],\"name\":\"verifySigner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_paymentNumber\",\"type\":\"uint256\"},{\"name\":\"_paymentMethod\",\"type\":\"uint8\"},{\"name\":\"_chargeAmountInWei\",\"type\":\"uint256\"},{\"name\":\"_prefixed\",\"type\":\"bool\"}],\"name\":\"makePayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_h\",\"type\":\"bytes32\"},{\"name\":\"_paymentNumber\",\"type\":\"uint256\"},{\"name\":\"_paymentMethod\",\"type\":\"uint8\"},{\"name\":\"_chargeAmountInWei\",\"type\":\"uint256\"},{\"name\":\"_prefixed\",\"type\":\"bool\"}],\"name\":\"verifyImages\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"goodNightSweetPrince\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_payer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_paymentNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_paymentMethod\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_paymentAmount\",\"type\":\"uint256\"}],\"name\":\"PaymentMade\",\"type\":\"event\"}]","ContractName":"Payments","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://95c6b1f84f1d7dc57cc8f776cd46eabe86067a3283d964a115d7b8b8bfdd6e7f"}]