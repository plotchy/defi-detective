[{"SourceCode":"// hevm: flattened sources of src/LerpFactory.sol\r\npragma solidity >=0.6.12 <0.7.0;\r\n\r\n////// src/Lerp.sol\r\n//\r\n/// Lerp.sol -- Linear Interpolation module\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.6.12; */\r\n\r\ninterface DenyLike {\r\n    function deny(address) external;\r\n}\r\n\r\ninterface FileLike {\r\n    function file(bytes32, uint256) external;\r\n}\r\n\r\ninterface FileIlkLike {\r\n    function file(bytes32, bytes32, uint256) external;\r\n}\r\n\r\n// Perform linear interpolation on a dss administrative value over time\r\n\r\nabstract contract BaseLerp {\r\n\r\n    uint256 constant WAD = 10 ** 18;\r\n\r\n    address immutable public target;\r\n    bytes32 immutable public what;\r\n    uint256 immutable public start;\r\n    uint256 immutable public end;\r\n    uint256 immutable public duration;\r\n\r\n    bool              public done;\r\n    uint256           public startTime;\r\n\r\n    constructor(address target_, bytes32 what_, uint256 startTime_, uint256 start_, uint256 end_, uint256 duration_) public {\r\n        require(duration_ != 0, \"Lerp/no-zero-duration\");\r\n        require(duration_ <= 365 days, \"Lerp/max-duration-one-year\");\r\n        require(startTime_ <= block.timestamp + 365 days, \"Lerp/start-within-one-year\");\r\n        // This is not the exact upper bound, but it's a practical one\r\n        // Ballparked from 2^256 / 10^18 and verified that this is less than that value\r\n        require(start_ <= 10 ** 59, \"Lerp/start-too-large\");\r\n        require(end_ <= 10 ** 59, \"Lerp/end-too-large\");\r\n        target = target_;\r\n        what = what_;\r\n        startTime = startTime_;\r\n        start = start_;\r\n        end = end_;\r\n        duration = duration_;\r\n    }\r\n\r\n    function tick() external returns (uint256 result) {\r\n        require(!done, \"Lerp/finished\");\r\n        if (block.timestamp >= startTime) {\r\n            if (block.timestamp < startTime + duration) {\r\n                // All bounds are constrained in the constructor so no need for safe-math\r\n                // 0 <= t < WAD\r\n                uint256 t = (block.timestamp - startTime) * WAD / duration;\r\n                // y = (end - start) * t + start [Linear Interpolation]\r\n                //   = end * t + start - start * t [Avoids overflow by moving the subtraction to the end]\r\n                update(result = end * t / WAD + start - start * t / WAD);\r\n            } else {\r\n                // Set the end value and mark as done\r\n                update(result = end);\r\n                try DenyLike(target).deny(address(this)) {} catch {}\r\n                done = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function update(uint256 value) virtual internal;\r\n\r\n}\r\n\r\n// Standard Lerp with only a uint256 value\r\n\r\ncontract Lerp is BaseLerp {\r\n\r\n    constructor(address target_, bytes32 what_, uint256 startTime_, uint256 start_, uint256 end_, uint256 duration_) public BaseLerp(target_, what_, startTime_, start_, end_, duration_) {\r\n    }\r\n\r\n    function update(uint256 value) override internal {\r\n        FileLike(target).file(what, value);\r\n    }\r\n\r\n}\r\n\r\n// Lerp that takes an ilk parameter\r\n\r\ncontract IlkLerp is BaseLerp {\r\n\r\n    bytes32 immutable public ilk;\r\n\r\n    constructor(address target_, bytes32 ilk_, bytes32 what_, uint256 startTime_, uint256 start_, uint256 end_, uint256 duration_) public BaseLerp(target_, what_, startTime_, start_, end_, duration_) {\r\n        ilk = ilk_;\r\n    }\r\n\r\n    function update(uint256 value) override internal {\r\n        FileIlkLike(target).file(ilk, what, value);\r\n    }\r\n\r\n}\r\n\r\n////// src/LerpFactory.sol\r\n//\r\n/// LerpFactory.sol -- Linear Interpolation creation module\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n/* pragma solidity ^0.6.12; */\r\n\r\n/* import \"./Lerp.sol\"; */\r\n\r\ncontract LerpFactory {\r\n\r\n    // --- Auth ---\r\n    function rely(address guy) external auth { wards[guy] = 1; emit Rely(guy); }\r\n    function deny(address guy) external auth { wards[guy] = 0; emit Deny(guy); }\r\n    mapping (address => uint256) public wards;\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"LerpFactory/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    mapping (bytes32 => address) public lerps;\r\n    address[] public active;  // Array of active lerps in no particular order\r\n\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n    event NewLerp(bytes32 name, address indexed target, bytes32 what, uint256 startTime, uint256 start, uint256 end, uint256 duration);\r\n    event NewIlkLerp(bytes32 name, address indexed target, bytes32 ilk, bytes32 what, uint256 startTime, uint256 start, uint256 end, uint256 duration);\r\n    event LerpFinished(address indexed lerp);\r\n\r\n    constructor() public {\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n    }\r\n\r\n    function newLerp(bytes32 name_, address target_, bytes32 what_, uint256 startTime_, uint256 start_, uint256 end_, uint256 duration_) external auth returns (address lerp) {\r\n        lerp = address(new Lerp(target_, what_, startTime_, start_, end_, duration_));\r\n        lerps[name_] = lerp;\r\n        active.push(lerp);\r\n        \r\n        emit NewLerp(name_, target_, what_, startTime_, start_, end_, duration_);\r\n    }\r\n\r\n    function newIlkLerp(bytes32 name_, address target_, bytes32 ilk_, bytes32 what_, uint256 startTime_, uint256 start_, uint256 end_, uint256 duration_) external auth returns (address lerp) {\r\n        lerp = address(new IlkLerp(target_, ilk_, what_, startTime_, start_, end_, duration_));\r\n        lerps[name_] = lerp;\r\n        active.push(lerp);\r\n        \r\n        emit NewIlkLerp(name_, target_, ilk_, what_, startTime_, start_, end_, duration_);\r\n    }\r\n\r\n    function remove(uint256 index) internal {\r\n        address lerp = active[index];\r\n        if (index != active.length - 1) {\r\n            active[index] = active[active.length - 1];\r\n        }\r\n        active.pop();\r\n        \r\n        emit LerpFinished(lerp);\r\n    }\r\n\r\n    // Tick all active lerps or wipe them if they are done\r\n    function tall() external {\r\n        for (uint256 i = 0; i < active.length; i++) {\r\n            BaseLerp lerp = BaseLerp(active[i]);\r\n            try lerp.tick() {} catch {\r\n                // Stop tracking if this lerp fails\r\n                remove(i);\r\n                i--;\r\n            }\r\n            if (lerp.done()) {\r\n                remove(i);\r\n                i--;\r\n            }\r\n        }\r\n    }\r\n\r\n    // The number of active lerps\r\n    function count() external view returns (uint256) {\r\n        return active.length;\r\n    }\r\n\r\n    // Return the entire array of active lerps\r\n    function list() external view returns (address[] memory) {\r\n        return active;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lerp\",\"type\":\"address\"}],\"name\":\"LerpFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"NewIlkLerp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"NewLerp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"active\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lerps\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"list\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"target_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ilk_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"what_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"startTime_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration_\",\"type\":\"uint256\"}],\"name\":\"newIlkLerp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lerp\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"target_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"what_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"startTime_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration_\",\"type\":\"uint256\"}],\"name\":\"newLerp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lerp\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LerpFactory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://af92f58577bdca9aca2dedced076a23ccf04422682ce2fd395ede7ed11f41816"}]