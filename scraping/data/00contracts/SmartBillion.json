[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  address public owner; //owner\r\n  address public animator; //animator\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address to, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  function commitDividend(address who) internal; // pays remaining dividend\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n  function transferFrom(address from, address to, uint value);\r\n  function approve(address spender, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint;\r\n  mapping(address => uint) balances;\r\n\r\n  modifier onlyPayloadSize(uint size) {\r\n     assert(msg.data.length >= size + 4);\r\n     _;\r\n  }\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\r\n    commitDividend(msg.sender);\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    if(_to == address(this)) {\r\n        commitDividend(owner);\r\n        balances[owner] = balances[owner].add(_value);\r\n        Transfer(msg.sender, owner, _value);\r\n    }\r\n    else {\r\n        commitDividend(_to);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n  }\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n\r\ncontract StandardToken is BasicToken, ERC20 {\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint the amout of tokens to be transfered\r\n   */\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n    commitDividend(_from);\r\n    commitDividend(_to);\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n  /**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint _value) {\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n  /**\r\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint specifing the amount of tokens still avaible for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}\r\n\r\n/**\r\n * @title SmartBillions contract\r\n */\r\ncontract SmartBillions is StandardToken {\r\n\r\n    // metadata\r\n    string public constant name = \"SmartBillions Token\";\r\n    string public constant symbol = \"PLAY\";\r\n    uint public constant decimals = 0;\r\n\r\n    // contract state\r\n    struct Wallet {\r\n        uint208 balance; // current balance of user\r\n    \tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\r\n    \tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\r\n    }\r\n    mapping (address => Wallet) wallets;\r\n    struct Bet {\r\n        uint192 value; // bet size\r\n        uint32 betHash; // selected numbers\r\n        uint32 blockNum; // blocknumber when lottery runs\r\n    }\r\n    mapping (address => Bet) bets;\r\n\r\n    uint public walletBalance = 0; // sum of funds in wallets\r\n\r\n    // investment parameters\r\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\r\n    uint public investBalance = 0; // funding from investors\r\n    uint public investBalanceMax = 200000 ether; // maximum funding\r\n    uint public dividendPeriod = 1;\r\n    uint[] public dividends; // dividens collected per period, growing array\r\n\r\n    // betting parameters\r\n    uint public maxWin = 0; // maximum prize won\r\n    uint public hashFirst = 0; // start time of building hashes database\r\n    uint public hashLast = 0; // last saved block of hashes\r\n    uint public hashNext = 0; // next available bet block.number\r\n    uint public hashBetSum = 0; // used bet volume of next block\r\n    uint public hashBetMax = 5 ether; // maximum bet size per block\r\n    uint[] public hashes; // space for storing lottery results\r\n\r\n    // constants\r\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\r\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\r\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\r\n\r\n    // events\r\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\r\n    event LogLoss(address indexed player, uint bethash, uint hash);\r\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\r\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\r\n    event LogRecordWin(address indexed player, uint amount);\r\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\r\n    //event LogWithdraw(address indexed who, uint amount);\r\n\r\n    modifier onlyOwner() {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAnimator() {\r\n        assert(msg.sender == animator);\r\n        _;\r\n    }\r\n\r\n    // constructor\r\n    function SmartBillions() {\r\n        owner = msg.sender;\r\n        animator = msg.sender;\r\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\r\n        //wallets[animator].lastDividendPeriod = uint16(dividendPeriod);\r\n        dividends.push(0); // not used\r\n        dividends.push(0); // current dividend\r\n    }\r\n\r\n/* getters */\r\n    \r\n    /**\r\n     * @dev Show length of allocated swap space\r\n     */\r\n    function hashesLength() constant external returns (uint) {\r\n        return uint(hashes.length);\r\n    }\r\n    \r\n    /**\r\n     * @dev Show balance of wallet\r\n     * @param _owner The address of the account.\r\n     */\r\n    function walletBalanceOf(address _owner) constant external returns (uint) {\r\n        return uint(wallets[_owner].balance);\r\n    }\r\n    \r\n    /**\r\n     * @dev Show last dividend period processed\r\n     * @param _owner The address of the account.\r\n     */\r\n    function walletPeriodOf(address _owner) constant external returns (uint) {\r\n        return uint(wallets[_owner].lastDividendPeriod);\r\n    }\r\n    \r\n    /**\r\n     * @dev Show block number when withdraw can continue\r\n     * @param _owner The address of the account.\r\n     */\r\n    function walletBlockOf(address _owner) constant external returns (uint) {\r\n        return uint(wallets[_owner].nextWithdrawBlock);\r\n    }\r\n    \r\n    /**\r\n     * @dev Show bet size.\r\n     * @param _owner The address of the player.\r\n     */\r\n    function betValueOf(address _owner) constant external returns (uint) {\r\n        return uint(bets[_owner].value);\r\n    }\r\n    \r\n    /**\r\n     * @dev Show block number of lottery run for the bet.\r\n     * @param _owner The address of the player.\r\n     */\r\n    function betHashOf(address _owner) constant external returns (uint) {\r\n        return uint(bets[_owner].betHash);\r\n    }\r\n    \r\n    /**\r\n     * @dev Show block number of lottery run for the bet.\r\n     * @param _owner The address of the player.\r\n     */\r\n    function betBlockNumberOf(address _owner) constant external returns (uint) {\r\n        return uint(bets[_owner].blockNum);\r\n    }\r\n    \r\n    /**\r\n     * @dev Print number of block till next expected dividend payment\r\n     */\r\n    function dividendsBlocks() constant external returns (uint) {\r\n        if(investStart > 0) {\r\n            return(0);\r\n        }\r\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\r\n        if(period > dividendPeriod) {\r\n            return(0);\r\n        }\r\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\r\n    }\r\n\r\n/* administrative functions */\r\n\r\n    /**\r\n     * @dev Change owner.\r\n     * @param _who The address of new owner.\r\n     */\r\n    function changeOwner(address _who) external onlyOwner {\r\n        assert(_who != address(0));\r\n        commitDividend(msg.sender);\r\n        commitDividend(_who);\r\n        owner = _who;\r\n    }\r\n\r\n    /**\r\n     * @dev Change animator.\r\n     * @param _who The address of new animator.\r\n     */\r\n    function changeAnimator(address _who) external onlyAnimator {\r\n        assert(_who != address(0));\r\n        commitDividend(msg.sender);\r\n        commitDividend(_who);\r\n        animator = _who;\r\n    }\r\n\r\n    /**\r\n     * @dev Set ICO Start block.\r\n     * @param _when The block number of the ICO.\r\n     */\r\n    function setInvestStart(uint _when) external onlyOwner {\r\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\r\n        investStart = _when;\r\n    }\r\n\r\n    /**\r\n     * @dev Set maximum bet size per block\r\n     * @param _maxsum The maximum bet size in wei.\r\n     */\r\n    function setBetMax(uint _maxsum) external onlyOwner {\r\n        hashBetMax = _maxsum;\r\n    }\r\n\r\n    /**\r\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\r\n     */\r\n    function resetBet() external onlyOwner {\r\n        hashNext = block.number + 3;\r\n        hashBetSum = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Move funds to cold storage\r\n     * @dev investBalance and walletBalance is protected from withdraw by owner\r\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\r\n     * @param _amount The amount of wei to move to cold storage\r\n     */\r\n    function coldStore(uint _amount) external onlyOwner {\r\n        houseKeeping();\r\n        require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount);\r\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\r\n            require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\r\n        }\r\n        msg.sender.transfer(_amount);\r\n        coldStoreLast = block.number;\r\n    }\r\n\r\n    /**\r\n     * @dev Move funds to contract\r\n     */\r\n    function hotStore() payable external { // not needed because jackpot is protected\r\n        houseKeeping();\r\n    }\r\n\r\n/* housekeeping functions */\r\n\r\n    /**\r\n     * @dev Update accounting\r\n     */\r\n    function houseKeeping() public {\r\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\r\n            investStart = 0; // start dividend payments\r\n        }\r\n        else {\r\n            if(hashFirst > 0){\r\n\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\r\n                if(period > dividends.length - 2) {\r\n                    dividends.push(0);\r\n                }\r\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\r\n                    dividendPeriod++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n/* payments */\r\n\r\n    /**\r\n     * @dev Pay balance from wallet\r\n     */\r\n    function payWallet() public {\r\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\r\n            uint balance = wallets[msg.sender].balance;\r\n            wallets[msg.sender].balance = 0;\r\n            walletBalance -= balance;\r\n            pay(balance);\r\n            //LogWithdraw(msg.sender,balance);\r\n        }\r\n    }\r\n\r\n    function pay(uint _amount) private {\r\n        uint maxpay = this.balance / 2;\r\n        if(maxpay >= _amount) {\r\n            msg.sender.transfer(_amount);\r\n            if(_amount > 1 finney) {\r\n                houseKeeping();\r\n            }\r\n        }\r\n        else {\r\n            uint keepbalance = _amount - maxpay;\r\n            walletBalance += keepbalance;\r\n            wallets[msg.sender].balance += uint208(keepbalance);\r\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\r\n            msg.sender.transfer(maxpay);\r\n        }\r\n    }\r\n\r\n/* investment functions */\r\n\r\n    /**\r\n     * @dev Buy tokens\r\n     */\r\n    function investDirect() payable external {\r\n        invest(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Buy tokens with affiliate partner\r\n     * @param _partner Affiliate partner\r\n     */\r\n    function invest(address _partner) payable public {\r\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\r\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\r\n        uint investing = msg.value;\r\n        if(investing > investBalanceMax - investBalance) {\r\n            investing = investBalanceMax - investBalance;\r\n            investBalance = investBalanceMax;\r\n            investStart = 0; // close investment round\r\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\r\n        }\r\n        else{\r\n            investBalance += investing;\r\n        }\r\n        if(_partner == address(0) || _partner == owner){\r\n            walletBalance += investing / 10;\r\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\r\n        else{\r\n            walletBalance += (investing * 5 / 100) * 2;\r\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\r\n            //wallets[_partner].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\r\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\r\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\r\n        uint senderBalance = investing / 10**15;\r\n        uint ownerBalance = investing * 16 / 10**17  ;\r\n        uint animatorBalance = investing * 10 / 10**17  ;\r\n        balances[msg.sender] += senderBalance;\r\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\r\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\r\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\r\n        Transfer(address(0),msg.sender,senderBalance); // for etherscan\r\n        Transfer(address(0),owner,ownerBalance); // for etherscan\r\n        Transfer(address(0),animator,animatorBalance); // for etherscan\r\n        LogInvestment(msg.sender,_partner,investing);\r\n    }\r\n\r\n    /**\r\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\r\n     */\r\n    function disinvest() external {\r\n        require(investStart == 0);\r\n        commitDividend(msg.sender);\r\n        uint initialInvestment = balances[msg.sender] * 10**15;\r\n        Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\r\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\r\n        investBalance -= initialInvestment;\r\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\r\n        payWallet();\r\n    }\r\n\r\n    /**\r\n     * @dev Pay unpaid dividends\r\n     */\r\n    function payDividends() external {\r\n        require(investStart == 0);\r\n        commitDividend(msg.sender);\r\n        payWallet();\r\n    }\r\n\r\n    /**\r\n     * @dev Commit remaining dividends before transfer of tokens\r\n     */\r\n    function commitDividend(address _who) internal {\r\n        uint last = wallets[_who].lastDividendPeriod;\r\n        if((balances[_who]==0) || (last==0)){\r\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\r\n            return;\r\n        }\r\n        if(last==dividendPeriod) {\r\n            return;\r\n        }\r\n        uint share = balances[_who] * 0xffffffff / totalSupply;\r\n        uint balance = 0;\r\n        for(;last<dividendPeriod;last++) {\r\n            balance += share * dividends[last];\r\n        }\r\n        balance = (balance / 0xffffffff);\r\n        walletBalance += balance;\r\n        wallets[_who].balance += uint208(balance);\r\n        wallets[_who].lastDividendPeriod = uint16(last);\r\n    }\r\n\r\n/* lottery functions */\r\n\r\n    function betPrize(Bet _player, uint24 _hash) constant private returns (uint) { // house fee 13.85%\r\n        uint24 bethash = uint24(_player.betHash);\r\n        uint24 hit = bethash ^ _hash;\r\n        uint24 matches =\r\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\r\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\r\n        if(matches == 6){\r\n            return(uint(_player.value) * 7000000);\r\n        }\r\n        if(matches == 5){\r\n            return(uint(_player.value) * 20000);\r\n        }\r\n        if(matches == 4){\r\n            return(uint(_player.value) * 500);\r\n        }\r\n        if(matches == 3){\r\n            return(uint(_player.value) * 25);\r\n        }\r\n        if(matches == 2){\r\n            return(uint(_player.value) * 3);\r\n        }\r\n        return(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if won in lottery\r\n     */\r\n    function betOf(address _who) constant external returns (uint)  {\r\n        Bet memory player = bets[_who];\r\n        if( (player.value==0) ||\r\n            (player.blockNum<=1) ||\r\n            (block.number<player.blockNum) ||\r\n            (block.number>=player.blockNum + (10 * hashesSize))){\r\n            return(0);\r\n        }\r\n        if(block.number<player.blockNum+256){\r\n            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\r\n        }\r\n        if(hashFirst>0){\r\n            uint32 hash = getHash(player.blockNum);\r\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                return(uint(player.value));\r\n            }\r\n            else{\r\n                return(betPrize(player,uint24(hash)));\r\n            }\r\n\t}\r\n        return(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if won in lottery\r\n     */\r\n    function won() public {\r\n        Bet memory player = bets[msg.sender];\r\n        if(player.blockNum==0){ // create a new player\r\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n            return;\r\n        }\r\n        if((player.value==0) || (player.blockNum==1)){\r\n            payWallet();\r\n            return;\r\n        }\r\n        require(block.number>player.blockNum); // if there is an active bet, throw()\r\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\r\n            LogLate(msg.sender,player.blockNum,block.number);\r\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n            return;\r\n        }\r\n        uint prize = 0;\r\n        uint32 hash = 0;\r\n        if(block.number<player.blockNum+256){\r\n            hash = uint24(block.blockhash(player.blockNum));\r\n            prize = betPrize(player,uint24(hash));\r\n        }\r\n        else {\r\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\r\n                hash = getHash(player.blockNum);\r\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\r\n                    prize = uint(player.value);\r\n                }\r\n                else{\r\n                    prize = betPrize(player,uint24(hash));\r\n                }\r\n\t    }\r\n            else{\r\n                LogLate(msg.sender,player.blockNum,block.number);\r\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n                return();\r\n            }\r\n        }\r\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\r\n        if(prize>0) {\r\n            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\r\n            if(prize > maxWin){\r\n                maxWin = prize;\r\n                LogRecordWin(msg.sender,prize);\r\n            }\r\n            pay(prize);\r\n        }\r\n        else{\r\n            LogLoss(msg.sender,uint(player.betHash),uint(hash));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Send less than 1 ether to contract to play or send 0 to retrieve funds\r\n     */\r\n    function () payable external {\r\n        if(msg.value > 0){\r\n            play();\r\n            return;\r\n        }\r\n        //check for dividends and other assets\r\n        if(investStart == 0 && balances[msg.sender]>0){\r\n            commitDividend(msg.sender);}\r\n        won(); // will run payWallet() if nothing else available\r\n    }\r\n\r\n    /**\r\n     * @dev Play in lottery\r\n     */\r\n    function play() payable public returns (uint) {\r\n        return playSystem(uint(sha3(msg.sender,block.number)), address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Play in lottery with random numbers\r\n     * @param _partner Affiliate partner\r\n     */\r\n    function playRandom(address _partner) payable public returns (uint) {\r\n        return playSystem(uint(sha3(msg.sender,block.number)), _partner);\r\n    }\r\n\r\n    //function playSystem(uint8 num1, uint8 num2, uint8 num3, address _partner) payable public returns (uint) {\r\n    //    return playHash(uint24(num1)|(uint24(num2)<<8)|(uint24(num3)<<16), _partner);\r\n    //}\r\n    \r\n    /**\r\n     * @dev Play in lottery with own numbers\r\n     * @param _partner Affiliate partner\r\n     */\r\n    function playSystem(uint _hash, address _partner) payable public returns (uint) {\r\n        won(); // check if player did not win \r\n        uint24 bethash = uint24(_hash);\r\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\r\n        if(msg.value > 0){\r\n            if(investStart==0) { // dividends only after investment finished\r\n                dividends[dividendPeriod] += msg.value / 34; // 3% dividend\r\n            }\r\n            if(_partner != address(0)) {\r\n                uint fee = msg.value / 100;\r\n                walletBalance += fee;\r\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\r\n            }\r\n            if(hashNext < block.number + 3) {\r\n                hashNext = block.number + 3;\r\n                hashBetSum = msg.value;\r\n            }\r\n            else{\r\n                if(hashBetSum > hashBetMax) {\r\n                    hashNext++;\r\n                    hashBetSum = msg.value;\r\n                }\r\n                else{\r\n                    hashBetSum += msg.value;\r\n                }\r\n            }\r\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\r\n            LogBet(msg.sender,uint(bethash),hashNext,msg.value);\r\n        }\r\n        putHash(); // players help collecing data\r\n        return(hashNext);\r\n    }\r\n\r\n/* database functions */\r\n\r\n    /**\r\n     * @dev Create hash data swap space\r\n     * @param _sadd Number of hashes to add (<=256)\r\n     */\r\n    function addHashes(uint _sadd) public returns (uint) {\r\n        require(hashes.length + _sadd<=hashesSize);\r\n        uint n = hashes.length;\r\n        hashes.length += _sadd;\r\n        for(;n<hashes.length;n++){ // make sure to burn gas\r\n            hashes[n] = 1;\r\n        }\r\n        if(hashes.length>=hashesSize) { // assume block.number > 10\r\n            hashFirst = block.number - ( block.number % 10);\r\n            hashLast = hashFirst;\r\n        }\r\n        return(hashes.length);\r\n    }\r\n\r\n    /**\r\n     * @dev Create hash data swap space, add 128 hashes\r\n     */\r\n    function addHashes128() external returns (uint) {\r\n        return(addHashes(128));\r\n    }\r\n\r\n    function calcHashes(uint32 _lastb, uint32 _delta) constant private returns (uint) {\r\n        return( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\r\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\r\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\r\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\r\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\r\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\r\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\r\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\r\n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\r\n            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\r\n            | ( ( uint(_delta) / hashesSize) << 240)); \r\n    }\r\n\r\n    function getHash(uint _block) constant private returns (uint32) {\r\n        uint delta = (_block - hashFirst) / 10;\r\n        uint hash = hashes[delta % hashesSize];\r\n        if(delta / hashesSize != hash >> 240) {\r\n            return(0x1000000); // load failed, incorrect data in hashes\r\n        }\r\n        uint slotp = (_block - hashFirst) % 10; \r\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\r\n    }\r\n    \r\n    /**\r\n     * @dev Fill hash data\r\n     */\r\n    function putHash() public returns (bool) {\r\n        uint lastb = hashLast;\r\n        if(lastb == 0 || block.number <= lastb + 10) {\r\n            return(false);\r\n        }\r\n        uint blockn256;\r\n        if(block.number<256) { // useless test for testnet :-(\r\n            blockn256 = 0;\r\n        }\r\n        else{\r\n            blockn256 = block.number - 256;\r\n        }\r\n        if(lastb < blockn256) {\r\n            uint num = blockn256;\r\n            num += num % 10;\r\n            lastb = num; \r\n        }\r\n        uint delta = (lastb - hashFirst) / 10;\r\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\r\n        hashLast = lastb + 10;\r\n        return(true);\r\n    }\r\n\r\n    /**\r\n     * @dev Fill hash data many times\r\n     * @param _num Number of iterations\r\n     */\r\n    function putHashes(uint _num) external {\r\n        uint n=0;\r\n        for(;n<_num;n++){\r\n            if(!putHash()){\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxsum\",\"type\":\"uint256\"}],\"name\":\"setBetMax\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"won\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"putHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxWin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"playRandom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"uint256\"},{\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"playSystem\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"animator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hashesSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sadd\",\"type\":\"uint256\"}],\"name\":\"addHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendsBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"betValueOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"changeAnimator\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"putHashes\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"betOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetBet\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hashes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"walletBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hashFirst\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hashesLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hashNext\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"walletBlockOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"betBlockNumberOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"betHashOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"play\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payWallet\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addHashes128\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hashLast\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"hotStore\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hashBetMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"investDirect\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investBalanceMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"coldStore\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coldStoreLast\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"houseKeeping\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hashBetSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payDividends\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disinvest\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"walletPeriodOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"setInvestStart\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bethash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"blocknumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betsize\",\"type\":\"uint256\"}],\"name\":\"LogBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bethash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"uint256\"}],\"name\":\"LogLoss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bethash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"LogWin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRecordWin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentBlockNumber\",\"type\":\"uint256\"}],\"name\":\"LogLate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"SmartBillions","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ac41cbede38ec212df422c8f66d92c3f2f405ac952c88708b15e7a64a2a56208"}]