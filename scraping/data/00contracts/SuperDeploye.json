[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"SuperDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n     __        __   ___  __   __   ___  __        __       ___  __  \\n    /__` |  | |__) |__  |__) |  \\\\ |__  |__) |    /  \\\\ \\\\ / |__  |__) \\n    .__/ \\\\__/ |    |___ |  \\\\ |__/ |___ |    |___ \\\\__/  |  |___ |  \\\\ \\n\\n    SuperDeployer by SuperCollectiv\\n\\n    ABOUT\\n    SuperDeployer is a simple CREATE2 contract deployer, which allows anyone\\n    to deploy a contract to a precalculated addess, such as a vanity address. \\n    We recommend using ERADICATE2 to generate salts. A good GPU can check 1B+ \\n    addresses/sec. Use this contract's address as the deployer.\\n\\n    CAUTION\\n    It is not recommended to use contracts that can be deleted (contains\\n    selfdestruct, delegatecall, or callcode). Deleted contracts can be \\n    redeployed to the same address using the same salt and bytecode.\\n    \\n    FORMULAS\\n    addresses to check on avg = 16**number of vanity chars at a specific location\\n    seconds to brute-force on avg = addresses to check on avg / checks per sec\\n    probability of brute-forcing in X seconds (%) = (seconds of brute-forcing / (addresses to check on avg / checks per sec)) * 100\\n    \\n    EXAMPLES\\n    1 out of 1,099,511,627,776 addresses have 10 leading zeros.\\n    A 10-leading zero address takes 18.3 mins to brute-force at 1B checks/sec.\\n    A 12-leading zero address takes 256x longer (3.3 days).\\n    A 14-leading zero address takes 65536x longer (834 days).\\n\\n    Method IDs (function hashes):\\n    \\\"38cb7245\\\": \\\"calculateAddress(bytes,bytes32)\\\"\\n    \\\"bd66e436\\\": \\\"deploy(bytes,bytes32,address)\\\"\\n\\n*/\\n\\n/**\\n    @title SuperDeployer\\n    @author SuperCollectiv\\n    @notice CREATE2 contract deployer.\\n */\\ncontract SuperDeployer {\\n\\n    /**\\n        @notice Calculate a contract address deployed from this contract using the bytecode and salt.\\n        @param bytecode The contract bytecode (starting with '0x').\\n        @param salt The salt to use (starting with '0x').\\n        @return calculatedAddress The address of the contract that will be deployed.\\n    */\\n    function calculateAddress(\\n        bytes memory bytecode,\\n        bytes32 salt\\n    ) public view returns (address calculatedAddress) {\\n        return address(\\n                    uint160(\\n                        uint256(\\n                            keccak256(\\n                                abi.encodePacked(\\n                                    bytes1(0xff),\\n                                    address(this), // This contract is the deployer.\\n                                    salt,\\n                                    keccak256(abi.encodePacked(bytecode))\\n                                )\\n                            )\\n                        )\\n                    )\\n                );\\n    }\\n\\n    /**\\n        @notice Deploy a contract using CREATE2.\\n        @dev Cannot deploy a contract at an address where one already exists unless it has been deleted.\\n        @param bytecode The contract bytecode (starting with '0x').\\n        @param salt The salt to use (starting with '0x').\\n        @param anticipatedAddress The address you are expecting the contract to be.\\n        @return deployedAddress The address of the deployed contract.\\n    */\\n    function deploy(\\n        bytes memory bytecode,\\n        bytes32 salt,\\n        address anticipatedAddress\\n    ) public payable returns (address deployedAddress) {\\n\\n        // Revert if a contract exists at the address.\\n        if (anticipatedAddress.code.length > 0) revert CONTRACT_EXISTS_AT_THIS_ADDRESS(anticipatedAddress);\\n\\n        // Ensure the anticipated address matches the calculated address.\\n        address calculatedAddress = calculateAddress(bytecode, salt);\\n        if (anticipatedAddress != calculatedAddress) revert CALCULATED_ADDRESS_DOES_NOT_MATCH(anticipatedAddress, calculatedAddress);\\n\\n        // Deploy contract using CREATE2.\\n        assembly {\\n            deployedAddress := create2(\\n                callvalue(),                    // forward ETH (constructor must be payable if >0)\\n                add(bytecode, 0x20),            // bytecode\\n                mload(bytecode),                // bytecode length\\n                salt                            // salt\\n            )\\n        }\\n\\n        // Ensure the anticipated address matches the deployed address.\\n        if (anticipatedAddress != deployedAddress) revert DEPLOYED_ADDRESS_DOES_NOT_MATCH(anticipatedAddress, deployedAddress);\\n\\n        return deployedAddress;\\n    }\\n}\\n\\n/// @notice Contract exists at this address.\\nerror CONTRACT_EXISTS_AT_THIS_ADDRESS(address anticipated);\\n/// @notice Calculated addresss does not match.\\nerror CALCULATED_ADDRESS_DOES_NOT_MATCH(address anticipated, address calculated);\\n/// @notice Deployed addresss does not match.\\nerror DEPLOYED_ADDRESS_DOES_NOT_MATCH(address anticipated, address deployed);\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"anticipated\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"calculated\",\"type\":\"address\"}],\"name\":\"CALCULATED_ADDRESS_DOES_NOT_MATCH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"anticipated\",\"type\":\"address\"}],\"name\":\"CONTRACT_EXISTS_AT_THIS_ADDRESS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"anticipated\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployed\",\"type\":\"address\"}],\"name\":\"DEPLOYED_ADDRESS_DOES_NOT_MATCH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"calculateAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"calculatedAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"anticipatedAddress\",\"type\":\"address\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"SuperDeployer","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]