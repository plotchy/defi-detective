[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/*\r\n* Zethroll.\r\n*\r\n* Adapted from PHXRoll, written in March 2018 by TechnicalRise:\r\n*   https://www.reddit.com/user/TechnicalRise/\r\n*\r\n* Adapted for Zethr by Norsefire and oguzhanox.\r\n*\r\n* Gas golfed by Etherguy\r\n* Audited & commented by Klob\r\n*/\r\n\r\ncontract ZTHReceivingContract {\r\n  /**\r\n   * @dev Standard ERC223 function that will handle incoming token transfers.\r\n   *\r\n   * @param _from  Token sender address.\r\n   * @param _value Amount of tokens.\r\n   * @param _data  Transaction metadata.\r\n   */\r\n  function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\r\n}\r\n\r\n\r\ncontract ZTHInterface {\r\n  function getFrontEndTokenBalanceOf(address who) public view returns (uint);\r\n  function transfer(address _to, uint _value) public returns (bool);\r\n  function approve(address spender, uint tokens) public returns (bool);\r\n}\r\n\r\ncontract Zethroll is ZTHReceivingContract {\r\n  using SafeMath for uint;\r\n\r\n  // Makes sure that player profit can't exceed a maximum amount,\r\n  //  that the bet size is valid, and the playerNumber is in range.\r\n  modifier betIsValid(uint _betSize, uint _playerNumber) {\r\n     require( calculateProfit(_betSize, _playerNumber) < maxProfit\r\n             && _betSize >= minBet\r\n             && _playerNumber > minNumber\r\n             && _playerNumber < maxNumber);\r\n    _;\r\n  }\r\n\r\n  // Requires game to be currently active\r\n  modifier gameIsActive {\r\n    require(gamePaused == false);\r\n    _;\r\n  }\r\n\r\n  // Requires msg.sender to be owner\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  // Constants\r\n  uint constant private MAX_INT = 2 ** 256 - 1;\r\n  uint constant public maxProfitDivisor = 1000000;\r\n  uint constant public maxNumber = 99;\r\n  uint constant public minNumber = 2;\r\n  uint constant public houseEdgeDivisor = 1000;\r\n\r\n  // Configurables\r\n  bool public gamePaused;\r\n\r\n  address public owner;\r\n  address public ZethrBankroll;\r\n  address public ZTHTKNADDR;\r\n\r\n  ZTHInterface public ZTHTKN;\r\n\r\n  uint public contractBalance;\r\n  uint public houseEdge;\r\n  uint public maxProfit;\r\n  uint public maxProfitAsPercentOfHouse;\r\n  uint public minBet = 0;\r\n\r\n  // Trackers\r\n  uint public totalBets;\r\n  uint public totalZTHWagered;\r\n\r\n  // Events\r\n\r\n  // Logs bets + output to web3 for precise 'payout on win' field in UI\r\n  event LogBet(address sender, uint value, uint rollUnder);\r\n\r\n  // Outputs to web3 UI on bet result\r\n  // Status: 0=lose, 1=win, 2=win + failed send, 3=refund, 4=refund + failed send\r\n  event LogResult(address player, uint result, uint rollUnder, uint profit, uint tokensBetted, bool won);\r\n\r\n  // Logs owner transfers\r\n  event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\r\n\r\n  // Logs changes in maximum profit\r\n  event MaxProfitChanged(uint _oldMaxProfit, uint _newMaxProfit);\r\n\r\n  // Logs current contract balance\r\n  event CurrentContractBalance(uint _tokens);\r\n  \r\n  constructor (address zthtknaddr, address zthbankrolladdr) public {\r\n    // Owner is deployer\r\n    owner = msg.sender;\r\n\r\n    // Initialize the ZTH contract and bankroll interfaces\r\n    ZTHTKN = ZTHInterface(zthtknaddr);\r\n    ZTHTKNADDR = zthtknaddr;\r\n\r\n    // Set the bankroll\r\n    ZethrBankroll = zthbankrolladdr;\r\n\r\n    // Init 990 = 99% (1% houseEdge)\r\n    houseEdge = 990;\r\n\r\n    // The maximum profit from each bet is 10% of the contract balance.\r\n    ownerSetMaxProfitAsPercentOfHouse(10000);\r\n\r\n    // Init min bet (1 ZTH)\r\n    ownerSetMinBet(1e18);\r\n\r\n    // Allow 'unlimited' token transfer by the bankroll\r\n    ZTHTKN.approve(zthbankrolladdr, MAX_INT);\r\n  }\r\n\r\n  function() public payable {} // receive zethr dividends\r\n\r\n  // Returns a random number using a specified block number\r\n  // Always use a FUTURE block number.\r\n  function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\r\n    return uint256(keccak256(\r\n        abi.encodePacked(\r\n        blockhash(blockn),\r\n        entropy)\r\n      ));\r\n  }\r\n\r\n  // Random helper\r\n  function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\r\n    return maxRandom(blockn, entropy) % upper;\r\n  }\r\n\r\n  // Calculate the maximum potential profit\r\n  function calculateProfit(uint _initBet, uint _roll)\r\n    private\r\n    view\r\n    returns (uint)\r\n  {\r\n    return ((((_initBet * (100 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\r\n  }\r\n\r\n  // I present a struct which takes only 20k gas\r\n  struct playerRoll{\r\n    uint200 tokenValue; // Token value in uint \r\n    uint48 blockn;      // Block number 48 bits \r\n    uint8 rollUnder;    // Roll under 8 bits\r\n  }\r\n\r\n  // Mapping because a player can do one roll at a time\r\n  mapping(address => playerRoll) public playerRolls;\r\n\r\n  function _playerRollDice(uint _rollUnder, TKN _tkn) private\r\n    gameIsActive\r\n    betIsValid(_tkn.value, _rollUnder)\r\n  {\r\n    require(_tkn.value < ((2 ** 200) - 1));   // Smaller than the storage of 1 uint200;\r\n    require(block.number < ((2 ** 48) - 1));  // Current block number smaller than storage of 1 uint48\r\n\r\n    // Note that msg.sender is the Token Contract Address\r\n    // and \"_from\" is the sender of the tokens\r\n\r\n    // Check that this is a ZTH token transfer\r\n    require(_zthToken(msg.sender));\r\n\r\n    playerRoll memory roll = playerRolls[_tkn.sender];\r\n\r\n    // Cannot bet twice in one block \r\n    require(block.number != roll.blockn);\r\n\r\n    // If there exists a roll, finish it\r\n    if (roll.blockn != 0) {\r\n      _finishBet(false, _tkn.sender);\r\n    }\r\n\r\n    // Set struct block number, token value, and rollUnder values\r\n    roll.blockn = uint40(block.number);\r\n    roll.tokenValue = uint200(_tkn.value);\r\n    roll.rollUnder = uint8(_rollUnder);\r\n\r\n    // Store the roll struct - 20k gas.\r\n    playerRolls[_tkn.sender] = roll;\r\n\r\n    // Provides accurate numbers for web3 and allows for manual refunds\r\n    emit LogBet(_tkn.sender, _tkn.value, _rollUnder);\r\n                 \r\n    // Increment total number of bets\r\n    totalBets += 1;\r\n\r\n    // Total wagered\r\n    totalZTHWagered += _tkn.value;\r\n  }\r\n\r\n  // Finished the current bet of a player, if they have one\r\n  function finishBet() public\r\n    gameIsActive\r\n    returns (uint)\r\n  {\r\n    return _finishBet(true, msg.sender);\r\n  }\r\n\r\n  /*\r\n   * Pay winner, update contract balance\r\n   * to calculate new max bet, and send reward.\r\n   */\r\n  function _finishBet(bool delete_it, address target) private returns (uint){\r\n    playerRoll memory roll = playerRolls[target];\r\n    require(roll.tokenValue > 0); // No re-entracy\r\n    require(roll.blockn != block.number);\r\n    // If the block is more than 255 blocks old, we can't get the result\r\n    // Also, if the result has already happened, fail as well\r\n    uint result;\r\n    if (block.number - roll.blockn > 255) {\r\n      result = 1000; // Cant win \r\n    } else {\r\n      // Grab the result - random based ONLY on a past block (future when submitted)\r\n      result = random(99, roll.blockn, target) + 1;\r\n    }\r\n\r\n    uint rollUnder = roll.rollUnder;\r\n\r\n    if (result < rollUnder) {\r\n      // Player has won!\r\n\r\n      // Safely map player profit\r\n      uint profit = calculateProfit(roll.tokenValue, rollUnder);\r\n\r\n      // Safely reduce contract balance by player profit\r\n      contractBalance = contractBalance.sub(profit);\r\n\r\n      emit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\r\n\r\n      // Update maximum profit\r\n      setMaxProfit();\r\n\r\n      if (delete_it){\r\n        // Prevent re-entracy memes\r\n        delete playerRolls[target];\r\n      }\r\n\r\n      // Transfer profit plus original bet\r\n      ZTHTKN.transfer(target, profit + roll.tokenValue);\r\n      \r\n      return result;\r\n\r\n    } else {\r\n      /*\r\n      * Player has lost\r\n      * Update contract balance to calculate new max bet\r\n      */\r\n      emit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\r\n\r\n      /*\r\n      *  Safely adjust contractBalance\r\n      *  SetMaxProfit\r\n      */\r\n      contractBalance = contractBalance.add(roll.tokenValue);\r\n\r\n      // No need to actually delete player roll here since player ALWAYS loses \r\n      // Saves gas on next buy \r\n\r\n      // Update maximum profit\r\n      setMaxProfit();\r\n      \r\n      return result;\r\n    }\r\n  }\r\n\r\n  // TKN struct\r\n  struct TKN {address sender; uint value;}\r\n\r\n  // Token fallback to bet or deposit from bankroll\r\n  function tokenFallback(address _from, uint _value, bytes _data) public returns (bool) {\r\n    require(msg.sender == ZTHTKNADDR);\r\n    if (_from == ZethrBankroll) {\r\n      // Update the contract balance\r\n      contractBalance = contractBalance.add(_value);\r\n\r\n      // Update the maximum profit\r\n      uint oldMaxProfit = maxProfit;\r\n      setMaxProfit();\r\n\r\n      emit MaxProfitChanged(oldMaxProfit, maxProfit);\r\n      return true;\r\n\r\n    } else {\r\n      TKN memory _tkn;\r\n      _tkn.sender = _from;\r\n      _tkn.value = _value;\r\n      uint8 chosenNumber = uint8(_data[0]);\r\n      _playerRollDice(chosenNumber, _tkn);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /*\r\n  * Sets max profit\r\n  */\r\n  function setMaxProfit() internal {\r\n    emit CurrentContractBalance(contractBalance);\r\n    maxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor;\r\n  }\r\n\r\n  // Only owner adjust contract balance variable (only used for max profit calc)\r\n  function ownerUpdateContractBalance(uint newContractBalance) public\r\n  onlyOwner\r\n  {\r\n    contractBalance = newContractBalance;\r\n  }\r\n\r\n  // Only owner address can set maxProfitAsPercentOfHouse\r\n  function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\r\n  onlyOwner\r\n  {\r\n    // Restricts each bet to a maximum profit of 20% contractBalance\r\n    require(newMaxProfitAsPercent <= 200000);\r\n    maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\r\n    setMaxProfit();\r\n  }\r\n\r\n  // Only owner address can set minBet\r\n  function ownerSetMinBet(uint newMinimumBet) public\r\n  onlyOwner\r\n  {\r\n    minBet = newMinimumBet;\r\n  }\r\n\r\n  // Only owner address can transfer ZTH\r\n  function ownerTransferZTH(address sendTo, uint amount) public\r\n  onlyOwner\r\n  {\r\n    // Safely update contract balance when sending out funds\r\n    contractBalance = contractBalance.sub(amount);\r\n\r\n    // update max profit\r\n    setMaxProfit();\r\n    require(ZTHTKN.transfer(sendTo, amount));\r\n    emit LogOwnerTransfer(sendTo, amount);\r\n  }\r\n\r\n  // Only owner address can set emergency pause #1\r\n  function ownerPauseGame(bool newStatus) public\r\n  onlyOwner\r\n  {\r\n    gamePaused = newStatus;\r\n  }\r\n\r\n  // Only owner address can set bankroll address\r\n  function ownerSetBankroll(address newBankroll) public\r\n  onlyOwner\r\n  {\r\n    ZTHTKN.approve(ZethrBankroll, 0);\r\n    ZethrBankroll = newBankroll;\r\n    ZTHTKN.approve(newBankroll, MAX_INT);\r\n  }\r\n\r\n  // Only owner address can set owner address\r\n  function ownerChangeOwner(address newOwner) public\r\n  onlyOwner\r\n  {\r\n    owner = newOwner;\r\n  }\r\n\r\n  // Only owner address can selfdestruct - emergency\r\n  function ownerkill() public\r\n  onlyOwner\r\n  {\r\n    ZTHTKN.transfer(owner, contractBalance);\r\n    selfdestruct(owner);\r\n  }\r\n  \r\n  function dumpdivs() public{\r\n      ZethrBankroll.transfer(address(this).balance);\r\n  }\r\n\r\n  function _zthToken(address _tokenContract) private view returns (bool) {\r\n    return _tokenContract == ZTHTKNADDR;\r\n    // Is this the ZTH token contract?\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalZTHWagered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"dumpdivs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZTHTKN\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitAsPercentOfHouse\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContractBalance\",\"type\":\"uint256\"}],\"name\":\"ownerUpdateContractBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownerChangeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxProfitAsPercent\",\"type\":\"uint256\"}],\"name\":\"ownerSetMaxProfitAsPercentOfHouse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockn\",\"type\":\"uint256\"},{\"name\":\"entropy\",\"type\":\"address\"}],\"name\":\"maxRandom\",\"outputs\":[{\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinimumBet\",\"type\":\"uint256\"}],\"name\":\"ownerSetMinBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"ownerPauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBankroll\",\"type\":\"address\"}],\"name\":\"ownerSetBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZethrBankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sendTo\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ownerTransferZTH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerRolls\",\"outputs\":[{\"name\":\"tokenValue\",\"type\":\"uint200\"},{\"name\":\"blockn\",\"type\":\"uint48\"},{\"name\":\"rollUnder\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerkill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdge\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdgeDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZTHTKNADDR\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"zthtknaddr\",\"type\":\"address\"},{\"name\":\"zthbankrolladdr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rollUnder\",\"type\":\"uint256\"}],\"name\":\"LogBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensBetted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"won\",\"type\":\"bool\"}],\"name\":\"LogResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"SentToAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"AmountTransferred\",\"type\":\"uint256\"}],\"name\":\"LogOwnerTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldMaxProfit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newMaxProfit\",\"type\":\"uint256\"}],\"name\":\"MaxProfitChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"CurrentContractBalance\",\"type\":\"event\"}]","ContractName":"Zethroll","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d48b633045af65ff636f3c6edd744748351e020d0000000000000000000000007430984e1d05d5f447c747123dd26845f6f17544","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://e4c83c38a0728bf194a4cf57bd8ad736f9c99a4b067a8941a174025175cc4baa"}]