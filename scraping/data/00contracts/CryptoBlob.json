[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n                    ____________________\r\n              _____|____________________|_____\r\n           __|_____|                    |_____|__\r\n        __|__|                                |__|__\r\n     __|__|                                      |__|__\r\n    |  |                                            |  |\r\n    |  |               __                   __      |  |\r\n    |  |              |  |                 |  |     |  |\r\n    |  |              |__|                 |__|     |  |\r\n    |  |            __________________________      |  |\r\n    |  |           |      ______________      |     |  |\r\n    |  |           |__   |_____         |   __|     |  |\r\n    |__|__            |_____|  |        |__|      __|__|\r\n       |__|_____            |  |        |   _____|__|\r\n          |_____|___________|  |        |__|_____|\r\n                |___________|  |        |__|\r\n     __   __       __  ___  __   __        __   __   __\r\n    /  ` |__) \\ / |__)  |  /  \\ |__) |    /  \\ |__) /__`\r\n    \\__, |  \\  |  |     |  \\__/ |__) |___ \\__/ |__) .__/\r\n     __        __   ___  __   __   __             ___  __  ___\r\n    /__` |  | |__) |__  |__) /  ` /  \\ |    |    |__  /  `  |  | \\  /\r\n    .__/ \\__/ |    |___ |  \\ \\__, \\__/ |___ |___ |___ \\__,  |  |  \\/\r\n\r\n    CryptoBlobs by SuperCollectiv. Learn more on https://cryptoblobs.com.\r\n    Copyright Â© 2022 SuperCollectiv LLC. All rights reserved.\r\n\r\n    Twitter: https://twitter.com/SuperCollectiv\r\n    Discord: https://cryptoblobs.com/discord\r\n\r\n    Write method IDs (function hashes):\r\n    \"095ea7b3\": \"approve(address,uint256)\"\r\n    \"1e897afb\": \"batch(bytes[])\"\r\n    \"007e6eda\": \"manageContract(uint256,address[],uint256[],string[],bytes)\"\r\n    \"eeca5d73\": \"manageTrades(address,bytes32)\"\r\n    \"f2e4b6c8\": \"metadata(string,string,string)\"\r\n    \"836a1040\": \"mint(uint256,address,uint256)\"\r\n    \"383be151\": \"optimize(uint256[])\"\r\n    \"0accf375\": \"sacrifice(uint256,uint256[])\"\r\n    \"42842e0e\": \"safeTransferFrom(address,address,uint256)\"\r\n    \"b88d4fde\": \"safeTransferFrom(address,address,uint256,bytes)\"\r\n    \"a22cb465\": \"setApprovalForAll(address,bool)\"\r\n    \"616e4167\": \"trade(address,address,uint256[],uint256[],uint256,uint256,uint256,bytes)\"\r\n    \"23b872dd\": \"transferFrom(address,address,uint256)\"\r\n\r\n    Read method IDs (function hashes):\r\n    \"7dcffcea\": \"accountData(address,bool,bool)\"\r\n    \"05f71139\": \"accountDataByCategory(address[],uint256)\"\r\n    \"673154e0\": \"addressesToENS(address[])\"\r\n    \"70a08231\": \"balanceOf(address)\"\r\n    \"e4b68f6a\": \"batchTradeHashUsedAndHasAccess(address[],uint256[])\"\r\n    \"6c8381f8\": \"candidate()\"\r\n    \"e8a3d485\": \"contractURI()\"\r\n    \"e9554894\": \"generalData(address,uint256)\"\r\n    \"081812fc\": \"getApproved(uint256)\"\r\n    \"e985e9c5\": \"isApprovedForAll(address,address)\"\r\n    \"9223dc85\": \"isTradeApprovedAndValid(address,address,uint256[],uint256[],uint256,uint256,uint256,bytes,bool)\"\r\n    \"06fdde03\": \"name()\"\r\n    \"8da5cb5b\": \"owner()\"\r\n    \"6352211e\": \"ownerOf(uint256)\"\r\n    \"4eba3a1d\": \"preapprovedServiceStatus(address)\"\r\n    \"01ffc9a7\": \"supportsInterface(bytes4)\"\r\n    \"95d89b41\": \"symbol()\"\r\n    \"4f6ccce7\": \"tokenByIndex(uint256)\"\r\n    \"29b69134\": \"tokenData(uint256,bool)\"\r\n    \"eb86b58e\": \"tokenDataByCategory(uint256,uint256,uint256)\"\r\n    \"2f745c59\": \"tokenOfOwnerByIndex(address,uint256)\"\r\n    \"c87b56dd\": \"tokenURI(uint256)\"\r\n    \"18160ddd\": \"totalSupply()\"\r\n\r\n    Event topics:\r\n    \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\": \"Transfer(address,address,uint256)\"\r\n    \"0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\": \"Approval(address,address,uint256)\"\r\n    \"0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31\": \"ApprovalForAll(address,address,bool)\"\r\n    \"0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0\": \"OwnershipTransferred(address,address)\"\r\n    \"0xf26aaf0d6935ae39e0b17d4770395a2cf37139301bf4a1550daabaa363cb8df0\": \"MintPurchase(address,address,uint256)\"\r\n    \"0x7236fe0badcff1706816875cc9df7b9b481c3fb939efe1e7967099499db621d9\": \"MintFree(address,address,uint256,uint256)\"\r\n    \"0x10d92c47650ef2b2a841f26c951f4391ccbb731e57d36a67665a0d138e08ef09\": \"Trade(bytes32,address,address,uint256[],uint256[],uint256,uint256,uint256,bool)\"\r\n    \"0xff06b6e7e3b7963958aa44cc1dff152337abfc3ef2d0ecd54bdcd8fb9694e0eb\": \"Optimize(address,uint256[],uint256)\"\r\n    \"0x062e360bff2a6872f7e8ce922ee6867aaeed320f740365aa0c33bb226d45b034\": \"Metadata(address,string,string,string,uint256)\"\r\n\r\n    Supported interfaces:\r\n    \"0x01ffc9a7\": \"IERC165\"\r\n    \"0x80ac58cd\": \"IERC721\"\r\n    \"0x5b5e139f\": \"IERC721Metadata\"\r\n    \"0x780e9d63\": \"IERC721Enumerable\"\r\n\r\n */\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n/**\r\n    @notice Interface ID: 0x01ffc9a7\r\n*/\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n    @notice Interface ID: 0x80ac58cd\r\n*/\r\ninterface IERC721 is IERC165 {\r\n    // Topic: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    // Topic: 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    // Topic: 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n/**\r\n    @notice Interface ID: 0x5b5e139f\r\n*/\r\ninterface IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n/**\r\n    @notice Interface ID: 0x780e9d63\r\n*/\r\ninterface IERC721Enumerable is IERC721 {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n/**\r\n    @notice Interface for reverse records.\r\n*/\r\ninterface IReverseRecords {\r\n    function getNames(address[] calldata addresses) external view returns (string[] memory r);\r\n}\r\n\r\n/**\r\n    @notice Allows the contract to have an owner that can manage the contract.\r\n*/\r\nabstract contract Ownable {\r\n\r\n    constructor() {\r\n        // Set the owner of the contract.\r\n        _contractOwner = tx.origin;\r\n\r\n        emit OwnershipTransferred(  // 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0\r\n            address(0),             // address indexed previousOwner\r\n            _contractOwner          // address indexed newOwner\r\n        );\r\n    }\r\n\r\n    // Topic: 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner, \r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @notice Owner can manage the contract using {manageContract}.\r\n    address internal _contractOwner;\r\n\r\n    /// @notice Candidate can confirm a contract transfer with {manageContract}.\r\n    address internal _contractCandidate;\r\n\r\n    /// @notice Fill up storage slot 2 for gas optimization.\r\n    uint96 internal _unused = 0;\r\n\r\n    /// @dev Returns the address of the current owner.\r\n    function owner() public view virtual returns (address) {\r\n        return _contractOwner;\r\n    }\r\n\r\n    /// @dev Returns the address of the current candidate.\r\n    function candidate() public view virtual returns (address) {\r\n        return _contractCandidate;\r\n    }\r\n}\r\n\r\n/**\r\n    @notice SuperERC721 is a hyperoptimized implementation of the ERC721 token (NFT) standard developed by SuperCollectiv.\r\n    @dev Only contains read methods. See [CryptoBlobs] for write methods.\r\n*/\r\nabstract contract SuperERC721 is\r\n    Ownable,\r\n    IERC721,\r\n    IERC721Metadata,\r\n    IERC721Enumerable\r\n{\r\n\r\n    constructor() {\r\n        // Initialize reentrancy status.\r\n        _reentrancyStatus = _reentrancyUnlocked;\r\n\r\n        // Preapproved services: OpenSea, X2Y2, LooksRare, Rarible, 0x Protocol v4, Element, SudoSwap, NFTX, and NFTTrader.\r\n        // Some of these services also work on NFT aggregator marketplaces like Gem, Genie, and Element (hybrid marketplace).\r\n        // You can revoke these services using {setApprovalForAll} or visit CryptoBlobs.com for a batch tx to revoke all.\r\n\r\n        // Services that list your account operators will not detect that these addresses have\r\n        // been approved unless you reapprove each service with {setApprovalForAll} or {batch}.\r\n        // Visit CryptoBlobs.com to create a batch transaction to reapprove all.\r\n\r\n        // SuperCollectiv can manage these services with {manageContract}. \r\n        // We can permanently disable, temporarily disable, and reenable temporarily disabled services.\r\n        // Use {preapprovedServiceStatus} to check the current status of each service.\r\n        \r\n        // [CAUTION] We audited each service and discovered the following:\r\n        // X2Y2 and Rarible both have an admin account that can transfer assets from your account. \r\n        // We still preapproved these services because they have a high reputation\r\n        // of being trustworthy and we could not find evidence of this being exploited.\r\n\r\n        // Ultimately, it is your responsibility to manage these services.\r\n        // You may send us feedback about this feature if you have any questions or concerns.\r\n\r\n        address[9] memory _preapprovedServices = [\r\n            // OpenSea\r\n            // https://opensea.io/\r\n            // https://etherscan.io/address/0x1E0049783F008A0085193E00003D00cd54003c71\r\n            0x1E0049783F008A0085193E00003D00cd54003c71,\r\n            // X2Y2\r\n            // https://x2y2.io/\r\n            // https://etherscan.io/address/0xF849de01B080aDC3A814FaBE1E2087475cF2E354\r\n            0xF849de01B080aDC3A814FaBE1E2087475cF2E354,\r\n            // LooksRare\r\n            // https://looksrare.org/\r\n            // https://etherscan.io/address/0xf42aa99F011A1fA7CDA90E5E98b277E306BcA83e\r\n            0xf42aa99F011A1fA7CDA90E5E98b277E306BcA83e,\r\n            // Rarible\r\n            // https://rarible.com/\r\n            // https://etherscan.io/address/0x4feE7B061C97C9c496b01DbcE9CDb10c02f0a0Be\r\n            0x4feE7B061C97C9c496b01DbcE9CDb10c02f0a0Be,\r\n            // 0x Protocol, Coinbase NFT, and more\r\n            // https://www.0x.org/ https://nft.coinbase.com/\r\n            // https://etherscan.io/address/0xDef1C0ded9bec7F1a1670819833240f027b25EfF\r\n            0xDef1C0ded9bec7F1a1670819833240f027b25EfF,\r\n            // Element\r\n            // https://element.market/ethereum\r\n            // https://etherscan.io/address/0x20F780A973856B93f63670377900C1d2a50a77c4\r\n            0x20F780A973856B93f63670377900C1d2a50a77c4,\r\n            // SudoSwap\r\n            // https://sudoswap.xyz/\r\n            // https://etherscan.io/address/0x2B2e8cDA09bBA9660dCA5cB6233787738Ad68329\r\n            0x2B2e8cDA09bBA9660dCA5cB6233787738Ad68329,\r\n            // NFTX\r\n            // https://nftx.io/\r\n            // https://etherscan.io/address/0x0fc584529a2aefa997697fafacba5831fac0c22d\r\n            0x0fc584529a2AEfA997697FAfAcbA5831faC0c22d,\r\n            // NFTTrader\r\n            // https://www.nfttrader.io/\r\n            // https://etherscan.io/address/0x657E383EdB9A7407E468acBCc9Fe4C9730c7C275\r\n            0x657E383EdB9A7407E468acBCc9Fe4C9730c7C275\r\n        ];\r\n        for (uint256 i; i < _preapprovedServices.length; i++) {\r\n            _account[_preapprovedServices[i]].preapprovedStatus = 2; // Enable each service.\r\n        }\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        if (_reentrancyStatus == _reentrancyLocked) revert REENTRANT_CALLS_ARE_NOT_ALLOWED();\r\n        _reentrancyStatus = _reentrancyLocked;\r\n        _;\r\n        _reentrancyStatus = _reentrancyUnlocked;\r\n    }\r\n\r\n    // Topic: 0xf26aaf0d6935ae39e0b17d4770395a2cf37139301bf4a1550daabaa363cb8df0\r\n    event MintPurchase(\r\n        address account,\r\n        address referrer,\r\n        uint256 data\r\n    );\r\n\r\n    // Topic: 0x7236fe0badcff1706816875cc9df7b9b481c3fb939efe1e7967099499db621d9\r\n    event MintFree(\r\n        address account, \r\n        address contractAddress, \r\n        uint256 tokenId,\r\n        uint256 data\r\n    );\r\n\r\n    // Topic: 0x10d92c47650ef2b2a841f26c951f4391ccbb731e57d36a67665a0d138e08ef09\r\n    event Trade(\r\n        bytes32 indexed hash,\r\n        address indexed maker,\r\n        address indexed taker,\r\n        uint256[] makerIds,\r\n        uint256[] takerIds,\r\n        uint256 price,\r\n        uint256 expiry,\r\n        uint256 timestamp,\r\n        bool isTrade\r\n    );\r\n\r\n    // Topic: 0xff06b6e7e3b7963958aa44cc1dff152337abfc3ef2d0ecd54bdcd8fb9694e0eb\r\n    event Optimize(\r\n        address indexed account,\r\n        uint256[] tokenIds,\r\n        uint256 timestamp\r\n    );\r\n\r\n    // Topic: 0x062e360bff2a6872f7e8ce922ee6867aaeed320f740365aa0c33bb226d45b034\r\n    event Metadata(\r\n        address indexed account,\r\n        string indexed table,\r\n        string indexed key,\r\n        string value,\r\n        uint256 timestamp\r\n    );\r\n\r\n    // Constants - These values cannot be modified.\r\n\r\n    /// @notice The symbol of the token.\r\n    string internal constant _symbol = \"BLOB\";\r\n    /// @notice Max supply of CryptoBlobs.\r\n    uint256 internal constant _maxSupply = 25000;\r\n    /// @notice Total supply when the giveaway ends.\r\n    uint256 internal constant _giveawayEnds = 10000;\r\n    /// @notice Total supply when the sacrifice promo and hourly drops offers ends.\r\n    uint256 internal constant _sacrificeAndHourlyDropsOffersEnds = 20000;\r\n    /// @notice Total supply when the referral program ends.\r\n    uint256 internal constant _referralProgramEnds = 25000;\r\n    /// @notice Maximum number of CryptoBlobs an account can purchase per transaction.\r\n    uint256 internal constant _purchaseLimit = 100;\r\n    /// @notice Maximum number of free CryptoBlobs an account can earn and claim.\r\n    uint256 internal constant _maxFreePerAccount = 10;\r\n    /// @notice Maximum number of NFTs per collection that can be redeemed.\r\n    uint256 internal constant _nftsPerCollectionLimit = 10;\r\n    /// @notice Base price increment per point used on the live market.\r\n    uint256 internal constant _basePriceIncrementPerPoint = 0.0000025 ether;\r\n    /// @notice Price and multiplier decline duration (1% per hour).\r\n    uint256 internal constant _declineDuration = 100 hours;\r\n    /// @notice Each BOGO lasts for 7.5 minutes. Takes 30 minutes for \"buy 1, get 1 free\".\r\n    uint256 internal constant _bogoDuration = 450 seconds;\r\n    /// @notice BOGO starts at \"buy 5, get 1 free\".\r\n    uint256 internal constant _bogoStartingFrom = 5;\r\n    /// @notice The number of sacrifices until an account can earn a free CryptoBlob.\r\n    uint256 internal constant _burnsPerReward = 10;\r\n    /// @notice The number of referral purchases until an account can earn a free CryptoBlob.\r\n    uint256 internal constant _referralsPerReward = 5;\r\n    /// @notice The number of purchases until an account starts earning hourly drops.\r\n    uint256 internal constant _hourlyDropThreshold = 5;\r\n    /// @notice Lowers gas when making calculations.\r\n    uint256 internal constant _sections = 8;\r\n    /// @notice Lowers gas when making calculations.\r\n    uint256 internal constant _distance = 3125;\r\n    /// @notice How long each drop takes to earn.\r\n    uint256 internal constant _hourlyDropDuration = 1 hours;\r\n    /// @notice The base amount the temporary demand multiplier fluctuates by.\r\n    uint256 internal constant _volatilityBase = 10;\r\n    /// @notice The amount volatility is multiplied by after the threshold is reached.\r\n    uint256 internal constant _volatilityMultiplier = 3;\r\n    /// @notice Threshold when volatility increases. Causes the price to increase or decrease faster.\r\n    uint256 internal constant _increasedVolatilityThreshold = 20000;\r\n    /// @notice Unlock status for reentrancy guard.\r\n    uint32 internal constant _reentrancyUnlocked = 1;\r\n    /// @notice Lock status for reentrancy guard.\r\n    uint32 internal constant _reentrancyLocked = 2;\r\n\r\n    // Public - The public has access to modify these values.\r\n\r\n    /// @notice Reentrancy guard status.\r\n    uint32 internal _reentrancyStatus;\r\n    /// @notice The number of CryptoBlobs that have been purchased.\r\n    uint32 internal _tokensMintedPurchase;\r\n    /// @notice The number of CryptoBlobs that have been claimed for free.\r\n    uint32 internal _tokensMintedFree;\r\n    /// @notice The number of CryptoBlobs that have been burned/sacrificed.\r\n    uint32 internal _tokensBurned;\r\n    /// @notice The temporary multiplier on the price, determined by demand and market activity.\r\n    uint32 internal _temporaryDemandMultiplier;\r\n    /// @notice The timestamp the last purchase was made.\r\n    uint32 internal _purchaseTimestamp;\r\n    /// @notice Used NFT IDs in a collection for the giveaway.\r\n    mapping(address => uint256[]) internal _nftsRedeemed;\r\n    /// @notice Stores account data.\r\n    mapping(address => Account) internal _account;\r\n    /// @notice Stores token data.\r\n    mapping(uint256 => Token) internal _token;\r\n\r\n    // Owner - SuperCollectiv has access to modify these values using {manageContract}.\r\n    // Additionally, we can modify _contractOwner and _contractCandidate in [Ownable].\r\n\r\n    /// @notice The name of the token. We may shorten the name after the initial mint.\r\n    string internal _name = \"CryptoBlobs.com | SuperCollectiv\";\r\n    /// @notice If the integrated trading platform is paused.\r\n    bool internal _tradingPaused;\r\n    /// @notice If sacrificing is paused.\r\n    bool internal _sacrificingPaused;\r\n    /// @notice The maximum number of souls the token URI will support.\r\n    uint256 internal _URIMaxSoulsLimit = 100;\r\n    /// @notice ENS reverse records address.\r\n    address internal _reverseRecordsAddress = 0x3671aE578E63FdF66ad4F3E12CC0c0d71Ac7510C;\r\n    /// @notice Contract URI for the contract.\r\n    string internal _contractURI;\r\n    /// @notice Token URI prefix for single URI schema.\r\n    string internal _tokenURIPrefix;\r\n    /// @notice Token URI prefixes for multi URI schema.\r\n    mapping(uint256 => string) internal _tokenURIPrefixes;\r\n\r\n    /**\r\n        @param tokensOwned The number of CryptoBlobs owned.\r\n        @param mintedPurchase The number of CryptoBlobs purchased.\r\n        @param mintedBogos The number of CryptoBlobs claimed from BOGO deals.\r\n        @param mintedGiveaway The number of CryptoBlobs claimed from the giveaway.\r\n        @param tokensBurned The number of CryptoBlobs burned.\r\n        @param mintedHourlyDrops The number of CryptoBlobs claimed from hourly drops.\r\n        @param mintedSacrifices The number of CryptoBlobs claimed from the sacrifice promo.\r\n        @param mintedReferrals The number of CryptoBlobs claimed from referring.\r\n        @param mintedSpecial The number of CryptoBlobs gifted from SuperCollectiv. Max number is 255.\r\n        @param tokensOptimized The number of CryptoBlobs optimized.\r\n        @param referralPurchases The number of CryptoBlobs purchased with account's referral link.\r\n        @param timestampHourlyDropLastClaimed Timestamp the account last claimed their hourly drop or initialized it.\r\n        @param timestampReferralLinkUsed Timestamp the account used a referral link.\r\n        @param timestampTradesLocked Timestamp the account locked their trades on the integrated trading platform.\r\n        @param timestampTradeHashUsed Timestamp when trade hashes have been cancelled or completed by the account.\r\n        @param approvals Addresses the account has approved to manage all CryptoBlobs owned by them.\r\n    */\r\n    struct Account {\r\n        // Order is optimized.\r\n        uint16 tokensOwned;\r\n        uint16 mintedPurchase;\r\n        uint8 mintedBogos;\r\n        uint8 mintedGiveaway;\r\n        uint16 tokensBurned;\r\n        uint8 mintedHourlyDrops;\r\n        uint8 mintedSacrifices;\r\n        uint8 mintedReferrals;\r\n        uint16 mintedSpecial;\r\n        uint16 tokensOptimized;\r\n        uint16 referralPurchases;\r\n        uint32 timestampHourlyDropLastClaimed;\r\n        uint32 timestampReferralLinkUsed;\r\n        uint32 timestampTradesLocked;\r\n        mapping(bytes32 => uint256) timestampTradeHashUsed;\r\n        mapping(address => uint256) approvals;\r\n        uint256 preapprovedStatus;\r\n    }\r\n\r\n    /**\r\n        @param mintTimestamp Timestamp minted.\r\n        @param burnTimestamp Timestamp burned.\r\n        @param souls Before burn: The number of souls harnessed. After burn: The number of souls transferred to burnTo.\r\n        @param burnTo CryptoBlob ID transferred souls to.\r\n        @param account Before burn: Address of the owner. After burn: Address that last owned it.\r\n        @param approval Address of the approved token operator.\r\n    */\r\n    struct Token {\r\n        uint32 mintTimestamp;\r\n        uint32 burnTimestamp;\r\n        uint16 souls;\r\n        uint16 burnTo;\r\n        address account;\r\n        address approval;\r\n    }\r\n\r\n    /**\r\n        @notice Batch transaction data for {batch}.\r\n    */\r\n    struct BatchData {\r\n        uint256 category;\r\n        address account1;\r\n        address account2;\r\n        uint256 tokenId;\r\n        uint256[] tokenIds;\r\n        bool approved;\r\n        bytes32 hash;\r\n    }\r\n\r\n    /**\r\n        @notice The name of the token.\r\n    */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n        @notice The symbol of the token.\r\n    */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n        @notice If an interface ID is supported. \r\n        @dev Supported interfaces: IERC165 (0x01ffc9a7), IERC721 (0x80ac58cd), IERC721Metadata (0x5b5e139f), IERC721Enumerable (0x780e9d63).\r\n        @param interfaceId Interface ID to check.\r\n        @return If `interfaceId` is supported.\r\n    */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return interfaceId == type(IERC165).interfaceId ||          // 0x01ffc9a7\r\n            interfaceId == type(IERC721).interfaceId ||             // 0x80ac58cd\r\n            interfaceId == type(IERC721Metadata).interfaceId ||     // 0x5b5e139f\r\n            interfaceId == type(IERC721Enumerable).interfaceId;     // 0x780e9d63\r\n    }\r\n\r\n    /**\r\n        @notice Returns a token ID owned by `owner` at a given index in its inventory.\r\n        @param owner The address of the account.\r\n        @param index Inventory index of `owner` to read. Uses index zero.\r\n        @return The token ID of the CryptoBlob at the index.\r\n    */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        unchecked {\r\n            uint256 tokensMinted = _tokensMinted(); // Saves gas.\r\n            uint256 indexOfOwner; // Iterates when inventory index does not match `index`.\r\n            address accountOfToken;\r\n            uint256 balance = balanceOf(owner);\r\n            if (index < balance) {\r\n                for (uint256 i; i < tokensMinted; i++) {\r\n                    uint256 tokenId = _getTokenId(i);\r\n                    if (_token[tokenId].account != address(0)) {\r\n                        accountOfToken = _token[tokenId].account; // Store address.\r\n                    }\r\n                    // If the CryptoBlob last checked is in the owner's inventory.\r\n                    if (accountOfToken == owner && !_isTokenSacrificed(tokenId)) {\r\n                        if (indexOfOwner != index) {\r\n                            indexOfOwner++; // Iterate if incorrect index.\r\n                        } else {\r\n                            return tokenId; // Return if the index matches.\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            revert OWNERS_BALANCE_IS_INSUFFICENT_FOR_THE_INDEX();\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice The circulating supply of CryptoBlobs.\r\n    */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        unchecked {\r\n            return _tokensMinted() - _tokensBurned; // Cannot underflow.\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Returns a token ID at a given `index`.\r\n        @param index Index of the circulating supply to read.\r\n        @return The token ID of the CryptoBlob at the index.\r\n    */\r\n    function tokenByIndex(uint256 index)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        unchecked {\r\n            uint256 tokensMinted = _tokensMinted();\r\n            uint256 tokenIdsIndex;\r\n            if (index < tokensMinted) {\r\n                // Check each minted CryptoBlob and return the ID when the index is reached.\r\n                for (uint256 i; i < tokensMinted; i++) {\r\n                    uint256 tokenId = _getTokenId(i);\r\n                    if (!_isTokenSacrificed(tokenId)) {\r\n                        if (tokenIdsIndex != index) {\r\n                            tokenIdsIndex++; // Iterate if incorrect index.\r\n                        } else {\r\n                            return tokenId; // Return if the index matches.\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            revert INVALID_CRYPTOBLOB_ID();\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice The balance of an account.\r\n        @param owner The address of the account.\r\n        @return The balance of `owner`.\r\n    */\r\n    function balanceOf(address owner)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        if (owner == address(0)) revert THE_ZERO_ADDRESS_CANNOT_HAVE_AN_ACCOUNT();\r\n        return _account[owner].tokensOwned;\r\n    }\r\n\r\n    /**\r\n        @notice The owner of a CryptoBlob ID.\r\n        @param tokenId The token ID of the CryptoBlob.\r\n        @return The owner of `tokenId`.\r\n    */\r\n    function ownerOf(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        unchecked {\r\n            _revertIfTokenIsInvalid(tokenId);\r\n            uint256 index = _getTokenIndex(tokenId);\r\n            while (true) {\r\n                if (_token[tokenId].account == address(0)) {\r\n                    tokenId = _getTokenId(--index);\r\n                } else {\r\n                    return _token[tokenId].account;\r\n                }\r\n            }\r\n            revert INVALID_CRYPTOBLOB_ID();\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice The token URI of a CryptoBlob ID.\r\n        @dev Unminted CryptoBlobs revert with an error.\r\n        @dev Sacrificed CryptoBlobs still have metadata.\r\n        @param tokenId The token ID of the CryptoBlob.\r\n        @return The token URI of `tokenId`.\r\n    */\r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        unchecked {\r\n            if (_getTokenIndex(tokenId) >= _tokensMinted()) revert INVALID_CRYPTOBLOB_ID();\r\n\r\n            uint256 souls;\r\n            if (!_isTokenSacrificed(tokenId)) souls = _token[tokenId].souls + 1; // Get souls harnessed and +1 for self.\r\n            if (souls > _URIMaxSoulsLimit) souls = _URIMaxSoulsLimit; // Limit souls.\r\n\r\n            if (bytes(_tokenURIPrefix).length > 0) {\r\n                // Single URI with an extension.\r\n                return string(abi.encodePacked(_tokenURIPrefix, _toPaddedString(souls), \"/\", _toPaddedString(tokenId)));\r\n            } else if (bytes(_tokenURIPrefixes[souls]).length > 0) {\r\n                // Multi URI with no extension.\r\n                return string(abi.encodePacked(_tokenURIPrefixes[souls], _toPaddedString(tokenId)));\r\n            } else {\r\n                // If no token URI.\r\n                return \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Returns the approved token operator for `tokenId`.\r\n        @dev Get all approved token operators with {tokenDataByCategory} category 1.\r\n        @param tokenId The token ID of the CryptoBlob.\r\n        @return The address of the account that can manage `tokenId`.\r\n    */\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        _revertIfTokenIsInvalid(tokenId);\r\n        return _token[tokenId].approval;\r\n    }\r\n\r\n    /**\r\n        @notice Returns if `operator` is an approved account operator of `owner`.\r\n        @dev Account operators can do everything the owner can do expect sign messages and manage their account operators.\r\n        @dev Preapproved services: OpenSea, X2Y2, LooksRare, Rarible, 0x Protocol v4, Element, SudoSwap, NFTX, and NFTTrader.\r\n        @dev You can revoke these services using {setApprovalForAll} or visit CryptoBlobs.com for a batch tx to revoke all at once.\r\n        @dev SuperCollectiv will permanently disable preapproved services if any issues are discovered with these contracts.\r\n        @dev Services that list your account operators will not detect that these addresses have\r\n        @dev been approved unless you reapprove each service with {setApprovalForAll} or {batch}.\r\n        @param owner The address of the account that owns the CryptoBlobs.\r\n        @param operator The address of the account to the check the status of.\r\n        @return If `operator` is an account operator of `owner`.\r\n    */\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n\r\n        // Preapproved services:\r\n        // OpenSea, X2Y2, LooksRare, Rarible, 0x Protocol v4, Element, SudoSwap, NFTX, and NFTTrader.\r\n        // You can manage these services like usual with {setApprovalForAll} or {batch}.\r\n\r\n        uint256 status = _account[owner].approvals[operator];\r\n        return (\r\n                    status == 2 || // If approved.\r\n                    (\r\n                        status == 0 && // If default value (never approved or revoked by the owner).\r\n                        _account[operator].preapprovedStatus == 2 && // If preapproved service.\r\n                        owner != operator // If not self.\r\n                    )\r\n                );\r\n    }\r\n\r\n    /**\r\n        @notice The contract URI for the CryptoBlobs smart contract.\r\n    */\r\n    function contractURI() public view returns (string memory) {\r\n        return _contractURI;\r\n    }\r\n\r\n    /**\r\n        @notice All-in-one method to get general data for the contract.\r\n        @dev Enter the zero address to query {generalData} without checking an NFT.\r\n        @param contractAddress Contract address of the NFT.\r\n        @param tokenId Token ID of the NFT.\r\n        @return data General contract data.\r\n        @return owner Owner of the NFT.\r\n        @return isERC721 If the token is an ERC721 NFT.\r\n        @return nftsRedeemed NFT IDs redeemed in the collection.\r\n        @return contractOwner Contract owner.\r\n        @return contractCandidate Contract candidate.\r\n        @return contractBalance Contract balance.\r\n    */\r\n    function generalData(address contractAddress, uint256 tokenId) \r\n        public \r\n        view \r\n        returns (\r\n            uint256[12] memory data, \r\n            address owner, \r\n            bool isERC721, \r\n            uint256[] memory nftsRedeemed,\r\n            address contractOwner,\r\n            address contractCandidate,\r\n            uint256 contractBalance\r\n        ) \r\n    {\r\n        unchecked {\r\n\r\n            // Supply data.\r\n            data[0] = _tokensMintedPurchase;\r\n            data[1] = _tokensMintedFree;\r\n            data[2] = _tokensBurned;\r\n\r\n            // Temporarily hold tokensMinted.\r\n            data[3] = _tokensMinted();\r\n\r\n            // Time until next hourly drop.\r\n            if (data[3] < _sacrificeAndHourlyDropsOffersEnds) data[4] = _hourlyDropDuration - (block.timestamp % _hourlyDropDuration);\r\n\r\n            // Statuses.\r\n            if (_tradingPaused) data[5] = 1;\r\n            if (_sacrificingPaused) data[6] = 1;\r\n            \r\n            // Get price.\r\n            if (data[3] != _maxSupply) (data[7], data[8], data[9], data[10], data[11]) = _marketPrice(data[0], data[1]);\r\n\r\n            // Check NFT.\r\n            if (contractAddress != address(0)) (owner, isERC721, nftsRedeemed) = _checkNFT(contractAddress, tokenId);\r\n\r\n            // Block timestamp.\r\n            data[3] = block.timestamp;\r\n\r\n            return (data, owner, isERC721, nftsRedeemed, _contractOwner, _contractCandidate, address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Check an NFT.\r\n        @param contractAddress Contract address of the NFT.\r\n        @param tokenId Token ID of the NFT.\r\n        @return owner Owner of the NFT.\r\n        @return isERC721 If the token is an ERC721 NFT.\r\n        @return nftsRedeemed NFT IDs redeemed in the collection.\r\n    */\r\n    function _checkNFT(address contractAddress, uint256 tokenId) internal view returns (address owner, bool isERC721, uint256[] memory nftsRedeemed) {\r\n        if (_isContractPastConstruction(contractAddress)) {\r\n            try IERC721(contractAddress).ownerOf(tokenId) returns (address _owner) { owner = _owner; } catch {}\r\n            try IERC165(contractAddress).supportsInterface(type(IERC721).interfaceId) returns (bool _isERC721) { isERC721 = _isERC721; } catch {}\r\n            //try IERC721Metadata(contractAddress).tokenURI(tokenId) returns (string memory _tokenURI) { if (bytes(_tokenURI).length == 0) isERC721 = false; } catch {}\r\n            nftsRedeemed = _nftsRedeemed[contractAddress];\r\n        }\r\n        return (owner, isERC721, nftsRedeemed);\r\n    }\r\n\r\n    /**\r\n        @notice Redeem an NFT.\r\n        @param contractAddress Contract address of the NFT.\r\n        @param tokenId Token ID of the NFT.\r\n        @return redeemed If the NFT was redeemed (true if no revert).\r\n    */\r\n    function _redeemNFT(address contractAddress, uint256 tokenId) internal returns (bool redeemed) {\r\n        unchecked {\r\n            // Get NFT data.\r\n            (address owner, bool isERC721, uint256[] memory nftsRedeemed) = _checkNFT(contractAddress, tokenId);\r\n\r\n            // Revert if not owner, not ERC721, or limit reached.\r\n            if (owner != msg.sender || !isERC721 || nftsRedeemed.length >= _nftsPerCollectionLimit) revert NFT_IS_NOT_ELIGIBLE();\r\n\r\n            // Revert if the NFT has been redeemed.\r\n            for (uint256 i; i < nftsRedeemed.length; i++) {\r\n                if (nftsRedeemed[i] == tokenId) revert NFT_IS_NOT_ELIGIBLE();\r\n            }\r\n\r\n            // Add to redeemed array.\r\n            _nftsRedeemed[contractAddress].push(tokenId);\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Account data for an account.\r\n        @dev The zero address cannot have an account.\r\n        @param account The address of the account.\r\n        @param getENS Optionally get the ENS name of `account`.\r\n        @param getTokens Optionally get the owned and burned tokens of `account`.\r\n        @return data 0 owned, 1 burned, 2 optimized, 3 purchased, 4 special, 5 free, (minted: 6 bogos, 7 drops, 8 sacrifices, 9 referrals, 10 giveaway), (claimable: 11 total, 12 drops, 13 sacrifices, 14 referrals, 15 giveaway), 16 referral purchases, (timestamps: 17 hourly drop last claimed, 18 referral link used, 19 trades locked), 20 is contract, 21 wallet balance.\r\n        @return ensName The ENS name of `account`.\r\n        @return ownedData Data for CryptoBlobs owned by the account (ID, souls, mint timestamp, approval as uint).\r\n        @return burnedData Data for CryptoBlobs burned by the account (ID, ID upgraded, souls transferred, mint timestamp, burn timestamp).\r\n    */\r\n    function accountData(address account, bool getENS, bool getTokens)\r\n        public\r\n        view\r\n        returns (\r\n            uint256[22] memory data,\r\n            string memory ensName,\r\n            uint256[] memory ownedData,\r\n            uint256[] memory burnedData\r\n        )\r\n    {\r\n        unchecked {\r\n            // Token stats\r\n            data[0] = balanceOf(account);\r\n            data[1] = _account[account].tokensBurned;\r\n            data[2] = _account[account].tokensOptimized;\r\n            // Minted amounts\r\n            // Total minted = mintedPurchase + mintedSpecial + mintedFree\r\n            data[3] = _account[account].mintedPurchase;\r\n            data[4] = _account[account].mintedSpecial;\r\n            // data[5] mintedFree total below\r\n            // mintedFree breakdown: 6-10\r\n            data[6] = _account[account].mintedBogos;\r\n            data[7] = _account[account].mintedHourlyDrops;\r\n            data[8] = _account[account].mintedSacrifices;\r\n            data[9] = _account[account].mintedReferrals;\r\n            data[10] = _account[account].mintedGiveaway;\r\n            // Claimables: 11-15\r\n            (data[5], data[12], data[13], data[14], data[15]) = _accountToClaimable(account);\r\n            data[11] = data[12] + data[13] + data[14] + data[15];\r\n            // Miscellaneous\r\n            data[16] = _account[account].referralPurchases;\r\n            // Timestamps\r\n            data[17] = _account[account].timestampHourlyDropLastClaimed;\r\n            data[18] = _account[account].timestampReferralLinkUsed;\r\n            data[19] = _account[account].timestampTradesLocked;\r\n            // Bools\r\n            if (_isContractPastConstruction(account)) data[20] = 1;\r\n            // Ether balance\r\n            data[21] = address(account).balance;\r\n\r\n            // Optionally get ENS name.\r\n            if (getENS) {\r\n                address[] memory addresses = new address[](1);\r\n                addresses[0] = account;\r\n                ensName = addressesToENS(addresses)[0];\r\n            }\r\n\r\n            // Optionally get tokens.\r\n            if (getTokens) {\r\n\r\n                uint256[4] memory variables;\r\n                // 0 = ownedIndex\r\n                // 1 = burnedIndex\r\n                // 2 = tokensChecked\r\n                // 3 = mintTimestampOfToken\r\n\r\n                // If currently owns CryptoBlobs or had sacrificed any.\r\n                if (data[0] + data[1] > 0) {\r\n\r\n                    // Create owned array.\r\n                    uint256 ownedDataAmount = 4;\r\n                    ownedData = new uint256[](data[0] * ownedDataAmount);\r\n                    // Each owned ID returns:\r\n                    // - token ID\r\n                    // - souls owned\r\n                    // - mint timestamp\r\n                    // - approval (as uint, must convert to hex)\r\n\r\n                    // Create burned array.\r\n                    uint256 burnedDataAmount = 5;\r\n                    burnedData = new uint256[](data[1] * burnedDataAmount);\r\n                    // Each burned ID returns:\r\n                    // - token ID\r\n                    // - token ID upgraded\r\n                    // - souls transferred to upgraded ID\r\n                    // - mint timestamp\r\n                    // - burn timestamp\r\n\r\n                    // Get all data for the account until all is found.\r\n                    address accountOfToken;\r\n                    while (data[0] + data[1] != variables[0] + variables[1]) {\r\n                        uint256 tokenId = _getTokenId(variables[2]++);\r\n                        // Get owner or last owner.\r\n                        if (_token[tokenId].account != address(0)) {\r\n                            accountOfToken = _token[tokenId].account;\r\n                        }\r\n                        // Get minted timestamp.\r\n                        if (_token[tokenId].mintTimestamp != 0) {\r\n                            variables[3] = _token[tokenId].mintTimestamp;\r\n                        }\r\n                        if (accountOfToken == account) {\r\n                            // If account matches query.\r\n                            if (!_isTokenSacrificed(tokenId)) { // If owned.\r\n                                ownedData[variables[0] * ownedDataAmount] = tokenId;\r\n                                ownedData[(variables[0] * ownedDataAmount) + 1] = _token[tokenId].souls + 1;\r\n                                ownedData[(variables[0] * ownedDataAmount) + 2] = variables[3];\r\n                                ownedData[(variables[0] * ownedDataAmount) + 3] = uint160(_token[tokenId].approval);\r\n                                variables[0]++;\r\n                            } else { // If sacrificed.\r\n                                burnedData[variables[1] * burnedDataAmount] = tokenId;\r\n                                burnedData[(variables[1] * burnedDataAmount) + 1] = _token[tokenId].burnTo;\r\n                                burnedData[(variables[1] * burnedDataAmount) + 2] = _token[tokenId].souls;\r\n                                burnedData[(variables[1] * burnedDataAmount) + 3] = variables[3];\r\n                                burnedData[(variables[1] * burnedDataAmount) + 4] = _token[tokenId].burnTimestamp;\r\n                                variables[1]++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return (data, ensName, ownedData, burnedData);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Account data for multiple accounts by category.\r\n        @dev See past event logs for more data. Use {addressesToENS} for ENS names.\r\n        @dev The zero address cannot have an account and returns from it should be ignored. This is not checked to optimize calls.\r\n        @param accounts The addresses of the accounts.\r\n        @param category (0: owned, burned, optimized, purchased), (1: owned, burned, optimized), 2 total claimable, 3 trades locked, (4: wallet balance, is contract)\r\n        @return data The uint data of all accounts, based on the category.\r\n    */\r\n    function accountDataByCategory(address[] memory accounts, uint256 category)\r\n        external\r\n        view\r\n        returns (uint256[] memory data)\r\n    {\r\n        unchecked {\r\n\r\n            // The following categories can be queried from logs.\r\n            // tokensMinted\r\n            // mintedFree\r\n            // mintedHourlyDrops\r\n            // mintedSacrifices\r\n            // mintedReferrals\r\n            // mintedGiveaway\r\n            // mintedBogos\r\n            // mintedSpecial\r\n            // referralPurchases\r\n            // timestampHourlyDropLastClaimed\r\n            // timestampReferralLinkUsed\r\n\r\n            // Use {accountData} for claimable specifics.\r\n            // claimableHourlyDrops\r\n            // claimableSacrifices\r\n            // claimableReferrals\r\n            // claimableGiveaway\r\n\r\n            uint256 accountsAmount = accounts.length;\r\n            if (category == 0) {\r\n                // Owned, burned, optimized, purchased.\r\n                // Data for the leaderboards.\r\n                uint256 amount = 4;\r\n                data = new uint256[](accountsAmount * amount);\r\n                for (uint256 i; i < accountsAmount; i++) {\r\n                    data[i * amount] = balanceOf(accounts[i]);\r\n                    data[i * amount + 1] = _account[accounts[i]].tokensBurned;\r\n                    data[i * amount + 2] = _account[accounts[i]].tokensOptimized;\r\n                    data[i * amount + 3] = _account[accounts[i]].mintedPurchase;\r\n                }\r\n            } else if (category == 1) {\r\n                // Owned, burned, optimized.\r\n                // Alternative for category 0 because purchases can be retrieved from past logs.\r\n                uint256 amount = 3;\r\n                data = new uint256[](accountsAmount * amount);\r\n                for (uint256 i; i < accountsAmount; i++) {\r\n                    data[i * amount] = balanceOf(accounts[i]);\r\n                    data[i * amount + 1] = _account[accounts[i]].tokensBurned;\r\n                    data[i * amount + 2] = _account[accounts[i]].tokensOptimized;\r\n                }\r\n            } else if (category == 2) {\r\n                // Total claimable.\r\n                data = new uint256[](accountsAmount);\r\n                for (uint256 i; i < accountsAmount; i++) {\r\n                    (\r\n                        ,\r\n                        uint256 claimableHourlyDrops, \r\n                        uint256 claimableSacrifices, \r\n                        uint256 claimableReferrals, \r\n                        uint256 claimableGiveaway\r\n                    ) = _accountToClaimable(accounts[i]);\r\n                    data[i] = claimableHourlyDrops + claimableSacrifices + claimableReferrals + claimableGiveaway;\r\n                }\r\n            } else if (category == 3) {\r\n                // Timestamp trades locked.\r\n                data = new uint256[](accountsAmount);\r\n                for (uint256 i; i < accountsAmount; i++) {\r\n                    data[i] = _account[accounts[i]].timestampTradesLocked;\r\n                }\r\n            } else {\r\n                // Wallet balance and is contract.\r\n                uint256 amount = 2;\r\n                data = new uint256[](accountsAmount * amount);\r\n                for (uint256 i; i < accountsAmount; i++) {\r\n                    data[i * amount] = address(accounts[i]).balance;\r\n                    if (_isContractPastConstruction(accounts[i])) data[i * amount + 1] = 1;\r\n                }\r\n            }\r\n            return data;\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Reverse records for the primary ENS name of accounts.\r\n        @dev _reverseRecordsAddress Can be updated to support additional features.\r\n        @param accounts The addresses of the accounts.\r\n        @return ensNames ENS names of `accounts`.\r\n    */\r\n    function addressesToENS(address[] memory accounts) public view returns (string[] memory ensNames) {\r\n        return IReverseRecords(_reverseRecordsAddress).getNames(accounts);\r\n    }\r\n\r\n    /**\r\n        @notice Token data for a CryptoBlob ID.\r\n        @param tokenId The token ID of the CryptoBlob.\r\n        @param getENS Optionally get the ENS names of accounts.\r\n        @return owner The owner of `tokenId`.\r\n        @return approval The approved token operator of `tokenId`.\r\n        @return burner The last owner of `tokenId` before it was burned.\r\n        @return mintTimestamp The timestamp `tokenId` was minted.\r\n        @return burnTimestamp The timestamp `tokenId` was burned.\r\n        @return ownedSouls The number of souls `tokenId` possesses, rewarded by {sacrifice}.\r\n        @return burnSouls The number of souls `tokenId` transferred after being burned.\r\n        @return burnTo The CryptoBlob ID `tokenId` transferred its soul(s) to.\r\n        @return distance Optimization distance/rank.\r\n        @return ensNames The ENS name of the owner, approval, and burner.\r\n    */\r\n    function tokenData(uint256 tokenId, bool getENS)\r\n        external\r\n        view\r\n        returns (\r\n            address owner,\r\n            address approval,\r\n            address burner,\r\n            uint256 mintTimestamp,\r\n            uint256 burnTimestamp,\r\n            uint256 ownedSouls,\r\n            uint256 burnSouls,\r\n            uint256 burnTo,\r\n            uint256 distance,\r\n            string[] memory ensNames\r\n        )\r\n    {\r\n        unchecked {\r\n            if (!_isTokenSacrificed(tokenId)) {\r\n                owner = ownerOf(tokenId); // Reverts if not yet minted.\r\n                approval = _token[tokenId].approval;\r\n                ownedSouls = _token[tokenId].souls + 1; // +1 for self.\r\n            } else {\r\n                burner = _token[tokenId].account;\r\n                burnTimestamp = _token[tokenId].burnTimestamp;\r\n                burnTo = _token[tokenId].burnTo;\r\n                burnSouls = _token[tokenId].souls;\r\n            }\r\n            uint256 index = _getTokenIndex(tokenId);\r\n            while (mintTimestamp == 0) {\r\n                if (_token[tokenId].mintTimestamp == 0) {\r\n                    if (_token[tokenId].account == address(0)) {\r\n                        distance++;\r\n                    }\r\n                    tokenId = _getTokenId(--index);\r\n                } else {\r\n                    mintTimestamp = _token[tokenId].mintTimestamp;\r\n                }\r\n            }\r\n            if (getENS) {\r\n                address[] memory addresses = new address[](3); // Create array.\r\n                addresses[0] = owner;\r\n                addresses[1] = approval;\r\n                addresses[2] = burner;\r\n                ensNames = addressesToENS(addresses); // Get ENS names.\r\n            }\r\n            return (\r\n                owner,\r\n                approval,\r\n                burner,\r\n                mintTimestamp,\r\n                burnTimestamp,\r\n                ownedSouls,\r\n                burnSouls,\r\n                burnTo,\r\n                distance,\r\n                ensNames\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n        @notice Information about all tokens. Uses index 0.\r\n        @dev Most providers will successfully call this function.\r\n        @dev Data can be split by specifying an index and an amount, which uses token indices.\r\n        @param category 0 owners, 1 approvals, 2 burners, 3 mintTimestamps, 4 burnTimestamps, 5 ownedSouls, 6 burnSouls, 7 burnTos, 8 distance.\r\n        @param index Index to start from when splitting data. Default is 0.\r\n        @param amount Amount to query when splitting data. Default is 0.\r\n        @return data The number data of all tokens, based on the category. Addresses are uints, which will need to be conversed to hex and checksummed.\r\n    */\r\n    function tokenDataByCategory(uint256 category, uint256 index, uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256[] memory data)\r\n    {\r\n        unchecked {\r\n            uint256 tokensMinted = _tokensMinted();\r\n            uint256 toIndex;\r\n            uint256 fromIndex;\r\n            if (amount == 0) { // Getting all data.\r\n                amount = _maxSupply;\r\n                toIndex = tokensMinted;\r\n            } else { // Getting range.\r\n                // Precheck for accurate data. \r\n                if (category == 0 || category == 3 || category == 8) {\r\n                    // toIndex temporarily holds precheck amount.\r\n                    uint maxPrecheck = _purchaseLimit + _maxFreePerAccount;\r\n                    if (index > maxPrecheck) {\r\n                        toIndex = maxPrecheck;\r\n                    } else if (index != 0) {\r\n                        toIndex = index % (maxPrecheck);\r\n                    }\r\n                }\r\n                fromIndex = index - toIndex; // Cannot underflow because index > toIndex (precheck).\r\n                toIndex += fromIndex + amount; // toIndex is calculated here.\r\n                // Limit amount.\r\n                if (toIndex > tokensMinted) {\r\n                    toIndex = tokensMinted;\r\n                    amount = toIndex - index; // Cannot underflow because toIndex always > index.\r\n                }\r\n            }\r\n            data = new uint256[](amount); // Create uint array.\r\n            uint256 holdNumber;\r\n            if (category != 8) {\r\n                while (fromIndex < toIndex) {\r\n                    // Check all minted CryptoBlobs.\r\n                    uint256 tokenId = _getTokenId(fromIndex); // Get token ID.\r\n                    bool sacrificed = _isTokenSacrificed(tokenId);\r\n                    uint256 dataRetrieved;\r\n                    if (category == 0) {\r\n                        // Update account of token.\r\n                        if (_token[tokenId].account != address(0)) {\r\n                            holdNumber = uint160(_token[tokenId].account);\r\n                        }\r\n                        // Add address if not sacrificed.\r\n                        if (!sacrificed) {\r\n                            dataRetrieved = holdNumber;\r\n                        }\r\n                    } else if (category == 1) {\r\n                        // Add approval.\r\n                        dataRetrieved = uint160(_token[tokenId].approval);\r\n                    } else if (category == 2) {\r\n                        // Update account of token.\r\n                        if (_token[tokenId].account != address(0)) {\r\n                            holdNumber = uint160(_token[tokenId].account);\r\n                        }\r\n                        // Add address if sacrificed.\r\n                        if (sacrificed) {\r\n                            dataRetrieved = holdNumber;\r\n                        }\r\n                    } else if (category == 3) {\r\n                        // Update latest mint timestamp.\r\n                        if (_token[tokenId].mintTimestamp != 0) {\r\n                            holdNumber = _token[tokenId].mintTimestamp;\r\n                        }\r\n                        // Add mint timestamp.\r\n                        dataRetrieved = holdNumber;\r\n                    } else if (category == 4) {\r\n                        // Add burn timestamp.\r\n                        dataRetrieved = _token[tokenId].burnTimestamp;\r\n                    } else if (category == 5 && !sacrificed) {\r\n                        // Add souls if not sacrificed.\r\n                        dataRetrieved = _token[tokenId].souls + 1;\r\n                    } else if (category == 6 && sacrificed) {\r\n                        // Add souls transferred if sacrificed.\r\n                        dataRetrieved = _token[tokenId].souls;\r\n                    } else if (category == 7 && sacrificed) {\r\n                        // Add token ID upgraded.\r\n                        dataRetrieved = _token[tokenId].burnTo;\r\n                    }\r\n                    // Add data to array.\r\n                    if (amount == _maxSupply) {\r\n                        if (dataRetrieved != 0) {\r\n                            data[tokenId - 1] = dataRetrieved;\r\n                        }\r\n                    } else if (fromIndex >= index) {\r\n                        if (dataRetrieved != 0) {\r\n                            data[fromIndex - index] = dataRetrieved;\r\n                        }\r\n                    }\r\n                    fromIndex++;\r\n                }\r\n            } else if (category == 8) {\r\n                uint256 tokensChecked;\r\n                while (fromIndex < toIndex) {\r\n                    if (_token[_getTokenId(toIndex - tokensChecked - 1)].account == address(0)) {\r\n                        holdNumber++;\r\n                    } else if (holdNumber > 0) {\r\n                        for (uint256 j; j < holdNumber + 1; j++) {\r\n                            if (amount == _maxSupply) {\r\n                                data[_getTokenId(toIndex - tokensChecked - 1 + j) - 1] = j;\r\n                            } else if (toIndex - tokensChecked - 1 + j >= index) {\r\n                                data[toIndex - tokensChecked - 1 + j - index] = j;\r\n                            }\r\n                        }\r\n                        delete holdNumber;\r\n                    }\r\n                    tokensChecked++;\r\n                    fromIndex++;\r\n                }\r\n            }\r\n            return data;\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Check if a trade is approved and valid. Returns the hash and error data.\r\n        @param maker The address of the maker.\r\n        @param taker The address of the taker.\r\n        @param makerIds The CryptoBlob IDs owned by `maker` to trade with `taker`.\r\n        @param takerIds The CryptoBlob IDs owned by `taker` to trade with `maker`.\r\n        @param price The price in WEI the `taker` must pay to `maker` to complete the trade.\r\n        @param expiry The UNIX time the trade automatically expires or 0 to never expire.\r\n        @param salt A nonce to allow the same trade parameters to be used again.\r\n        @param signature The signature of the signed hash.\r\n        @param checkAccess Whether to verify each CryptoBlob ID.\r\n        @return hash The hash of the trade.\r\n        @return errors The errors of the trade. Valid trades return all zeros.\r\n    */\r\n    function isTradeApprovedAndValid(\r\n        address maker,\r\n        address taker,\r\n        uint256[] memory makerIds,\r\n        uint256[] memory takerIds,\r\n        uint256 price,\r\n        uint256 expiry,\r\n        uint256 salt,\r\n        bytes memory signature,\r\n        bool checkAccess\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            bytes32 hash,\r\n            uint256[8] memory errors\r\n        )\r\n    {\r\n        unchecked {\r\n            // Trade data is hashed into 32 bytes and the hash gets signed.\r\n            hash = keccak256(\r\n                abi.encode(\r\n                    address(this),\r\n                    maker,\r\n                    taker,\r\n                    keccak256(abi.encode(makerIds)),\r\n                    keccak256(abi.encode(takerIds)),\r\n                    price,\r\n                    expiry,\r\n                    salt\r\n                )\r\n            );\r\n\r\n            // Error if the maker's address does not match the recovered signer's address.\r\n            if (!_isTradeApproved(maker, hash, signature)) errors[0] = 1;\r\n\r\n            // Error if the maker is the zero address.\r\n            if (maker == address(0)) errors[1] = 1;\r\n\r\n            // Error if the maker has their trades locked (returns timestamp locked).\r\n            errors[2] = _account[maker].timestampTradesLocked;\r\n\r\n            // Error if the hash has been used (returns timestamp used).\r\n            errors[3] = _account[maker].timestampTradeHashUsed[hash];\r\n\r\n            // Error if the trade has expired. An expiry of 0 means it never expires.\r\n            if (expiry <= block.timestamp && expiry != 0) errors[4] = 1;\r\n\r\n            // Error if taker IDs are listed when the trade is public.\r\n            if (taker == address(0) && takerIds.length > 0) errors[5] = 1;\r\n\r\n            // Error if an account does not have access to the IDs.\r\n            // `checkAccess` is false during a trade because IDs are verified in {trade} after each transfer.\r\n            if (checkAccess) {\r\n                for (uint256 i; i < makerIds.length; i++) {\r\n                    (bool hasAccess,) = _hasAccess(maker, makerIds[i]);\r\n                    if (!hasAccess) errors[6]++; // Returns amount without access.\r\n                }\r\n                for (uint256 i; i < takerIds.length; i++) {\r\n                    (bool hasAccess,) = _hasAccess(taker, takerIds[i]);\r\n                    if (!hasAccess) errors[7]++; // Returns amount without access.\r\n                }\r\n            }\r\n\r\n            return (hash, errors);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Check if trade hashes have been used and if an account can access token IDs.\r\n        @dev Token ID is checked if number is <= 25000, else the hash is checked.\r\n        @dev Hashes must be converted to uint.\r\n        @param accounts The addresses of the accounts.\r\n        @param numbers The hashes (as uint) or token IDs to check.\r\n        @return data Data returned.\r\n    */\r\n    function batchTradeHashUsedAndHasAccess(\r\n        address[] memory accounts,\r\n        uint256[] memory numbers\r\n    ) \r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory data\r\n        )\r\n    {\r\n        uint256 maxSupply = _maxSupply; // Get max supply.\r\n        uint256 accountsAmount = accounts.length; // Get return length.\r\n        data = new uint256[](accountsAmount); // Create array.\r\n        for (uint256 i; i < accountsAmount; i++) {\r\n            if (numbers[i] > maxSupply) { // If checking hash.\r\n                data[i] = _account[accounts[i]].timestampTradeHashUsed[bytes32(numbers[i])]; // Convert to bytes32 and check if used.\r\n            } else {\r\n                bool hasAccess;\r\n                (hasAccess,) = _hasAccess(accounts[i], numbers[i]);\r\n                if (hasAccess) data[i] = 1; // Return 1 if account has access.\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n        @notice Returns the status for a preapproved service.\r\n        @dev SuperCollectiv can only manage services preapproved in the constructor.\r\n        @dev 0x1E0049783F008A0085193E00003D00cd54003c71 (OpenSea).\r\n        @dev 0xF849de01B080aDC3A814FaBE1E2087475cF2E354 (X2Y2).\r\n        @dev 0xf42aa99F011A1fA7CDA90E5E98b277E306BcA83e (LooksRare).\r\n        @dev 0x4feE7B061C97C9c496b01DbcE9CDb10c02f0a0Be (Rarible).\r\n        @dev 0xDef1C0ded9bec7F1a1670819833240f027b25EfF (0x Protocol, Coinbase NFT, and more).\r\n        @dev 0x20F780A973856B93f63670377900C1d2a50a77c4 (Element).\r\n        @dev 0x2B2e8cDA09bBA9660dCA5cB6233787738Ad68329 (SudoSwap).\r\n        @dev 0x0fc584529a2AEfA997697FAfAcbA5831faC0c22d (NFTX).\r\n        @dev 0x657E383EdB9A7407E468acBCc9Fe4C9730c7C275 (NFTTrader).\r\n        @param account The address of the account.\r\n        @return status 0 = service is permanently disabled, 1 = service is temporarily disabled, 2 = service is enabled.\r\n    */\r\n    function preapprovedServiceStatus(address account) external view returns (uint256 status) {\r\n        return _account[account].preapprovedStatus;\r\n    }\r\n\r\n    /**\r\n        @notice The amount of CryptoBlobs an account can claim for free from offers. Contracts aren't eligible.\r\n        @param account The address of the account.\r\n        @return mintedFree The amount minted for free.\r\n        @return claimableHourlyDrops The amount claimable from the hourly drops.\r\n        @return claimableSacrifices The amount claimable from the sacrifice promo.\r\n        @return claimableReferrals The amount claimable from the referral program.\r\n        @return claimableGiveaway The amount claimable from the giveaway.\r\n    */\r\n    function _accountToClaimable(address account) internal view returns (\r\n            uint256 mintedFree,\r\n            uint256 claimableHourlyDrops,\r\n            uint256 claimableSacrifices,\r\n            uint256 claimableReferrals,\r\n            uint256 claimableGiveaway\r\n        )\r\n    {\r\n        unchecked {\r\n            // Calculate how many the account has claimed for free.\r\n            mintedFree = _accountToMintedFree(account);\r\n\r\n            // Offers are limited to non-contracts and if the account has not reached its limit of 10 free CryptoBlobs.\r\n            if (!_isContractPastConstruction(account) && mintedFree < _maxFreePerAccount) {\r\n\r\n                // Priority: claimableReferrals, claimableHourlyDrops, claimableSacrifices, claimableGiveaway.\r\n                // The priority system will 'overwrite' CryptoBlobs you've earned in the order above.\r\n\r\n                uint256 mintedFreeFuture = mintedFree;\r\n                uint256 tokensMinted = _tokensMinted();\r\n\r\n                // Return if 25K+ have been minted.\r\n                if (tokensMinted >= _referralProgramEnds) \r\n                    return (\r\n                        mintedFree, \r\n                        claimableHourlyDrops, \r\n                        claimableSacrifices, \r\n                        claimableReferrals, \r\n                        claimableGiveaway\r\n                    );\r\n                \r\n                // REFERRAL PROGRAM (claimableReferrals)\r\n                // Granted when:\r\n                // - under 25K mints\r\n                // - 1 for every 5 purchased by referred accounts\r\n                if ((_account[account].referralPurchases / _referralsPerReward) > _account[account].mintedReferrals) {\r\n                    claimableReferrals = (_account[account].referralPurchases / _referralsPerReward) - _account[account].mintedReferrals;\r\n                    mintedFreeFuture += claimableReferrals;\r\n                    if (mintedFreeFuture >= _maxFreePerAccount) { // If limit reached or surpassed.\r\n                        return (\r\n                            mintedFree, \r\n                            claimableHourlyDrops, \r\n                            claimableSacrifices, \r\n                            claimableReferrals - (mintedFreeFuture - _maxFreePerAccount), // Remove any over limit.\r\n                            claimableGiveaway\r\n                        );\r\n                    }\r\n                }\r\n                \r\n                // Return if 20K+ have been minted.\r\n                if (tokensMinted >= _sacrificeAndHourlyDropsOffersEnds)\r\n                    return (\r\n                        mintedFree, \r\n                        claimableHourlyDrops, \r\n                        claimableSacrifices, \r\n                        claimableReferrals, \r\n                        claimableGiveaway\r\n                    ); \r\n\r\n                // HOURLY DROP (claimableHourlyDrops)\r\n                // Granted when:\r\n                // - under 20K mints\r\n                // - has been initialized (when 5 or more purchased)\r\n                // - not initialized or claimed hourly drop today\r\n                if (\r\n                    _account[account].timestampHourlyDropLastClaimed != 0 && // If initialized.\r\n                    _account[account].timestampHourlyDropLastClaimed / _hourlyDropDuration != block.timestamp / _hourlyDropDuration // If not initialized or claimed today.\r\n                ) {\r\n                    claimableHourlyDrops = 1; // Grant 1.\r\n                    mintedFreeFuture += claimableHourlyDrops;\r\n                    if (mintedFreeFuture >= _maxFreePerAccount) { // If limit reached or surpassed.\r\n                        return (\r\n                            mintedFree, \r\n                            claimableHourlyDrops, // Only 1 granted so mintedFreeFuture cannot be > _maxFreePerAccount, only equal to.\r\n                            claimableSacrifices, \r\n                            claimableReferrals, \r\n                            claimableGiveaway\r\n                        );\r\n                    }\r\n                }\r\n\r\n                // SACRIFICE PROMO (claimableSacrifices)\r\n                // Granted when:\r\n                // - under 20K mints\r\n                // - 1 for every 10 burned\r\n                if ((_account[account].tokensBurned / _burnsPerReward) > _account[account].mintedSacrifices) {\r\n                    claimableSacrifices = (_account[account].tokensBurned / _burnsPerReward) - _account[account].mintedSacrifices;\r\n                    mintedFreeFuture += claimableSacrifices;\r\n                    if (mintedFreeFuture >= _maxFreePerAccount) { // If limit reached or surpassed.\r\n                        return (\r\n                            mintedFree, \r\n                            claimableHourlyDrops, \r\n                            claimableSacrifices - (mintedFreeFuture - _maxFreePerAccount), // Remove any over limit.\r\n                            claimableReferrals, \r\n                            claimableGiveaway\r\n                        );\r\n                    }\r\n                }\r\n\r\n                // Return if 10K+ have been minted.\r\n                if (tokensMinted >= _giveawayEnds)\r\n                    return (\r\n                        mintedFree, \r\n                        claimableHourlyDrops, \r\n                        claimableSacrifices, \r\n                        claimableReferrals, \r\n                        claimableGiveaway\r\n                    ); \r\n\r\n                // GIVEAWAY (claimableGiveaway)\r\n                // Granted when:\r\n                // - under 10K mints\r\n                // - not claimed from the giveaway\r\n                // - NFT redeeming is valid\r\n                if (_account[account].mintedGiveaway == 0) { // If not claimed from the giveaway.\r\n                    claimableGiveaway = 1; // Grant 1.\r\n                    mintedFreeFuture += claimableGiveaway;\r\n                    if (mintedFreeFuture >= _maxFreePerAccount) { // If limit reached or surpassed.\r\n                        return (\r\n                            mintedFree, \r\n                            claimableHourlyDrops, \r\n                            claimableSacrifices, \r\n                            claimableReferrals, \r\n                            claimableGiveaway // Only 1 granted so mintedFreeFuture cannot be > _maxFreePerAccount, only equal to.\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n            return (mintedFree, claimableHourlyDrops, claimableSacrifices, claimableReferrals, claimableGiveaway);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Returns the amount an account minted for free.\r\n        @dev Special mints from SuperCollectiv are not included.\r\n        @param account The address of the account.\r\n        @return mintedFree How many `account` minted for free.\r\n    */\r\n    function _accountToMintedFree(address account) internal view returns (uint256 mintedFree) {\r\n        unchecked {\r\n            mintedFree = (\r\n                _account[account].mintedBogos + \r\n                _account[account].mintedHourlyDrops + \r\n                _account[account].mintedSacrifices + \r\n                _account[account].mintedReferrals + \r\n                _account[account].mintedGiveaway\r\n                );\r\n            return mintedFree;\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Check if a trade is approved by the maker and is valid.\r\n        @dev Extracts the public address from a hash and signature pair via ECDSA, then checks if it matches the maker's address.\r\n        @param maker The address of the maker.\r\n        @param hash The hash of the trade.\r\n        @param signature The signature if the signed hash.\r\n        @return approved If `maker` and signer's addresses match.\r\n    */\r\n    function _isTradeApproved(\r\n        address maker,\r\n        bytes32 hash,\r\n        bytes memory signature\r\n    ) internal pure returns (bool approved) {\r\n        unchecked {\r\n            // Initialize\r\n            if (maker == address(0)) return false; // Always false if zero address.\r\n            if (signature.length != 65) return false; // Check length.\r\n\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n\r\n            // Use assembly to get the signature parameters for ecrecover.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n\r\n            // If the signature is valid not malleable.\r\n            if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) return false;\r\n            if (v != 27 && v != 28) return false;\r\n\r\n            // Calculate the signer.\r\n            // \\x19Ethereum Signed Message:\\n32 == 0x19457468657265756d205369676e6564204d6573736167653a0a3332\r\n            address signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), v, r, s);\r\n            if (signer == address(0)) return false;\r\n\r\n            return (maker == signer); // Check if the addresses match.\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Mints an amount of CryptoBlobs to an address.\r\n        @dev The contract does not support safeMint to save gas.\r\n        @param to The address of the account to mint the CryptoBlobs to.\r\n        @param purchase The amount of CryptoBlobs to mint to `to` as the purchase mint type.\r\n        @param free The amount of CryptoBlobs to mint to `to` as the free mint type.\r\n        @param safeBlockTimestamp The current timestamp.\r\n        @param tokensMinted The current total number of CryptoBlobs minted.\r\n    */\r\n    function _mint(\r\n        address to,\r\n        uint256 purchase,\r\n        uint256 free,\r\n        uint32 safeBlockTimestamp,\r\n        uint256 tokensMinted\r\n    ) internal {\r\n        unchecked {\r\n\r\n            // Initialize mint.\r\n            if (to == address(0)) revert THE_ZERO_ADDRESS_CANNOT_HAVE_AN_ACCOUNT();\r\n            uint256 amount = purchase + free; // Calculate amount minting.\r\n            if (\r\n                amount == 0 || // If minting zero.\r\n                tokensMinted + amount > _maxSupply || // If minting over max supply.\r\n                amount > _purchaseLimit + _maxFreePerAccount // If minting over 110 CryptoBlobs (should never occur).\r\n            ) revert AMOUNT_MINTING_IS_INVALID();\r\n\r\n            // Increase the circulating supply.\r\n            if (purchase > 0) _tokensMintedPurchase += uint32(purchase);\r\n            if (free > 0) {\r\n                _tokensMintedFree += uint32(free);\r\n                if (_accountToMintedFree(to) > _maxFreePerAccount) revert AMOUNT_MINTING_IS_INVALID(); // If account has over 10 free mints (should never occur).\r\n            }\r\n\r\n            // Update the recipient's balance.\r\n            _account[to].tokensOwned += uint16(amount);\r\n\r\n            // Save token data.\r\n            uint256 tokenId = _getTokenId(tokensMinted);\r\n            _token[tokenId].account = to;\r\n            _token[tokenId].mintTimestamp = safeBlockTimestamp;\r\n\r\n            // Total mints after this transaction (reuse variable to save gas).\r\n            purchase = tokensMinted + amount;\r\n\r\n            // Transfer event for each token.\r\n            while (tokensMinted != purchase) {\r\n                emit Transfer(      // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\r\n                    address(0),     // address indexed from\r\n                    to,             // address indexed to\r\n                    ((tokensMinted / _sections) % 2 == 0)   // uint256 indexed tokenId\r\n                    ? ((_distance * (tokensMinted % _sections)) + ((_distance * tokensMinted) / _maxSupply) + 1)\r\n                    : (_maxSupply - ((_distance * (tokensMinted % _sections)) + ((_distance * tokensMinted) / _maxSupply)))\r\n                );\r\n                tokensMinted++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Calculates the price and additional market info.\r\n        @dev Price starts at 0 ETH and is determined by supply, demand, and recent market activity.\r\n        @dev Price will be higher if purchased compared to being claimed for free.\r\n        @dev tokensMintedPurchase and tokensMintedFree are sent as parameters to lower gas.\r\n        @param tokensMintedPurchase Number of purchased mints.\r\n        @param tokensMintedFree Number of free mints.\r\n        @return price The current price to purchase a CryptoBlobs in WEI.\r\n        @return base The current base price in WEI.\r\n        @return multiplier The multiplier on the price, which increases/decreases with demand.\r\n        @return decline The percentage the price has declined since the last purchase.\r\n        @return bogo The current BOGO deal determined by demand and market activity.\r\n    */\r\n    function _marketPrice(uint256 tokensMintedPurchase, uint256 tokensMintedFree)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 price,\r\n            uint256 base,\r\n            uint256 multiplier,\r\n            uint256 decline,\r\n            uint256 bogo\r\n        )\r\n    {\r\n        unchecked {\r\n\r\n            // Calculate the base price.\r\n            // +2 points per CryptoBlob purchased.\r\n            // +1 points per CryptoBlob claimed for free.\r\n            // +1 points per CryptoBlob burned.\r\n            // +2 points per CryptoBlob minted after 20,000 mints.\r\n            base = ((tokensMintedPurchase * 2) + tokensMintedFree + _tokensBurned) * _basePriceIncrementPerPoint;\r\n            if (tokensMintedPurchase + tokensMintedFree > _increasedVolatilityThreshold) {\r\n                base += ((tokensMintedPurchase + tokensMintedFree) - _increasedVolatilityThreshold) * _basePriceIncrementPerPoint * _volatilityMultiplier;\r\n            }\r\n\r\n            // Calculate the multiplier.\r\n            // The multiplier is determined by demand.\r\n            // Paid mints increases the multiplier by 0.01% and 0.03% after 20,000 for increased volatility.\r\n            // Free mints decreases the multiplier by 0.01% and 0.03% after 20,000 for increased volatility for every 2.\r\n            // Cannot underflow because timestamp cannot decrease and _declineDuration > elapsed is checked.\r\n            uint256 elapsed = block.timestamp - _purchaseTimestamp;\r\n            if (_declineDuration > elapsed) {\r\n                multiplier = ((_declineDuration - elapsed) * _temporaryDemandMultiplier) / _declineDuration;\r\n            }\r\n\r\n            // Calculate the percentage declined.\r\n            decline = (elapsed * 100000) / _declineDuration;\r\n            if (decline > 100000) decline = 100000; // Limit decline to 100%.\r\n\r\n            // Calculate the price. Cannot underflow because decline is limited to 100%.\r\n            price = ((((base * (multiplier + 100000)) / 100000) * (100000 - decline)) / 100000);\r\n\r\n            // Calculate the current BOGO deal.\r\n            bogo = _bogoStartingFrom;\r\n            if (elapsed >= _bogoDuration) {\r\n                bogo = 1;\r\n                if (_bogoStartingFrom > (elapsed / _bogoDuration)) {\r\n                    bogo = _bogoStartingFrom - (elapsed / _bogoDuration);\r\n                }\r\n            }\r\n\r\n            return (price, base, multiplier, decline, bogo);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Transfers a CryptoBlob from one account to another.\r\n        @dev Ownership is not checked within this function to save gas, instead\r\n        @dev `from` will always be the owner's address whenever this function is called.\r\n        @dev {_transfer} is called by 2 functions: {transferFrom} and {trade}, each time the\r\n        @dev owner's address is retrieved via {_revertIfNoAccess} > {_hasAccess} > {ownerOf}.\r\n        @param from The address that owns `tokenId`.\r\n        @param to The address of the account to transfer `tokenId` to.\r\n        @param tokenId The token ID of the CryptoBlob to transfer.\r\n    */\r\n    function _transfer(address from, address to, uint256 tokenId) internal {\r\n        unchecked {\r\n\r\n            // Cannot transfer to the zero address.\r\n            if (to == address(0)) revert THE_ZERO_ADDRESS_CANNOT_HAVE_AN_ACCOUNT();\r\n\r\n            // Update owner's stats.\r\n            // Cannot underflow because ownership is checked.\r\n            _account[from].tokensOwned--;\r\n            _account[to].tokensOwned++;\r\n\r\n            // Implicitly clear approvals.\r\n            delete _token[tokenId].approval;\r\n\r\n            // ERC721 standards says to not emit an Approval event when transferring. https://eips.ethereum.org/EIPS/eip-721\r\n            // \"When a Transfer event emits, this also indicates that the approved address for that NFT (if any) is reset to none.\"\r\n\r\n            // Transfer 'tokenId' to 'to'.\r\n            _token[tokenId].account = to;\r\n\r\n            emit Transfer(  // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\r\n                from,       // address indexed from\r\n                to,         // address indexed to\r\n                tokenId     // uint256 indexed tokenId\r\n            );\r\n\r\n            // Finalize transfer.\r\n            tokenId = _getTokenIndex(tokenId) + 1;\r\n            if (tokenId < _tokensMinted()) {\r\n                tokenId = _getTokenId(tokenId);\r\n                if (_token[tokenId].account == address(0)) _token[tokenId].account = from;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Checks if an address can manage a CryptoBlob and gets the owner's address.\r\n        @dev Owner is returned so {ownerOf} does not have to be called again.\r\n        @dev Use {batchTradeHashUsedAndHasAccess} to access this function.\r\n        @param account The address of the account to check the access status of.\r\n        @param tokenId The token ID of the CryptoBlob.\r\n        @return hasAccess If the address can manage the token.\r\n        @return owner The address of the account that owns `tokenId`.\r\n    */\r\n    function _hasAccess(address account, uint256 tokenId) internal view returns (bool hasAccess, address owner) {\r\n        owner = ownerOf(tokenId); // Get the owner. Reverts if the token does not exist.\r\n        return (\r\n                (\r\n                    account == owner ||                     // If owner.\r\n                    isApprovedForAll(owner, account) ||     // If account operator via {setApprovalForAll}.\r\n                    getApproved(tokenId) == account         // If token operator via {approve}.\r\n                ), \r\n                owner\r\n            );\r\n    }\r\n\r\n    /**\r\n        @notice Reverts if an account does not have access to manage a CryptoBlob ID.\r\n        @param account The address of the account to check the access status of.\r\n        @param tokenId The token ID of the CryptoBlob.\r\n        @return owner The address of the account that owns `tokenId`.\r\n    */\r\n    function _revertIfNoAccess(address account, uint256 tokenId) internal view returns (address owner) {\r\n        (bool hasAccess, address _owner) = _hasAccess(account, tokenId);\r\n        if (!hasAccess) revert RESTRICTED_ACCESS();\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n        @notice Returns the total number of CryptoBlobs minted.\r\n        @return minted The amount of CryptoBlobs minted.\r\n    */\r\n    function _tokensMinted() internal view returns (uint256 minted) {\r\n        unchecked {\r\n            return _tokensMintedPurchase + _tokensMintedFree; // Cannot overflow.\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Returns TRUE if a CryptoBlob has been sacrificed.\r\n        @param tokenId The token ID of the CryptoBlob.\r\n        @return burned If `tokenId` has been sacrificed or not.\r\n    */\r\n    function _isTokenSacrificed(uint256 tokenId) internal view returns (bool burned) {\r\n        unchecked {\r\n            return (_token[tokenId].burnTimestamp != 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Reverts if the token ID does not exist.\r\n        @param tokenId The token ID of the CryptoBlob.\r\n    */\r\n    function _revertIfTokenIsInvalid(uint256 tokenId) internal view {\r\n        unchecked {\r\n            if (_getTokenIndex(tokenId) >= _tokensMinted()) revert INVALID_CRYPTOBLOB_ID();\r\n            if (_isTokenSacrificed(tokenId)) revert CRYPTOBLOB_HAS_BEEN_SACRIFICED();\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Safely get the UNIX time for a unit32 number.\r\n        @dev The contract does not use uint256 timestamps to save gas.\r\n        @dev The maximum date/time the contract supports is Feb 7, 2106 6:28:15 AM.\r\n        @dev Refer to past logs for uint256 timestamps.\r\n        @return _seconds The current timestamp, which stops counting at uint32's limit.\r\n    */\r\n    function _safeBlockTimestamp() internal view returns (uint32 _seconds) {\r\n        unchecked {\r\n            if (block.timestamp < type(uint32).max) {\r\n                return uint32(block.timestamp);\r\n            } else {\r\n                return type(uint32).max;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice If an address is a contract past construction.\r\n        @dev Returns FALSE if accessed in a constructor.\r\n    */\r\n    function _isContractPastConstruction(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n    \r\n    /**\r\n        @notice Converts a uint256 number to a padded number string, up to 5-digit numbers.\r\n    */\r\n    function _toPaddedString(uint256 value) internal pure returns (string memory) {\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++; // Counts how many digits the number has.\r\n            temp /= 10; // If value is 12345, then temp will be 1234, 123, 12, 1, 0.\r\n        }\r\n        bytes memory padding;\r\n        for (uint256 i; i < 5 - digits; i++) {\r\n            padding = abi.encodePacked(padding, \"0\"); // Create padding.\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            buffer[--digits] = bytes1(uint8(48 + value % 10)); // Convert.\r\n            value /= 10; // Same thing as temp above.\r\n        }\r\n        return string(abi.encodePacked(string(padding), string(buffer))); // Merge padding and number.\r\n    }\r\n\r\n    /**\r\n        @notice Interacts with another contract and/or transfers ETH.\r\n        @param account Address to interact with.\r\n        @param amount Amount of ETH to transfer.\r\n        @param data Data to send to the contract.\r\n    */\r\n    function _interaction(address account, uint256 amount, bytes memory data) internal {\r\n        if (amount > address(this).balance) revert INSUFFICIENT_CONTRACT_BALANCE(); // Check balance.\r\n        (bool success, bytes memory returndata) = payable(account).call{value: amount}(data);\r\n        // If not successful.\r\n        if (!success) {\r\n            // If no return data.\r\n            if (returndata.length == 0) {\r\n                // Revert with a generic error.\r\n                if (amount > 0) {\r\n                    revert UNABLE_TO_TRANSFER_ETHER();\r\n                } else {\r\n                    revert UNABLE_TO_INTERACT_WITH_CONTRACT();\r\n                }\r\n            } else {\r\n                // Revert with the error from the contract.\r\n                assembly {\r\n                    revert(add(32, returndata), mload(returndata))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Transfers ETH to another address.\r\n        @param account Address to transfer ETH to.\r\n        @param amount Amount of ETH to transfer.\r\n    */\r\n    function _transferEther(address account, uint256 amount) internal {\r\n        _interaction(account, amount, \"\");\r\n    }\r\n\r\n    /**\r\n        @notice Convert index to token ID.\r\n    */\r\n    function _getTokenId(uint256 index) internal pure returns (uint256 tokenId) {\r\n        unchecked {\r\n            if (index >= _maxSupply) revert INVALID_CRYPTOBLOB_ID();\r\n            if ((index / _sections) % 2 == 0) {\r\n                return (_distance * (index % _sections)) + ((_distance * index) / _maxSupply) + 1;\r\n            } else {\r\n                return _maxSupply - ((_distance * (index % _sections)) + ((_distance * index) / _maxSupply));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Convert token ID to index.\r\n    */\r\n    function _getTokenIndex(uint256 tokenId) internal pure returns (uint256 index) {\r\n        unchecked {\r\n            if (tokenId > _maxSupply || tokenId < 1) revert INVALID_CRYPTOBLOB_ID();\r\n            uint256 base = tokenId % _distance;\r\n            if (base == 0) base = _distance;\r\n            if (base % 2 != 0) { tokenId--; } else { tokenId = _maxSupply - tokenId; }\r\n            return (((tokenId % _distance) * _sections) + (tokenId / _distance));\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n    @title CryptoBlobs\r\n    @author SuperCollectiv\r\n    @dev Only contains write methods. See [SuperERC721] for read methods.\r\n*/\r\ncontract CryptoBlobs is SuperERC721 {\r\n\r\n    /**\r\n        @notice Mint CryptoBlobs by claiming them for free or purchasing them on the Live Market.\r\n        @dev Purchasing CryptoBlobs has an estimated gas fee of 66,200 + 2,050 GWEI/mint.\r\n        @param key Each account has a unique key to claim free CryptoBlobs. Enter 0 if making a purchase.\r\n        @param account When purchasing = referrer's address or zero address if none. When claiming = contract address of NFT or zero address if none.\r\n        @param number When purchasing = amount to purchase (limit 100/tx). When claiming = token ID of the NFT or 0 if none.\r\n    */\r\n    function mint(uint256 key, address account, uint256 number) external payable nonReentrant {\r\n        unchecked {\r\n\r\n            // Initialize.\r\n            uint256 tokensMintedPurchase = _tokensMintedPurchase; // Get amount purchased.\r\n            uint256 tokensMintedFree = _tokensMintedFree; // Get amount claimed for free.\r\n            uint32 safeBlockTimestamp = _safeBlockTimestamp(); // Get timestmap.\r\n\r\n            if (key == 0) {\r\n\r\n                // account = referrer\r\n                // number = amountPurchasing\r\n\r\n                // Get price and total.\r\n                (\r\n                    uint256 tokenPrice,,\r\n                    uint256 multiplier,,\r\n                    uint256 bogo\r\n                ) = _marketPrice(tokensMintedPurchase, tokensMintedFree);\r\n\r\n                // Calculate total price.\r\n                uint256 salePrice = tokenPrice * number;\r\n\r\n                // If the value sent is insufficient, the contract will attempt to \r\n                // prevent a revert by minting the maximum amount with the value sent.\r\n                // Purchase one at a time if you do not want this feature.\r\n                if (msg.value < salePrice) { // If the amount sent is insufficient.\r\n\r\n                    if (msg.value >= tokenPrice) { // If at least one can be purchased with the amount sent.\r\n                        // New amount cannot be higher than the old amount because msg.value < salePrice.\r\n                        number = msg.value / tokenPrice; // Calculate max amount that can be minted.\r\n                        salePrice = tokenPrice * number; // Calculate new total price.\r\n                    }\r\n\r\n                    // Revert if the value sent is still insufficient.\r\n                    if (msg.value < salePrice) revert INSUFFICIENT_FUNDS_SENT_PRICE_MAY_HAVE_INCREASED(salePrice, msg.value);\r\n                }\r\n\r\n                // Revert if minting too many (>100).\r\n                if (number > _purchaseLimit) revert PURCHASE_LIMIT_IS_100_PER_TRANSACTION();\r\n\r\n                // Issue refund. Refund is always issued.\r\n                // Cannot underflow because transaction reverts if msg.value < salePrice.\r\n                _transferEther(msg.sender, (msg.value - salePrice));\r\n\r\n                // Add to total account purchased. If price is 0 ETH, it will still count as a purchase.\r\n                _account[msg.sender].mintedPurchase += uint16(number);\r\n\r\n                // Initialize hourly drops if 5 are purchased. Drops at 00:00AM UTC each day. See {generalData} for countdown.\r\n                if (\r\n                    _account[msg.sender].mintedPurchase >= _hourlyDropThreshold && // If amount purchased surpasses threshold.\r\n                    _account[msg.sender].timestampHourlyDropLastClaimed == 0 // If hourly drop not initialized.\r\n                ) {\r\n                    _account[msg.sender].timestampHourlyDropLastClaimed = safeBlockTimestamp; // Initialize.\r\n                }\r\n\r\n                // BOGO deal\r\n                uint256 bogoReward;\r\n                if (number >= bogo) { // If purchased enough for BOGO deal reward.\r\n                    if (msg.sender == tx.origin) { // If not contract.\r\n                        uint256 mintedFree = _accountToMintedFree(msg.sender);\r\n                        if (mintedFree < _maxFreePerAccount) { // If account can claim more.\r\n                            bogoReward = number / bogo; // Calculate amount earned.\r\n                            if (mintedFree + bogoReward > _maxFreePerAccount) { // Correct amount if claiming too many.\r\n                                // Grant remaining amount. Overflow check above (mintedFree < _maxFreePerAccount).\r\n                                bogoReward = _maxFreePerAccount - mintedFree;\r\n                            }\r\n                            _account[msg.sender].mintedBogos += uint8(bogoReward); // Add to mintedBogos total.\r\n                        }\r\n                    }\r\n                    // Update demand multiplier.\r\n                    // Paid mints increases the multiplier by 0.01% and 0.03% after 20,000 for increased volatility.\r\n                    // Free mints decreases the multiplier by 0.01% and 0.03% after 20,000 for increased volatility for every 2.\r\n                    if (tokensMintedPurchase + tokensMintedFree < _increasedVolatilityThreshold) {\r\n                        _temporaryDemandMultiplier = uint32(multiplier + ((number - (bogoReward / 2)) * _volatilityBase)); // Increase.\r\n                    } else {\r\n                        _temporaryDemandMultiplier = uint32(multiplier + ((number - (bogoReward / 2)) * _volatilityBase * _volatilityMultiplier)); // Increase.\r\n                    }\r\n                } else {\r\n                    // Update demand multiplier.\r\n                    // Paid mints increases the multiplier by 0.01% and 0.03% after 20,000 for increased volatility.\r\n                    // Free mints decreases the multiplier by 0.01% and 0.03% after 20,000 for increased volatility for every 2.\r\n                    if (tokensMintedPurchase + tokensMintedFree < _increasedVolatilityThreshold) {\r\n                        _temporaryDemandMultiplier = uint32(multiplier + (number * _volatilityBase)); // Increase.\r\n                    } else {\r\n                        _temporaryDemandMultiplier = uint32(multiplier + (number * _volatilityBase * _volatilityMultiplier)); // Increase.\r\n                    }\r\n                }\r\n\r\n                // Referral program\r\n                if (account != address(0)) { // If referred.\r\n                    if (\r\n                        _account[msg.sender].timestampReferralLinkUsed == 0 && // If not previously referred.\r\n                        account != msg.sender && // If not self.\r\n                        msg.sender == tx.origin // If not contract.\r\n                    ) {\r\n                        _account[msg.sender].timestampReferralLinkUsed = safeBlockTimestamp; // Timestamp referred.\r\n                        _account[account].referralPurchases += uint16(number); // Add to referralPurchases total.\r\n                    } else {\r\n                        account = address(0); // Remove referral.\r\n                    }\r\n                }\r\n\r\n                // Update timestamp of latest mint.\r\n                _purchaseTimestamp = safeBlockTimestamp;\r\n\r\n                // Mint token(s).\r\n                _mint(\r\n                    msg.sender,                                 // recipient\r\n                    number,                                     // purchased mints\r\n                    bogoReward,                                 // free mints\r\n                    safeBlockTimestamp,                         // timestamp\r\n                    tokensMintedPurchase + tokensMintedFree     // tokens minted\r\n                );\r\n\r\n                emit MintPurchase(  // 0xf26aaf0d6935ae39e0b17d4770395a2cf37139301bf4a1550daabaa363cb8df0\r\n                    msg.sender,     // address indexed account\r\n                    account,        // address indexed referrer\r\n                    ((              // uint256 data\r\n                        ((\r\n                            ((\r\n                                tokenPrice          // +XXXXXXXXXXXXXXX price\r\n                            * 10**3) + number)      // X---XXXXXXXXXXXX amount purchased\r\n                        * 10**2) + bogoReward)      // XXXX--XXXXXXXXXX amount earned\r\n                    * 10**10) + block.timestamp)    // XXXXXX---------- timestamp\r\n                );\r\n\r\n            } else {\r\n                \r\n                // account = contractAddress\r\n                // number = tokenId\r\n\r\n                // Initialize claim\r\n                if (tx.origin != msg.sender || address(uint160(type(uint160).max - key)) != msg.sender) revert RESTRICTED_ACCESS();\r\n\r\n                // Get claimable amounts.\r\n                (\r\n                    ,\r\n                    uint256 claimableHourlyDrops, \r\n                    uint256 claimableSacrifices, \r\n                    uint256 claimableReferrals, \r\n                    uint256 claimableGiveaway\r\n                ) = _accountToClaimable(msg.sender);\r\n\r\n                // Claim hourly drops.\r\n                if (claimableHourlyDrops > 0) {\r\n                    _account[msg.sender].mintedHourlyDrops += uint8(claimableHourlyDrops);\r\n                    _account[msg.sender].timestampHourlyDropLastClaimed = safeBlockTimestamp; // Timestamp claimed.\r\n                }\r\n\r\n                // Claim sacrifices.\r\n                if (claimableSacrifices > 0) {\r\n                    _account[msg.sender].mintedSacrifices += uint8(claimableSacrifices);\r\n                }\r\n\r\n                // Claim referrals.\r\n                if (claimableReferrals > 0) {\r\n                    _account[msg.sender].mintedReferrals += uint8(claimableReferrals);\r\n                }\r\n\r\n                // Claim giveaway.\r\n                if (claimableGiveaway > 0) {\r\n                    if (account != address(0) && _redeemNFT(account, number)) {\r\n                        _account[msg.sender].mintedGiveaway += uint8(claimableGiveaway);\r\n                    } else {\r\n                        delete claimableGiveaway;\r\n                        delete account;\r\n                        delete number;\r\n                    }\r\n                } else {\r\n                    delete account;\r\n                    delete number;\r\n                }\r\n\r\n                // Revert if nothing to claim.\r\n                uint256 claimableTotal = claimableHourlyDrops + claimableSacrifices + claimableReferrals + claimableGiveaway;\r\n                if (claimableTotal == 0) revert ACCOUNT_HAS_NOTHING_TO_CLAIM();\r\n\r\n                // Update demand multiplier.\r\n                // Paid mints increases the multiplier by 0.01% and 0.03% after 20,000 for increased volatility.\r\n                // Free mints decreases the multiplier by 0.01% and 0.03% after 20,000 for increased volatility for every 2.\r\n                if (claimableTotal >= 2) { // If claiming two or more.\r\n                    uint256 multiplierIncrement;\r\n                    if (tokensMintedPurchase + tokensMintedFree < _increasedVolatilityThreshold) {\r\n                        multiplierIncrement = (claimableTotal / 2) * _volatilityBase; // Increase.\r\n                    } else {\r\n                        multiplierIncrement = (claimableTotal / 2) * _volatilityBase * _volatilityMultiplier; // Increase.\r\n                    }\r\n                    if (_temporaryDemandMultiplier > multiplierIncrement) {\r\n                        _temporaryDemandMultiplier -= uint32(multiplierIncrement); // Decrease.\r\n                    } else {\r\n                        delete _temporaryDemandMultiplier; // Cannot be negative.\r\n                    }\r\n                }\r\n\r\n                // Mint token(s).\r\n                _mint(\r\n                    msg.sender,                                 // recipient\r\n                    0,                                          // purchased mints\r\n                    claimableTotal,                             // free mints\r\n                    safeBlockTimestamp,                         // timestamp\r\n                    tokensMintedPurchase + tokensMintedFree     // tokens minted\r\n                );\r\n\r\n                emit MintFree(      // 0x7236fe0badcff1706816875cc9df7b9b481c3fb939efe1e7967099499db621d9\r\n                    msg.sender,     // address indexed account\r\n                    account,        // address indexed contractAddress\r\n                    number,         // uint256 tokenId\r\n                    ((              // uint256 data\r\n                        ((\r\n                            ((\r\n                                claimableHourlyDrops            // -XXXXXXXXXXXXXX hourly drops claimed (max 1 per tx)\r\n                            * 10**2) + claimableSacrifices)     // X--XXXXXXXXXXXX sacrifices claimed (max 10 per tx)\r\n                        * 10**2) + claimableReferrals)          // XXX--XXXXXXXXXX referrals claimed (max 10 per tx)\r\n                    * 10**10) + block.timestamp)                // XXXXX---------- timestamp\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Approves `to` to be a token operator of `tokenId`.\r\n        @dev You must be the owner of `tokenId` or an account operator of the owner.\r\n        @dev Only a single account can be approved at a time.\r\n        @dev Approve the zero address to clear the current approval.\r\n        @dev The approval is cleared when the token is transferred.\r\n        @param to The address of the account to approve.\r\n        @param tokenId The token ID of the CryptoBlob to manage.\r\n    */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        // Get the owner of `tokenId`.\r\n        address owner = ownerOf(tokenId);\r\n\r\n        // Cannot approve the current owner.\r\n        if (to == owner) revert CANNOT_APPROVE_THIS_ADDRESS();\r\n\r\n        // Revert if not the owner and not approved for all.\r\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert RESTRICTED_ACCESS();\r\n\r\n        // Approve `to` to manage `tokenId`.\r\n        _token[tokenId].approval = to;\r\n\r\n        emit Approval(  // 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\r\n            owner,      // address indexed owner\r\n            to,         // address indexed approved\r\n            tokenId     // uint256 indexed tokenId\r\n        );\r\n    }\r\n\r\n    /**\r\n        @notice Approves `to` to be an account operator of your account.\r\n        @dev Account operators can do everything the owner can do expect sign messages and manage their account operators.\r\n        @dev Preapproved services: OpenSea, X2Y2, LooksRare, Rarible, 0x Protocol v4, Element, SudoSwap, NFTX, and NFTTrader.\r\n        @dev You can revoke these services using {setApprovalForAll} or visit CryptoBlobs.com for a batch tx to revoke all at once.\r\n        @dev SuperCollectiv will permanently disable preapproved services if any issues are discovered with these contracts.\r\n        @dev Services that list your account operators will not detect that these addresses have\r\n        @dev been approved unless you reapprove each service with {setApprovalForAll} or {batch}.\r\n        @param operator The address of the account to update the operator status of.\r\n        @param approved The approval status to set `operator` to.\r\n    */\r\n    function setApprovalForAll(address operator, bool approved)\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        unchecked {\r\n            if (msg.sender == operator) revert CANNOT_APPROVE_THIS_ADDRESS();\r\n\r\n            // Numbers are used to enable the preapproved services feature. Works similarly to an enum.\r\n            // Values:\r\n            // 0 = default\r\n            // 1 = revoked\r\n            // 2 = approved\r\n\r\n            if (approved) {\r\n                _account[msg.sender].approvals[operator] = 2; // Approve.\r\n            } else {\r\n                _account[msg.sender].approvals[operator] = 1; // Revoked.\r\n            }\r\n\r\n            emit ApprovalForAll(    // 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31\r\n                msg.sender,         // address indexed owner\r\n                operator,           // address indexed operator\r\n                approved            // bool approved\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Transfers `tokenId` from `from` to `to`.\r\n        @param from The address of the account that owns `tokenId`.\r\n        @param to The address of the account to transfer `tokenId` to.\r\n        @param tokenId The token ID of the CryptoBlob to transfer.\r\n    */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        // Reverts if the sender does not have access.\r\n        // The owner's address is returned if the sender does have access.\r\n        address owner = _revertIfNoAccess(msg.sender, tokenId);\r\n        if (owner != from) revert FROM_ADDRESS_DOES_NOT_MATCH_THE_OWNERS_ADDRESS();\r\n        // Transfer the CryptoBlob to the new owner.\r\n        _transfer(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n        @notice Safely transfers `tokenId` from `from` to `to` by checking onERC721Received if `to` is a contract.\r\n        @param from The address of the account that owns `tokenId`.\r\n        @param to The address of the account to transfer `tokenId` to.\r\n        @param tokenId The token ID of the CryptoBlob to transfer.\r\n    */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n        @notice Safely transfers `tokenId` from `from` to `to` by checking onERC721Received if `to` is a contract.\r\n        @param from The address of the account that owns `tokenId`.\r\n        @param to The address of the account to transfer `tokenId` to.\r\n        @param tokenId The token ID of the CryptoBlob to transfer.\r\n        @param data Bytes of data to send to `to`.\r\n    */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        // Transfer the CryptoBlob if the sender has access to it.\r\n        transferFrom(from, to, tokenId);\r\n        // Check if 'to' supports ERC721 NFTs so the CryptoBlob does not get stuck.\r\n        if (_isContractPastConstruction(to)) {\r\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\r\n                if (retval != IERC721Receiver.onERC721Received.selector) revert CONTRACT_DOES_NOT_HAVE_ONERC721RECEIVED_IMPLEMENTED();\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert CONTRACT_DOES_NOT_HAVE_ONERC721RECEIVED_IMPLEMENTED();\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Allows you to make multiple transactions in a single transaction.\r\n        @dev Categories: 0 {transferFrom}, 1 {setApprovalForAll}, 2 {approve}, 3 {manageTrades}, 4 {optimize}, 5 {sacrifice}.\r\n        @dev Each transaction is separately encoded and processed in the order of the array.\r\n        @param batchDataEncoded The encoded batch data.\r\n    */\r\n    function batch(\r\n        bytes[] memory batchDataEncoded\r\n    ) external {\r\n        unchecked {\r\n            for (uint256 i; i < batchDataEncoded.length; i++) {\r\n\r\n                // Decode this transaction.\r\n                BatchData memory batchData = abi.decode(batchDataEncoded[i], (BatchData));\r\n\r\n                // Determine function and transact.\r\n                if (batchData.category == 0) {\r\n                    // Transfer the CryptoBlob if the sender has access to it.\r\n                    transferFrom(batchData.account1, batchData.account2, batchData.tokenId);\r\n                } else if (batchData.category == 1) {\r\n                    // Approve or revoke an account operator.\r\n                    setApprovalForAll(batchData.account1, batchData.approved);\r\n                } else if (batchData.category == 2) {\r\n                    // Approve or revoke a token operator.\r\n                    approve(batchData.account1, batchData.tokenId);\r\n                } else if (batchData.category == 3) {\r\n                    // Cancel a trade or lock/unlock trades for an account you have access to.\r\n                    manageTrades(batchData.account1, batchData.hash);\r\n                } else if (batchData.category == 4) {\r\n                    // Optimize CryptoBlobs.\r\n                    optimize(batchData.tokenIds);\r\n                } else if (batchData.category == 5) {\r\n                    // Sacrifice CryptoBlobs.\r\n                    sacrifice(batchData.tokenId, batchData.tokenIds);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Cancel a trade or lock/unlock your trades on the integrated trading platform.\r\n        @dev This has no effect on third-party NFT marketplaces.\r\n        @dev Locking your trades prevents others from completing them.\r\n        @dev Trades that auto-expire will continue to countdown when they're locked.\r\n        @param account The account to manage the trades of. Can be an account you are an operator of.\r\n        @param hash The hash of the trade to cancel. 0 bytes to unlock trades. 1 byte to lock trades.\r\n    */\r\n    function manageTrades(\r\n        address account,\r\n        bytes32 hash\r\n    ) public {\r\n        unchecked {\r\n            // Check if the caller has access.\r\n            if (msg.sender != account && !isApprovedForAll(account, msg.sender)) revert RESTRICTED_ACCESS();\r\n\r\n            if (hash == 0x0000000000000000000000000000000000000000000000000000000000000000) { // Unlock trades.\r\n                delete _account[account].timestampTradesLocked;\r\n            } else if (hash == 0x0000000000000000000000000000000000000000000000000000000000000001) { // Lock trades.\r\n                _account[account].timestampTradesLocked = _safeBlockTimestamp();\r\n            } else if (_account[account].timestampTradeHashUsed[hash] == 0) { // Cancel trade if not cancelled.\r\n                // The block timestamp is multiplied by 10 to store a binary number. 0 means cancelled. 1 means completed.\r\n                _account[account].timestampTradeHashUsed[hash] = block.timestamp * 10;\r\n            } else {\r\n                revert RESTRICTED_ACCESS();\r\n            }\r\n\r\n            uint256[] memory empty = new uint256[](0); // Empty array.\r\n\r\n            // msg.sender is `taker` when isTrade is false, which can be an account operator.\r\n            emit Trade(             // 0x10d92c47650ef2b2a841f26c951f4391ccbb731e57d36a67665a0d138e08ef09\r\n                hash,               // address indexed hash\r\n                account,            // address indexed maker\r\n                msg.sender,         // address indexed taker\r\n                empty,              // uint256[] makerIds\r\n                empty,              // uint256[] takerIds\r\n                0,                  // uint256 price\r\n                0,                  // uint256 expiry\r\n                block.timestamp,    // uint256 timestamp\r\n                false               // bool isTrade\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Confirm a trade on the integrated trading platform.\r\n        @dev Buy, sell, and trade multiple CryptoBlobs at a time.\r\n        @dev Makers and takers can trade CryptoBlobs that they have access to. \r\n        @dev Approve accounts with {approve} or {setApprovalForAll}.\r\n        @dev Makers do not need to approve this contract to trade.\r\n        @dev Only takers can transfer ETH in a trade. Makers can't deposit ETH.\r\n        @dev Use {manageTrades} to cancel a trade or lock/unlock your trades.\r\n        @dev The trading platform does not currently support EIP-712.\r\n        @param maker The address of the maker.\r\n        @param taker The address of the taker.\r\n        @param makerIds The CryptoBlob IDs `maker` has access to trade.\r\n        @param takerIds The CryptoBlob IDs `taker` has access to trade.\r\n        @param price The price (in WEI) the `taker` must pay to `maker` to complete the trade.\r\n        @param expiry The timestamp the trade auto-expires, or 0 for never expires.\r\n        @param salt Salt allows the same trade parameters to be used again, resulting in a different hash.\r\n        @param signature The signature is the hash of the trade signed by the maker.\r\n    */\r\n    function trade(\r\n        address maker,\r\n        address taker,\r\n        uint256[] memory makerIds,\r\n        uint256[] memory takerIds,\r\n        uint256 price,\r\n        uint256 expiry,\r\n        uint256 salt,\r\n        bytes memory signature\r\n    ) external payable nonReentrant {\r\n        unchecked {\r\n\r\n            // Check if trading is paused.\r\n            if (_tradingPaused) revert TRADING_IS_CURRENTLY_DISABLED();\r\n\r\n            // Revert if the trade is private and if the sender is not the taker.\r\n            if (taker != address(0) && msg.sender != taker) revert TRADE_IS_NOT_FOR_YOU();\r\n\r\n            // Revert if the amount sent is insufficient.\r\n            if (msg.value < price) revert INSUFFICIENT_FUNDS_SENT();\r\n\r\n            // Get the hash and errors for the trade.\r\n            (bytes32 hash, uint256[8] memory errors) = isTradeApprovedAndValid(\r\n                maker,\r\n                taker,\r\n                makerIds,\r\n                takerIds,\r\n                price,\r\n                expiry,\r\n                salt,\r\n                signature, \r\n                false\r\n            );\r\n\r\n            // Revert if the trade contains errors.\r\n            for (uint256 i; i < errors.length; i++) if (errors[i] != 0) revert INVALID_TRADE();\r\n\r\n            // Transfer sale price to the maker.\r\n            if (price > 0) _transferEther(maker, price);\r\n\r\n            // Transfer CryptoBlobs.\r\n            // Third-party NFT marketplaces require an approval to use {transferFrom}, but this trading platform uses {_transfer}, \r\n            // an internal function, to bypass approvals. This allows takers to complete trades on the maker's behalf using a signature.\r\n            // Note that {_revertIfNoAccess} returns the owner's address because makers and takers can be approved accounts.\r\n\r\n            // Transfer maker IDs. Reverts if the maker does not have access to transfer a maker ID.\r\n            for (uint256 i; i < makerIds.length; i++) _transfer(_revertIfNoAccess(maker, makerIds[i]), msg.sender, makerIds[i]);\r\n\r\n            // Transfer taker IDs. Reverts if the sender does not have access to transfer a taker ID.\r\n            for (uint256 i; i < takerIds.length; i++) _transfer(_revertIfNoAccess(msg.sender, takerIds[i]), maker, takerIds[i]);\r\n\r\n            // Use the trade hash.\r\n            // The block timestamp is multiplied by 10 to store a binary number. 0 means cancelled. 1 means completed.\r\n            _account[maker].timestampTradeHashUsed[hash] = (block.timestamp * 10) + 1;\r\n\r\n            emit Trade(             // 0x10d92c47650ef2b2a841f26c951f4391ccbb731e57d36a67665a0d138e08ef09\r\n                hash,               // bytes32 hash\r\n                maker,              // address indexed maker\r\n                msg.sender,         // address indexed taker\r\n                makerIds,           // uint256[] makerIds\r\n                takerIds,           // uint256[] takerIds\r\n                price,              // uint256 price\r\n                expiry,             // uint256 expiry\r\n                block.timestamp,    // uint256 timestamp\r\n                true                // bool isTrade\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Optimize CryptoBlobs to lower future transaction fees with it.\r\n        @dev You can optimize any CryptoBlob, even if you do not own it.\r\n        @dev You earn one account level per CryptoBlob you optimize.\r\n        @param tokenIds The token IDs of the CryptoBlobs.\r\n    */\r\n    function optimize(\r\n        uint256[] memory tokenIds\r\n    ) public {\r\n        unchecked {\r\n            uint256 amount = tokenIds.length;\r\n            for (uint256 i; i < amount; i++) {\r\n                if (_token[tokenIds[i]].account != address(0)) revert CRYPTOBLOB_DOES_NOT_REQUIRE_OPTIMIZATION();\r\n                _token[tokenIds[i]].account = ownerOf(tokenIds[i]);\r\n            }\r\n            _account[msg.sender].tokensOptimized += uint16(amount);\r\n\r\n            emit Optimize(              // 0xff06b6e7e3b7963958aa44cc1dff152337abfc3ef2d0ecd54bdcd8fb9694e0eb\r\n                msg.sender,             // address indexed account\r\n                tokenIds,               // uint256[] tokenIds\r\n                block.timestamp         // uint256 timestamp\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Sacrifice and upgrade CryptoBlobs.\r\n        @dev Sacrificing permanently removes CryptoBlobs from the circulating supply and\r\n        @dev rewards a meta-collectible called souls via a soul transferring system.\r\n        @dev The more souls a CryptoBlob possess, the higher its rarity, rank, and value. \r\n        @dev The earlier your CryptoBlobs harnesses souls, the easier it will be to collect them.\r\n        @dev Only 25,000 souls exist, one for each CryptoBlob. Souls cannot be created or destroyed.\r\n        @dev You also earn 1 free CryptoBlob for every 10 sacrificed during the limited-time promotion.\r\n        @dev You must have access to a CryptoBlob to sacrifice it but not upgrade it.\r\n        @param tokenIdUpgrading The CryptoBlob ID that will harness the souls of `tokenIdsSacrificing`.\r\n        @param tokenIdsSacrificing The CryptoBlob IDs being sacrificed.\r\n    */\r\n    function sacrifice(\r\n        uint256 tokenIdUpgrading,\r\n        uint256[] memory tokenIdsSacrificing\r\n    ) public {\r\n        unchecked {\r\n\r\n            // Check if sacrificing is paused.\r\n            if (_sacrificingPaused) revert SACRIFICING_IS_CURRENTLY_DISABLED();\r\n\r\n            // Check if upgrading ID exists.\r\n            _revertIfTokenIsInvalid(tokenIdUpgrading);\r\n\r\n            uint16 totalSouls;\r\n            uint256 amount = tokenIdsSacrificing.length;\r\n            uint32 safeBlockTimestamp = _safeBlockTimestamp();\r\n\r\n            for (uint256 i; i < amount; i++) {\r\n\r\n                // Get sacrificing ID.\r\n                uint256 tokenIdSacrificing = tokenIdsSacrificing[i];\r\n\r\n                // Revert if sacrificing ID matches upgrading.\r\n                if (tokenIdSacrificing == tokenIdUpgrading) revert INVALID_CRYPTOBLOB_ID();\r\n\r\n                // Revert if the caller does not have access and get the owner.\r\n                address owner = _revertIfNoAccess(msg.sender, tokenIdSacrificing);\r\n\r\n                // Update owner's stats. Cannot underflow because ownership is checked.\r\n                _account[owner].tokensOwned--;\r\n                _account[owner].tokensBurned++;\r\n\r\n                // Implicitly clear approvals.\r\n                delete _token[tokenIdSacrificing].approval;\r\n\r\n                // ERC721 standards says to not emit an Approval event when transferring. https://eips.ethereum.org/EIPS/eip-721\r\n                // \"When a Transfer event emits, this also indicates that the approved address for that NFT (if any) is reset to none.\"\r\n\r\n                // Save the token ID burned to.\r\n                _token[tokenIdSacrificing].burnTo = uint16(tokenIdUpgrading);\r\n\r\n                // Update souls to now say how many were transferred. +1 for own soul.\r\n                _token[tokenIdSacrificing].souls++;\r\n\r\n                // Add to total.\r\n                totalSouls += _token[tokenIdSacrificing].souls; \r\n\r\n                // '_token[].account' now stores the address of the last owner.\r\n                if (_token[tokenIdSacrificing].account != owner) _token[tokenIdSacrificing].account = owner;\r\n\r\n                // Save the timestamp when it was burned.\r\n                _token[tokenIdSacrificing].burnTimestamp = safeBlockTimestamp;\r\n\r\n                // Burn event.\r\n                emit Transfer(              // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\r\n                    owner,                  // address indexed from\r\n                    address(0),             // address indexed to\r\n                    tokenIdSacrificing      // uint256 indexed tokenId\r\n                );\r\n\r\n            }\r\n            _token[tokenIdUpgrading].souls += totalSouls; // Transfer souls.\r\n            _tokensBurned += uint32(amount); // Update total burned.\r\n\r\n            // A 'Sacrifice' event is not emitted. Refer to 'Transfer' logs instead or data saved to the contract.\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Allows SuperCollectiv to manage the contract.\r\n        @dev Only _contractOwner can manage the contract. \r\n        @dev Only _contractCandidate can confirm a contract transfer. \r\n        @dev All other addresses will revert.\r\n        @param category Category to manage.\r\n    */\r\n    function manageContract(\r\n        uint256 category,\r\n        address[] memory _address,\r\n        uint256[] memory _uint,\r\n        string[] memory _string,\r\n        bytes memory _bytes\r\n    ) external payable nonReentrant {\r\n        unchecked {\r\n            if (msg.sender == _contractOwner) {\r\n                // Manage the contract if the caller is the owner.\r\n                if (category == 0) {\r\n                    // Update token name.\r\n                    _name = _string[0];\r\n                } else if (category == 1) {\r\n                    // Update contract URI.\r\n                    _contractURI = _string[0];\r\n                } else if (category == 2) {\r\n                    // Update token URI prefix for single URI.\r\n                    _tokenURIPrefix = _string[0];\r\n                } else if (category == 3) {\r\n                    // Update token URI prefixes for multi URI.\r\n                    uint256 startFrom = _uint[0];\r\n                    for (uint256 i; i < _string.length; i++) {\r\n                        _tokenURIPrefixes[i + startFrom] = _string[i];\r\n                    }\r\n                } else if (category == 4) {\r\n                    // Update max souls limit.\r\n                    _URIMaxSoulsLimit = _uint[0];\r\n                } else if (category == 5) {\r\n                    // Toggle trading.\r\n                    _tradingPaused = !_tradingPaused;\r\n                } else if (category == 6) {\r\n                    // Toggle sacrificing.\r\n                    _sacrificingPaused = !_sacrificingPaused; \r\n                } else if (category == 7) {\r\n                    // Manage preapproved services.\r\n                    // Only services in the constructor can be managed.\r\n                    // We can permanently and temporarily disable preapproved services.\r\n                    // We cannot reenable a service that has been permanently disabled.\r\n                    // Use {preapprovedServiceStatus} to check the current status of each service.\r\n                    for (uint256 i; i < _address.length; i++) {\r\n                        if (\r\n                            _uint[i] <= 2 && // Status set cannot be higher than 2.\r\n                            (_account[_address[i]].preapprovedStatus == 1 || // If service is temporarily disabled.\r\n                            _account[_address[i]].preapprovedStatus == 2) // If service is enabled.\r\n                        ) { \r\n                            // 0 = permanently disable service\r\n                            // 1 = temporarily disable service\r\n                            // 2 = reenable service\r\n                            _account[_address[i]].preapprovedStatus = _uint[i];\r\n                        } else {\r\n                            revert RESTRICTED_ACCESS();\r\n                        }\r\n                    }\r\n                } else if (category == 8) {\r\n                    // Update reverse records contract address.\r\n                    _reverseRecordsAddress = _address[0];\r\n                } else if (category == 9) {\r\n                    // Approve or revoke a candidate.\r\n                    _contractCandidate = _address[0];\r\n                } else if (category == 10) {\r\n                    // Gift free CryptoBlobs to any address (up to 100 at a time).\r\n                    uint32 safeBlockTimestamp = _safeBlockTimestamp();\r\n                    for (uint256 i; i < _address.length; i++) {\r\n                        uint16 amount = uint16(_uint[i]); // Get amount.\r\n                        if (amount > _purchaseLimit) revert(); // Revert if >100.\r\n                        address recipient = _address[i]; // Get recipient.\r\n                        _account[recipient].mintedSpecial += amount; // Add to recipient's special mints. Max number is 255.\r\n                        _mint(\r\n                            recipient,              // recipient\r\n                            0,                      // purchased mints\r\n                            amount,                 // free mints\r\n                            safeBlockTimestamp,     // timestamp\r\n                            _tokensMinted()         // tokens minted\r\n                        );\r\n                    }\r\n                } else if (category == 11) {\r\n                    // Interact with another contract or transfer contract balance.\r\n                    _interaction(_address[0], _uint[0], _bytes);\r\n                } else {\r\n                    // Withdraw the entire contract balance to the owner.\r\n                    _transferEther(_contractOwner, address(this).balance);\r\n                }\r\n                // A 'ManageContract' event is not emitted. Use a block explorer for past transactions. Function hash: '007e6eda'.\r\n            } else if (_contractCandidate != address(0) && msg.sender == _contractCandidate) {\r\n                // Transfer the contract if the caller is the candidate.\r\n                emit OwnershipTransferred(      // 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0\r\n                    _contractOwner,             // address indexed previousOwner\r\n                    _contractCandidate          // address indexed newOwner\r\n                );\r\n                _contractOwner = _contractCandidate; // Set the new owner.\r\n                delete _contractCandidate; // Delete the candidate.\r\n            } else {\r\n                // All other addresses are reverted.\r\n                revert RESTRICTED_ACCESS();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Emit metadata.\r\n    */\r\n    function metadata(\r\n        string memory table,\r\n        string memory key,\r\n        string memory value\r\n    ) external {\r\n        emit Metadata(          // 0x062e360bff2a6872f7e8ce922ee6867aaeed320f740365aa0c33bb226d45b034\r\n            msg.sender,         // address indexed account\r\n            table,              // string indexed table\r\n            key,                // string indexed key\r\n            value,              // string value\r\n            block.timestamp     // uint256 timestamp\r\n        );\r\n    }\r\n\r\n}\r\n\r\n/// @notice Restricted access.\r\nerror RESTRICTED_ACCESS();\r\n/// @notice Reentrant calls are not allowed;\r\nerror REENTRANT_CALLS_ARE_NOT_ALLOWED();\r\n/// @notice Insufficient contract balance.\r\nerror INSUFFICIENT_CONTRACT_BALANCE();\r\n/// @notice Unable to transfer ether.\r\nerror UNABLE_TO_TRANSFER_ETHER();\r\n/// @notice Unable to interact with contract.\r\nerror UNABLE_TO_INTERACT_WITH_CONTRACT();\r\n/// @notice The zero address cannot have an account.\r\nerror THE_ZERO_ADDRESS_CANNOT_HAVE_AN_ACCOUNT();\r\n/// @notice Invalid CryptoBlob ID.\r\nerror INVALID_CRYPTOBLOB_ID();\r\n/// @notice CryptoBlob has been sacrificed.\r\nerror CRYPTOBLOB_HAS_BEEN_SACRIFICED();\r\n/// @notice Cannot approve this address.\r\nerror CANNOT_APPROVE_THIS_ADDRESS();\r\n/// @notice Contract does not have onERC721Received implemented.\r\nerror CONTRACT_DOES_NOT_HAVE_ONERC721RECEIVED_IMPLEMENTED();\r\n/// @notice From address does not match the owner's address.\r\nerror FROM_ADDRESS_DOES_NOT_MATCH_THE_OWNERS_ADDRESS();\r\n/// @notice Owner's balance is insufficient for the index.\r\nerror OWNERS_BALANCE_IS_INSUFFICENT_FOR_THE_INDEX();\r\n/// @notice Purchase limit is 100 per transaction.\r\nerror PURCHASE_LIMIT_IS_100_PER_TRANSACTION();\r\n/// @notice Insufficient funds sent. Price may have increased.\r\nerror INSUFFICIENT_FUNDS_SENT_PRICE_MAY_HAVE_INCREASED(\r\n    uint256 price,\r\n    uint256 received\r\n);\r\n/// @notice Insufficient funds sent.\r\nerror INSUFFICIENT_FUNDS_SENT();\r\n/// @notice Invalid trade.\r\nerror INVALID_TRADE();\r\n/// @notice NFT is not eligible.\r\nerror NFT_IS_NOT_ELIGIBLE();\r\n/// @notice Account has nothing to claim.\r\nerror ACCOUNT_HAS_NOTHING_TO_CLAIM();\r\n/// @notice Trading is currently disabled.\r\nerror TRADING_IS_CURRENTLY_DISABLED();\r\n/// @notice Sacrificing is currently disabled.\r\nerror SACRIFICING_IS_CURRENTLY_DISABLED();\r\n/// @notice CryptoBlob does not require optimization.\r\nerror CRYPTOBLOB_DOES_NOT_REQUIRE_OPTIMIZATION();\r\n/// @notice Trade is not for you.\r\nerror TRADE_IS_NOT_FOR_YOU();\r\n/// @notice Amount minting is invalid.\r\nerror AMOUNT_MINTING_IS_INVALID();","ABI":"[{\"inputs\":[],\"name\":\"ACCOUNT_HAS_NOTHING_TO_CLAIM\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AMOUNT_MINTING_IS_INVALID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CANNOT_APPROVE_THIS_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CONTRACT_DOES_NOT_HAVE_ONERC721RECEIVED_IMPLEMENTED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CRYPTOBLOB_DOES_NOT_REQUIRE_OPTIMIZATION\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CRYPTOBLOB_HAS_BEEN_SACRIFICED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FROM_ADDRESS_DOES_NOT_MATCH_THE_OWNERS_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_CONTRACT_BALANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_FUNDS_SENT\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"INSUFFICIENT_FUNDS_SENT_PRICE_MAY_HAVE_INCREASED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_CRYPTOBLOB_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_TRADE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFT_IS_NOT_ELIGIBLE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OWNERS_BALANCE_IS_INSUFFICENT_FOR_THE_INDEX\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PURCHASE_LIMIT_IS_100_PER_TRANSACTION\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"REENTRANT_CALLS_ARE_NOT_ALLOWED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RESTRICTED_ACCESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SACRIFICING_IS_CURRENTLY_DISABLED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"THE_ZERO_ADDRESS_CANNOT_HAVE_AN_ACCOUNT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TRADE_IS_NOT_FOR_YOU\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TRADING_IS_CURRENTLY_DISABLED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNABLE_TO_INTERACT_WITH_CONTRACT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNABLE_TO_TRANSFER_ETHER\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"table\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Metadata\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"MintFree\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"MintPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Optimize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"makerIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"takerIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isTrade\",\"type\":\"bool\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"getENS\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"getTokens\",\"type\":\"bool\"}],\"name\":\"accountData\",\"outputs\":[{\"internalType\":\"uint256[22]\",\"name\":\"data\",\"type\":\"uint256[22]\"},{\"internalType\":\"string\",\"name\":\"ensName\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"ownedData\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"burnedData\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"}],\"name\":\"accountDataByCategory\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addressesToENS\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"ensNames\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"batchDataEncoded\",\"type\":\"bytes[]\"}],\"name\":\"batch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"numbers\",\"type\":\"uint256[]\"}],\"name\":\"batchTradeHashUsedAndHasAccess\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"candidate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"generalData\",\"outputs\":[{\"internalType\":\"uint256[12]\",\"name\":\"data\",\"type\":\"uint256[12]\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isERC721\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"nftsRedeemed\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"contractOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractCandidate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"contractBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"makerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"takerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"checkAccess\",\"type\":\"bool\"}],\"name\":\"isTradeApprovedAndValid\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[8]\",\"name\":\"errors\",\"type\":\"uint256[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_address\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_uint\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"_string\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"_bytes\",\"type\":\"bytes\"}],\"name\":\"manageContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"manageTrades\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"table\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"metadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"optimize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"preapprovedServiceStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIdUpgrading\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIdsSacrificing\",\"type\":\"uint256[]\"}],\"name\":\"sacrifice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"getENS\",\"type\":\"bool\"}],\"name\":\"tokenData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"approval\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ownedSouls\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnSouls\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"ensNames\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokenDataByCategory\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"makerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"takerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"trade\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CryptoBlobs","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8ffa5b6648d67726ee664a9cacd2ac9ecb29b1af636a015db437e784c7ee8fb0"}]