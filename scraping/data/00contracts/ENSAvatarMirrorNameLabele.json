[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ENSAvatarMirrorNameLabeler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n\\n/// @title ENS Avatar Mirror Name Labeler\\n\\n/**\\n *        ><<    ><<<<< ><<    ><<      ><<\\n *      > ><<          ><<      ><<      ><<\\n *     >< ><<         ><<       ><<      ><<\\n *   ><<  ><<        ><<        ><<      ><<\\n *  ><<<< >< ><<     ><<        ><<      ><<\\n *        ><<        ><<       ><<<<    ><<<<\\n */\\n\\npragma solidity ^0.8.17;\\n\\ncontract ENSAvatarMirrorNameLabeler {\\n    function substring(string memory str, uint256 startIndex, uint256 endIndex) internal pure returns (string memory) {\\n        bytes memory strBytes = bytes(str);\\n        bytes memory result = new bytes(endIndex - startIndex);\\n        for (uint256 i = startIndex; i < endIndex; i++) {\\n            result[i - startIndex] = strBytes[i];\\n        }\\n        return string(result);\\n    }\\n\\n    function namehashLabelCount(string memory domain) internal pure returns (uint256 count) {\\n        bytes memory domainBytes = bytes(domain);\\n\\n        if (domainBytes.length > 0) {\\n            count += 1;\\n        }\\n\\n        for (uint256 i = 0; i < domainBytes.length; i++) {\\n            if (domainBytes[i] == \\\".\\\") {\\n                count += 1;\\n            }\\n        }\\n    }\\n\\n    function namehashLabels(string memory domain) internal pure returns (bytes32[] memory) {\\n        bytes memory domainBytes = bytes(domain);\\n        bytes32[] memory labels = new bytes32[](namehashLabelCount(domain));\\n\\n        if (labels.length == 0) {\\n            return labels;\\n        }\\n\\n        uint256 fromIndex = 0;\\n        uint256 labelIndex = labels.length - 1;\\n        for (uint256 i = 0; i < domainBytes.length && labelIndex > 0; i++) {\\n            if (domainBytes[i] == \\\".\\\") {\\n                labels[labelIndex] = keccak256(abi.encodePacked(substring(domain, fromIndex, i)));\\n                labelIndex -= 1;\\n                fromIndex = i + 1;\\n            }\\n        }\\n\\n        labels[labelIndex] = keccak256(abi.encodePacked(substring(domain, fromIndex, domainBytes.length)));\\n\\n        return labels;\\n    }\\n\\n    function namehash(string memory domain) external pure returns (bytes32 result) {\\n        bytes32[] memory labels = namehashLabels(domain);\\n        for (uint256 i = 0; i < labels.length; i++) {\\n            result = keccak256(abi.encodePacked(result, labels[i]));\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"}],\"name\":\"namehash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ENSAvatarMirrorNameLabeler","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]