[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"CoboSafeModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\nimport \\\"EnumerableSet.sol\\\";\\nimport \\\"GnosisSafe.sol\\\";\\nimport \\\"Ownable.sol\\\";\\n\\n/// Interface of AclProtector\\ninterface AclProtector {\\n    function check(bytes32 role, uint256 value, bytes calldata data) external returns (bool);\\n}\\n\\n/// Interface of TransferProtector\\ninterface TransferProtector {\\n    function check(bytes32[] memory roles, address receiver, uint256 value) external returns (bool);\\n}\\n\\n/// @title A GnosisSafe module that implements Cobo's role based access control policy\\n/// @author Cobo Safe Dev Team (safe_devs@cobo.com)\\n/// @notice Use this module to access Gnosis Safe with role based access control policy\\n/// @dev This contract implements the core data structure and its related features.\\ncontract CoboSafeModule is Ownable {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    string public constant NAME = \\\"Cobo Safe Module\\\";\\n    string public constant VERSION = \\\"0.4.0\\\";\\n\\n    address public transferProtector;\\n\\n    // Below are predefined roles: ROLE_HARVESTER\\n    //\\n    // Gnosis safe owners need to call to `grantRole(ROLE_XXX, delegate)` to grant permission to a delegate.\\n\\n    // 'harvesters\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00'\\n    bytes32 public constant ROLE_HARVESTER =\\n        0x6861727665737465727300000000000000000000000000000000000000000000;\\n\\n    /// @notice Event fired when a delegate is added\\n    /// @dev Event fired when a delegate is added via `grantRole` method\\n    /// @param delegate the delegate being added\\n    /// @param sender the owner who added the delegate\\n    event DelegateAdded(address indexed delegate, address indexed sender);\\n\\n    /// @notice Event fired when a delegate is removed\\n    /// @dev Event fired when a delegate is remove via `revokeRole` method\\n    /// @param delegate the delegate being removed\\n    /// @param sender the owner who removed the delegate\\n    event DelegateRemoved(address indexed delegate, address indexed sender);\\n\\n    /// @notice Event fired when a role is added\\n    /// @dev Event fired when a role is being added via `addRole` method\\n    /// @param role the role being added\\n    /// @param sender the owner who added the role\\n    event RoleAdded(bytes32 indexed role, address indexed sender);\\n\\n    /// @notice Event fired when a role is grant to a delegate\\n    /// @dev Event fired when a role is grant to a delegate via `grantRole`\\n    /// @param role the role being granted\\n    /// @param delegate the delegate being granted the given role\\n    /// @param sender the owner who granted the role to the given delegate\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed delegate,\\n        address indexed sender\\n    );\\n\\n    /// @notice Event fired when a role is revoked from a delegate\\n    /// @dev Event fired when a role is revoked from a delegate via `revokeRole`\\n    /// @param role the role being revoked\\n    /// @param delegate the delegate being revoked the given role\\n    /// @param sender the owner who revoked the role from the given delegate\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed delegate,\\n        address indexed sender\\n    );\\n\\n    /// @notice Event fired after a transaction is successfully executed by a delegate\\n    /// @dev Event fired after a transaction is successfully executed by a delegate via `execTransaction` method\\n    /// @param to the targate contract to execute the transaction\\n    /// @param value the ether value to be sent to the target contract when executing the transaction\\n    /// @param operation use `call` or `delegatecall` to execute the transaction on the contract\\n    /// @param data input data to execute the transaction on the given contract\\n    /// @param sender the delegate who execute the transaction\\n    event ExecTransaction(\\n        address indexed to,\\n        uint256 value,\\n        Enum.Operation operation,\\n        bytes data,\\n        address indexed sender\\n    );\\n\\n    /// @notice Event fired when a role is associated with a contract and its function list\\n    /// @dev Event fired when a role is associated with a contract and its function list via `assocRoleWithContractFuncs`\\n    /// @param role the role to be associated with the given contract and function list\\n    /// @param _contract the target contract to be associated with the role\\n    /// @param funcList a list of function signatures of the given contract to be associated with the role\\n    /// @param sender the owner who associated the role with the contract and its function list\\n    event AssocContractFuncs(\\n        bytes32 indexed role,\\n        address indexed _contract,\\n        string[] funcList,\\n        address indexed sender\\n    );\\n\\n    /// @notice Event fired when a role is disassociate from a contract and its function list\\n    /// @dev Event fired when a role is disassociate from a contract and its function list via `dissocRoleFromContractFuncs`\\n    /// @param role the role to be disassociated from the given contract and function list\\n    /// @param _contract the target contract to be disassociated from the role\\n    /// @param funcList a list of function signatures of the given contract to be disassociated from the role\\n    /// @param sender the owner who disassociated the role from the contract and its function list\\n    event DissocContractFuncs(\\n        bytes32 indexed role,\\n        address indexed _contract,\\n        string[] funcList,\\n        address indexed sender\\n    );\\n\\n    /// @notice Event fired when a protector to a contract is changed\\n    /// @dev Event fired when a protector is changed to protect a contract via `installAclForContract`\\n    /// @param _contract the target contract to be protected\\n    /// @param oldProtector the protector contract to be uninstalled\\n    /// @param newProtector the protector contract to installed\\n    /// @param sender the owner who install the protector to the target contract\\n    event ProtectorChanged(\\n        address indexed _contract,\\n        address oldProtector,\\n        address indexed newProtector,\\n        address indexed sender\\n    );\\n\\n    /// @notice Event fired when a call is checked by a protector\\n    /// @dev Event fired when the a call is checked via `_hasPermission`\\n    /// @param _contract the target contract to be execute\\n    /// @param contractFunc the target contract function to be execute\\n    /// @param protector the contract to check the access control\\n    /// @param role the role to check the access control\\n    /// @param value the ether value to be sent to the target contract\\n    /// @param data the original call data\\n    /// @param success the result of access control checking\\n    /// @param sender the user who trigger the execution\\n    event AclChecked(\\n        address indexed _contract,\\n        bytes4 contractFunc,\\n        address indexed protector,\\n        bytes32 role,\\n        uint256 value,\\n        bytes data,\\n        bool success,\\n        address indexed sender\\n    );\\n\\n    /// @notice Event fired when a transfer is checked by a protector\\n    /// @dev Event fired when the a transfer is checked via `_isAllowedTransfer`\\n    /// @param protector the contract to check the access control\\n    /// @param receiver transfer receiver\\n    /// @param value ETH value\\n    /// @param success the result of access control checking\\n    /// @param sender the user who trigger the execution\\n    event TransferChecked(\\n        address indexed protector,\\n        address indexed receiver,\\n        uint256 value,\\n        bool success,\\n        address indexed sender\\n    );\\n\\n    /// @dev Tracks the set of granted delegates. The set is dynamically added\\n    ///      to or removed from by  `grantRole` and `rokeRole`.  `isDelegate`\\n    ///      also uses it to test if a caller is a valid delegate or not\\n    EnumerableSet.AddressSet delegateSet;\\n\\n    /// @dev Tracks what roles each delegate owns. The mapping is dynamically\\n    ///      added to or removed from by  `grantRole` and `rokeRole`. `hasRole`\\n    ///      also uses it to test if a delegate is granted a given role or not\\n    mapping(address => EnumerableSet.Bytes32Set) delegateToRoles;\\n\\n    /// @dev Tracks the set of roles. The set keeps track of all defined roles.\\n    ///      It is updated by `addRole`, and possibly by `removeRole` if to be\\n    ///      supported. All role based access policy checks against the set for\\n    ///      role validity.\\n    EnumerableSet.Bytes32Set roleSet;\\n\\n    /// @dev Tracks the set of contract address. The set keeps track of contracts\\n    ///      which have been associated with a role. It is updated by\\n    ///      `assocRoleWithContractFuncs` and `dissocRoleFromContractFuncs`\\n    EnumerableSet.AddressSet contractSet;\\n\\n    /// @dev mapping from `contract address` => `function selectors`\\n    mapping(address => EnumerableSet.Bytes32Set) contractToFuncs;\\n\\n    /// @dev mapping from `contract address` => `function selectors` => `list of roles`\\n    mapping(address => mapping(bytes32 => EnumerableSet.Bytes32Set)) funcToRoles;\\n\\n    /// @dev mapping from `contract address` => `protector contract address`\\n    mapping(address => address) public contractToProtector;\\n\\n    /// @dev modifier to assert only delegate is allow to proceed\\n    modifier onlyDelegate() {\\n        require(isDelegate(_msgSender()), \\\"must be delegate\\\");\\n        _;\\n    }\\n\\n    /// @dev modifier to assert the given role must be predefined\\n    /// @param role the role to be checked\\n    modifier roleDefined(bytes32 role) {\\n        require(roleSet.contains(role), \\\"unrecognized role\\\");\\n        _;\\n    }\\n\\n    /// @notice Contructor function for CoboSafeModule\\n    /// @dev When this module is deployed, its ownership will be automatically\\n    ///      transferred to the given Gnosis safe instance. The instance is\\n    ///      supposed to call `enableModule` on the constructed module instance\\n    ///      in order for it to function properly.\\n    /// @param _safe the Gnosis Safe (GnosisSafeProxy) instance's address\\n    constructor(address payable _safe) {\\n        require(_safe != address(0), \\\"invalid safe address\\\");\\n\\n        // Add default role. Use `addRole` to make sure `RoleAdded` event is fired\\n        addRole(ROLE_HARVESTER);\\n\\n        // make the given safe the owner of the current module.\\n        _transferOwnership(_safe);\\n    }\\n\\n    /// @notice Checks if an address is a permitted delegate\\n    /// @dev the address must have been granted role via `grantRole` in order to become a delegate\\n    /// @param delegate the address to be checked\\n    /// @return true|false\\n    function isDelegate(address delegate) public view returns (bool) {\\n        return delegateSet.contains(delegate);\\n    }\\n\\n    /// @notice Grant a role to a delegate\\n    /// @dev Granting a role to a delegate will give delegate permission to call\\n    ///      contract functions associated with the role. Only owner can grant\\n    ///      role and the must be predefined and not granted to the delegate\\n    ///      already. on success, `RoleGranted` event would be fired and\\n    ///      possibly `DelegateAdded` as well if this is the first role being\\n    ///      granted to the delegate.\\n    /// @param role the role to be granted\\n    /// @param delegate the delegate to be granted role\\n    function grantRole(bytes32 role, address delegate)\\n        external\\n        onlyOwner\\n        roleDefined(role)\\n    {\\n        require(!_hasRole(role, delegate), \\\"role already granted\\\");\\n\\n        delegateToRoles[delegate].add(role);\\n\\n        // We need to emit `DelegateAdded` before `RoleGranted` to allow\\n        // subgraph event handler to process in sensible order.\\n        if (delegateSet.add(delegate)) {\\n            emit DelegateAdded(delegate, _msgSender());\\n        }\\n\\n        emit RoleGranted(role, delegate, _msgSender());\\n    }\\n\\n    /// @notice Revoke a role from a delegate\\n    /// @dev Revoking a role from a delegate will remove the permission the\\n    ///      delegate has to call contract functions associated with the role.\\n    ///      Only owner can revoke the role.  The role has to be predefined and\\n    ///      granted to the delegate before revoking, otherwise the function\\n    ///      will be reverted. `RoleRevoked` event would be fired and possibly\\n    ///      `DelegateRemoved` as well if this is the last role the delegate\\n    ///      owns.\\n    /// @param role the role to be granted\\n    /// @param delegate the delegate to be granted role\\n    function revokeRole(bytes32 role, address delegate)\\n        external\\n        onlyOwner\\n        roleDefined(role)\\n    {\\n        require(_hasRole(role, delegate), \\\"role has not been granted\\\");\\n\\n        delegateToRoles[delegate].remove(role);\\n\\n        // We need to make sure `RoleRevoked` is fired before `DelegateRemoved`\\n        // to make sure the event handlers in subgraphs are triggered in the\\n        // right order.\\n        emit RoleRevoked(role, delegate, _msgSender());\\n\\n        if (delegateToRoles[delegate].length() == 0) {\\n            delegateSet.remove(delegate);\\n            emit DelegateRemoved(delegate, _msgSender());\\n        }\\n    }\\n\\n    /// @notice Test if a delegate has a role\\n    /// @dev The role has be predefined or the function will be reverted.\\n    /// @param role the role to be checked\\n    /// @param delegate the delegate to be checked\\n    /// @return true|false\\n    function hasRole(bytes32 role, address delegate)\\n        external\\n        view\\n        roleDefined(role)\\n        returns (bool)\\n    {\\n        return _hasRole(role, delegate);\\n    }\\n\\n    /// @notice Test if a delegate has a role (internal version)\\n    /// @dev This does the same check as hasRole, but avoid the checks on if the\\n    ///      role is defined. Internal functions can call this to save gas consumptions\\n    /// @param role the role to be checked\\n    /// @param delegate the delegate to be checked\\n    /// @return true|false\\n    function _hasRole(bytes32 role, address delegate)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return delegateToRoles[delegate].contains(role);\\n    }\\n\\n    /// @notice Add a new role\\n    /// @dev only owner can call this function, the role has to be a new role.\\n    ///      On success, `RoleAdded` event will be fired\\n    /// @param role the role to be added\\n    function addRole(bytes32 role) public onlyOwner {\\n        require(!roleSet.contains(role), \\\"role exists\\\");\\n\\n        roleSet.add(role);\\n\\n        emit RoleAdded(role, _msgSender());\\n    }\\n\\n    /// @notice Call Gnosis Safe to execute a transaction\\n    /// @dev Delegates can call this method to invoke gnosis safe to forward to\\n    ///      transaction to target contract method `to`::`func`, where `func`\\n    ///      is the function selector contained in first 4 bytes of `data`.\\n    ///      The function can only be called by delegates.\\n    /// @param to The target contract to be called by Gnosis Safe\\n    /// @param value The value data to be transferred by Gnosis Safe\\n    /// @param data The input data to be called by Gnosis Safe\\n    ///\\n    /// TODO: implement EIP712 signature.\\n    function execTransaction(address to, uint256 value, bytes calldata data)\\n        external\\n        onlyDelegate\\n    {\\n        _execTransaction(to, value, data);\\n    }\\n\\n    /// @notice Batch execute multiple transaction via Gnosis Safe\\n    /// @dev This is batch version of the `execTransaction` function to allow\\n    ///      the delegates to bundle multiple calls into a single transaction and\\n    ///      sign only once. Batch execute the transactions, one failure cause the\\n    ///      batch reverted. Only delegates are allowed to call this.\\n    /// @param toList list of contract addresses to be called\\n    /// @param valueList list of value data associated with each contract call\\n    /// @param dataList list of input data associated with each contract call\\n    function batchExecTransactions(\\n        address[] calldata toList,\\n        uint256[] calldata valueList,\\n        bytes[] calldata dataList\\n    ) external onlyDelegate {\\n        require(\\n            toList.length > 0 && toList.length == valueList.length && toList.length == dataList.length,\\n            \\\"invalid inputs\\\"\\n        );\\n\\n        for (uint256 i = 0; i < toList.length; i++) {\\n            _execTransaction(toList[i], valueList[i], dataList[i]);\\n        }\\n    }\\n\\n    /// @dev The internal implementation of `execTransaction` and\\n    ///      `batchExecTransactions`, that invokes gnosis safe to forward to\\n    ///      transaction to target contract method `to`::`func`, where `func` is\\n    ///      the function selector contained in first 4 bytes of `data`.  The\\n    ///      function checks if the calling delegate has the required permission\\n    ///      to call the designated contract function before invoking Gnosis\\n    ///      Safe.\\n    /// @param to The target contract to be called by Gnosis Safe\\n    /// @param value The value data to be transferred by Gnosis Safe\\n    /// @param data The input data to be called by Gnosis Safe\\n    function _execTransaction(address to, uint256 value, bytes calldata data) internal {\\n        require(_hasPermission(_msgSender(), to, value, data), \\\"permission denied\\\");\\n\\n        // execute the transaction from Gnosis Safe, note this call will bypass\\n        // safe owners confirmation.\\n        require(\\n            GnosisSafe(payable(owner())).execTransactionFromModule(\\n                to,\\n                value,\\n                data,\\n                Enum.Operation.Call\\n            ),\\n            \\\"failed in execution in safe\\\"\\n        );\\n\\n        emit ExecTransaction(to, value, Enum.Operation.Call, data, _msgSender());\\n    }\\n\\n    /// @dev Internal function to check if a delegate has the permission to call a given contract function\\n    /// @param delegate the delegate to be checked\\n    /// @param to the target contract\\n    /// @param value The value to be checked by protector\\n    /// @param data the calldata to be checked by protector\\n    /// @return true|false\\n    function _hasPermission(\\n        address delegate,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal returns (bool) {\\n        bytes32[] memory roles = getRolesByDelegate(delegate);\\n        require(roles.length > 0, \\\"no role granted to delegate\\\");\\n\\n        // for ETH transfer\\n        if (data.length == 0) {\\n            require(transferProtector != address(0), \\\"invalid transfer protector\\\");\\n            return _checkByTransferProtector(roles, to, value);\\n\\n        } else {\\n            require(data.length >=4, \\\"invalid data length\\\");\\n\\n            bytes4 selector;\\n            assembly {\\n                selector := calldataload(data.offset)\\n            }\\n\\n            EnumerableSet.Bytes32Set storage funcRoles = funcToRoles[to][selector];\\n            address aclProtector = contractToProtector[to];\\n            for (uint256 index = 0; index < roles.length; index++) {\\n                // check func and parameters\\n                if (funcRoles.contains(roles[index])) {\\n                    if (aclProtector != address(0)) {\\n                        if (_checkByAclProtector(aclProtector, roles[index], to, value, selector, data)) {\\n                            return true;\\n                        }\\n                    } else {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n    /// @dev Internal function to check if a role has the permission to transfer ETH\\n    /// @param roles the roles to check\\n    /// @param receiver ETH receiver\\n    /// @param value ETH value\\n    /// @return true|false\\n    function _checkByTransferProtector(\\n        bytes32[] memory roles,\\n        address receiver,\\n        uint256 value\\n    ) internal returns (bool) {\\n        bool success = TransferProtector(transferProtector).check(\\n            roles,\\n            receiver,\\n            value\\n        );\\n        emit TransferChecked(\\n            transferProtector,\\n            receiver,\\n            value,\\n            success,\\n            _msgSender()\\n        );\\n        return success;\\n    }\\n\\n    /// @dev Internal function to check if a role has the permission to exec transaction\\n    /// @param aclProtector address of the protector contract\\n    /// @param role the role to check\\n    /// @param to the target contract\\n    /// @param value The value to be checked by protector\\n    /// @param selector the selector to be checked by protector\\n    /// @param data the calldata to be checked by protector\\n    /// @return true|false\\n    function _checkByAclProtector(\\n        address aclProtector,\\n        bytes32 role,\\n        address to,\\n        uint256 value,\\n        bytes4 selector,\\n        bytes calldata data\\n    ) internal returns (bool) {\\n        bool success = AclProtector(aclProtector).check(\\n            role,\\n            value,\\n            data\\n        );\\n        emit AclChecked(\\n            to,\\n            selector,\\n            aclProtector,\\n            role,\\n            value,\\n            data,\\n            success,\\n            _msgSender()\\n        );\\n        return success;\\n    }\\n\\n    /// @dev Public function to check if a role has the permission to call a given contract function\\n    /// @param role the role to be checked\\n    /// @param to the target contract\\n    /// @param selector the function selector of the contract function to be called\\n    /// @return true|false\\n    function roleCanAccessContractFunc(\\n        bytes32 role,\\n        address to,\\n        bytes4 selector\\n    ) external view returns (bool) {\\n        return funcToRoles[to][selector].contains(role);\\n    }\\n\\n    /// @notice Associate a role with given contract funcs\\n    /// @dev only owners are allowed to call this function, the given role has\\n    ///      to be predefined. On success, the role will be associated with the\\n    ///      given contract function, `AssocContractFuncs` event will be fired.\\n    /// @param role the role to be associated\\n    /// @param _contract the contract address to be associated with the role\\n    /// @param funcList the list of contract functions to be associated with the role\\n    function assocRoleWithContractFuncs(\\n        bytes32 role,\\n        address _contract,\\n        string[] calldata funcList\\n    ) external onlyOwner roleDefined(role) {\\n        require(funcList.length > 0, \\\"empty funcList\\\");\\n\\n        for (uint256 index = 0; index < funcList.length; index++) {\\n            bytes4 funcSelector = bytes4(keccak256(bytes(funcList[index])));\\n            bytes32 funcSelector32 = bytes32(funcSelector);\\n            funcToRoles[_contract][funcSelector32].add(role);\\n            contractToFuncs[_contract].add(funcSelector32);\\n        }\\n\\n        contractSet.add(_contract);\\n\\n        emit AssocContractFuncs(role, _contract, funcList, _msgSender());\\n    }\\n\\n    /// @notice Dissociate a role from given contract funcs\\n    /// @dev only owners are allowed to call this function, the given role has\\n    ///      to be predefined. On success, the role will be disassociated from\\n    ///      the given contract function, `DissocContractFuncs` event will be\\n    ///      fired.\\n    /// @param role the role to be disassociated\\n    /// @param _contract the contract address to be disassociated from the role\\n    /// @param funcList the list of contract functions to be disassociated from the role\\n    function dissocRoleFromContractFuncs(\\n        bytes32 role,\\n        address _contract,\\n        string[] calldata funcList\\n    ) external onlyOwner roleDefined(role) {\\n        require(funcList.length > 0, \\\"empty funcList\\\");\\n\\n        for (uint256 index = 0; index < funcList.length; index++) {\\n            bytes4 funcSelector = bytes4(keccak256(bytes(funcList[index])));\\n            bytes32 funcSelector32 = bytes32(funcSelector);\\n            funcToRoles[_contract][funcSelector32].remove(role);\\n\\n            if (funcToRoles[_contract][funcSelector32].length() <= 0) {\\n                contractToFuncs[_contract].remove(funcSelector32);\\n            }\\n        }\\n\\n        if (contractToFuncs[_contract].length() <= 0) {\\n            contractSet.remove(_contract);\\n        }\\n\\n        emit DissocContractFuncs(role, _contract, funcList, _msgSender());\\n    }\\n\\n    /// @notice Install protector contract for given contract\\n    /// @dev only owners are allowed to call this function. On success, the contract will\\n    ///      protector with the selector mapping, `AclInstalled` event will be fired,\\n    ///      `AclUninstalled` event may be fired when old protector existed.\\n    /// @param _contract the contract to be protected(address(0) for transfer protector)\\n    /// @param newProtector the acl/transfer contract\\n    function installProtectorContract(address _contract, address newProtector)\\n        external\\n        onlyOwner\\n    {\\n        address oldProtector;\\n        if (address(_contract) == address(0)) {\\n            // transfer protector\\n            oldProtector = transferProtector;\\n            require(oldProtector != newProtector, \\\"invalid transfer protector\\\");\\n            transferProtector = newProtector;\\n        } else {\\n            // acl protector\\n            oldProtector = contractToProtector[_contract];\\n            require(oldProtector != newProtector, \\\"invalid acl protector\\\");\\n            contractToProtector[_contract] = newProtector;\\n        }\\n\\n        emit ProtectorChanged(_contract, oldProtector, newProtector, _msgSender());\\n    }\\n\\n    /// @notice Get all the delegates who are currently granted any role\\n    /// @return list of delegate addresses\\n    function getAllDelegates() public view returns (address[] memory) {\\n        bytes32[] memory store = delegateSet._inner._values;\\n        address[] memory result;\\n        assembly {\\n            result := store\\n        }\\n        return result;\\n    }\\n\\n    /// @notice Given a delegate, return all the roles granted to the delegate\\n    /// @return list of roles\\n    function getRolesByDelegate(address delegate)\\n        public\\n        view\\n        returns (bytes32[] memory)\\n    {\\n        return delegateToRoles[delegate]._inner._values;\\n    }\\n\\n    /// @notice Get all the roles defined in the module\\n    /// @return list of roles\\n    function getAllRoles() external view returns (bytes32[] memory) {\\n        return roleSet._inner._values;\\n    }\\n\\n    /// @notice Get all the contracts ever associated with any role\\n    /// @return list of contract addresses\\n    function getAllContracts() public view returns (address[] memory) {\\n        bytes32[] memory store = contractSet._inner._values;\\n        address[] memory result;\\n        assembly {\\n            result := store\\n        }\\n        return result;\\n    }\\n\\n    /// @notice Given a contract, list all the function selectors of this contract associated with a role\\n    /// @param _contract the contract\\n    /// @return list of function selectors in the contract ever associated with a role\\n    function getFuncsByContract(address _contract)\\n        public\\n        view\\n        returns (bytes4[] memory)\\n    {\\n        bytes32[] memory store = contractToFuncs[_contract]._inner._values;\\n        bytes4[] memory result;\\n        assembly {\\n            result := store\\n        }\\n        return result;\\n    }\\n\\n    /// @notice Given a function, list all the roles that have permission to access to them\\n    /// @param _contract the contract address\\n    /// @param funcSelector the function selector\\n    /// @return list of roles\\n    function getRolesByContractFunction(address _contract, bytes4 funcSelector)\\n        public\\n        view\\n        returns (bytes32[] memory)\\n    {\\n        return funcToRoles[_contract][funcSelector]._inner._values;\\n    }\\n}\\n\"\r\n    },\r\n    \"EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"GnosisSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\n/// @title Enum - Collection of enums\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n}\\n\\ninterface GnosisSafe {\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\nimport \\\"Context.sol\\\";\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\nabstract contract TransferOwnable is Ownable {\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"CoboSafeModule.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_safe\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"contractFunc\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"AclChecked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"funcList\",\"type\":\"string[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"AssocContractFuncs\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"DelegateAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"DelegateRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"funcList\",\"type\":\"string[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"DissocContractFuncs\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ExecTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldProtector\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newProtector\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ProtectorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protector\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"TransferChecked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_HARVESTER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"addRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"funcList\",\"type\":\"string[]\"}],\"name\":\"assocRoleWithContractFuncs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"toList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"valueList\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"dataList\",\"type\":\"bytes[]\"}],\"name\":\"batchExecTransactions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contractToProtector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"funcList\",\"type\":\"string[]\"}],\"name\":\"dissocRoleFromContractFuncs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllDelegates\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllRoles\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"getFuncsByContract\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"funcSelector\",\"type\":\"bytes4\"}],\"name\":\"getRolesByContractFunction\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"getRolesByDelegate\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newProtector\",\"type\":\"address\"}],\"name\":\"installProtectorContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"isDelegate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"roleCanAccessContractFunc\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferProtector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CoboSafeModule","CompilerVersion":"v0.8.14+commit.80d49f37","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000089ed30ba4dd03014f7ae7e3858c11bd937b63402","EVMVersion":"istanbul","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8d5679eb650dda30e7613807ea096c981ae7edc966adb85746cda9d809168eb5"}]