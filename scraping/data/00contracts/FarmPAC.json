[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/app/contracts/pactFarm/AbstractFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../vendors/libraries/SafeMath.sol\\\";\\nimport \\\"../vendors/libraries/SafeERC20.sol\\\";\\nimport \\\"../vendors/interfaces/IERC20.sol\\\";\\nimport \\\"./UsersStorage.sol\\\";\\nimport \\\"./StagesStorage.sol\\\";\\n\\nabstract contract AbstractFarm is UsersStorage, StagesStorage {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    constructor(IERC20 pact_, uint256 totalRewardAmount_) LpTokensStorage(pact_) StagesStorage(totalRewardAmount_) public {}\\n\\n////////////////////////////////////////////////////////////\\n\\n    struct PoolInfoInFarmStage {\\n        uint256 lastRewardBlock;    // Last block number that ERC20s distribution occurs.\\n        uint256 accERC20PerShare;   // Accumulated ERC20s per share, times 1e36.\\n    }\\n    // stageId => poolId => PoolInfoInFarmStage\\n    mapping (uint256 => mapping (uint256 => PoolInfoInFarmStage)) public _poolInfoInFarmStages;\\n\\n    // Update reward variables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        for (uint256 poolId = 0; poolId < _poolInfoCount; ++poolId) {\\n            updatePool(poolId);\\n        }\\n    }\\n\\n    // poolId => firstNotFinishedStage\\n    mapping (uint256 => uint256) _firstNotFinishedStages;\\n\\n    function updatePool(uint256 poolId) public {\\n        require(poolId < _poolInfoCount, \\\"updatePool: Pool is not exists\\\");\\n        PoolInfo storage pool = _poolInfo[poolId];\\n        _updatePool(pool);\\n    }\\n    function _updatePool(PoolInfo storage pool) internal {\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n\\n        StageInfo storage stage;\\n        for (uint256 stageId = _firstNotFinishedStages[pool.id]; stageId < _stageInfoCount; ++stageId) {\\n            stage = _stageInfo[stageId];\\n\\n            if (stage.startBlock > block.number) {\\n                return;\\n            }\\n\\n            if (_updatePoolInfoInFarmStage(stage, pool, lpSupply)) {\\n                _firstNotFinishedStages[pool.id] = stageId.add(1);\\n            }\\n        }\\n    }\\n    function _updatePoolInfoInFarmStage(\\n        StageInfo storage stage,\\n        PoolInfo storage pool,\\n        uint256 lpSupply\\n    ) internal returns (bool) {\\n        uint256 lastBlock = block.number < stage.endBlock ? block.number : stage.endBlock;\\n\\n        PoolInfoInFarmStage storage poolInFarmStage = _poolInfoInFarmStages[stage.id][pool.id];\\n        if (poolInFarmStage.lastRewardBlock < stage.startBlock) {\\n            poolInFarmStage.lastRewardBlock = stage.startBlock;\\n        }\\n\\n        if (lastBlock <= poolInFarmStage.lastRewardBlock) {\\n            return true;\\n        }\\n\\n        if (lpSupply == 0) {\\n            poolInFarmStage.lastRewardBlock = lastBlock;\\n            return false;\\n        }\\n\\n        uint256 nrOfBlocks = lastBlock.sub(poolInFarmStage.lastRewardBlock);\\n        uint256 erc20Reward = nrOfBlocks.mul(stage.rewardPerBlock).mul(pool.allocPoint).div(_totalAllocPoint);\\n\\n        poolInFarmStage.accERC20PerShare = poolInFarmStage.accERC20PerShare.add(erc20Reward.mul(1e36).div(lpSupply));\\n        poolInFarmStage.lastRewardBlock = block.number;\\n        return false;\\n    }\\n\\n////////////////////////////////////////////////////////////\\n\\n    function pending(uint256 poolId, address account) external view returns (uint256) {\\n        require(poolId < _poolInfoCount, \\\"pending: Pool is not exists\\\");\\n        PoolInfo storage pool = _poolInfo[poolId];\\n        UserInfo storage user = _userInfo[poolId][account];\\n        uint256 rewardPending = user.rewardPending;\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n\\n        for (uint256 stageId = 0; stageId < _stageInfoCount; ++stageId) {\\n            StageInfo storage stage = _stageInfo[stageId];\\n\\n            if (stage.startBlock > block.number) {\\n                break;\\n            }\\n\\n            PoolInfoInFarmStage storage poolInFarmStage = _poolInfoInFarmStages[stageId][poolId];\\n\\n            uint256 accERC20PerShare = poolInFarmStage.accERC20PerShare;\\n            uint256 lastBlock = block.number < stage.endBlock ? block.number : stage.endBlock;\\n\\n            if (lastBlock > poolInFarmStage.lastRewardBlock && lpSupply != 0) {\\n                uint256 startBlock = poolInFarmStage.lastRewardBlock < stage.startBlock ? stage.startBlock : poolInFarmStage.lastRewardBlock;\\n\\n                uint256 nrOfBlocks = lastBlock.sub(startBlock);\\n                uint256 erc20Reward = nrOfBlocks.mul(stage.rewardPerBlock).mul(pool.allocPoint).div(_totalAllocPoint);\\n\\n                accERC20PerShare = accERC20PerShare.add(erc20Reward.mul(1e36).div(lpSupply));\\n            }\\n\\n            uint256 pendingAmount = user.amount.mul(accERC20PerShare).div(1e36).sub(_userRewardDebt[stageId][poolId][account]);\\n            rewardPending = rewardPending.add(pendingAmount);\\n        }\\n\\n        return rewardPending;\\n    }\\n\\n////////////////////////////////////////////////////////////\\n\\n    function _addLpToken(uint256 allocPoint, IUniswapV2Pair lpToken, bool withUpdate) internal {\\n        if (withUpdate) {\\n            massUpdatePools();\\n        }\\n        _addLpToken(allocPoint, lpToken);\\n    }\\n\\n    function _updateLpToken(uint256 poolId, uint256 allocPoint, bool withUpdate) internal {\\n        if (withUpdate) {\\n            massUpdatePools();\\n        }\\n        _updateLpToken(poolId, allocPoint);\\n    }\\n\\n////////////////////////////////////////////////////////////\\n\\n    uint256 _totalRewardPending;\\n\\n    // stageId => poolId => account => userRewardDebt\\n    mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public _userRewardDebt;\\n\\n    function _beforeBalanceChange(PoolInfo storage pool, address account) internal virtual override {\\n        _updatePool(pool);\\n        UserInfo storage user = _userInfo[pool.id][account];\\n\\n        StageInfo storage stage;\\n        for (uint256 stageId = 0; stageId < _stageInfoCount; ++stageId) {\\n            stage = _stageInfo[stageId];\\n            if (stage.startBlock > block.number) {\\n                return;\\n            }\\n            PoolInfoInFarmStage storage poolInFarmStage = _poolInfoInFarmStages[stage.id][pool.id];\\n\\n            uint256 pendingAmount = user.amount\\n                .mul(poolInFarmStage.accERC20PerShare)\\n                .div(1e36)\\n                .sub(_userRewardDebt[stage.id][pool.id][account]);\\n\\n            user.rewardPending = user.rewardPending.add(pendingAmount);\\n            _totalRewardPending = _totalRewardPending.add(pendingAmount);\\n        }\\n    }\\n    function _afterBalanceChange(PoolInfo storage pool, address account) internal virtual override {\\n        UserInfo storage user = _userInfo[pool.id][account];\\n\\n        StageInfo storage stage;\\n        for (uint256 stageId = 0; stageId < _stageInfoCount; ++stageId) {\\n            stage = _stageInfo[stageId];\\n            if (stage.startBlock > block.number) {\\n                return;\\n            }\\n\\n            PoolInfoInFarmStage storage poolInFarmStage = _poolInfoInFarmStages[stage.id][pool.id];\\n            _userRewardDebt[stage.id][pool.id][account] = user.amount.mul(poolInFarmStage.accERC20PerShare).div(1e36);\\n        }\\n    }\\n\\n    function _updateUserRewardDebtAndPending(PoolInfo storage pool, address account) internal {\\n        _updatePool(pool);\\n        UserInfo storage user = _userInfo[pool.id][account];\\n\\n        StageInfo storage stage;\\n        for (uint256 stageId = 0; stageId < _stageInfoCount; ++stageId) {\\n            stage = _stageInfo[stageId];\\n            if (stage.startBlock > block.number) {\\n                return;\\n            }\\n            PoolInfoInFarmStage storage poolInFarmStage = _poolInfoInFarmStages[stage.id][pool.id];\\n\\n            uint256 pendingAmount = user.amount\\n                .mul(poolInFarmStage.accERC20PerShare)\\n                .div(1e36)\\n                .sub(_userRewardDebt[stage.id][pool.id][account])\\n            ;\\n\\n            user.rewardPending = user.rewardPending.add(pendingAmount);\\n            _totalRewardPending = _totalRewardPending.add(pendingAmount);\\n            _userRewardDebt[stage.id][pool.id][account] = user.amount.mul(poolInFarmStage.accERC20PerShare).div(1e36);\\n        }\\n    }\\n\\n////////////////////////////////////////////////////////////\\n\\n    event Harvest(address indexed user, uint256 indexed poolId, uint256 amount);\\n    // Withdraw LP tokens from Farm.\\n    function withdrawAndHarvest(uint256 poolId, uint256 amount) public {\\n        require(poolId < _poolInfoCount, \\\"withdrawAndHarvest: Pool is not exists\\\");\\n        PoolInfo storage pool = _poolInfo[poolId];\\n        require(amount > 0, \\\"withdrawAndHarvest: can't withdraw zero amount\\\");\\n        UserInfo storage user = _userInfo[poolId][msg.sender];\\n        require(user.amount >= amount, \\\"withdrawAndHarvest: can't withdraw more than deposit\\\");\\n\\n        _beforeBalanceChange(pool, msg.sender);\\n\\n        user.amount = user.amount.sub(amount);\\n        pool.lpToken.safeTransfer(address(msg.sender), amount);\\n        emit Withdraw(msg.sender, poolId, amount);\\n\\n        _pact.transfer(msg.sender, user.rewardPending);\\n        _totalRewardPending = _totalRewardPending.sub(user.rewardPending);\\n\\n        emit Harvest(msg.sender, poolId, user.rewardPending);\\n        user.rewardPending = 0;\\n\\n        _afterBalanceChange(pool, msg.sender);\\n    }\\n    // Harvest PACTs from Farm.\\n    function harvest(uint256 poolId) public {\\n        require(poolId < _poolInfoCount, \\\"harvest: Pool is not exists\\\");\\n        PoolInfo storage pool = _poolInfo[poolId];\\n        UserInfo storage user = _userInfo[poolId][msg.sender];\\n        require(user.userExists, \\\"harvest: can't harvest from new user\\\");\\n\\n        _updateUserRewardDebtAndPending(pool, msg.sender);\\n\\n        _pact.transfer(msg.sender, user.rewardPending);\\n        _totalRewardPending = _totalRewardPending.sub(user.rewardPending);\\n\\n        emit Harvest(msg.sender, poolId, user.rewardPending);\\n        user.rewardPending = 0;\\n    }\\n\\n}\"\r\n    },\r\n    \"/app/contracts/pactFarm/FarmPACT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./AbstractFarm.sol\\\";\\nimport \\\"../vendors/libraries/SafeMath.sol\\\";\\nimport \\\"../vendors/contracts/access/GovernanceOwnable.sol\\\";\\n\\n// Cloned and modified from https://github.com/ltonetwork/uniswap-farming/blob/master/contracts/Farm.sol\\ncontract FarmPACT is GovernanceOwnable, AbstractFarm {\\n    using SafeMath for uint256;\\n\\n    uint256 _blockGenerationFrequency;\\n    function blockGenerationFrequency() public view returns (uint256) {\\n        return _blockGenerationFrequency;\\n    }\\n\\n    // etherium - block_generation_frequency_ ~ 15s\\n    // binance smart chain - block_generation_frequency_ ~ 4s\\n    constructor(\\n        address governance_,\\n        IERC20 pact_,\\n        uint256 blockGenerationFrequency_,\\n        uint256 totalRewardAmount_\\n    ) GovernanceOwnable(governance_) AbstractFarm(pact_, totalRewardAmount_) public {\\n        require(blockGenerationFrequency_ > 0, \\\"constructor: blockGenerationFrequency is empty\\\");\\n        _blockGenerationFrequency = blockGenerationFrequency_;\\n    }\\n\\n    function startFarming(uint256 startBlock) public onlyGovernance {\\n        require(_lastStageEndBlock == 0, \\\"startFarming: already started\\\");\\n        uint currentBalance = _pact.balanceOf(address(this));\\n        require(currentBalance >= _totalRewardAmount, \\\"startFarming: currentBalance is not enough\\\");\\n\\n        _addFirstStage(startBlock, 10 days / _blockGenerationFrequency, _totalRewardAmount / 8);\\n        _addStage(20 days / _blockGenerationFrequency, _totalRewardAmount / 8);\\n        _addStage(150 days / _blockGenerationFrequency, _totalRewardAmount / 8);\\n        _addStage(180 days / _blockGenerationFrequency, _totalRewardAmount / 8);\\n        _addStage(1080 days / _blockGenerationFrequency, _totalRewardAmount / 2);\\n    }\\n\\n    function addLpToken(uint256 _allocPoint, address _lpToken, bool _withUpdate) public onlyGovernance {\\n        _addLpToken(_allocPoint, IUniswapV2Pair(_lpToken), _withUpdate);\\n    }\\n\\n    function updateLpToken(uint256 poolId, uint256 allocPoint, bool withUpdate) public onlyGovernance {\\n        _updateLpToken(poolId, allocPoint, withUpdate);\\n    }\\n}\"\r\n    },\r\n    \"/app/contracts/pactFarm/LpTokensStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../vendors/libraries/SafeMath.sol\\\";\\nimport \\\"../vendors/interfaces/IERC20.sol\\\";\\nimport \\\"../vendors/interfaces/IUniswapV2Pair.sol\\\";\\n\\nabstract contract LpTokensStorage {\\n    using SafeMath for uint256;\\n\\n    // Address of the ERC20 Token contract.\\n    IERC20 _pact;\\n    constructor(IERC20 pact_) public {\\n        require(address(pact_) != address(0), \\\"LpTokensStorage::constructor: pact_ - is empty\\\");\\n        _pact = pact_;\\n    }\\n\\n    function pact() public view returns (address) {\\n        return address(_pact);\\n    }\\n\\n    struct PoolInfo {\\n        uint256 id;\\n        IUniswapV2Pair lpToken;    // Address of LP token contract.\\n        uint256 allocPoint;         // How many allocation points assigned to this pool. ERC20s to distribute per block.\\n    }\\n    // poolId => PoolInfo\\n    PoolInfo[] _poolInfo;\\n    uint256 _poolInfoCount = 0;\\n    mapping (address => bool) _lpTokensList;\\n    // Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 _totalAllocPoint = 0;\\n\\n\\n    function poolInfoCount() public view returns (uint256) {\\n        return _poolInfoCount;\\n    }\\n    function poolInfo(uint256 poolId) public view returns (PoolInfo memory) {\\n        return _poolInfo[poolId];\\n    }\\n    function totalAllocPoint() public view returns (uint256) {\\n        return _totalAllocPoint;\\n    }\\n\\n    function _addLpToken(uint256 allocPoint, IUniswapV2Pair lpToken) internal {\\n        require(_lpTokensList[address(lpToken)] == false, \\\"_addLpToken: LP Token exists\\\");\\n\\n        _totalAllocPoint = _totalAllocPoint.add(allocPoint);\\n\\n        _poolInfo.push(PoolInfo({\\n            id: _poolInfoCount,\\n            lpToken: lpToken,\\n            allocPoint: allocPoint\\n        }));\\n        ++_poolInfoCount;\\n        _lpTokensList[address(lpToken)] = true;\\n    }\\n\\n    function _updateLpToken(uint256 poolId, uint256 allocPoint) internal {\\n        require(poolId < _poolInfoCount, \\\"_updateLpToken: Pool is not exists\\\");\\n        PoolInfo storage pool = _poolInfo[poolId];\\n\\n        _totalAllocPoint = _totalAllocPoint.sub(pool.allocPoint).add(allocPoint);\\n        pool.allocPoint = allocPoint;\\n    }\\n}\"\r\n    },\r\n    \"/app/contracts/pactFarm/StagesStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../vendors/libraries/SafeMath.sol\\\";\\n\\nabstract contract StagesStorage {\\n    using SafeMath for uint256;\\n\\n    uint256 _totalRewardAmount;\\n    function totalRewardAmount() public view returns (uint256) {\\n        return _totalRewardAmount;\\n    }\\n\\n    constructor(\\n        uint256 totalRewardAmount_\\n    ) public {\\n        require(totalRewardAmount_ > 0, \\\"constructor: totalRewardAmount is empty\\\");\\n        _totalRewardAmount = totalRewardAmount_;\\n    }\\n\\n    struct StageInfo {\\n        uint256 id;\\n        uint256 startBlock;\\n        uint256 endBlock;\\n        uint256 rewardPerBlock;\\n    }\\n    // stageId => StageInfo\\n    StageInfo[] _stageInfo;\\n    uint256 _stageInfoCount = 0;\\n    uint256 _totalRewardInStages;\\n    uint256 _lastStageEndBlock;\\n\\n    function stageInfo(uint256 stageId) public view returns (StageInfo memory) {\\n        return _stageInfo[stageId];\\n    }\\n    function stageInfoCount() public view returns (uint256) {\\n        return _stageInfoCount;\\n    }\\n    function totalRewardInStages() public view returns (uint256) {\\n        return _totalRewardInStages;\\n    }\\n\\n    function _addFirstStage(\\n        uint256 startBlock,\\n        uint256 periodInBlocks,\\n        uint256 rewardAmount\\n    ) internal {\\n        require(_lastStageEndBlock == 0, \\\"_addFirstStage: first stage is already installed\\\");\\n        startBlock = block.number > startBlock ? block.number : startBlock;\\n        __addStage(\\n            startBlock,\\n            periodInBlocks,\\n            rewardAmount\\n        );\\n    }\\n\\n    function _addStage(\\n        uint256 periodInBlocks,\\n        uint256 rewardAmount\\n    ) internal {\\n        require(_lastStageEndBlock > 0, \\\"_addStage: first stage is not installed yet\\\");\\n        __addStage(\\n            _lastStageEndBlock,\\n            periodInBlocks,\\n            rewardAmount\\n        );\\n    }\\n\\n    function __addStage(\\n        uint256 startBlock,\\n        uint256 periodInBlocks,\\n        uint256 rewardAmount\\n    ) private {\\n        StageInfo memory newStage = StageInfo({\\n            id: _stageInfoCount,\\n            startBlock: startBlock,\\n            endBlock: startBlock.add(periodInBlocks),\\n            rewardPerBlock: rewardAmount.div(periodInBlocks)\\n        });\\n        ++_stageInfoCount;\\n        _stageInfo.push(newStage);\\n\\n        _lastStageEndBlock = newStage.endBlock.add(1);\\n        _totalRewardInStages = _totalRewardInStages.add(rewardAmount);\\n        require(_totalRewardInStages <= _totalRewardAmount, \\\"__addStage: _totalRewardInStages > _totalRewardAmount\\\");\\n    }\\n\\n    function stagesLength() external view returns (uint256) {\\n        return _stageInfo.length;\\n    }\\n}\"\r\n    },\r\n    \"/app/contracts/pactFarm/UsersStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../vendors/libraries/SafeMath.sol\\\";\\nimport \\\"../vendors/libraries/SafeERC20.sol\\\";\\nimport \\\"../vendors/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./LpTokensStorage.sol\\\";\\n\\nabstract contract UsersStorage is LpTokensStorage {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IUniswapV2Pair;\\n\\n    struct UserInfo {\\n        bool userExists;\\n        uint256 amount;\\n        uint256 rewardPending;\\n    }\\n    // poolId => account => UserInfo\\n    mapping (uint256 => mapping (address => UserInfo)) public _userInfo;\\n\\n    event Deposit(address indexed user, uint256 indexed poolId, uint256 amount);\\n    event Withdraw(address indexed user, uint256 indexed poolId, uint256 amount);\\n\\n    // Deposit LP tokens to Farm for ERC20 allocation.\\n    function deposit(uint256 poolId, uint256 amount) public {\\n        require(poolId < _poolInfoCount, \\\"deposit: Pool is not exists\\\");\\n        PoolInfo storage pool = _poolInfo[poolId];\\n        require(amount > 0, \\\"deposit: can't deposit zero amount\\\");\\n        UserInfo storage user = _userInfo[poolId][msg.sender];\\n        user.userExists = true;\\n\\n        _beforeBalanceChange(pool, msg.sender);\\n\\n        user.amount = user.amount.add(amount);\\n        pool.lpToken.safeTransferFrom(address(msg.sender), amount);\\n        emit Deposit(msg.sender, poolId, amount);\\n\\n        _afterBalanceChange(pool, msg.sender);\\n    }\\n    // Withdraw LP tokens from Farm.\\n    function withdraw(uint256 poolId, uint256 amount) public {\\n        require(poolId < _poolInfoCount, \\\"withdraw: Pool is not exists\\\");\\n        PoolInfo storage pool = _poolInfo[poolId];\\n        require(amount > 0, \\\"withdraw: can't withdraw zero amount\\\");\\n        UserInfo storage user = _userInfo[poolId][msg.sender];\\n        require(user.amount >= amount, \\\"withdraw: can't withdraw more than deposit\\\");\\n\\n        _beforeBalanceChange(pool, msg.sender);\\n\\n        user.amount = user.amount.sub(amount);\\n        pool.lpToken.safeTransfer(address(msg.sender), amount);\\n        emit Withdraw(msg.sender, poolId, amount);\\n\\n        _afterBalanceChange(pool, msg.sender);\\n    }\\n    function _beforeBalanceChange(PoolInfo storage pool, address account) internal virtual {}\\n    function _afterBalanceChange(PoolInfo storage pool, address account) internal virtual {}\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/contracts/access/GovernanceOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"../../interfaces/IGovernanceOwnable.sol\\\";\\n\\nabstract contract GovernanceOwnable is IGovernanceOwnable {\\n    address private _governanceAddress;\\n\\n    event GovernanceSetTransferred(address indexed previousGovernance, address indexed newGovernance);\\n\\n    constructor (address governance_) public {\\n        require(governance_ != address(0), \\\"Governance address should be not null\\\");\\n        _governanceAddress = governance_;\\n        emit GovernanceSetTransferred(address(0), governance_);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current governanceAddress.\\n     */\\n    function governance() public view override returns (address) {\\n        return _governanceAddress;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the governanceAddress.\\n     */\\n    modifier onlyGovernance() {\\n        require(_governanceAddress == msg.sender, \\\"Governance: caller is not the governance\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev SetGovernance of the contract to a new account (`newGovernance`).\\n     * Can only be called by the current onlyGovernance.\\n     */\\n    function setGovernance(address newGovernance) public virtual override onlyGovernance {\\n        require(newGovernance != address(0), \\\"GovernanceOwnable: new governance is the zero address\\\");\\n        emit GovernanceSetTransferred(_governanceAddress, newGovernance);\\n        _governanceAddress = newGovernance;\\n    }\\n\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n\\r\\n    function balanceOf(address tokenOwner) external view returns (uint balance);\\r\\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\\r\\n    function approve(address spender, uint tokens) external returns (bool success);\\r\\n    function transfer(address to, uint tokens) external returns (bool success);\\r\\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\r\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/app/contracts/vendors/interfaces/IGovernanceOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n\\ninterface IGovernanceOwnable {\\n    event GovernanceSetTransferred(address indexed previousGovernance, address indexed newGovernance);\\n\\n    function governance() external view returns (address);\\n    function setGovernance(address newGovernance) external;\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/interfaces/IUniswapV2ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IUniswapV2ERC20 is IERC20 {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IUniswapV2ERC20.sol\\\";\\n\\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n    function safeSymbol(IERC20 token) internal view returns(string memory) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    function safeName(IERC20 token) internal view returns(string memory) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    function safeDecimals(IERC20 token) public view returns (uint8) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\r\\n    }\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"SafeERC20: Transfer failed\\\");\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\r\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"SafeERC20: TransferFrom failed\\\");\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return add(a, b, \\\"SafeMath: Add Overflow\\\");\\r\\n    }\\r\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, errorMessage);// \\\"SafeMath: Add Overflow\\\"\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: Underflow\\\");\\r\\n    }\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;// \\\"SafeMath: Underflow\\\"\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mul(a, b, \\\"SafeMath: Mul Overflow\\\");\\r\\n    }\\r\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, errorMessage);// \\\"SafeMath: Mul Overflow\\\"\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath: division by zero\\\");\\r\\n        uint256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"pact_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockGenerationFrequency_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceSetTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_poolInfoInFarmStages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accERC20PerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"userExists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userRewardDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"addLpToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockGenerationFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pact\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"}],\"internalType\":\"struct LpTokensStorage.PoolInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolInfoCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stageId\",\"type\":\"uint256\"}],\"name\":\"stageInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct StagesStorage.StageInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stageInfoCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stagesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"}],\"name\":\"startFarming\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardInStages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withUpdate\",\"type\":\"bool\"}],\"name\":\"updateLpToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAndHarvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FarmPACT","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000013c674c7f56232592c19e5fbba345b8d3a9dc99f00000000000000000000000066e7ce35578a37209d01f99f3d2ff271f981f581000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000000000000000000000108b2a2c28029094000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]