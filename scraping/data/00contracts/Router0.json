[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IBorrowable.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IBorrowable {\\n    /*** Tarot ERC20 ***/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*** Pool Token ***/\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    function underlying() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function totalBalance() external view returns (uint256);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function exchangeRate() external returns (uint256);\\n\\n    function mint(address minter) external returns (uint256 mintTokens);\\n\\n    function redeem(address redeemer) external returns (uint256 redeemAmount);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function _setFactory() external;\\n\\n    /*** Borrowable ***/\\n\\n    event BorrowApproval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Borrow(\\n        address indexed sender,\\n        address indexed borrower,\\n        address indexed receiver,\\n        uint256 borrowAmount,\\n        uint256 repayAmount,\\n        uint256 accountBorrowsPrior,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n    event Liquidate(\\n        address indexed sender,\\n        address indexed borrower,\\n        address indexed liquidator,\\n        uint256 seizeTokens,\\n        uint256 repayAmount,\\n        uint256 accountBorrowsPrior,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n\\n    function BORROW_FEE() external pure returns (uint256);\\n\\n    function collateral() external view returns (address);\\n\\n    function reserveFactor() external view returns (uint256);\\n\\n    function exchangeRateLast() external view returns (uint256);\\n\\n    function borrowIndex() external view returns (uint256);\\n\\n    function totalBorrows() external view returns (uint256);\\n\\n    function borrowAllowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function borrowBalance(address borrower) external view returns (uint256);\\n\\n    function borrowTracker() external view returns (address);\\n\\n    function BORROW_PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function borrowApprove(address spender, uint256 value)\\n        external\\n        returns (bool);\\n\\n    function borrowPermit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function borrow(\\n        address borrower,\\n        address receiver,\\n        uint256 borrowAmount,\\n        bytes calldata data\\n    ) external;\\n\\n    function liquidate(address borrower, address liquidator)\\n        external\\n        returns (uint256 seizeTokens);\\n\\n    function trackBorrow(address borrower) external;\\n\\n    /*** Borrowable Interest Rate Model ***/\\n\\n    event AccrueInterest(\\n        uint256 interestAccumulated,\\n        uint256 borrowIndex,\\n        uint256 totalBorrows\\n    );\\n    event CalculateKink(uint256 kinkRate);\\n    event CalculateBorrowRate(uint256 borrowRate);\\n\\n    function KINK_BORROW_RATE_MAX() external pure returns (uint256);\\n\\n    function KINK_BORROW_RATE_MIN() external pure returns (uint256);\\n\\n    function KINK_MULTIPLIER() external pure returns (uint256);\\n\\n    function borrowRate() external view returns (uint256);\\n\\n    function kinkBorrowRate() external view returns (uint256);\\n\\n    function kinkUtilizationRate() external view returns (uint256);\\n\\n    function adjustSpeed() external view returns (uint256);\\n\\n    function rateUpdateTimestamp() external view returns (uint32);\\n\\n    function accrualTimestamp() external view returns (uint32);\\n\\n    function accrueInterest() external;\\n\\n    /*** Borrowable Setter ***/\\n\\n    event NewReserveFactor(uint256 newReserveFactor);\\n    event NewKinkUtilizationRate(uint256 newKinkUtilizationRate);\\n    event NewAdjustSpeed(uint256 newAdjustSpeed);\\n    event NewBorrowTracker(address newBorrowTracker);\\n\\n    function RESERVE_FACTOR_MAX() external pure returns (uint256);\\n\\n    function KINK_UR_MIN() external pure returns (uint256);\\n\\n    function KINK_UR_MAX() external pure returns (uint256);\\n\\n    function ADJUST_SPEED_MIN() external pure returns (uint256);\\n\\n    function ADJUST_SPEED_MAX() external pure returns (uint256);\\n\\n    function _initialize(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _underlying,\\n        address _collateral\\n    ) external;\\n\\n    function _setReserveFactor(uint256 newReserveFactor) external;\\n\\n    function _setKinkUtilizationRate(uint256 newKinkUtilizationRate) external;\\n\\n    function _setAdjustSpeed(uint256 newAdjustSpeed) external;\\n\\n    function _setBorrowTracker(address newBorrowTracker) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Router03.sol\": {\r\n      \"content\": \"pragma solidity =0.6.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/IRouter03.sol\\\";\\nimport \\\"./interfaces/IPoolToken.sol\\\";\\nimport \\\"./interfaces/IBorrowable.sol\\\";\\nimport \\\"./interfaces/ICollateral.sol\\\";\\nimport \\\"./interfaces/ITarotCallee.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IVaultToken.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\n\\ncontract Router03 is IRouter03, ITarotCallee {\\n    using SafeMath for uint256;\\n\\n    address public immutable override factory;\\n    address public immutable override bDeployer;\\n    address public immutable override cDeployer;\\n    address public immutable override WETH;\\n\\n    modifier ensure(uint256 deadline) {\\n        require(deadline >= block.timestamp, \\\"TarotRouter: EXPIRED\\\");\\n        _;\\n    }\\n\\n    modifier checkETH(address poolToken) {\\n        require(\\n            WETH == IPoolToken(poolToken).underlying(),\\n            \\\"TarotRouter: NOT_WETH\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        address _factory,\\n        address _bDeployer,\\n        address _cDeployer,\\n        address _WETH\\n    ) public {\\n        factory = _factory;\\n        bDeployer = _bDeployer;\\n        cDeployer = _cDeployer;\\n        WETH = _WETH;\\n    }\\n\\n    receive() external payable {\\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    /*** Mint ***/\\n\\n    function _mint(\\n        address poolToken,\\n        address token,\\n        uint256 amount,\\n        address from,\\n        address to\\n    ) internal virtual returns (uint256 tokens) {\\n        if (from == address(this))\\n            TransferHelper.safeTransfer(token, poolToken, amount);\\n        else TransferHelper.safeTransferFrom(token, from, poolToken, amount);\\n        tokens = IPoolToken(poolToken).mint(to);\\n    }\\n\\n    function mint(\\n        address poolToken,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) returns (uint256 tokens) {\\n        return\\n            _mint(\\n                poolToken,\\n                IPoolToken(poolToken).underlying(),\\n                amount,\\n                msg.sender,\\n                to\\n            );\\n    }\\n\\n    function mintETH(\\n        address poolToken,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        ensure(deadline)\\n        checkETH(poolToken)\\n        returns (uint256 tokens)\\n    {\\n        IWETH(WETH).deposit{value: msg.value}();\\n        return _mint(poolToken, WETH, msg.value, address(this), to);\\n    }\\n\\n    function mintCollateral(\\n        address poolToken,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external virtual override ensure(deadline) returns (uint256 tokens) {\\n        address underlying = IPoolToken(poolToken).underlying();\\n        if (this.isVaultToken(underlying)) {\\n            address uniswapV2Pair = IVaultToken(underlying).underlying();\\n            _permit(uniswapV2Pair, amount, deadline, permitData);\\n            TransferHelper.safeTransferFrom(\\n                uniswapV2Pair,\\n                msg.sender,\\n                underlying,\\n                amount\\n            );\\n            IVaultToken(underlying).mint(poolToken);\\n            return IPoolToken(poolToken).mint(to);\\n        } else {\\n            _permit(underlying, amount, deadline, permitData);\\n            return _mint(poolToken, underlying, amount, msg.sender, to);\\n        }\\n    }\\n\\n    /*** Redeem ***/\\n\\n    function redeem(\\n        address poolToken,\\n        uint256 tokens,\\n        address to,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) public virtual override ensure(deadline) returns (uint256 amount) {\\n        _permit(poolToken, tokens, deadline, permitData);\\n        IPoolToken(poolToken).transferFrom(msg.sender, poolToken, tokens);\\n        address underlying = IPoolToken(poolToken).underlying();\\n        if (this.isVaultToken(underlying)) {\\n            IPoolToken(poolToken).redeem(underlying);\\n            return IVaultToken(underlying).redeem(to);\\n        } else {\\n            return IPoolToken(poolToken).redeem(to);\\n        }\\n    }\\n\\n    function redeemETH(\\n        address poolToken,\\n        uint256 tokens,\\n        address to,\\n        uint256 deadline,\\n        bytes memory permitData\\n    )\\n        public\\n        virtual\\n        override\\n        ensure(deadline)\\n        checkETH(poolToken)\\n        returns (uint256 amountETH)\\n    {\\n        amountETH = redeem(\\n            poolToken,\\n            tokens,\\n            address(this),\\n            deadline,\\n            permitData\\n        );\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    /*** Borrow ***/\\n\\n    function borrow(\\n        address borrowable,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) public virtual override ensure(deadline) {\\n        _borrowPermit(borrowable, amount, deadline, permitData);\\n        IBorrowable(borrowable).borrow(msg.sender, to, amount, new bytes(0));\\n    }\\n\\n    function borrowETH(\\n        address borrowable,\\n        uint256 amountETH,\\n        address to,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) public virtual override ensure(deadline) checkETH(borrowable) {\\n        borrow(borrowable, amountETH, address(this), deadline, permitData);\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    /*** Repay ***/\\n\\n    function _repayAmount(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower\\n    ) internal virtual returns (uint256 amount) {\\n        IBorrowable(borrowable).accrueInterest();\\n        uint256 borrowedAmount = IBorrowable(borrowable).borrowBalance(\\n            borrower\\n        );\\n        amount = amountMax < borrowedAmount ? amountMax : borrowedAmount;\\n    }\\n\\n    function repay(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) returns (uint256 amount) {\\n        amount = _repayAmount(borrowable, amountMax, borrower);\\n        TransferHelper.safeTransferFrom(\\n            IBorrowable(borrowable).underlying(),\\n            msg.sender,\\n            borrowable,\\n            amount\\n        );\\n        IBorrowable(borrowable).borrow(borrower, address(0), 0, new bytes(0));\\n    }\\n\\n    function repayETH(\\n        address borrowable,\\n        address borrower,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        ensure(deadline)\\n        checkETH(borrowable)\\n        returns (uint256 amountETH)\\n    {\\n        amountETH = _repayAmount(borrowable, msg.value, borrower);\\n        IWETH(WETH).deposit{value: amountETH}();\\n        assert(IWETH(WETH).transfer(borrowable, amountETH));\\n        IBorrowable(borrowable).borrow(borrower, address(0), 0, new bytes(0));\\n        // refund surpluss eth, if any\\n        if (msg.value > amountETH)\\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n    }\\n\\n    /*** Liquidate ***/\\n\\n    function liquidate(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint256 amount, uint256 seizeTokens)\\n    {\\n        amount = _repayAmount(borrowable, amountMax, borrower);\\n        TransferHelper.safeTransferFrom(\\n            IBorrowable(borrowable).underlying(),\\n            msg.sender,\\n            borrowable,\\n            amount\\n        );\\n        seizeTokens = IBorrowable(borrowable).liquidate(borrower, to);\\n    }\\n\\n    function liquidateETH(\\n        address borrowable,\\n        address borrower,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        ensure(deadline)\\n        checkETH(borrowable)\\n        returns (uint256 amountETH, uint256 seizeTokens)\\n    {\\n        amountETH = _repayAmount(borrowable, msg.value, borrower);\\n        IWETH(WETH).deposit{value: amountETH}();\\n        assert(IWETH(WETH).transfer(borrowable, amountETH));\\n        seizeTokens = IBorrowable(borrowable).liquidate(borrower, to);\\n        // refund surpluss eth, if any\\n        if (msg.value > amountETH)\\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n    }\\n\\n    /*** Leverage LP Token ***/\\n\\n    function _leverage(\\n        address underlying,\\n        uint256 amountA,\\n        uint256 amountB,\\n        address to\\n    ) internal virtual {\\n        address borrowableA = getBorrowable(underlying, 0);\\n        // mint collateral\\n        bytes memory borrowBData = abi.encode(\\n            CalleeData({\\n                callType: CallType.ADD_LIQUIDITY_AND_MINT,\\n                underlying: underlying,\\n                borrowableIndex: 1,\\n                data: abi.encode(\\n                    AddLiquidityAndMintCalldata({\\n                        amountA: amountA,\\n                        amountB: amountB,\\n                        to: to\\n                    })\\n                )\\n            })\\n        );\\n        // borrow borrowableB\\n        bytes memory borrowAData = abi.encode(\\n            CalleeData({\\n                callType: CallType.BORROWB,\\n                underlying: underlying,\\n                borrowableIndex: 0,\\n                data: abi.encode(\\n                    BorrowBCalldata({\\n                        borrower: msg.sender,\\n                        receiver: address(this),\\n                        borrowAmount: amountB,\\n                        data: borrowBData\\n                    })\\n                )\\n            })\\n        );\\n        // borrow borrowableA\\n        IBorrowable(borrowableA).borrow(\\n            msg.sender,\\n            address(this),\\n            amountA,\\n            borrowAData\\n        );\\n    }\\n\\n    function leverage(\\n        address underlying,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitDataA,\\n        bytes calldata permitDataB\\n    ) external virtual override ensure(deadline) {\\n        _borrowPermit(\\n            getBorrowable(underlying, 0),\\n            amountADesired,\\n            deadline,\\n            permitDataA\\n        );\\n        _borrowPermit(\\n            getBorrowable(underlying, 1),\\n            amountBDesired,\\n            deadline,\\n            permitDataB\\n        );\\n        address uniswapV2Pair = getUniswapV2Pair(underlying);\\n        (uint256 amountA, uint256 amountB) = _optimalLiquidity(\\n            uniswapV2Pair,\\n            amountADesired,\\n            amountBDesired,\\n            amountAMin,\\n            amountBMin\\n        );\\n        _leverage(underlying, amountA, amountB, to);\\n    }\\n\\n    function _addLiquidityAndMint(\\n        address underlying,\\n        uint256 amountA,\\n        uint256 amountB,\\n        address to\\n    ) internal virtual {\\n        (\\n            address collateral,\\n            address borrowableA,\\n            address borrowableB\\n        ) = getLendingPool(underlying);\\n        address uniswapV2Pair = getUniswapV2Pair(underlying);\\n        // add liquidity to uniswap pair\\n        TransferHelper.safeTransfer(\\n            IBorrowable(borrowableA).underlying(),\\n            uniswapV2Pair,\\n            amountA\\n        );\\n        TransferHelper.safeTransfer(\\n            IBorrowable(borrowableB).underlying(),\\n            uniswapV2Pair,\\n            amountB\\n        );\\n        // mint LP token\\n        if (this.isVaultToken(underlying))\\n            IUniswapV2Pair(uniswapV2Pair).mint(underlying);\\n        IUniswapV2Pair(underlying).mint(collateral);\\n        // mint collateral\\n        ICollateral(collateral).mint(to);\\n    }\\n\\n    /*** Deleverage LP Token ***/\\n\\n    function deleverage(\\n        address underlying,\\n        uint256 redeemTokens,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external virtual override ensure(deadline) {\\n        address collateral = getCollateral(underlying);\\n        uint256 exchangeRate = ICollateral(collateral).exchangeRate();\\n        require(redeemTokens > 0, \\\"TarotRouter: REDEEM_ZERO\\\");\\n        uint256 redeemAmount = (redeemTokens - 1).mul(exchangeRate).div(1e18);\\n        _permit(collateral, redeemTokens, deadline, permitData);\\n        bytes memory redeemData = abi.encode(\\n            CalleeData({\\n                callType: CallType.REMOVE_LIQ_AND_REPAY,\\n                underlying: underlying,\\n                borrowableIndex: 0,\\n                data: abi.encode(\\n                    RemoveLiqAndRepayCalldata({\\n                        borrower: msg.sender,\\n                        redeemTokens: redeemTokens,\\n                        redeemAmount: redeemAmount,\\n                        amountAMin: amountAMin,\\n                        amountBMin: amountBMin\\n                    })\\n                )\\n            })\\n        );\\n        // flashRedeem\\n        ICollateral(collateral).flashRedeem(\\n            address(this),\\n            redeemAmount,\\n            redeemData\\n        );\\n    }\\n\\n    function _removeLiqAndRepay(\\n        address underlying,\\n        address borrower,\\n        uint256 redeemTokens,\\n        uint256 redeemAmount,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) internal virtual {\\n        (\\n            address collateral,\\n            address borrowableA,\\n            address borrowableB\\n        ) = getLendingPool(underlying);\\n        address tokenA = IBorrowable(borrowableA).underlying();\\n        address tokenB = IBorrowable(borrowableB).underlying();\\n        address uniswapV2Pair = getUniswapV2Pair(underlying);\\n        // removeLiquidity\\n        IUniswapV2Pair(underlying).transfer(underlying, redeemAmount);\\n        //TransferHelper.safeTransfer(underlying, underlying, redeemAmount);\\n        if (this.isVaultToken(underlying))\\n            IVaultToken(underlying).redeem(uniswapV2Pair);\\n        (uint256 amountAMax, uint256 amountBMax) = IUniswapV2Pair(uniswapV2Pair)\\n            .burn(address(this));\\n        require(amountAMax >= amountAMin, \\\"TarotRouter: INSUFFICIENT_A_AMOUNT\\\");\\n        require(amountBMax >= amountBMin, \\\"TarotRouter: INSUFFICIENT_B_AMOUNT\\\");\\n        // repay and refund\\n        _repayAndRefund(borrowableA, tokenA, borrower, amountAMax);\\n        _repayAndRefund(borrowableB, tokenB, borrower, amountBMax);\\n        // repay flash redeem\\n        ICollateral(collateral).transferFrom(\\n            borrower,\\n            collateral,\\n            redeemTokens\\n        );\\n    }\\n\\n    function _repayAndRefund(\\n        address borrowable,\\n        address token,\\n        address borrower,\\n        uint256 amountMax\\n    ) internal virtual {\\n        //repay\\n        uint256 amount = _repayAmount(borrowable, amountMax, borrower);\\n        TransferHelper.safeTransfer(token, borrowable, amount);\\n        IBorrowable(borrowable).borrow(borrower, address(0), 0, new bytes(0));\\n        // refund excess\\n        if (amountMax > amount) {\\n            uint256 refundAmount = amountMax - amount;\\n            if (token == WETH) {\\n                IWETH(WETH).withdraw(refundAmount);\\n                TransferHelper.safeTransferETH(borrower, refundAmount);\\n            } else TransferHelper.safeTransfer(token, borrower, refundAmount);\\n        }\\n    }\\n\\n    /*** Tarot Callee ***/\\n\\n    enum CallType {\\n        ADD_LIQUIDITY_AND_MINT,\\n        BORROWB,\\n        REMOVE_LIQ_AND_REPAY\\n    }\\n    struct CalleeData {\\n        CallType callType;\\n        address underlying;\\n        uint8 borrowableIndex;\\n        bytes data;\\n    }\\n    struct AddLiquidityAndMintCalldata {\\n        uint256 amountA;\\n        uint256 amountB;\\n        address to;\\n    }\\n    struct BorrowBCalldata {\\n        address borrower;\\n        address receiver;\\n        uint256 borrowAmount;\\n        bytes data;\\n    }\\n    struct RemoveLiqAndRepayCalldata {\\n        address borrower;\\n        uint256 redeemTokens;\\n        uint256 redeemAmount;\\n        uint256 amountAMin;\\n        uint256 amountBMin;\\n    }\\n\\n    function tarotBorrow(\\n        address sender,\\n        address borrower,\\n        uint256 borrowAmount,\\n        bytes calldata data\\n    ) external virtual override {\\n        borrower;\\n        borrowAmount;\\n        CalleeData memory calleeData = abi.decode(data, (CalleeData));\\n        address declaredCaller = getBorrowable(\\n            calleeData.underlying,\\n            calleeData.borrowableIndex\\n        );\\n        // only succeeds if called by a borrowable and if that borrowable has been called by the router\\n        require(sender == address(this), \\\"TarotRouter: SENDER_NOT_ROUTER\\\");\\n        require(\\n            msg.sender == declaredCaller,\\n            \\\"TarotRouter: UNAUTHORIZED_CALLER\\\"\\n        );\\n        if (calleeData.callType == CallType.ADD_LIQUIDITY_AND_MINT) {\\n            AddLiquidityAndMintCalldata memory d = abi.decode(\\n                calleeData.data,\\n                (AddLiquidityAndMintCalldata)\\n            );\\n            _addLiquidityAndMint(\\n                calleeData.underlying,\\n                d.amountA,\\n                d.amountB,\\n                d.to\\n            );\\n        } else if (calleeData.callType == CallType.BORROWB) {\\n            BorrowBCalldata memory d = abi.decode(\\n                calleeData.data,\\n                (BorrowBCalldata)\\n            );\\n            address borrowableB = getBorrowable(calleeData.underlying, 1);\\n            IBorrowable(borrowableB).borrow(\\n                d.borrower,\\n                d.receiver,\\n                d.borrowAmount,\\n                d.data\\n            );\\n        } else revert();\\n    }\\n\\n    function tarotRedeem(\\n        address sender,\\n        uint256 redeemAmount,\\n        bytes calldata data\\n    ) external virtual override {\\n        redeemAmount;\\n        CalleeData memory calleeData = abi.decode(data, (CalleeData));\\n        address declaredCaller = getCollateral(calleeData.underlying);\\n        // only succeeds if called by a collateral and if that collateral has been called by the router\\n        require(sender == address(this), \\\"TarotRouter: SENDER_NOT_ROUTER\\\");\\n        require(\\n            msg.sender == declaredCaller,\\n            \\\"TarotRouter: UNAUTHORIZED_CALLER\\\"\\n        );\\n        if (calleeData.callType == CallType.REMOVE_LIQ_AND_REPAY) {\\n            RemoveLiqAndRepayCalldata memory d = abi.decode(\\n                calleeData.data,\\n                (RemoveLiqAndRepayCalldata)\\n            );\\n            _removeLiqAndRepay(\\n                calleeData.underlying,\\n                d.borrower,\\n                d.redeemTokens,\\n                d.redeemAmount,\\n                d.amountAMin,\\n                d.amountBMin\\n            );\\n        } else revert();\\n    }\\n\\n    /*** Utilities ***/\\n\\n    function _permit(\\n        address poolToken,\\n        uint256 amount,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) internal virtual {\\n        if (permitData.length == 0) return;\\n        (bool approveMax, uint8 v, bytes32 r, bytes32 s) = abi.decode(\\n            permitData,\\n            (bool, uint8, bytes32, bytes32)\\n        );\\n        uint256 value = approveMax ? uint256(-1) : amount;\\n        IPoolToken(poolToken).permit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s\\n        );\\n    }\\n\\n    function _borrowPermit(\\n        address borrowable,\\n        uint256 amount,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) internal virtual {\\n        if (permitData.length == 0) return;\\n        (bool approveMax, uint8 v, bytes32 r, bytes32 s) = abi.decode(\\n            permitData,\\n            (bool, uint8, bytes32, bytes32)\\n        );\\n        uint256 value = approveMax ? uint256(-1) : amount;\\n        IBorrowable(borrowable).borrowPermit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s\\n        );\\n    }\\n\\n    function _optimalLiquidity(\\n        address uniswapV2Pair,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) public view virtual returns (uint256 amountA, uint256 amountB) {\\n        (uint256 reserveA, uint256 reserveB, ) = IUniswapV2Pair(uniswapV2Pair)\\n            .getReserves();\\n        uint256 amountBOptimal = _quote(amountADesired, reserveA, reserveB);\\n        if (amountBOptimal <= amountBDesired) {\\n            require(\\n                amountBOptimal >= amountBMin,\\n                \\\"TarotRouter: INSUFFICIENT_B_AMOUNT\\\"\\n            );\\n            (amountA, amountB) = (amountADesired, amountBOptimal);\\n        } else {\\n            uint256 amountAOptimal = _quote(amountBDesired, reserveB, reserveA);\\n            assert(amountAOptimal <= amountADesired);\\n            require(\\n                amountAOptimal >= amountAMin,\\n                \\\"TarotRouter: INSUFFICIENT_A_AMOUNT\\\"\\n            );\\n            (amountA, amountB) = (amountAOptimal, amountBDesired);\\n        }\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function _quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(amountA > 0, \\\"TarotRouter: INSUFFICIENT_AMOUNT\\\");\\n        require(\\n            reserveA > 0 && reserveB > 0,\\n            \\\"TarotRouter: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    function isVaultToken(address underlying)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        if (underlying == WETH) {\\n            return false;\\n        }\\n        try IVaultToken(underlying).isVaultToken() returns (bool result) {\\n            return result;\\n        } catch {\\n            return false;\\n        }\\n    }\\n\\n    function getUniswapV2Pair(address underlying)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        try IVaultToken(underlying).underlying() returns (address u) {\\n            if (u != address(0)) return u;\\n            return underlying;\\n        } catch {\\n            return underlying;\\n        }\\n    }\\n\\n    function getBorrowable(address underlying, uint8 index)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address borrowable)\\n    {\\n        require(index < 2, \\\"TarotRouter: INDEX_TOO_HIGH\\\");\\n        borrowable = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\\"ff\\\",\\n                        bDeployer,\\n                        keccak256(abi.encodePacked(factory, underlying, index)),\\n                        hex\\\"395cea33582aa76fdbf6a549e06bd8df47f4126708805f42bb1e05eacbb65d8f\\\" // Borrowable bytecode keccak256\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function getCollateral(address underlying)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address collateral)\\n    {\\n        collateral = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\\"ff\\\",\\n                        cDeployer,\\n                        keccak256(abi.encodePacked(factory, underlying)),\\n                        hex\\\"140d37d0a16c25fa05a48ae5a423f248fced47fe2c37e9ef67a3339b03dcc1db\\\" // Collateral bytecode keccak256\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function getLendingPool(address underlying)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (\\n            address collateral,\\n            address borrowableA,\\n            address borrowableB\\n        )\\n    {\\n        collateral = getCollateral(underlying);\\n        borrowableA = getBorrowable(underlying, 0);\\n        borrowableB = getBorrowable(underlying, 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRouter03.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IRouter03 {\\n    function factory() external pure returns (address);\\n\\n    function bDeployer() external pure returns (address);\\n\\n    function cDeployer() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function mint(\\n        address poolToken,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 tokens);\\n\\n    function mintETH(\\n        address poolToken,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 tokens);\\n\\n    function mintCollateral(\\n        address poolToken,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external returns (uint256 tokens);\\n\\n    function redeem(\\n        address poolToken,\\n        uint256 tokens,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external returns (uint256 amount);\\n\\n    function redeemETH(\\n        address poolToken,\\n        uint256 tokens,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external returns (uint256 amountETH);\\n\\n    function borrow(\\n        address borrowable,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external;\\n\\n    function borrowETH(\\n        address borrowable,\\n        uint256 amountETH,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external;\\n\\n    function repay(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline\\n    ) external returns (uint256 amount);\\n\\n    function repayETH(\\n        address borrowable,\\n        address borrower,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountETH);\\n\\n    function liquidate(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amount, uint256 seizeTokens);\\n\\n    function liquidateETH(\\n        address borrowable,\\n        address borrower,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountETH, uint256 seizeTokens);\\n\\n    function leverage(\\n        address uniswapV2Pair,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitDataA,\\n        bytes calldata permitDataB\\n    ) external;\\n\\n    function deleverage(\\n        address uniswapV2Pair,\\n        uint256 redeemTokens,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external;\\n\\n    function isVaultToken(address underlying) external view returns (bool);\\n\\n    function getUniswapV2Pair(address underlying)\\n        external\\n        view\\n        returns (address);\\n\\n    function getBorrowable(address uniswapV2Pair, uint8 index)\\n        external\\n        view\\n        returns (address borrowable);\\n\\n    function getCollateral(address uniswapV2Pair)\\n        external\\n        view\\n        returns (address collateral);\\n\\n    function getLendingPool(address uniswapV2Pair)\\n        external\\n        view\\n        returns (\\n            address collateral,\\n            address borrowableA,\\n            address borrowableB\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolToken.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IPoolToken {\\n    /*** Tarot ERC20 ***/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*** Pool Token ***/\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    function underlying() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function totalBalance() external view returns (uint256);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function exchangeRate() external returns (uint256);\\n\\n    function mint(address minter) external returns (uint256 mintTokens);\\n\\n    function redeem(address redeemer) external returns (uint256 redeemAmount);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function _setFactory() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollateral.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ICollateral {\\n    /*** Tarot ERC20 ***/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*** Pool Token ***/\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    function underlying() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function totalBalance() external view returns (uint256);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function exchangeRate() external returns (uint256);\\n\\n    function mint(address minter) external returns (uint256 mintTokens);\\n\\n    function redeem(address redeemer) external returns (uint256 redeemAmount);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function _setFactory() external;\\n\\n    /*** Collateral ***/\\n\\n    function borrowable0() external view returns (address);\\n\\n    function borrowable1() external view returns (address);\\n\\n    function tarotPriceOracle() external view returns (address);\\n\\n    function safetyMarginSqrt() external view returns (uint256);\\n\\n    function liquidationIncentive() external view returns (uint256);\\n\\n    function getPrices() external returns (uint256 price0, uint256 price1);\\n\\n    function tokensUnlocked(address from, uint256 value)\\n        external\\n        returns (bool);\\n\\n    function accountLiquidityAmounts(\\n        address account,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) external returns (uint256 liquidity, uint256 shortfall);\\n\\n    function accountLiquidity(address account)\\n        external\\n        returns (uint256 liquidity, uint256 shortfall);\\n\\n    function canBorrow(\\n        address account,\\n        address borrowable,\\n        uint256 accountBorrows\\n    ) external returns (bool);\\n\\n    function seize(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external returns (uint256 seizeTokens);\\n\\n    function flashRedeem(\\n        address redeemer,\\n        uint256 redeemAmount,\\n        bytes calldata data\\n    ) external;\\n\\n    /*** Collateral Setter ***/\\n\\n    event NewSafetyMargin(uint256 newSafetyMarginSqrt);\\n    event NewLiquidationIncentive(uint256 newLiquidationIncentive);\\n\\n    function SAFETY_MARGIN_SQRT_MIN() external pure returns (uint256);\\n\\n    function SAFETY_MARGIN_SQRT_MAX() external pure returns (uint256);\\n\\n    function LIQUIDATION_INCENTIVE_MIN() external pure returns (uint256);\\n\\n    function LIQUIDATION_INCENTIVE_MAX() external pure returns (uint256);\\n\\n    function _initialize(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _underlying,\\n        address _borrowable0,\\n        address _borrowable1\\n    ) external;\\n\\n    function _setSafetyMarginSqrt(uint256 newSafetyMarginSqrt) external;\\n\\n    function _setLiquidationIncentive(uint256 newLiquidationIncentive) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITarotCallee.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ITarotCallee {\\n    function tarotBorrow(\\n        address sender,\\n        address borrower,\\n        uint256 borrowAmount,\\n        bytes calldata data\\n    ) external;\\n\\n    function tarotRedeem(\\n        address sender,\\n        uint256 redeemAmount,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultToken.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport \\\"./IMasterChef.sol\\\";\\nimport \\\"./IUniswapV2Router01.sol\\\";\\n\\ninterface IVaultToken {\\n    /*** Tarot ERC20 ***/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*** Pool Token ***/\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    function underlying() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function totalBalance() external view returns (uint256);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function exchangeRate() external view returns (uint256);\\n\\n    function mint(address minter) external returns (uint256 mintTokens);\\n\\n    function redeem(address redeemer) external returns (uint256 redeemAmount);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function _setFactory() external;\\n\\n    /*** VaultToken ***/\\n\\n    event Reinvest(address indexed caller, uint256 reward, uint256 bounty);\\n\\n    function isVaultToken() external pure returns (bool);\\n\\n    function router() external view returns (IUniswapV2Router01);\\n\\n    function masterChef() external view returns (IMasterChef);\\n\\n    function rewardsToken() external view returns (address);\\n\\n    function WETH() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function swapFeeFactor() external view returns (uint256);\\n\\n    function pid() external view returns (uint256);\\n\\n    function REINVEST_BOUNTY() external pure returns (uint256);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function _initialize(\\n        IUniswapV2Router01 _router,\\n        IMasterChef _masterChef,\\n        address _rewardsToken,\\n        uint256 _swapFeeFactor,\\n        uint256 _pid\\n    ) external;\\n\\n    function reinvest() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to)\\n        external\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.6.6;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity =0.6.6;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x095ea7b3, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeApprove: approve failed\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0xa9059cbb, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeTransfer: transfer failed\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::transferFrom: transferFrom failed\\\"\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(\\n            success,\\n            \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMasterChef.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n// Making the original MasterChef as an interface leads to compilation fail.\\n// Use Contract instead of Interface here\\ncontract IMasterChef {\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 amount; // How many LP tokens the user has provided.\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n    }\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IERC20 lpToken; // Address of LP token contract.\\n        uint256 allocPoint; // How many allocation points assigned to this pool. Reward tokens to distribute per block.\\n        uint256 lastRewardBlock; // Last block number that reward token distribution occurs.\\n        uint256 accRewardTokenPerShare; // Accumulated reward tokens per share, times 1e12. See below.\\n    }\\n\\n    // Info of each user that stakes LP tokens.\\n    mapping(uint256 => PoolInfo) public poolInfo;\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n\\n    // Deposit LP tokens to MasterChef.\\n    function deposit(uint256 _pid, uint256 _amount) external {}\\n\\n    // Withdraw LP tokens from MasterChef.\\n    function withdraw(uint256 _pid, uint256 _amount) external {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/Router02.sol\": {\r\n      \"content\": \"pragma solidity =0.6.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/IRouter02.sol\\\";\\nimport \\\"./interfaces/IPoolToken.sol\\\";\\nimport \\\"./interfaces/IBorrowable.sol\\\";\\nimport \\\"./interfaces/ICollateral.sol\\\";\\nimport \\\"./interfaces/ITarotCallee.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IVaultToken.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\n\\ncontract Router02 is IRouter02, ITarotCallee {\\n    using SafeMath for uint256;\\n\\n    address public immutable override factory;\\n    address public immutable override bDeployer;\\n    address public immutable override cDeployer;\\n    address public immutable override WETH;\\n\\n    modifier ensure(uint256 deadline) {\\n        require(deadline >= block.timestamp, \\\"TarotRouter: EXPIRED\\\");\\n        _;\\n    }\\n\\n    modifier checkETH(address poolToken) {\\n        require(\\n            WETH == IPoolToken(poolToken).underlying(),\\n            \\\"TarotRouter: NOT_WETH\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        address _factory,\\n        address _bDeployer,\\n        address _cDeployer,\\n        address _WETH\\n    ) public {\\n        factory = _factory;\\n        bDeployer = _bDeployer;\\n        cDeployer = _cDeployer;\\n        WETH = _WETH;\\n    }\\n\\n    receive() external payable {\\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    /*** Mint ***/\\n\\n    function _mint(\\n        address poolToken,\\n        address token,\\n        uint256 amount,\\n        address from,\\n        address to\\n    ) internal virtual returns (uint256 tokens) {\\n        if (from == address(this))\\n            TransferHelper.safeTransfer(token, poolToken, amount);\\n        else TransferHelper.safeTransferFrom(token, from, poolToken, amount);\\n        tokens = IPoolToken(poolToken).mint(to);\\n    }\\n\\n    function mint(\\n        address poolToken,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) returns (uint256 tokens) {\\n        return\\n            _mint(\\n                poolToken,\\n                IPoolToken(poolToken).underlying(),\\n                amount,\\n                msg.sender,\\n                to\\n            );\\n    }\\n\\n    function mintETH(\\n        address poolToken,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        ensure(deadline)\\n        checkETH(poolToken)\\n        returns (uint256 tokens)\\n    {\\n        IWETH(WETH).deposit{value: msg.value}();\\n        return _mint(poolToken, WETH, msg.value, address(this), to);\\n    }\\n\\n    function mintCollateral(\\n        address poolToken,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external virtual override ensure(deadline) returns (uint256 tokens) {\\n        address underlying = IPoolToken(poolToken).underlying();\\n        if (isVaultToken(underlying)) {\\n            address uniswapV2Pair = IVaultToken(underlying).underlying();\\n            _permit(uniswapV2Pair, amount, deadline, permitData);\\n            TransferHelper.safeTransferFrom(\\n                uniswapV2Pair,\\n                msg.sender,\\n                underlying,\\n                amount\\n            );\\n            IVaultToken(underlying).mint(poolToken);\\n            return IPoolToken(poolToken).mint(to);\\n        } else {\\n            _permit(underlying, amount, deadline, permitData);\\n            return _mint(poolToken, underlying, amount, msg.sender, to);\\n        }\\n    }\\n\\n    /*** Redeem ***/\\n\\n    function redeem(\\n        address poolToken,\\n        uint256 tokens,\\n        address to,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) public virtual override ensure(deadline) returns (uint256 amount) {\\n        _permit(poolToken, tokens, deadline, permitData);\\n        IPoolToken(poolToken).transferFrom(msg.sender, poolToken, tokens);\\n        address underlying = IPoolToken(poolToken).underlying();\\n        if (isVaultToken(underlying)) {\\n            IPoolToken(poolToken).redeem(underlying);\\n            return IVaultToken(underlying).redeem(to);\\n        } else {\\n            return IPoolToken(poolToken).redeem(to);\\n        }\\n    }\\n\\n    function redeemETH(\\n        address poolToken,\\n        uint256 tokens,\\n        address to,\\n        uint256 deadline,\\n        bytes memory permitData\\n    )\\n        public\\n        virtual\\n        override\\n        ensure(deadline)\\n        checkETH(poolToken)\\n        returns (uint256 amountETH)\\n    {\\n        amountETH = redeem(\\n            poolToken,\\n            tokens,\\n            address(this),\\n            deadline,\\n            permitData\\n        );\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    /*** Borrow ***/\\n\\n    function borrow(\\n        address borrowable,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) public virtual override ensure(deadline) {\\n        _borrowPermit(borrowable, amount, deadline, permitData);\\n        IBorrowable(borrowable).borrow(msg.sender, to, amount, new bytes(0));\\n    }\\n\\n    function borrowETH(\\n        address borrowable,\\n        uint256 amountETH,\\n        address to,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) public virtual override ensure(deadline) checkETH(borrowable) {\\n        borrow(borrowable, amountETH, address(this), deadline, permitData);\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    /*** Repay ***/\\n\\n    function _repayAmount(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower\\n    ) internal virtual returns (uint256 amount) {\\n        IBorrowable(borrowable).accrueInterest();\\n        uint256 borrowedAmount = IBorrowable(borrowable).borrowBalance(\\n            borrower\\n        );\\n        amount = amountMax < borrowedAmount ? amountMax : borrowedAmount;\\n    }\\n\\n    function repay(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) returns (uint256 amount) {\\n        amount = _repayAmount(borrowable, amountMax, borrower);\\n        TransferHelper.safeTransferFrom(\\n            IBorrowable(borrowable).underlying(),\\n            msg.sender,\\n            borrowable,\\n            amount\\n        );\\n        IBorrowable(borrowable).borrow(borrower, address(0), 0, new bytes(0));\\n    }\\n\\n    function repayETH(\\n        address borrowable,\\n        address borrower,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        ensure(deadline)\\n        checkETH(borrowable)\\n        returns (uint256 amountETH)\\n    {\\n        amountETH = _repayAmount(borrowable, msg.value, borrower);\\n        IWETH(WETH).deposit{value: amountETH}();\\n        assert(IWETH(WETH).transfer(borrowable, amountETH));\\n        IBorrowable(borrowable).borrow(borrower, address(0), 0, new bytes(0));\\n        // refund surpluss eth, if any\\n        if (msg.value > amountETH)\\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n    }\\n\\n    /*** Liquidate ***/\\n\\n    function liquidate(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint256 amount, uint256 seizeTokens)\\n    {\\n        amount = _repayAmount(borrowable, amountMax, borrower);\\n        TransferHelper.safeTransferFrom(\\n            IBorrowable(borrowable).underlying(),\\n            msg.sender,\\n            borrowable,\\n            amount\\n        );\\n        seizeTokens = IBorrowable(borrowable).liquidate(borrower, to);\\n    }\\n\\n    function liquidateETH(\\n        address borrowable,\\n        address borrower,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        ensure(deadline)\\n        checkETH(borrowable)\\n        returns (uint256 amountETH, uint256 seizeTokens)\\n    {\\n        amountETH = _repayAmount(borrowable, msg.value, borrower);\\n        IWETH(WETH).deposit{value: amountETH}();\\n        assert(IWETH(WETH).transfer(borrowable, amountETH));\\n        seizeTokens = IBorrowable(borrowable).liquidate(borrower, to);\\n        // refund surpluss eth, if any\\n        if (msg.value > amountETH)\\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n    }\\n\\n    /*** Leverage LP Token ***/\\n\\n    function _leverage(\\n        address underlying,\\n        uint256 amountA,\\n        uint256 amountB,\\n        address to\\n    ) internal virtual {\\n        address borrowableA = getBorrowable(underlying, 0);\\n        // mint collateral\\n        bytes memory borrowBData = abi.encode(\\n            CalleeData({\\n                callType: CallType.ADD_LIQUIDITY_AND_MINT,\\n                underlying: underlying,\\n                borrowableIndex: 1,\\n                data: abi.encode(\\n                    AddLiquidityAndMintCalldata({\\n                        amountA: amountA,\\n                        amountB: amountB,\\n                        to: to\\n                    })\\n                )\\n            })\\n        );\\n        // borrow borrowableB\\n        bytes memory borrowAData = abi.encode(\\n            CalleeData({\\n                callType: CallType.BORROWB,\\n                underlying: underlying,\\n                borrowableIndex: 0,\\n                data: abi.encode(\\n                    BorrowBCalldata({\\n                        borrower: msg.sender,\\n                        receiver: address(this),\\n                        borrowAmount: amountB,\\n                        data: borrowBData\\n                    })\\n                )\\n            })\\n        );\\n        // borrow borrowableA\\n        IBorrowable(borrowableA).borrow(\\n            msg.sender,\\n            address(this),\\n            amountA,\\n            borrowAData\\n        );\\n    }\\n\\n    function leverage(\\n        address underlying,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitDataA,\\n        bytes calldata permitDataB\\n    ) external virtual override ensure(deadline) {\\n        _borrowPermit(\\n            getBorrowable(underlying, 0),\\n            amountADesired,\\n            deadline,\\n            permitDataA\\n        );\\n        _borrowPermit(\\n            getBorrowable(underlying, 1),\\n            amountBDesired,\\n            deadline,\\n            permitDataB\\n        );\\n        address uniswapV2Pair = getUniswapV2Pair(underlying);\\n        (uint256 amountA, uint256 amountB) = _optimalLiquidity(\\n            uniswapV2Pair,\\n            amountADesired,\\n            amountBDesired,\\n            amountAMin,\\n            amountBMin\\n        );\\n        _leverage(underlying, amountA, amountB, to);\\n    }\\n\\n    function _addLiquidityAndMint(\\n        address underlying,\\n        uint256 amountA,\\n        uint256 amountB,\\n        address to\\n    ) internal virtual {\\n        (\\n            address collateral,\\n            address borrowableA,\\n            address borrowableB\\n        ) = getLendingPool(underlying);\\n        address uniswapV2Pair = getUniswapV2Pair(underlying);\\n        // add liquidity to uniswap pair\\n        TransferHelper.safeTransfer(\\n            IBorrowable(borrowableA).underlying(),\\n            uniswapV2Pair,\\n            amountA\\n        );\\n        TransferHelper.safeTransfer(\\n            IBorrowable(borrowableB).underlying(),\\n            uniswapV2Pair,\\n            amountB\\n        );\\n        // mint LP token\\n        if (isVaultToken(underlying))\\n            IUniswapV2Pair(uniswapV2Pair).mint(underlying);\\n        IUniswapV2Pair(underlying).mint(collateral);\\n        // mint collateral\\n        ICollateral(collateral).mint(to);\\n    }\\n\\n    /*** Deleverage LP Token ***/\\n\\n    function deleverage(\\n        address underlying,\\n        uint256 redeemTokens,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external virtual override ensure(deadline) {\\n        address collateral = getCollateral(underlying);\\n        uint256 exchangeRate = ICollateral(collateral).exchangeRate();\\n        require(redeemTokens > 0, \\\"TarotRouter: REDEEM_ZERO\\\");\\n        uint256 redeemAmount = (redeemTokens - 1).mul(exchangeRate).div(1e18);\\n        _permit(collateral, redeemTokens, deadline, permitData);\\n        bytes memory redeemData = abi.encode(\\n            CalleeData({\\n                callType: CallType.REMOVE_LIQ_AND_REPAY,\\n                underlying: underlying,\\n                borrowableIndex: 0,\\n                data: abi.encode(\\n                    RemoveLiqAndRepayCalldata({\\n                        borrower: msg.sender,\\n                        redeemTokens: redeemTokens,\\n                        redeemAmount: redeemAmount,\\n                        amountAMin: amountAMin,\\n                        amountBMin: amountBMin\\n                    })\\n                )\\n            })\\n        );\\n        // flashRedeem\\n        ICollateral(collateral).flashRedeem(\\n            address(this),\\n            redeemAmount,\\n            redeemData\\n        );\\n    }\\n\\n    function _removeLiqAndRepay(\\n        address underlying,\\n        address borrower,\\n        uint256 redeemTokens,\\n        uint256 redeemAmount,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) internal virtual {\\n        (\\n            address collateral,\\n            address borrowableA,\\n            address borrowableB\\n        ) = getLendingPool(underlying);\\n        address tokenA = IBorrowable(borrowableA).underlying();\\n        address tokenB = IBorrowable(borrowableB).underlying();\\n        address uniswapV2Pair = getUniswapV2Pair(underlying);\\n        // removeLiquidity\\n        IUniswapV2Pair(underlying).transfer(underlying, redeemAmount);\\n        //TransferHelper.safeTransfer(underlying, underlying, redeemAmount);\\n        if (isVaultToken(underlying))\\n            IVaultToken(underlying).redeem(uniswapV2Pair);\\n        (uint256 amountAMax, uint256 amountBMax) = IUniswapV2Pair(uniswapV2Pair)\\n            .burn(address(this));\\n        require(amountAMax >= amountAMin, \\\"TarotRouter: INSUFFICIENT_A_AMOUNT\\\");\\n        require(amountBMax >= amountBMin, \\\"TarotRouter: INSUFFICIENT_B_AMOUNT\\\");\\n        // repay and refund\\n        _repayAndRefund(borrowableA, tokenA, borrower, amountAMax);\\n        _repayAndRefund(borrowableB, tokenB, borrower, amountBMax);\\n        // repay flash redeem\\n        ICollateral(collateral).transferFrom(\\n            borrower,\\n            collateral,\\n            redeemTokens\\n        );\\n    }\\n\\n    function _repayAndRefund(\\n        address borrowable,\\n        address token,\\n        address borrower,\\n        uint256 amountMax\\n    ) internal virtual {\\n        //repay\\n        uint256 amount = _repayAmount(borrowable, amountMax, borrower);\\n        TransferHelper.safeTransfer(token, borrowable, amount);\\n        IBorrowable(borrowable).borrow(borrower, address(0), 0, new bytes(0));\\n        // refund excess\\n        if (amountMax > amount) {\\n            uint256 refundAmount = amountMax - amount;\\n            if (token == WETH) {\\n                IWETH(WETH).withdraw(refundAmount);\\n                TransferHelper.safeTransferETH(borrower, refundAmount);\\n            } else TransferHelper.safeTransfer(token, borrower, refundAmount);\\n        }\\n    }\\n\\n    /*** Tarot Callee ***/\\n\\n    enum CallType {\\n        ADD_LIQUIDITY_AND_MINT,\\n        BORROWB,\\n        REMOVE_LIQ_AND_REPAY\\n    }\\n    struct CalleeData {\\n        CallType callType;\\n        address underlying;\\n        uint8 borrowableIndex;\\n        bytes data;\\n    }\\n    struct AddLiquidityAndMintCalldata {\\n        uint256 amountA;\\n        uint256 amountB;\\n        address to;\\n    }\\n    struct BorrowBCalldata {\\n        address borrower;\\n        address receiver;\\n        uint256 borrowAmount;\\n        bytes data;\\n    }\\n    struct RemoveLiqAndRepayCalldata {\\n        address borrower;\\n        uint256 redeemTokens;\\n        uint256 redeemAmount;\\n        uint256 amountAMin;\\n        uint256 amountBMin;\\n    }\\n\\n    function tarotBorrow(\\n        address sender,\\n        address borrower,\\n        uint256 borrowAmount,\\n        bytes calldata data\\n    ) external virtual override {\\n        borrower;\\n        borrowAmount;\\n        CalleeData memory calleeData = abi.decode(data, (CalleeData));\\n        address declaredCaller = getBorrowable(\\n            calleeData.underlying,\\n            calleeData.borrowableIndex\\n        );\\n        // only succeeds if called by a borrowable and if that borrowable has been called by the router\\n        require(sender == address(this), \\\"TarotRouter: SENDER_NOT_ROUTER\\\");\\n        require(\\n            msg.sender == declaredCaller,\\n            \\\"TarotRouter: UNAUTHORIZED_CALLER\\\"\\n        );\\n        if (calleeData.callType == CallType.ADD_LIQUIDITY_AND_MINT) {\\n            AddLiquidityAndMintCalldata memory d = abi.decode(\\n                calleeData.data,\\n                (AddLiquidityAndMintCalldata)\\n            );\\n            _addLiquidityAndMint(\\n                calleeData.underlying,\\n                d.amountA,\\n                d.amountB,\\n                d.to\\n            );\\n        } else if (calleeData.callType == CallType.BORROWB) {\\n            BorrowBCalldata memory d = abi.decode(\\n                calleeData.data,\\n                (BorrowBCalldata)\\n            );\\n            address borrowableB = getBorrowable(calleeData.underlying, 1);\\n            IBorrowable(borrowableB).borrow(\\n                d.borrower,\\n                d.receiver,\\n                d.borrowAmount,\\n                d.data\\n            );\\n        } else revert();\\n    }\\n\\n    function tarotRedeem(\\n        address sender,\\n        uint256 redeemAmount,\\n        bytes calldata data\\n    ) external virtual override {\\n        redeemAmount;\\n        CalleeData memory calleeData = abi.decode(data, (CalleeData));\\n        address declaredCaller = getCollateral(calleeData.underlying);\\n        // only succeeds if called by a collateral and if that collateral has been called by the router\\n        require(sender == address(this), \\\"TarotRouter: SENDER_NOT_ROUTER\\\");\\n        require(\\n            msg.sender == declaredCaller,\\n            \\\"TarotRouter: UNAUTHORIZED_CALLER\\\"\\n        );\\n        if (calleeData.callType == CallType.REMOVE_LIQ_AND_REPAY) {\\n            RemoveLiqAndRepayCalldata memory d = abi.decode(\\n                calleeData.data,\\n                (RemoveLiqAndRepayCalldata)\\n            );\\n            _removeLiqAndRepay(\\n                calleeData.underlying,\\n                d.borrower,\\n                d.redeemTokens,\\n                d.redeemAmount,\\n                d.amountAMin,\\n                d.amountBMin\\n            );\\n        } else revert();\\n    }\\n\\n    /*** Utilities ***/\\n\\n    function _permit(\\n        address poolToken,\\n        uint256 amount,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) internal virtual {\\n        if (permitData.length == 0) return;\\n        (bool approveMax, uint8 v, bytes32 r, bytes32 s) = abi.decode(\\n            permitData,\\n            (bool, uint8, bytes32, bytes32)\\n        );\\n        uint256 value = approveMax ? uint256(-1) : amount;\\n        IPoolToken(poolToken).permit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s\\n        );\\n    }\\n\\n    function _borrowPermit(\\n        address borrowable,\\n        uint256 amount,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) internal virtual {\\n        if (permitData.length == 0) return;\\n        (bool approveMax, uint8 v, bytes32 r, bytes32 s) = abi.decode(\\n            permitData,\\n            (bool, uint8, bytes32, bytes32)\\n        );\\n        uint256 value = approveMax ? uint256(-1) : amount;\\n        IBorrowable(borrowable).borrowPermit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s\\n        );\\n    }\\n\\n    function _optimalLiquidity(\\n        address uniswapV2Pair,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) public view virtual returns (uint256 amountA, uint256 amountB) {\\n        (uint256 reserveA, uint256 reserveB, ) = IUniswapV2Pair(uniswapV2Pair)\\n            .getReserves();\\n        uint256 amountBOptimal = _quote(amountADesired, reserveA, reserveB);\\n        if (amountBOptimal <= amountBDesired) {\\n            require(\\n                amountBOptimal >= amountBMin,\\n                \\\"TarotRouter: INSUFFICIENT_B_AMOUNT\\\"\\n            );\\n            (amountA, amountB) = (amountADesired, amountBOptimal);\\n        } else {\\n            uint256 amountAOptimal = _quote(amountBDesired, reserveB, reserveA);\\n            assert(amountAOptimal <= amountADesired);\\n            require(\\n                amountAOptimal >= amountAMin,\\n                \\\"TarotRouter: INSUFFICIENT_A_AMOUNT\\\"\\n            );\\n            (amountA, amountB) = (amountAOptimal, amountBDesired);\\n        }\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function _quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(amountA > 0, \\\"TarotRouter: INSUFFICIENT_AMOUNT\\\");\\n        require(\\n            reserveA > 0 && reserveB > 0,\\n            \\\"TarotRouter: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    function isVaultToken(address underlying)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        try IVaultToken(underlying).isVaultToken() returns (bool result) {\\n            return result;\\n        } catch {\\n            return false;\\n        }\\n    }\\n\\n    function getUniswapV2Pair(address underlying)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        try IVaultToken(underlying).underlying() returns (address u) {\\n            if (u != address(0)) return u;\\n            return underlying;\\n        } catch {\\n            return underlying;\\n        }\\n    }\\n\\n    function getBorrowable(address underlying, uint8 index)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address borrowable)\\n    {\\n        require(index < 2, \\\"TarotRouter: INDEX_TOO_HIGH\\\");\\n        borrowable = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\\"ff\\\",\\n                        bDeployer,\\n                        keccak256(abi.encodePacked(factory, underlying, index)),\\n                        hex\\\"395cea33582aa76fdbf6a549e06bd8df47f4126708805f42bb1e05eacbb65d8f\\\" // Borrowable bytecode keccak256\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function getCollateral(address underlying)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address collateral)\\n    {\\n        collateral = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\\"ff\\\",\\n                        cDeployer,\\n                        keccak256(abi.encodePacked(factory, underlying)),\\n                        hex\\\"5caf389f3c99ab6804e0c6a0ca7534b4e4d69ee703e936e8cb04b655b536e213\\\" // Collateral bytecode keccak256\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function getLendingPool(address underlying)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (\\n            address collateral,\\n            address borrowableA,\\n            address borrowableB\\n        )\\n    {\\n        collateral = getCollateral(underlying);\\n        borrowableA = getBorrowable(underlying, 0);\\n        borrowableB = getBorrowable(underlying, 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRouter02.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IRouter02 {\\n    function factory() external pure returns (address);\\n\\n    function bDeployer() external pure returns (address);\\n\\n    function cDeployer() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function mint(\\n        address poolToken,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 tokens);\\n\\n    function mintETH(\\n        address poolToken,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 tokens);\\n\\n    function mintCollateral(\\n        address poolToken,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external returns (uint256 tokens);\\n\\n    function redeem(\\n        address poolToken,\\n        uint256 tokens,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external returns (uint256 amount);\\n\\n    function redeemETH(\\n        address poolToken,\\n        uint256 tokens,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external returns (uint256 amountETH);\\n\\n    function borrow(\\n        address borrowable,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external;\\n\\n    function borrowETH(\\n        address borrowable,\\n        uint256 amountETH,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external;\\n\\n    function repay(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline\\n    ) external returns (uint256 amount);\\n\\n    function repayETH(\\n        address borrowable,\\n        address borrower,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountETH);\\n\\n    function liquidate(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amount, uint256 seizeTokens);\\n\\n    function liquidateETH(\\n        address borrowable,\\n        address borrower,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountETH, uint256 seizeTokens);\\n\\n    function leverage(\\n        address uniswapV2Pair,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitDataA,\\n        bytes calldata permitDataB\\n    ) external;\\n\\n    function deleverage(\\n        address uniswapV2Pair,\\n        uint256 redeemTokens,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external;\\n\\n    function isVaultToken(address underlying) external view returns (bool);\\n\\n    function getUniswapV2Pair(address underlying)\\n        external\\n        view\\n        returns (address);\\n\\n    function getBorrowable(address uniswapV2Pair, uint8 index)\\n        external\\n        view\\n        returns (address borrowable);\\n\\n    function getCollateral(address uniswapV2Pair)\\n        external\\n        view\\n        returns (address collateral);\\n\\n    function getLendingPool(address uniswapV2Pair)\\n        external\\n        view\\n        returns (\\n            address collateral,\\n            address borrowableA,\\n            address borrowableB\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/Router01.sol\": {\r\n      \"content\": \"pragma solidity =0.6.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/IRouter01.sol\\\";\\nimport \\\"./interfaces/IPoolToken.sol\\\";\\nimport \\\"./interfaces/IBorrowable.sol\\\";\\nimport \\\"./interfaces/ICollateral.sol\\\";\\nimport \\\"./interfaces/ITarotCallee.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\n\\ncontract Router01 is IRouter01, ITarotCallee {\\n    using SafeMath for uint256;\\n\\n    address public immutable override factory;\\n    address public immutable override bDeployer;\\n    address public immutable override cDeployer;\\n    address public immutable override WETH;\\n\\n    modifier ensure(uint256 deadline) {\\n        require(deadline >= block.timestamp, \\\"TarotRouter: EXPIRED\\\");\\n        _;\\n    }\\n\\n    modifier checkETH(address poolToken) {\\n        require(\\n            WETH == IPoolToken(poolToken).underlying(),\\n            \\\"TarotRouter: NOT_WETH\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        address _factory,\\n        address _bDeployer,\\n        address _cDeployer,\\n        address _WETH\\n    ) public {\\n        factory = _factory;\\n        bDeployer = _bDeployer;\\n        cDeployer = _cDeployer;\\n        WETH = _WETH;\\n    }\\n\\n    receive() external payable {\\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    /*** Mint ***/\\n\\n    function _mint(\\n        address poolToken,\\n        address underlying,\\n        uint256 amount,\\n        address from,\\n        address to\\n    ) internal virtual returns (uint256 tokens) {\\n        if (from == address(this))\\n            TransferHelper.safeTransfer(underlying, poolToken, amount);\\n        else\\n            TransferHelper.safeTransferFrom(\\n                underlying,\\n                from,\\n                poolToken,\\n                amount\\n            );\\n        tokens = IPoolToken(poolToken).mint(to);\\n    }\\n\\n    function mint(\\n        address poolToken,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) returns (uint256 tokens) {\\n        return\\n            _mint(\\n                poolToken,\\n                IPoolToken(poolToken).underlying(),\\n                amount,\\n                msg.sender,\\n                to\\n            );\\n    }\\n\\n    function mintETH(\\n        address poolToken,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        ensure(deadline)\\n        checkETH(poolToken)\\n        returns (uint256 tokens)\\n    {\\n        IWETH(WETH).deposit{value: msg.value}();\\n        return _mint(poolToken, WETH, msg.value, address(this), to);\\n    }\\n\\n    function mintCollateral(\\n        address poolToken,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external virtual override ensure(deadline) returns (uint256 tokens) {\\n        address uniswapV2Pair = IPoolToken(poolToken).underlying();\\n        _permit(uniswapV2Pair, amount, deadline, permitData);\\n        return _mint(poolToken, uniswapV2Pair, amount, msg.sender, to);\\n    }\\n\\n    /*** Redeem ***/\\n\\n    function redeem(\\n        address poolToken,\\n        uint256 tokens,\\n        address to,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) public virtual override ensure(deadline) returns (uint256 amount) {\\n        _permit(poolToken, tokens, deadline, permitData);\\n        IPoolToken(poolToken).transferFrom(msg.sender, poolToken, tokens);\\n        amount = IPoolToken(poolToken).redeem(to);\\n    }\\n\\n    function redeemETH(\\n        address poolToken,\\n        uint256 tokens,\\n        address to,\\n        uint256 deadline,\\n        bytes memory permitData\\n    )\\n        public\\n        virtual\\n        override\\n        ensure(deadline)\\n        checkETH(poolToken)\\n        returns (uint256 amountETH)\\n    {\\n        amountETH = redeem(\\n            poolToken,\\n            tokens,\\n            address(this),\\n            deadline,\\n            permitData\\n        );\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    /*** Borrow ***/\\n\\n    function borrow(\\n        address borrowable,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) public virtual override ensure(deadline) {\\n        _borrowPermit(borrowable, amount, deadline, permitData);\\n        IBorrowable(borrowable).borrow(msg.sender, to, amount, new bytes(0));\\n    }\\n\\n    function borrowETH(\\n        address borrowable,\\n        uint256 amountETH,\\n        address to,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) public virtual override ensure(deadline) checkETH(borrowable) {\\n        borrow(borrowable, amountETH, address(this), deadline, permitData);\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    /*** Repay ***/\\n\\n    function _repayAmount(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower\\n    ) internal virtual returns (uint256 amount) {\\n        IBorrowable(borrowable).accrueInterest();\\n        uint256 borrowedAmount = IBorrowable(borrowable).borrowBalance(\\n            borrower\\n        );\\n        amount = amountMax < borrowedAmount ? amountMax : borrowedAmount;\\n    }\\n\\n    function repay(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline\\n    ) external virtual override ensure(deadline) returns (uint256 amount) {\\n        amount = _repayAmount(borrowable, amountMax, borrower);\\n        TransferHelper.safeTransferFrom(\\n            IBorrowable(borrowable).underlying(),\\n            msg.sender,\\n            borrowable,\\n            amount\\n        );\\n        IBorrowable(borrowable).borrow(borrower, address(0), 0, new bytes(0));\\n    }\\n\\n    function repayETH(\\n        address borrowable,\\n        address borrower,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        ensure(deadline)\\n        checkETH(borrowable)\\n        returns (uint256 amountETH)\\n    {\\n        amountETH = _repayAmount(borrowable, msg.value, borrower);\\n        IWETH(WETH).deposit{value: amountETH}();\\n        assert(IWETH(WETH).transfer(borrowable, amountETH));\\n        IBorrowable(borrowable).borrow(borrower, address(0), 0, new bytes(0));\\n        // refund surpluss eth, if any\\n        if (msg.value > amountETH)\\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n    }\\n\\n    /*** Liquidate ***/\\n\\n    function liquidate(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        virtual\\n        override\\n        ensure(deadline)\\n        returns (uint256 amount, uint256 seizeTokens)\\n    {\\n        amount = _repayAmount(borrowable, amountMax, borrower);\\n        TransferHelper.safeTransferFrom(\\n            IBorrowable(borrowable).underlying(),\\n            msg.sender,\\n            borrowable,\\n            amount\\n        );\\n        seizeTokens = IBorrowable(borrowable).liquidate(borrower, to);\\n    }\\n\\n    function liquidateETH(\\n        address borrowable,\\n        address borrower,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        ensure(deadline)\\n        checkETH(borrowable)\\n        returns (uint256 amountETH, uint256 seizeTokens)\\n    {\\n        amountETH = _repayAmount(borrowable, msg.value, borrower);\\n        IWETH(WETH).deposit{value: amountETH}();\\n        assert(IWETH(WETH).transfer(borrowable, amountETH));\\n        seizeTokens = IBorrowable(borrowable).liquidate(borrower, to);\\n        // refund surpluss eth, if any\\n        if (msg.value > amountETH)\\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n    }\\n\\n    /*** Leverage LP Token ***/\\n\\n    function _leverage(\\n        address uniswapV2Pair,\\n        uint256 amountA,\\n        uint256 amountB,\\n        address to\\n    ) internal virtual {\\n        address borrowableA = getBorrowable(uniswapV2Pair, 0);\\n        // mint collateral\\n        bytes memory borrowBData = abi.encode(\\n            CalleeData({\\n                callType: CallType.ADD_LIQUIDITY_AND_MINT,\\n                uniswapV2Pair: uniswapV2Pair,\\n                borrowableIndex: 1,\\n                data: abi.encode(\\n                    AddLiquidityAndMintCalldata({\\n                        amountA: amountA,\\n                        amountB: amountB,\\n                        to: to\\n                    })\\n                )\\n            })\\n        );\\n        // borrow borrowableB\\n        bytes memory borrowAData = abi.encode(\\n            CalleeData({\\n                callType: CallType.BORROWB,\\n                uniswapV2Pair: uniswapV2Pair,\\n                borrowableIndex: 0,\\n                data: abi.encode(\\n                    BorrowBCalldata({\\n                        borrower: msg.sender,\\n                        receiver: address(this),\\n                        borrowAmount: amountB,\\n                        data: borrowBData\\n                    })\\n                )\\n            })\\n        );\\n        // borrow borrowableA\\n        IBorrowable(borrowableA).borrow(\\n            msg.sender,\\n            address(this),\\n            amountA,\\n            borrowAData\\n        );\\n    }\\n\\n    function leverage(\\n        address uniswapV2Pair,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitDataA,\\n        bytes calldata permitDataB\\n    ) external virtual override ensure(deadline) {\\n        _borrowPermit(\\n            getBorrowable(uniswapV2Pair, 0),\\n            amountADesired,\\n            deadline,\\n            permitDataA\\n        );\\n        _borrowPermit(\\n            getBorrowable(uniswapV2Pair, 1),\\n            amountBDesired,\\n            deadline,\\n            permitDataB\\n        );\\n        (uint256 amountA, uint256 amountB) = _optimalLiquidity(\\n            uniswapV2Pair,\\n            amountADesired,\\n            amountBDesired,\\n            amountAMin,\\n            amountBMin\\n        );\\n        _leverage(uniswapV2Pair, amountA, amountB, to);\\n    }\\n\\n    function _addLiquidityAndMint(\\n        address uniswapV2Pair,\\n        uint256 amountA,\\n        uint256 amountB,\\n        address to\\n    ) internal virtual {\\n        (\\n            address collateral,\\n            address borrowableA,\\n            address borrowableB\\n        ) = getLendingPool(uniswapV2Pair);\\n        // add liquidity to uniswap pair\\n        TransferHelper.safeTransfer(\\n            IBorrowable(borrowableA).underlying(),\\n            uniswapV2Pair,\\n            amountA\\n        );\\n        TransferHelper.safeTransfer(\\n            IBorrowable(borrowableB).underlying(),\\n            uniswapV2Pair,\\n            amountB\\n        );\\n        IUniswapV2Pair(uniswapV2Pair).mint(collateral);\\n        // mint collateral\\n        ICollateral(collateral).mint(to);\\n    }\\n\\n    /*** Deleverage LP Token ***/\\n\\n    function deleverage(\\n        address uniswapV2Pair,\\n        uint256 redeemTokens,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external virtual override ensure(deadline) {\\n        address collateral = getCollateral(uniswapV2Pair);\\n        uint256 exchangeRate = ICollateral(collateral).exchangeRate();\\n        require(redeemTokens > 0, \\\"TarotRouter: REDEEM_ZERO\\\");\\n        uint256 redeemAmount = (redeemTokens - 1).mul(exchangeRate).div(1e18);\\n        _permit(collateral, redeemTokens, deadline, permitData);\\n        bytes memory redeemData = abi.encode(\\n            CalleeData({\\n                callType: CallType.REMOVE_LIQ_AND_REPAY,\\n                uniswapV2Pair: uniswapV2Pair,\\n                borrowableIndex: 0,\\n                data: abi.encode(\\n                    RemoveLiqAndRepayCalldata({\\n                        borrower: msg.sender,\\n                        redeemTokens: redeemTokens,\\n                        redeemAmount: redeemAmount,\\n                        amountAMin: amountAMin,\\n                        amountBMin: amountBMin\\n                    })\\n                )\\n            })\\n        );\\n        // flashRedeem\\n        ICollateral(collateral).flashRedeem(\\n            address(this),\\n            redeemAmount,\\n            redeemData\\n        );\\n    }\\n\\n    function _removeLiqAndRepay(\\n        address uniswapV2Pair,\\n        address borrower,\\n        uint256 redeemTokens,\\n        uint256 redeemAmount,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) internal virtual {\\n        (\\n            address collateral,\\n            address borrowableA,\\n            address borrowableB\\n        ) = getLendingPool(uniswapV2Pair);\\n        address tokenA = IBorrowable(borrowableA).underlying();\\n        address tokenB = IBorrowable(borrowableB).underlying();\\n        // removeLiquidity\\n        TransferHelper.safeTransfer(uniswapV2Pair, uniswapV2Pair, redeemAmount);\\n        (uint256 amountAMax, uint256 amountBMax) = IUniswapV2Pair(uniswapV2Pair)\\n        .burn(address(this));\\n        require(amountAMax >= amountAMin, \\\"TarotRouter: INSUFFICIENT_A_AMOUNT\\\");\\n        require(amountBMax >= amountBMin, \\\"TarotRouter: INSUFFICIENT_B_AMOUNT\\\");\\n        // repay and refund\\n        _repayAndRefund(borrowableA, tokenA, borrower, amountAMax);\\n        _repayAndRefund(borrowableB, tokenB, borrower, amountBMax);\\n        // repay flash redeem\\n        ICollateral(collateral).transferFrom(\\n            borrower,\\n            collateral,\\n            redeemTokens\\n        );\\n    }\\n\\n    function _repayAndRefund(\\n        address borrowable,\\n        address token,\\n        address borrower,\\n        uint256 amountMax\\n    ) internal virtual {\\n        //repay\\n        uint256 amount = _repayAmount(borrowable, amountMax, borrower);\\n        TransferHelper.safeTransfer(token, borrowable, amount);\\n        IBorrowable(borrowable).borrow(borrower, address(0), 0, new bytes(0));\\n        // refund excess\\n        if (amountMax > amount) {\\n            uint256 refundAmount = amountMax - amount;\\n            if (token == WETH) {\\n                IWETH(WETH).withdraw(refundAmount);\\n                TransferHelper.safeTransferETH(borrower, refundAmount);\\n            } else TransferHelper.safeTransfer(token, borrower, refundAmount);\\n        }\\n    }\\n\\n    /*** Tarot Callee ***/\\n\\n    enum CallType {\\n        ADD_LIQUIDITY_AND_MINT,\\n        BORROWB,\\n        REMOVE_LIQ_AND_REPAY\\n    }\\n    struct CalleeData {\\n        CallType callType;\\n        address uniswapV2Pair;\\n        uint8 borrowableIndex;\\n        bytes data;\\n    }\\n    struct AddLiquidityAndMintCalldata {\\n        uint256 amountA;\\n        uint256 amountB;\\n        address to;\\n    }\\n    struct BorrowBCalldata {\\n        address borrower;\\n        address receiver;\\n        uint256 borrowAmount;\\n        bytes data;\\n    }\\n    struct RemoveLiqAndRepayCalldata {\\n        address borrower;\\n        uint256 redeemTokens;\\n        uint256 redeemAmount;\\n        uint256 amountAMin;\\n        uint256 amountBMin;\\n    }\\n\\n    function tarotBorrow(\\n        address sender,\\n        address borrower,\\n        uint256 borrowAmount,\\n        bytes calldata data\\n    ) external virtual override {\\n        borrower;\\n        borrowAmount;\\n        CalleeData memory calleeData = abi.decode(data, (CalleeData));\\n        address declaredCaller = getBorrowable(\\n            calleeData.uniswapV2Pair,\\n            calleeData.borrowableIndex\\n        );\\n        // only succeeds if called by a borrowable and if that borrowable has been called by the router\\n        require(sender == address(this), \\\"TarotRouter: SENDER_NOT_ROUTER\\\");\\n        require(\\n            msg.sender == declaredCaller,\\n            \\\"TarotRouter: UNAUTHORIZED_CALLER\\\"\\n        );\\n        if (calleeData.callType == CallType.ADD_LIQUIDITY_AND_MINT) {\\n            AddLiquidityAndMintCalldata memory d = abi.decode(\\n                calleeData.data,\\n                (AddLiquidityAndMintCalldata)\\n            );\\n            _addLiquidityAndMint(\\n                calleeData.uniswapV2Pair,\\n                d.amountA,\\n                d.amountB,\\n                d.to\\n            );\\n        } else if (calleeData.callType == CallType.BORROWB) {\\n            BorrowBCalldata memory d = abi.decode(\\n                calleeData.data,\\n                (BorrowBCalldata)\\n            );\\n            address borrowableB = getBorrowable(calleeData.uniswapV2Pair, 1);\\n            IBorrowable(borrowableB).borrow(\\n                d.borrower,\\n                d.receiver,\\n                d.borrowAmount,\\n                d.data\\n            );\\n        } else revert();\\n    }\\n\\n    function tarotRedeem(\\n        address sender,\\n        uint256 redeemAmount,\\n        bytes calldata data\\n    ) external virtual override {\\n        redeemAmount;\\n        CalleeData memory calleeData = abi.decode(data, (CalleeData));\\n        address declaredCaller = getCollateral(calleeData.uniswapV2Pair);\\n        // only succeeds if called by a collateral and if that collateral has been called by the router\\n        require(sender == address(this), \\\"TarotRouter: SENDER_NOT_ROUTER\\\");\\n        require(\\n            msg.sender == declaredCaller,\\n            \\\"TarotRouter: UNAUTHORIZED_CALLER\\\"\\n        );\\n        if (calleeData.callType == CallType.REMOVE_LIQ_AND_REPAY) {\\n            RemoveLiqAndRepayCalldata memory d = abi.decode(\\n                calleeData.data,\\n                (RemoveLiqAndRepayCalldata)\\n            );\\n            _removeLiqAndRepay(\\n                calleeData.uniswapV2Pair,\\n                d.borrower,\\n                d.redeemTokens,\\n                d.redeemAmount,\\n                d.amountAMin,\\n                d.amountBMin\\n            );\\n        } else revert();\\n    }\\n\\n    /*** Utilities ***/\\n\\n    function _permit(\\n        address poolToken,\\n        uint256 amount,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) internal virtual {\\n        if (permitData.length == 0) return;\\n        (bool approveMax, uint8 v, bytes32 r, bytes32 s) = abi.decode(\\n            permitData,\\n            (bool, uint8, bytes32, bytes32)\\n        );\\n        uint256 value = approveMax ? uint256(-1) : amount;\\n        IPoolToken(poolToken).permit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s\\n        );\\n    }\\n\\n    function _borrowPermit(\\n        address borrowable,\\n        uint256 amount,\\n        uint256 deadline,\\n        bytes memory permitData\\n    ) internal virtual {\\n        if (permitData.length == 0) return;\\n        (bool approveMax, uint8 v, bytes32 r, bytes32 s) = abi.decode(\\n            permitData,\\n            (bool, uint8, bytes32, bytes32)\\n        );\\n        uint256 value = approveMax ? uint256(-1) : amount;\\n        IBorrowable(borrowable).borrowPermit(\\n            msg.sender,\\n            address(this),\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s\\n        );\\n    }\\n\\n    function _optimalLiquidity(\\n        address uniswapV2Pair,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) public view virtual returns (uint256 amountA, uint256 amountB) {\\n        (uint256 reserveA, uint256 reserveB, ) = IUniswapV2Pair(uniswapV2Pair)\\n        .getReserves();\\n        uint256 amountBOptimal = _quote(amountADesired, reserveA, reserveB);\\n        if (amountBOptimal <= amountBDesired) {\\n            require(\\n                amountBOptimal >= amountBMin,\\n                \\\"TarotRouter: INSUFFICIENT_B_AMOUNT\\\"\\n            );\\n            (amountA, amountB) = (amountADesired, amountBOptimal);\\n        } else {\\n            uint256 amountAOptimal = _quote(amountBDesired, reserveB, reserveA);\\n            assert(amountAOptimal <= amountADesired);\\n            require(\\n                amountAOptimal >= amountAMin,\\n                \\\"TarotRouter: INSUFFICIENT_A_AMOUNT\\\"\\n            );\\n            (amountA, amountB) = (amountAOptimal, amountBDesired);\\n        }\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function _quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(amountA > 0, \\\"TarotRouter: INSUFFICIENT_AMOUNT\\\");\\n        require(\\n            reserveA > 0 && reserveB > 0,\\n            \\\"TarotRouter: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    function getBorrowable(address uniswapV2Pair, uint8 index)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address borrowable)\\n    {\\n        require(index < 2, \\\"TarotRouter: INDEX_TOO_HIGH\\\");\\n        borrowable = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\\"ff\\\",\\n                        bDeployer,\\n                        keccak256(\\n                            abi.encodePacked(factory, uniswapV2Pair, index)\\n                        ),\\n                        hex\\\"721ca65ff8c327d91c0cbfff6b09c0d4a60a2cdc400730bda4582a6adc1447e5\\\" // Borrowable bytecode keccak256\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function getCollateral(address uniswapV2Pair)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address collateral)\\n    {\\n        collateral = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\\"ff\\\",\\n                        cDeployer,\\n                        keccak256(abi.encodePacked(factory, uniswapV2Pair)),\\n                        hex\\\"326662b4eab5ef52fa98ce27b557770bbf166e66fe2b9c9877b907cca7504017\\\" // Collateral bytecode keccak256\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function getLendingPool(address uniswapV2Pair)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (\\n            address collateral,\\n            address borrowableA,\\n            address borrowableB\\n        )\\n    {\\n        collateral = getCollateral(uniswapV2Pair);\\n        borrowableA = getBorrowable(uniswapV2Pair, 0);\\n        borrowableB = getBorrowable(uniswapV2Pair, 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRouter01.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IRouter01 {\\n    function factory() external pure returns (address);\\n\\n    function bDeployer() external pure returns (address);\\n\\n    function cDeployer() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function mint(\\n        address poolToken,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 tokens);\\n\\n    function mintETH(\\n        address poolToken,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 tokens);\\n\\n    function mintCollateral(\\n        address poolToken,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external returns (uint256 tokens);\\n\\n    function redeem(\\n        address poolToken,\\n        uint256 tokens,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external returns (uint256 amount);\\n\\n    function redeemETH(\\n        address poolToken,\\n        uint256 tokens,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external returns (uint256 amountETH);\\n\\n    function borrow(\\n        address borrowable,\\n        uint256 amount,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external;\\n\\n    function borrowETH(\\n        address borrowable,\\n        uint256 amountETH,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external;\\n\\n    function repay(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline\\n    ) external returns (uint256 amount);\\n\\n    function repayETH(\\n        address borrowable,\\n        address borrower,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountETH);\\n\\n    function liquidate(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amount, uint256 seizeTokens);\\n\\n    function liquidateETH(\\n        address borrowable,\\n        address borrower,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountETH, uint256 seizeTokens);\\n\\n    function leverage(\\n        address uniswapV2Pair,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bytes calldata permitDataA,\\n        bytes calldata permitDataB\\n    ) external;\\n\\n    function deleverage(\\n        address uniswapV2Pair,\\n        uint256 redeemTokens,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external;\\n\\n    function getBorrowable(address uniswapV2Pair, uint8 index)\\n        external\\n        view\\n        returns (address borrowable);\\n\\n    function getCollateral(address uniswapV2Pair)\\n        external\\n        view\\n        returns (address collateral);\\n\\n    function getLendingPool(address uniswapV2Pair)\\n        external\\n        view\\n        returns (\\n            address collateral,\\n            address borrowableA,\\n            address borrowableB\\n        );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bDeployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cDeployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniswapV2Pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"}],\"name\":\"_optimalLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"borrowETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"deleverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getBorrowable\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getCollateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getLendingPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrowableA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrowableB\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getUniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"isVaultToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitDataA\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"permitDataB\",\"type\":\"bytes\"}],\"name\":\"leverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"liquidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"liquidateETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"mintCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"mintETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"redeemETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"repayETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tarotBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tarotRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Router03","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004b6dae049a35196a773028b2e835cccce9dd4723000000000000000000000000b092e1bf50f518b3ebf7ed26a40015183ae36ac2000000000000000000000000b3f352c936ce9c29c40d8befae9caebbcc0b6252000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]