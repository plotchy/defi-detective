[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"BadgerRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity =0.8.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"EnumerableSet.sol\\\";\\n\\ncontract BadgerRegistry {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  /// @dev is the vault at the experimental, guarded, open or deprecated stage? Only for Prod Vaults\\n  enum VaultStatus {\\n    deprecated,\\n    experimental,\\n    guarded,\\n    open\\n  }\\n\\n  uint256 public constant VAULT_STATUS_LENGTH = 4;\\n\\n  struct VaultInfo {\\n    address vault;\\n    string version;\\n    VaultStatus status;\\n    string metadata;\\n  }\\n\\n  struct VaultMetadata {\\n    address vault;\\n    string metadata;\\n  }\\n\\n  struct VaultData {\\n    string version;\\n    VaultStatus status;\\n    VaultMetadata[] list;\\n  }\\n\\n  /// @dev Multisig. Vaults from here are considered Production ready\\n  address public governance;\\n  address public developer; //@notice an address with some powers to make things easier in development\\n  address public strategistGuild;\\n\\n  /// @dev Given an Author Address, and Version, Return the Vault\\n  mapping(address => mapping(string => EnumerableSet.AddressSet)) private vaults;\\n\\n  /// @dev Given an Author Address, and Vault Address, Return the VaultInfo\\n  mapping(address => mapping(address => VaultInfo)) public vaultInfoByAuthorAndVault;\\n\\n  mapping(string => address) public addresses;\\n  mapping(address => string) public keyByAddress;\\n\\n  /// @dev Given Version and VaultStatus, returns the list of Vaults in production\\n  mapping(string => mapping(VaultStatus => EnumerableSet.AddressSet)) private productionVaults;\\n\\n  /// @dev Given Vault Address, returns the VaultInfo in production\\n  mapping(address => VaultInfo) public productionVaultInfoByVault;\\n\\n  // Known constants you can use\\n  string[] public keys; //@notice, you don't have a guarantee of the key being there, it's just a utility\\n  string[] public versions; //@notice, you don't have a guarantee of the key being there, it's just a utility\\n\\n  event NewVault(address author, string version, string metadata, address vault);\\n  event RemoveVault(address author, string version, string metadata, address vault);\\n  event PromoteVault(address author, string version, string metadata, address vault, VaultStatus status);\\n  event DemoteVault(address author, string version, string metadata, address vault, VaultStatus status);\\n  event PurgeVault(address author, string version, string metadata, address vault, VaultStatus status);\\n\\n  event Set(string key, address at);\\n  event AddKey(string key);\\n  event DeleteKey(string key);\\n  event AddVersion(string version);\\n\\n  function initialize(address newGovernance, address newStrategistGuild) public {\\n    require(governance == address(0));\\n    governance = newGovernance;\\n    strategistGuild = newStrategistGuild;\\n    developer = address(0);\\n\\n    versions.push(\\\"v1\\\"); //For v1\\n    versions.push(\\\"v1.5\\\"); //For v1.5\\n    versions.push(\\\"v2\\\"); //For v2\\n  }\\n\\n  /// @dev Setter for Governance the highest level of admin control\\n  function setGovernance(address _newGov) public {\\n    require(msg.sender == governance, \\\"!gov\\\");\\n    governance = _newGov;\\n  }\\n\\n  /// @dev Setter for developer, a fast EOA that can demote and only promote to experimental\\n  function setDeveloper(address newDev) public {\\n    require(msg.sender == governance || msg.sender == developer, \\\"!gov\\\");\\n    developer = newDev;\\n  }\\n\\n  /// @dev Setter for StrategistGuild a Multi that can do pretty much as much as governance\\n  function setStrategistGuild(address newStrategistGuild) public {\\n    require(msg.sender == governance, \\\"!gov\\\");\\n    strategistGuild = newStrategistGuild;\\n  }\\n\\n  /// @dev Utility function to add Versions for Vaults,\\n  //@notice No guarantee that it will be properly used\\n  function addVersions(string memory version) public {\\n    require(msg.sender == governance, \\\"!gov\\\");\\n    versions.push(version);\\n\\n    emit AddVersion(version);\\n  }\\n\\n  /// @dev Add a vault, under the msg.sender key\\n  /// @notice Anyone can add a vault to here, it will be indexed by their address\\n  function add(\\n    address vault,\\n    string memory version,\\n    string memory metadata\\n  ) public {\\n    verifyMetadata(metadata);\\n    VaultInfo memory existedVaultInfo = vaultInfoByAuthorAndVault[msg.sender][vault];\\n    if (existedVaultInfo.vault != address(0)) {\\n      require(\\n        // Compare strings via their hash because solidity\\n        vault == existedVaultInfo.vault &&\\n          keccak256(bytes(version)) == keccak256(bytes(existedVaultInfo.version)) &&\\n          keccak256(bytes(metadata)) == keccak256(bytes(existedVaultInfo.metadata)),\\n        \\\"BadgerRegistry: vault info changed. Please remove before add changed vault info\\\"\\n      );\\n      // Same vault cannot be added twice (nothing happens)\\n      return;\\n    }\\n\\n    // Vault status start as experimental, this aids in promotion / demotion invariants\\n    vaultInfoByAuthorAndVault[msg.sender][vault] = VaultInfo({\\n      vault: vault,\\n      version: version,\\n      status: VaultStatus(1),\\n      metadata: metadata\\n    });\\n\\n    vaults[msg.sender][version].add(vault);\\n    emit NewVault(msg.sender, version, metadata, vault);\\n  }\\n\\n  /// @dev Remove the vault from your index\\n  function remove(address vault) public {\\n    VaultInfo memory existedVaultInfo = vaultInfoByAuthorAndVault[msg.sender][vault];\\n    if (existedVaultInfo.vault == address(0)) {\\n      return;\\n    }\\n    delete vaultInfoByAuthorAndVault[msg.sender][vault];\\n    bool removedFromVersionSet = vaults[msg.sender][existedVaultInfo.version].remove(vault);\\n    if (removedFromVersionSet) {\\n      emit RemoveVault(msg.sender, existedVaultInfo.version, existedVaultInfo.metadata, vault);\\n    }\\n  }\\n\\n  /// @dev Promote a vault to Production\\n  /// @notice Promote just means indexed by the Governance Address\\n  /// @notice developer can only promote up to experimental\\n  function promote(\\n    address vault,\\n    string memory version,\\n    string memory metadata,\\n    VaultStatus status\\n  ) public {\\n    require(msg.sender == governance || msg.sender == strategistGuild || msg.sender == developer, \\\"!auth\\\");\\n    verifyMetadata(metadata);\\n\\n    VaultStatus actualStatus = status;\\n    if (msg.sender == developer) {\\n      // Developer can only bump up to experimental\\n      actualStatus = VaultStatus.experimental;\\n    }\\n\\n    VaultInfo memory existedVaultInfo = productionVaultInfoByVault[vault];\\n    if (existedVaultInfo.vault != address(0)) {\\n      require(\\n        // Compare strings via their hash because solidity\\n        vault == existedVaultInfo.vault && keccak256(bytes(version)) == keccak256(bytes(existedVaultInfo.version)),\\n        \\\"BadgerRegistry: vault info changed. Please demote before promote changed vault info\\\"\\n      );\\n      productionVaultInfoByVault[vault].status = actualStatus;\\n    } else {\\n      productionVaultInfoByVault[vault] = VaultInfo({\\n        vault: vault,\\n        version: version,\\n        status: actualStatus,\\n        metadata: metadata\\n      });\\n    }\\n    require(uint256(actualStatus) >= uint256(existedVaultInfo.status), \\\"BadgerRegistry: Vault is not being promoted\\\");\\n\\n    bool addedToVersionStatusSet = productionVaults[version][actualStatus].add(vault);\\n    // If addedToVersionStatusSet remove from old and emit event\\n    if (addedToVersionStatusSet) {\\n      // also remove from old prod\\n      if (uint256(actualStatus) > 0) {\\n        for (uint256 status_ = uint256(actualStatus); status_ > 0; --status_) {\\n          productionVaults[version][VaultStatus(status_ - 1)].remove(vault);\\n        }\\n      }\\n\\n      emit PromoteVault(msg.sender, version, metadata, vault, actualStatus);\\n    }\\n  }\\n\\n  /// @dev Demotes the vault to a lower status\\n  /// @notice all roles can demote\\n  function demote(address vault, VaultStatus status) public {\\n    require(msg.sender == governance || msg.sender == strategistGuild || msg.sender == developer, \\\"!auth\\\");\\n\\n    VaultStatus actualStatus = status;\\n\\n    VaultInfo memory existedVaultInfo = productionVaultInfoByVault[vault];\\n    require(existedVaultInfo.vault != address(0), \\\"BadgerRegistry: Vault does not exist\\\");\\n    // Value should be allowed to be equal to allow for promotion of vaults to experimental status as prod vaults\\n    require(uint256(actualStatus) < uint256(existedVaultInfo.status), \\\"BadgerRegistry: Vault is not being demoted\\\");\\n\\n    productionVaults[existedVaultInfo.version][existedVaultInfo.status].remove(vault);\\n    productionVaultInfoByVault[vault].status = status;\\n    emit DemoteVault(msg.sender, existedVaultInfo.version, existedVaultInfo.metadata, vault, status);\\n    productionVaults[existedVaultInfo.version][status].add(vault);\\n  }\\n\\n  function purge(address vault) public {\\n    require(msg.sender == governance || msg.sender == strategistGuild, \\\"!auth\\\");\\n\\n    VaultInfo memory existedVaultInfo = productionVaultInfoByVault[vault];\\n    require(existedVaultInfo.vault != address(0), \\\"BadgerRegistry: Vault does not exist\\\");\\n\\n    bool removedFromVersionStatusSet = productionVaults[existedVaultInfo.version][existedVaultInfo.status].remove(\\n      vault\\n    );\\n    bool deletedFromVaultInfoByVault = productionVaultInfoByVault[vault].vault != address(0);\\n    if (removedFromVersionStatusSet || deletedFromVaultInfoByVault) {\\n      delete productionVaultInfoByVault[vault];\\n      emit PurgeVault(msg.sender, existedVaultInfo.version, existedVaultInfo.metadata, vault, existedVaultInfo.status);\\n    }\\n  }\\n\\n  /// @notice Metadata may need to be updated in the case of a vault upgrade (e.g. curve -> convex)\\n  /// @dev Update a vault metadata\\n  /// @param vault Vault address\\n  function updateMetadata(address vault, string memory metadata) public {\\n    require(msg.sender == governance || msg.sender == strategistGuild, \\\"!auth\\\");\\n    verifyMetadata(metadata);\\n\\n    require(productionVaultInfoByVault[vault].vault != address(0), \\\"BadgerRegistry: Vault does not exist\\\");\\n\\n    productionVaultInfoByVault[vault].metadata = metadata;\\n  }\\n\\n  /** KEY Management */\\n\\n  /// @dev Set the value of a key to a specific address\\n  //@notice e.g. controller = 0x123123\\n  function set(string memory key, address at) public {\\n    require(msg.sender == governance, \\\"!gov\\\");\\n    _addKey(key);\\n    addresses[key] = at;\\n    keyByAddress[at] = key;\\n    emit Set(key, at);\\n  }\\n\\n  /// @dev Delete a key\\n  function deleteKey(string memory key) external {\\n    require(msg.sender == governance, \\\"!gov\\\");\\n    _deleteKey(key);\\n  }\\n\\n  function _deleteKey(string memory key) private {\\n    address at = addresses[key];\\n    delete keyByAddress[at];\\n\\n    for (uint256 x = 0; x < keys.length; x++) {\\n      // Compare strings via their hash because solidity\\n      if (keccak256(bytes(key)) == keccak256(bytes(keys[x]))) {\\n        delete addresses[key];\\n        keys[x] = keys[keys.length - 1];\\n        keys.pop();\\n        emit DeleteKey(key);\\n        return;\\n      }\\n    }\\n  }\\n\\n  /// @dev Delete keys\\n  function deleteKeys(string[] memory _keys) external {\\n    require(msg.sender == governance, \\\"!gov\\\");\\n\\n    uint256 length = _keys.length;\\n    for (uint256 x = 0; x < length; ++x) {\\n      _deleteKey(_keys[x]);\\n    }\\n  }\\n\\n  /// @dev Retrieve the value of a key\\n  function get(string memory key) public view returns (address) {\\n    return addresses[key];\\n  }\\n\\n  /// @dev Get keys count\\n  function keysCount() public view returns (uint256) {\\n    return keys.length;\\n  }\\n\\n  /// @dev Add a key to the list of keys\\n  //@notice This is used to make it easier to discover keys,\\n  //@notice however you have no guarantee that all keys will be in the list\\n  function _addKey(string memory key) internal {\\n    //If we find the key, skip\\n    for (uint256 x = 0; x < keys.length; x++) {\\n      // Compare strings via their hash because solidity\\n      if (keccak256(bytes(key)) == keccak256(bytes(keys[x]))) {\\n        return;\\n      }\\n    }\\n\\n    // Else let's add it and emit the event\\n    keys.push(key);\\n\\n    emit AddKey(key);\\n  }\\n\\n  /// @dev Retrieve a list of all Vaults from the given author and version\\n  function getVaults(string memory version, address author) public view returns (VaultInfo[] memory) {\\n    uint256 length = vaults[author][version].length();\\n\\n    VaultInfo[] memory list = new VaultInfo[](length);\\n    for (uint256 i = 0; i < length; i++) {\\n      list[i] = vaultInfoByAuthorAndVault[author][vaults[author][version].at(i)];\\n    }\\n    return list;\\n  }\\n\\n  /// @dev Retrieve a list of all Vaults that are in production, based on Version and Status\\n  function getFilteredProductionVaults(string memory version, VaultStatus status)\\n    public\\n    view\\n    returns (VaultInfo[] memory)\\n  {\\n    uint256 length = productionVaults[version][status].length();\\n\\n    VaultInfo[] memory list = new VaultInfo[](length);\\n    for (uint256 i = 0; i < length; i++) {\\n      list[i] = productionVaultInfoByVault[productionVaults[version][status].at(i)];\\n    }\\n    return list;\\n  }\\n\\n  /// @dev Given the list of versions, fetches all production vaults\\n  function getProductionVaults() public view returns (VaultData[] memory) {\\n    uint256 versionsCount = versions.length;\\n\\n    VaultData[] memory data = new VaultData[](versionsCount * VAULT_STATUS_LENGTH);\\n\\n    for (uint256 x = 0; x < versionsCount; x++) {\\n      for (uint256 y = 0; y < VAULT_STATUS_LENGTH; y++) {\\n        uint256 length = productionVaults[versions[x]][VaultStatus(y)].length();\\n        VaultMetadata[] memory list = new VaultMetadata[](length);\\n        for (uint256 z = 0; z < length; z++) {\\n          VaultInfo storage vaultInfo = productionVaultInfoByVault[productionVaults[versions[x]][VaultStatus(y)].at(z)];\\n          list[z] = VaultMetadata({vault: vaultInfo.vault, metadata: vaultInfo.metadata});\\n        }\\n        data[x * VAULT_STATUS_LENGTH + y] = VaultData({version: versions[x], status: VaultStatus(y), list: list});\\n      }\\n    }\\n\\n    return data;\\n  }\\n\\n  /// @notice Metadata is used for offchain naming and information display of vaults\\n  /// @dev Metadata expected format: name=MyVault,protocol=Badger,behavior=DCA\\n  function verifyMetadata(string memory metadata) private pure {\\n    bytes memory metadataBytes = bytes(metadata);\\n    uint256 nameIndex;\\n    uint256 protocolIndex;\\n    uint256 behaviorIndex;\\n    for (uint256 i = 0; i < metadataBytes.length; i++) {\\n      if (metadataBytes[i] == 0x3d) {\\n        // \\\"=\\\"\\n        if (nameIndex == 0) {\\n          nameIndex = i;\\n        } else if (protocolIndex == 0) {\\n          protocolIndex = i;\\n        } else if (behaviorIndex == 0) {\\n          behaviorIndex = i;\\n          break;\\n        }\\n      }\\n    }\\n    require(nameIndex > 0, \\\"BadgerRegistry: Invalid Name\\\");\\n    require(protocolIndex > 0, \\\"BadgerRegistry: Invalid Protocol\\\");\\n    require(behaviorIndex > 0, \\\"BadgerRegistry: Invalid Behavior\\\");\\n    // offsets on indices are to backtrack to start of expected delimiter\\n    require(keccak256(getSlice(metadataBytes, 0, nameIndex - 1)) == keccak256(\\\"name\\\"), \\\"BadgerRegistry: Invalid Name\\\");\\n    require(\\n      keccak256(getSlice(metadataBytes, protocolIndex - 8, protocolIndex - 1)) == keccak256(\\\"protocol\\\"),\\n      \\\"BadgerRegistry: Invalid Protocol\\\"\\n    );\\n    require(\\n      keccak256(getSlice(metadataBytes, behaviorIndex - 8, behaviorIndex - 1)) == keccak256(\\\"behavior\\\"),\\n      \\\"BadgerRegistry: Invalid Behavior\\\"\\n    );\\n  }\\n\\n  // https://ethereum.stackexchange.com/questions/78559/how-can-i-slice-bytes-strings-and-arrays-in-solidity\\n  function getSlice(\\n    bytes memory text,\\n    uint256 begin,\\n    uint256 end\\n  ) private pure returns (bytes memory) {\\n    bytes memory a = new bytes(end - begin + 1);\\n    for (uint256 i = begin; i <= end; i++) {\\n      a[i - begin] = text[i];\\n    }\\n    return a;\\n  }\\n}\\n\"\r\n    },\r\n    \"EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"BadgerRegistry.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"AddKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"AddVersion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"DeleteKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"DemoteVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"NewVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"PromoteVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"PurgeVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"RemoveVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"at\",\"type\":\"address\"}],\"name\":\"Set\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VAULT_STATUS_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"addVersions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"deleteKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_keys\",\"type\":\"string[]\"}],\"name\":\"deleteKeys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"demote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"getFilteredProductionVaults\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"internalType\":\"struct BadgerRegistry.VaultInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProductionVaults\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"internalType\":\"struct BadgerRegistry.VaultMetadata[]\",\"name\":\"list\",\"type\":\"tuple[]\"}],\"internalType\":\"struct BadgerRegistry.VaultData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"}],\"name\":\"getVaults\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"internalType\":\"struct BadgerRegistry.VaultInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newStrategistGuild\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"keyByAddress\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"keys\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keysCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"productionVaultInfoByVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"},{\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"promote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"purge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"at\",\"type\":\"address\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDev\",\"type\":\"address\"}],\"name\":\"setDeveloper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGov\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStrategistGuild\",\"type\":\"address\"}],\"name\":\"setStrategistGuild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategistGuild\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"updateMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaultInfoByAuthorAndVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"versions\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BadgerRegistry","CompilerVersion":"v0.8.11+commit.d7f03943","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]