[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/ParsecReferralTracking.sol\r\n\r\ncontract ParsecReferralTracking {\r\n  mapping (address => address) public referrer;\r\n\r\n  event ReferrerUpdated(address indexed _referee, address indexed _referrer);\r\n\r\n  function _updateReferrerFor(address _referee, address _referrer) internal {\r\n    if (_referrer != address(0) && _referrer != _referee) {\r\n      referrer[_referee] = _referrer;\r\n      emit ReferrerUpdated(_referee, _referrer);\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/ParsecShipInfo.sol\r\n\r\ncontract ParsecShipInfo {\r\n  uint256 public constant TOTAL_SHIP = 900;\r\n  uint256 public constant TOTAL_ARK = 100;\r\n  uint256 public constant TOTAL_HAWKING = 400;\r\n  uint256 public constant TOTAL_SATOSHI = 400;\r\n\r\n  uint256 public constant NAME_NOT_AVAILABLE = 0;\r\n  uint256 public constant NAME_ARK = 1;\r\n  uint256 public constant NAME_HAWKING = 2;\r\n  uint256 public constant NAME_SATOSHI = 3;\r\n\r\n  uint256 public constant TYPE_NOT_AVAILABLE = 0;\r\n  uint256 public constant TYPE_EXPLORER_FREIGHTER = 1;\r\n  uint256 public constant TYPE_EXPLORER = 2;\r\n  uint256 public constant TYPE_FREIGHTER = 3;\r\n\r\n  uint256 public constant COLOR_NOT_AVAILABLE = 0;\r\n  uint256 public constant COLOR_CUSTOM = 1;\r\n  uint256 public constant COLOR_BLACK = 2;\r\n  uint256 public constant COLOR_BLUE = 3;\r\n  uint256 public constant COLOR_BROWN = 4;\r\n  uint256 public constant COLOR_GOLD = 5;\r\n  uint256 public constant COLOR_GREEN = 6;\r\n  uint256 public constant COLOR_GREY = 7;\r\n  uint256 public constant COLOR_PINK = 8;\r\n  uint256 public constant COLOR_RED = 9;\r\n  uint256 public constant COLOR_SILVER = 10;\r\n  uint256 public constant COLOR_WHITE = 11;\r\n  uint256 public constant COLOR_YELLOW = 12;\r\n\r\n  function getShip(uint256 _shipId)\r\n    external\r\n    pure\r\n    returns (\r\n      uint256 /* _name */,\r\n      uint256 /* _type */,\r\n      uint256 /* _color */\r\n    )\r\n  {\r\n    return (\r\n      _getShipName(_shipId),\r\n      _getShipType(_shipId),\r\n      _getShipColor(_shipId)\r\n    );\r\n  }\r\n\r\n  function _getShipName(uint256 _shipId) internal pure returns (uint256 /* _name */) {\r\n    if (_shipId < 1) {\r\n      return NAME_NOT_AVAILABLE;\r\n    } else if (_shipId <= TOTAL_ARK) {\r\n      return NAME_ARK;\r\n    } else if (_shipId <= TOTAL_ARK + TOTAL_HAWKING) {\r\n      return NAME_HAWKING;\r\n    } else if (_shipId <= TOTAL_SHIP) {\r\n      return NAME_SATOSHI;\r\n    } else {\r\n      return NAME_NOT_AVAILABLE;\r\n    }\r\n  }\r\n\r\n  function _getShipType(uint256 _shipId) internal pure returns (uint256 /* _type */) {\r\n    if (_shipId < 1) {\r\n      return TYPE_NOT_AVAILABLE;\r\n    } else if (_shipId <= TOTAL_ARK) {\r\n      return TYPE_EXPLORER_FREIGHTER;\r\n    } else if (_shipId <= TOTAL_ARK + TOTAL_HAWKING) {\r\n      return TYPE_EXPLORER;\r\n    } else if (_shipId <= TOTAL_SHIP) {\r\n      return TYPE_FREIGHTER;\r\n    } else {\r\n      return TYPE_NOT_AVAILABLE;\r\n    }\r\n  }\r\n\r\n  function _getShipColor(uint256 _shipId) internal pure returns (uint256 /* _color */) {\r\n    if (_shipId < 1) {\r\n      return COLOR_NOT_AVAILABLE;\r\n    } else if (_shipId == 1) {\r\n      return COLOR_CUSTOM;\r\n    } else if (_shipId <= 23) {\r\n      return COLOR_BLACK;\r\n    } else if (_shipId <= 37) {\r\n      return COLOR_BLUE;\r\n    } else if (_shipId <= 42) {\r\n      return COLOR_BROWN;\r\n    } else if (_shipId <= 45) {\r\n      return COLOR_GOLD;\r\n    } else if (_shipId <= 49) {\r\n      return COLOR_GREEN;\r\n    } else if (_shipId <= 64) {\r\n      return COLOR_GREY;\r\n    } else if (_shipId <= 67) {\r\n      return COLOR_PINK;\r\n    } else if (_shipId <= 77) {\r\n      return COLOR_RED;\r\n    } else if (_shipId <= 83) {\r\n      return COLOR_SILVER;\r\n    } else if (_shipId <= 93) {\r\n      return COLOR_WHITE;\r\n    } else if (_shipId <= 100) {\r\n      return COLOR_YELLOW;\r\n    } else if (_shipId <= 140) {\r\n      return COLOR_BLACK;\r\n    } else if (_shipId <= 200) {\r\n      return COLOR_BLUE;\r\n    } else if (_shipId <= 237) {\r\n      return COLOR_BROWN;\r\n    } else if (_shipId <= 247) {\r\n      return COLOR_GOLD;\r\n    } else if (_shipId <= 330) {\r\n      return COLOR_GREEN;\r\n    } else if (_shipId <= 370) {\r\n      return COLOR_GREY;\r\n    } else if (_shipId <= 380) {\r\n      return COLOR_PINK;\r\n    } else if (_shipId <= 440) {\r\n      return COLOR_RED;\r\n    } else if (_shipId <= 460) {\r\n      return COLOR_SILVER;\r\n    } else if (_shipId <= 500) {\r\n      return COLOR_WHITE;\r\n    } else if (_shipId <= 540) {\r\n      return COLOR_BLACK;\r\n    } else if (_shipId <= 600) {\r\n      return COLOR_BLUE;\r\n    } else if (_shipId <= 637) {\r\n      return COLOR_BROWN;\r\n    } else if (_shipId <= 647) {\r\n      return COLOR_GOLD;\r\n    } else if (_shipId <= 730) {\r\n      return COLOR_GREEN;\r\n    } else if (_shipId <= 770) {\r\n      return COLOR_GREY;\r\n    } else if (_shipId <= 780) {\r\n      return COLOR_PINK;\r\n    } else if (_shipId <= 840) {\r\n      return COLOR_RED;\r\n    } else if (_shipId <= 860) {\r\n      return COLOR_SILVER;\r\n    } else if (_shipId <= TOTAL_SHIP) {\r\n      return COLOR_WHITE;\r\n    } else {\r\n      return COLOR_NOT_AVAILABLE;\r\n    }\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/ParsecShipPricing.sol\r\n\r\ncontract ParsecShipPricing {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public constant TOTAL_PARSEC_CREDIT_SUPPLY = 30856775800000000;\r\n\r\n  // Starting with 30,856,775,800,000,000 (total supply of Parsec Credit, including 6 decimals),\r\n  // each time we multiply the number we have with 0.9995. These are results:\r\n  // 1: 30841347412100000\r\n  // 2: 30825926738393950\r\n  // 4: 30795108518137240.6484875\r\n  // 8: 30733564478368113.80826526098454678\r\n  // 16: 30610845140405444.1555510982248498\r\n  // 32: 30366874565355062.01905741115048326\r\n  // 64: 29884751305352135.55319509943479229\r\n  // 128: 28943346718121670.05118183115407839\r\n  // 256: 27148569399315026.57115329246779589\r\n  // 512: 23885995905943752.64119680273916152\r\n  // 1024: 18489968106737895.55394216521160879\r\n  // 2048: 11079541258752787.70222144092290365\r\n  // 4096: 3978258626243293.616409580784511455\r\n  // 8192: 512903285808596.2996925781077178762\r\n  // 16384: 8525510970373.470528186667481043039\r\n  // 32768: 2355538951.219861249087266462563245\r\n  // 65536: 179.8167049816644768546906209889074\r\n  // 75918: 0.9996399085102312393019871402909541\r\n\r\n  uint256[18] private _multipliers = [\r\n    30841347412100000,\r\n    30825926738393950,\r\n    307951085181372406484875,\r\n    3073356447836811380826526098454678,\r\n    306108451404054441555510982248498,\r\n    3036687456535506201905741115048326,\r\n    2988475130535213555319509943479229,\r\n    2894334671812167005118183115407839,\r\n    2714856939931502657115329246779589,\r\n    2388599590594375264119680273916152,\r\n    1848996810673789555394216521160879,\r\n    1107954125875278770222144092290365,\r\n    3978258626243293616409580784511455,\r\n    5129032858085962996925781077178762,\r\n    8525510970373470528186667481043039,\r\n    2355538951219861249087266462563245,\r\n    1798167049816644768546906209889074\r\n  ];\r\n\r\n  uint256[18] private _decimals = [\r\n    0, 0, 7, 17, 16,\r\n    17, 17, 17, 17, 17,\r\n    17, 17, 18, 19, 21,\r\n    24, 31\r\n  ];\r\n\r\n  function _getShipPrice(\r\n    uint256 _initialPrice,\r\n    uint256 _minutesPassed\r\n  )\r\n    internal\r\n    view\r\n    returns (uint256 /* _price */)\r\n  {\r\n    require(\r\n      _initialPrice <= TOTAL_PARSEC_CREDIT_SUPPLY,\r\n      \"Initial ship price must not be greater than total Parsec Credit.\"\r\n    );\r\n\r\n    if (_minutesPassed >> _multipliers.length > 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 _price = _initialPrice;\r\n\r\n    for (uint256 _powerOfTwo = 0; _powerOfTwo < _multipliers.length; _powerOfTwo++) {\r\n      if (_minutesPassed >> _powerOfTwo & 1 > 0) {\r\n        _price = _price\r\n          .mul(_multipliers[_powerOfTwo])\r\n          .div(TOTAL_PARSEC_CREDIT_SUPPLY)\r\n          .div(10 ** _decimals[_powerOfTwo]);\r\n      }\r\n    }\r\n\r\n    return _price;\r\n  }\r\n}\r\n\r\n// File: contracts/TokenRecipient.sol\r\n\r\ninterface TokenRecipient {\r\n  function receiveApproval(\r\n    address _from,\r\n    uint256 _value,\r\n    address _token,\r\n    bytes _extraData\r\n  )\r\n    external;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() public view returns (string _name);\r\n  function symbol() public view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Receiver.sol\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n   *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n   *  than the magic value MUST result in the transaction being reverted.\r\n   *  Note: the contract address is always the message sender.\r\n   * @param _from The sending address\r\n   * @param _tokenId The NFT identifier which is being transfered\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721BasicToken.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721BasicToken is ERC721Basic {\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  // Mapping from token ID to owner\r\n  mapping (uint256 => address) internal tokenOwner;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) internal tokenApprovals;\r\n\r\n  // Mapping from owner to number of owned token\r\n  mapping (address => uint256) internal ownedTokensCount;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n  /**\r\n   * @dev Guarantees msg.sender is owner of the given token\r\n   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n   */\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(ownerOf(_tokenId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n   * @param _tokenId uint256 ID of the token to validate\r\n   */\r\n  modifier canTransfer(uint256 _tokenId) {\r\n    require(isApprovedOrOwner(msg.sender, _tokenId));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the balance of the specified address\r\n   * @param _owner address to query the balance of\r\n   * @return uint256 representing the amount owned by the passed address\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    require(_owner != address(0));\r\n    return ownedTokensCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the owner of the specified token ID\r\n   * @param _tokenId uint256 ID of the token to query the owner of\r\n   * @return owner address currently marked as the owner of the given token ID\r\n   */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address owner = tokenOwner[_tokenId];\r\n    require(owner != address(0));\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the specified token exists\r\n   * @param _tokenId uint256 ID of the token to query the existance of\r\n   * @return whether the token exists\r\n   */\r\n  function exists(uint256 _tokenId) public view returns (bool) {\r\n    address owner = tokenOwner[_tokenId];\r\n    return owner != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Approves another address to transfer the given token ID\r\n   * @dev The zero address indicates there is no approved address.\r\n   * @dev There can only be one approved address per token at a given time.\r\n   * @dev Can only be called by the token owner or an approved operator.\r\n   * @param _to address to be approved for the given token ID\r\n   * @param _tokenId uint256 ID of the token to be approved\r\n   */\r\n  function approve(address _to, uint256 _tokenId) public {\r\n    address owner = ownerOf(_tokenId);\r\n    require(_to != owner);\r\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\r\n      tokenApprovals[_tokenId] = _to;\r\n      emit Approval(owner, _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the approved address for a token ID, or zero if no address set\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved for a the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Sets or unsets the approval of a given operator\r\n   * @dev An operator is allowed to transfer all tokens of the sender on their behalf\r\n   * @param _to operator address to set the approval\r\n   * @param _approved representing the status of the approval to be set\r\n   */\r\n  function setApprovalForAll(address _to, bool _approved) public {\r\n    require(_to != msg.sender);\r\n    operatorApprovals[msg.sender][_to] = _approved;\r\n    emit ApprovalForAll(msg.sender, _to, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Tells whether an operator is approved by a given owner\r\n   * @param _owner owner address which you want to query the approval of\r\n   * @param _operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n    return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of a given token ID to another address\r\n   * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\r\n    require(_from != address(0));\r\n    require(_to != address(0));\r\n\r\n    clearApproval(_from, _tokenId);\r\n    removeTokenFrom(_from, _tokenId);\r\n    addTokenTo(_to, _tokenId);\r\n\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n   *  which is called upon a safe transfer, and return the magic value\r\n   *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n   *  the transfer is reverted.\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n    canTransfer(_tokenId)\r\n  {\r\n    // solium-disable-next-line arg-overflow\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n   *  which is called upon a safe transfer, and return the magic value\r\n   *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n   *  the transfer is reverted.\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes data to send along with a safe transfer check\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    canTransfer(_tokenId)\r\n  {\r\n    transferFrom(_from, _to, _tokenId);\r\n    // solium-disable-next-line arg-overflow\r\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the given spender can transfer a given token ID\r\n   * @param _spender address of the spender to query\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @return bool whether the msg.sender is approved for the given token ID,\r\n   *  is an operator of the owner, or is the owner of the token\r\n   */\r\n  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\r\n    address owner = ownerOf(_tokenId);\r\n    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * @dev Reverts if the given token ID already exists\r\n   * @param _to The address that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    addTokenTo(_to, _tokenId);\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * @dev Reverts if the token does not exist\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address _owner, uint256 _tokenId) internal {\r\n    clearApproval(_owner, _tokenId);\r\n    removeTokenFrom(_owner, _tokenId);\r\n    emit Transfer(_owner, address(0), _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to clear current approval of a given token ID\r\n   * @dev Reverts if the given address is not indeed the owner of the token\r\n   * @param _owner owner of the token\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   */\r\n  function clearApproval(address _owner, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _owner);\r\n    if (tokenApprovals[_tokenId] != address(0)) {\r\n      tokenApprovals[_tokenId] = address(0);\r\n      emit Approval(_owner, address(0), _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n    require(tokenOwner[_tokenId] == address(0));\r\n    tokenOwner[_tokenId] = _to;\r\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _from);\r\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n    tokenOwner[_tokenId] = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke `onERC721Received` on a target address\r\n   * @dev The call is not executed if the target address is not a contract\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _to target address that will receive the tokens\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes optional data to send along with the call\r\n   * @return whether the call correctly returned the expected magic value\r\n   */\r\n  function checkAndCallSafeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    internal\r\n    returns (bool)\r\n  {\r\n    if (!_to.isContract()) {\r\n      return true;\r\n    }\r\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\r\n    return (retval == ERC721_RECEIVED);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Token.sol\r\n\r\n/**\r\n * @title Full ERC721 Token\r\n * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * Moreover, it includes approve all functionality using operator terminology\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Token is ERC721, ERC721BasicToken {\r\n  // Token name\r\n  string internal name_;\r\n\r\n  // Token symbol\r\n  string internal symbol_;\r\n\r\n  // Mapping from owner to list of owned token IDs\r\n  mapping (address => uint256[]) internal ownedTokens;\r\n\r\n  // Mapping from token ID to index of the owner tokens list\r\n  mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n  // Array with all token ids, used for enumeration\r\n  uint256[] internal allTokens;\r\n\r\n  // Mapping from token id to position in the allTokens array\r\n  mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n  // Optional mapping for token URIs\r\n  mapping(uint256 => string) internal tokenURIs;\r\n\r\n  /**\r\n   * @dev Constructor function\r\n   */\r\n  function ERC721Token(string _name, string _symbol) public {\r\n    name_ = _name;\r\n    symbol_ = _symbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token name\r\n   * @return string representing the token name\r\n   */\r\n  function name() public view returns (string) {\r\n    return name_;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token symbol\r\n   * @return string representing the token symbol\r\n   */\r\n  function symbol() public view returns (string) {\r\n    return symbol_;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an URI for a given token ID\r\n   * @dev Throws if the token ID does not exist. May return an empty string.\r\n   * @param _tokenId uint256 ID of the token to query\r\n   */\r\n  function tokenURI(uint256 _tokenId) public view returns (string) {\r\n    require(exists(_tokenId));\r\n    return tokenURIs[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n   * @param _owner address owning the tokens list to be accessed\r\n   * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n   */\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\r\n    require(_index < balanceOf(_owner));\r\n    return ownedTokens[_owner][_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the total amount of tokens stored by the contract\r\n   * @return uint256 representing the total amount of tokens\r\n   */\r\n  function totalSupply() public view returns (uint256) {\r\n    return allTokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token ID at a given index of all the tokens in this contract\r\n   * @dev Reverts if the index is greater or equal to the total number of tokens\r\n   * @param _index uint256 representing the index to be accessed of the tokens list\r\n   * @return uint256 token ID at the given index of the tokens list\r\n   */\r\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n    require(_index < totalSupply());\r\n    return allTokens[_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to set the token URI for a given token\r\n   * @dev Reverts if the token ID does not exist\r\n   * @param _tokenId uint256 ID of the token to set its URI\r\n   * @param _uri string URI to assign\r\n   */\r\n  function _setTokenURI(uint256 _tokenId, string _uri) internal {\r\n    require(exists(_tokenId));\r\n    tokenURIs[_tokenId] = _uri;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n    super.addTokenTo(_to, _tokenId);\r\n    uint256 length = ownedTokens[_to].length;\r\n    ownedTokens[_to].push(_tokenId);\r\n    ownedTokensIndex[_tokenId] = length;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n    super.removeTokenFrom(_from, _tokenId);\r\n\r\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n    ownedTokens[_from][tokenIndex] = lastToken;\r\n    ownedTokens[_from][lastTokenIndex] = 0;\r\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n    ownedTokens[_from].length--;\r\n    ownedTokensIndex[_tokenId] = 0;\r\n    ownedTokensIndex[lastToken] = tokenIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * @dev Reverts if the given token ID already exists\r\n   * @param _to address the beneficiary that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    super._mint(_to, _tokenId);\r\n\r\n    allTokensIndex[_tokenId] = allTokens.length;\r\n    allTokens.push(_tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * @dev Reverts if the token does not exist\r\n   * @param _owner owner of the token to burn\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address _owner, uint256 _tokenId) internal {\r\n    super._burn(_owner, _tokenId);\r\n\r\n    // Clear metadata (if any)\r\n    if (bytes(tokenURIs[_tokenId]).length != 0) {\r\n      delete tokenURIs[_tokenId];\r\n    }\r\n\r\n    // Reorg all tokens array\r\n    uint256 tokenIndex = allTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = allTokens.length.sub(1);\r\n    uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n    allTokens[tokenIndex] = lastToken;\r\n    allTokens[lastTokenIndex] = 0;\r\n\r\n    allTokens.length--;\r\n    allTokensIndex[_tokenId] = 0;\r\n    allTokensIndex[lastToken] = tokenIndex;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/ParsecShipAuction.sol\r\n\r\n// solium-disable-next-line lbrace\r\ncontract ParsecShipAuction is\r\n  ERC721Token(\"Parsec Initial Ship\", \"PIS\"),\r\n  ParsecShipInfo,\r\n  ParsecShipPricing,\r\n  ParsecReferralTracking,\r\n  Ownable,\r\n  Pausable\r\n{\r\n  uint256 public constant PARSEC_CREDIT_DECIMALS = 6;\r\n\r\n  uint256 public constant FIRST_AUCTIONS_MINIMUM_RAISE = 2 * uint256(10) ** (5 + PARSEC_CREDIT_DECIMALS);\r\n\r\n  uint256 public constant SECOND_AUCTIONS_INITIAL_PERCENTAGE = 50;\r\n  uint256 public constant LATER_AUCTIONS_INITIAL_PERCENTAGE = 125;\r\n\r\n  uint256 public constant REFERRAL_REWARD_PERCENTAGE = 20;\r\n\r\n  ERC20 public parsecCreditContract = ERC20(0x4373D59176891dA98CA6faaa86bd387fc9e12b6E);\r\n\r\n  // May 15th, 2018 – 16:00 UTC\r\n  uint256 public firstAuctionsStartDate = 1526400000;\r\n\r\n  uint256 public firstAuctionsInitialDuration = 48 hours;\r\n  uint256 public firstAuctionsExtendableDuration = 12 hours;\r\n\r\n  uint256 public firstAuctionsExtendedChunkDuration = 1 hours;\r\n  uint256 public firstAuctionsExtendedDuration = 0;\r\n\r\n  uint256 public firstAuctionsHighestBid = uint256(10) ** (6 + PARSEC_CREDIT_DECIMALS);\r\n  address public firstAuctionsHighestBidder = address(0);\r\n  address public firstAuctionsReferrer;\r\n  bool public firstAuctionConcluded = false;\r\n\r\n  uint256 private _lastAuctionedShipId = 0;\r\n  uint256 private _lastAuctionsWinningBid;\r\n  uint256 private _lastAuctionWinsDate;\r\n\r\n  event FirstShipBidded(\r\n    address indexed _bidder,\r\n    uint256 _value,\r\n    address indexed _referrer\r\n  );\r\n\r\n  event LaterShipBidded(\r\n    uint256 indexed _shipId,\r\n    address indexed _winner,\r\n    uint256 _value,\r\n    address indexed _referrer\r\n  );\r\n\r\n  function receiveApproval(\r\n    address _from,\r\n    uint256 _value,\r\n    address _token,\r\n    bytes _extraData\r\n  )\r\n    external\r\n    whenNotPaused\r\n  {\r\n    require(_token == address(parsecCreditContract));\r\n    require(_extraData.length == 64);\r\n\r\n    uint256 _shipId;\r\n    address _referrer;\r\n\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      _shipId := calldataload(164)\r\n      _referrer := calldataload(196)\r\n    }\r\n\r\n    if (_shipId == 1) {\r\n      _bidFirstShip(_value, _from, _referrer);\r\n    } else {\r\n      _bidLaterShip(_shipId, _value, _from, _referrer);\r\n    }\r\n  }\r\n\r\n  function getFirstAuctionsRemainingDuration() external view returns (uint256 /* _duration */) {\r\n    uint256 _currentDate = now;\r\n    uint256 _endDate = getFirstAuctionsEndDate();\r\n\r\n    if (_endDate >= _currentDate) {\r\n      return _endDate - _currentDate;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function concludeFirstAuction() external {\r\n    require(getLastAuctionedShipId() >= 1, \"The first auction must have ended.\");\r\n    require(!firstAuctionConcluded, \"The first auction must not have been concluded.\");\r\n\r\n    firstAuctionConcluded = true;\r\n\r\n    if (firstAuctionsHighestBidder != address(0)) {\r\n      _mint(firstAuctionsHighestBidder, 1);\r\n\r\n      if (firstAuctionsReferrer != address(0)) {\r\n        _sendTo(\r\n          firstAuctionsReferrer,\r\n          firstAuctionsHighestBid.mul(REFERRAL_REWARD_PERCENTAGE).div(100)\r\n        );\r\n      }\r\n    } else {\r\n      _mint(owner, 1);\r\n    }\r\n  }\r\n\r\n  function getFirstAuctionsExtendableStartDate() public view returns (uint256 /* _extendableStartDate */) {\r\n    return firstAuctionsStartDate\r\n      // solium-disable indentation\r\n      .add(firstAuctionsInitialDuration)\r\n      .sub(firstAuctionsExtendableDuration);\r\n      // solium-enable indentation\r\n  }\r\n\r\n  function getFirstAuctionsEndDate() public view returns (uint256 /* _endDate */) {\r\n    return firstAuctionsStartDate\r\n      .add(firstAuctionsInitialDuration)\r\n      .add(firstAuctionsExtendedDuration);\r\n  }\r\n\r\n  function getLastAuctionedShipId() public view returns (uint256 /* _shipId */) {\r\n    if (_lastAuctionedShipId == 0 && now >= getFirstAuctionsEndDate()) {\r\n      return 1;\r\n    } else {\r\n      return _lastAuctionedShipId;\r\n    }\r\n  }\r\n\r\n  function getLastAuctionsWinningBid() public view returns (uint256 /* _value */) {\r\n    if (_lastAuctionedShipId == 0 && now >= getFirstAuctionsEndDate()) {\r\n      return firstAuctionsHighestBid;\r\n    } else {\r\n      return _lastAuctionsWinningBid;\r\n    }\r\n  }\r\n\r\n  function getLastAuctionWinsDate() public view returns (uint256 /* _date */) {\r\n    if (_lastAuctionedShipId == 0) {\r\n      uint256 _firstAuctionsEndDate = getFirstAuctionsEndDate();\r\n\r\n      if (now >= _firstAuctionsEndDate) {\r\n        return _firstAuctionsEndDate;\r\n      }\r\n    }\r\n\r\n    return _lastAuctionWinsDate;\r\n  }\r\n\r\n  function getShipPrice(uint256 _shipId) public view returns (uint256 /* _price */) {\r\n    uint256 _minutesPassed = now\r\n      .sub(getLastAuctionWinsDate())\r\n      .div(1 minutes);\r\n\r\n    return getShipPrice(_shipId, _minutesPassed);\r\n  }\r\n\r\n  function getShipPrice(uint256 _shipId, uint256 _minutesPassed) public view returns (uint256 /* _price */) {\r\n    require(_shipId >= 2, \"Ship ID must be greater than or equal to 2.\");\r\n    require(_shipId <= TOTAL_SHIP, \"Ship ID must be smaller than or equal to total number of ship.\");\r\n    require(_shipId == getLastAuctionedShipId().add(1), \"Can only get price of the ship which is being auctioned.\");\r\n\r\n    uint256 _initialPrice = getLastAuctionsWinningBid();\r\n\r\n    if (_shipId == 2) {\r\n      _initialPrice = _initialPrice\r\n        .mul(SECOND_AUCTIONS_INITIAL_PERCENTAGE)\r\n        .div(100);\r\n    } else {\r\n      _initialPrice = _initialPrice\r\n        .mul(LATER_AUCTIONS_INITIAL_PERCENTAGE)\r\n        .div(100);\r\n    }\r\n\r\n    return _getShipPrice(_initialPrice, _minutesPassed);\r\n  }\r\n\r\n  function _bidFirstShip(uint256 _value, address _bidder, address _referrer) internal {\r\n    require(now >= firstAuctionsStartDate, \"Auction of the first ship is not started yet.\");\r\n    require(now < getFirstAuctionsEndDate(), \"Auction of the first ship has ended.\");\r\n\r\n    require(_value >= firstAuctionsHighestBid.add(FIRST_AUCTIONS_MINIMUM_RAISE), \"Not enough Parsec Credit.\");\r\n\r\n    _updateReferrerFor(_bidder, _referrer);\r\n    _receiveFrom(_bidder, _value);\r\n\r\n    if (firstAuctionsHighestBidder != address(0)) {\r\n      _sendTo(firstAuctionsHighestBidder, firstAuctionsHighestBid);\r\n    }\r\n\r\n    firstAuctionsHighestBid = _value;\r\n    firstAuctionsHighestBidder = _bidder;\r\n\r\n    // To prevent the first auction's referrer being overriden,\r\n    // since later auction's bidders could be the same as the first auction's bidder\r\n    // but their referrers could be different.\r\n    firstAuctionsReferrer = referrer[_bidder];\r\n\r\n    if (now >= getFirstAuctionsExtendableStartDate()) {\r\n      firstAuctionsExtendedDuration = firstAuctionsExtendedDuration\r\n        .add(firstAuctionsExtendedChunkDuration);\r\n    }\r\n\r\n    emit FirstShipBidded(_bidder, _value, referrer[_bidder]);\r\n  }\r\n\r\n  function _bidLaterShip(\r\n    uint256 _shipId,\r\n    uint256 _value,\r\n    address _bidder,\r\n    address _referrer\r\n  )\r\n    internal\r\n  {\r\n    uint256 _price = getShipPrice(_shipId);\r\n    require(_value >= _price, \"Not enough Parsec Credit.\");\r\n\r\n    _updateReferrerFor(_bidder, _referrer);\r\n\r\n    if (_price > 0) {\r\n      _receiveFrom(_bidder, _price);\r\n    }\r\n\r\n    _mint(_bidder, _shipId);\r\n\r\n    _lastAuctionedShipId = _shipId;\r\n    _lastAuctionsWinningBid = _price;\r\n    _lastAuctionWinsDate = now;\r\n\r\n    if (referrer[_bidder] != address(0) && _price > 0) {\r\n      _sendTo(referrer[_bidder], _price.mul(REFERRAL_REWARD_PERCENTAGE).div(100));\r\n    }\r\n\r\n    emit LaterShipBidded(\r\n      _shipId,\r\n      _bidder,\r\n      _value,\r\n      referrer[_bidder]\r\n    );\r\n  }\r\n\r\n  function _receiveFrom(address _from, uint256 _value) internal {\r\n    parsecCreditContract.transferFrom(_from, this, _value);\r\n  }\r\n\r\n  function _sendTo(address _to, uint256 _value) internal {\r\n    // Not like when transferring ETH, we are not afraid of a DoS attack here\r\n    // because Parsec Credit contract is trustable and there are no callbacks involved.\r\n    // solium-disable-next-line security/no-low-level-calls\r\n    require(address(parsecCreditContract).call(\r\n      bytes4(keccak256(\"transfer(address,uint256)\")),\r\n      _to,\r\n      _value\r\n    ), \"Parsec Credit transfer failed.\");\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/HasNoContracts.sol\r\n\r\n/**\r\n * @title Contracts that should not own Contracts\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\r\n * of this contract to reclaim ownership of the contracts.\r\n */\r\ncontract HasNoContracts is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim ownership of Ownable contracts\r\n   * @param contractAddr The address of the Ownable to be reclaimed.\r\n   */\r\n  function reclaimContract(address contractAddr) external onlyOwner {\r\n    Ownable contractInst = Ownable(contractAddr);\r\n    contractInst.transferOwnership(owner);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/HasNoEther.sol\r\n\r\n/**\r\n * @title Contracts that should not own Ether\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\r\n * in the contract, it will allow the owner to reclaim this ether.\r\n * @notice Ether can still be sent to this contract by:\r\n * calling functions labeled `payable`\r\n * `selfdestruct(contract_address)`\r\n * mining directly to the contract address\r\n */\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  function HasNoEther() public payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    // solium-disable-next-line security/no-send\r\n    assert(owner.send(address(this).balance));\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20Basic compatible tokens\r\n   * @param token ERC20Basic The address of the token contract\r\n   */\r\n  function reclaimToken(ERC20Basic token) external onlyOwner {\r\n    uint256 balance = token.balanceOf(this);\r\n    token.safeTransfer(owner, balance);\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/HasNoTokens.sol\r\n\r\n/**\r\n * @title Contracts that should not own Tokens\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.\r\n * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\r\n * owner to reclaim the tokens.\r\n */\r\ncontract HasNoTokens is CanReclaimToken {\r\n\r\n /**\r\n  * @dev Reject all ERC223 compatible tokens\r\n  * @param from_ address The address that is transferring the tokens\r\n  * @param value_ uint256 the amount of the specified token\r\n  * @param data_ Bytes The data passed from the caller.\r\n  */\r\n  function tokenFallback(address from_, uint256 value_, bytes data_) external {\r\n    from_;\r\n    value_;\r\n    data_;\r\n    revert();\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/NoOwner.sol\r\n\r\n/**\r\n * @title Base contract for contracts that should not own things.\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or\r\n * Owned contracts. See respective base contracts for details.\r\n */\r\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\r\n}\r\n\r\n// File: contracts/ParsecInitialShip.sol\r\n\r\n// solium-disable-next-line lbrace\r\ncontract ParsecInitialShip is\r\n  ParsecShipAuction,\r\n  NoOwner\r\n{\r\n  function reclaimToken(ERC20Basic token) external onlyOwner {\r\n    require(token != parsecCreditContract); // Use `reclaimParsecCredit()` instead!\r\n    uint256 balance = token.balanceOf(this);\r\n    token.safeTransfer(owner, balance);\r\n  }\r\n\r\n  function reclaimParsecCredit() external onlyOwner {\r\n    require(firstAuctionConcluded, \"The first auction must have been concluded.\");\r\n    _sendTo(owner, parsecCreditContract.balanceOf(this));\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"concludeFirstAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FIRST_AUCTIONS_MINIMUM_RAISE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastAuctionsWinningBid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_GREEN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstAuctionsEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimParsecCredit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstAuctionsExtendableStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_PARSEC_CREDIT_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"reclaimContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstAuctionsExtendedDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TYPE_EXPLORER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_GREY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shipId\",\"type\":\"uint256\"}],\"name\":\"getShip\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_PINK\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastAuctionedShipId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_WHITE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_ARK\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_RED\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstAuctionConcluded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstAuctionsRemainingDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME_SATOSHI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstAuctionsHighestBidder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME_NOT_AVAILABLE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFERRAL_REWARD_PERCENTAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_SHIP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstAuctionsExtendedChunkDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstAuctionsHighestBid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TYPE_EXPLORER_FREIGHTER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME_HAWKING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_BROWN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shipId\",\"type\":\"uint256\"},{\"name\":\"_minutesPassed\",\"type\":\"uint256\"}],\"name\":\"getShipPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TYPE_NOT_AVAILABLE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shipId\",\"type\":\"uint256\"}],\"name\":\"getShipPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_NOT_AVAILABLE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_SATOSHI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_SILVER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_HAWKING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TYPE_FREIGHTER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_YELLOW\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstAuctionsExtendableDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from_\",\"type\":\"address\"},{\"name\":\"value_\",\"type\":\"uint256\"},{\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastAuctionWinsDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LATER_AUCTIONS_INITIAL_PERCENTAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SECOND_AUCTIONS_INITIAL_PERCENTAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstAuctionsReferrer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstAuctionsStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"parsecCreditContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_BLACK\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PARSEC_CREDIT_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_CUSTOM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstAuctionsInitialDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_GOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME_ARK\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLOR_BLUE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"FirstShipBidded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_shipId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"LaterShipBidded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_referee\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"ReferrerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"ParsecInitialShip","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://dbf0831eb68b75b73165f61f773a63869ea7853bffe8aca30e6ef301a9524e01"}]