[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@ribbon-finance/rvol/contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.7.3;\\n\\ninterface IPriceOracle {\\n    function decimals() external view returns (uint256 _decimals);\\n\\n    function latestAnswer() external view returns (uint256 price);\\n}\\n\"\r\n    },\r\n    \"@ribbon-finance/rvol/contracts/interfaces/IVolatilityOracle.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.7.3;\\n\\ninterface IVolatilityOracle {\\n    function commit(address pool) external;\\n\\n    function twap(address pool) external returns (uint256 price);\\n\\n    function vol(address pool)\\n        external\\n        view\\n        returns (uint256 standardDeviation);\\n\\n    function annualizedVol(address pool)\\n        external\\n        view\\n        returns (uint256 annualStdev);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/GammaInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.2;\\npragma experimental ABIEncoderV2;\\n\\nlibrary GammaTypes {\\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\\n    struct Vault {\\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\\n        address[] shortOtokens;\\n        // addresses of oTokens a user has bought and deposited in this vault\\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral\\n        // in order to write oTokens against (i.e. in spreads)\\n        address[] longOtokens;\\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\\n        address[] collateralAssets;\\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\\n        uint256[] shortAmounts;\\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\\n        uint256[] longAmounts;\\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\\n        uint256[] collateralAmounts;\\n    }\\n}\\n\\ninterface IOtoken {\\n    function underlyingAsset() external view returns (address);\\n\\n    function strikeAsset() external view returns (address);\\n\\n    function collateralAsset() external view returns (address);\\n\\n    function strikePrice() external view returns (uint256);\\n\\n    function expiryTimestamp() external view returns (uint256);\\n\\n    function isPut() external view returns (bool);\\n}\\n\\ninterface IOtokenFactory {\\n    function getOtoken(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external view returns (address);\\n\\n    function createOtoken(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external returns (address);\\n\\n    function getTargetOtokenAddress(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external view returns (address);\\n\\n    event OtokenCreated(\\n        address tokenAddress,\\n        address creator,\\n        address indexed underlying,\\n        address indexed strike,\\n        address indexed collateral,\\n        uint256 strikePrice,\\n        uint256 expiry,\\n        bool isPut\\n    );\\n}\\n\\ninterface IController {\\n    // possible actions that can be performed\\n    enum ActionType {\\n        OpenVault,\\n        MintShortOption,\\n        BurnShortOption,\\n        DepositLongOption,\\n        WithdrawLongOption,\\n        DepositCollateral,\\n        WithdrawCollateral,\\n        SettleVault,\\n        Redeem,\\n        Call\\n    }\\n\\n    struct ActionArgs {\\n        // type of action that is being performed on the system\\n        ActionType actionType;\\n        // address of the account owner\\n        address owner;\\n        // address which we move assets from or to (depending on the action type)\\n        address secondAddress;\\n        // asset that is to be transfered\\n        address asset;\\n        // index of the vault that is to be modified (if any)\\n        uint256 vaultId;\\n        // amount of asset that is to be transfered\\n        uint256 amount;\\n        // each vault can hold multiple short / long / collateral assets\\n        // but we are restricting the scope to only 1 of each in this version\\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\\n        uint256 index;\\n        // any other data that needs to be passed in for arbitrary function calls\\n        bytes data;\\n    }\\n\\n    struct RedeemArgs {\\n        // address to which we pay out the oToken proceeds\\n        address receiver;\\n        // oToken that is to be redeemed\\n        address otoken;\\n        // amount of oTokens that is to be redeemed\\n        uint256 amount;\\n    }\\n\\n    function getPayout(address _otoken, uint256 _amount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function operate(ActionArgs[] calldata _actions) external;\\n\\n    function getAccountVaultCounter(address owner)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function oracle() external view returns (address);\\n\\n    function getVault(address _owner, uint256 _vaultId)\\n        external\\n        view\\n        returns (GammaTypes.Vault memory);\\n\\n    function getProceed(address _owner, uint256 _vaultId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function isSettlementAllowed(\\n        address _underlying,\\n        address _strike,\\n        address _collateral,\\n        uint256 _expiry\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRibbon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.3;\\n\\ninterface IStrikeSelection {\\n    function getStrikePrice(uint256 expiryTimestamp, bool isPut)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function delta() external view returns (uint256);\\n}\\n\\ninterface IOptionsPremiumPricer {\\n    function getPremium(\\n        uint256 strikePrice,\\n        uint256 timeToExpiry,\\n        bool isPut\\n    ) external view returns (uint256);\\n\\n    function getOptionDelta(\\n        uint256 sp,\\n        uint256 st,\\n        uint256 v,\\n        uint256 t\\n    ) external view returns (uint256 delta);\\n\\n    function getUnderlyingPrice() external view returns (uint256 price);\\n\\n    function priceOracle() external view returns (address oracle);\\n\\n    function volatilityOracle() external view returns (address oracle);\\n\\n    function pool() external view returns (address _pool);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/StrikeSelection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport {IOtoken} from \\\"../interfaces/GammaInterface.sol\\\";\\nimport {\\n    IPriceOracle\\n} from \\\"@ribbon-finance/rvol/contracts/interfaces/IPriceOracle.sol\\\";\\nimport {DSMath} from \\\"../vendor/DSMath.sol\\\";\\nimport {IOptionsPremiumPricer} from \\\"../interfaces/IRibbon.sol\\\";\\nimport {\\n    IVolatilityOracle\\n} from \\\"@ribbon-finance/rvol/contracts/interfaces/IVolatilityOracle.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract StrikeSelection is DSMath, Ownable {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * Immutables\\n     */\\n    IOptionsPremiumPricer public immutable optionsPremiumPricer;\\n    IVolatilityOracle public immutable volatilityOracle;\\n\\n    // delta for options strike price selection. 1 is 10000\\n    uint256 public delta;\\n    // step in absolute terms at which we will increment\\n    // (ex: 100 * 10 ** assetOracleDecimals means we will move at increments of 100 points)\\n    uint256 public step;\\n    // multiplier to shift asset prices\\n    uint256 private immutable assetOracleMultiplier;\\n\\n    event DeltaSet(uint256 oldDelta, uint256 newDelta, address owner);\\n    event StepSet(uint256 oldStep, uint256 newStep, address owner);\\n\\n    constructor(\\n        address _optionsPremiumPricer,\\n        uint256 _delta,\\n        uint256 _step\\n    ) {\\n        require(_optionsPremiumPricer != address(0), \\\"!_optionsPremiumPricer\\\");\\n        require(_delta > 0, \\\"!_delta\\\");\\n        require(_step > 0, \\\"!_step\\\");\\n        optionsPremiumPricer = IOptionsPremiumPricer(_optionsPremiumPricer);\\n        volatilityOracle = IVolatilityOracle(\\n            IOptionsPremiumPricer(_optionsPremiumPricer).volatilityOracle()\\n        );\\n        // ex: delta = 7500 (.75)\\n        delta = _delta;\\n        uint256 _assetOracleMultiplier =\\n            10 **\\n                IPriceOracle(\\n                    IOptionsPremiumPricer(_optionsPremiumPricer).priceOracle()\\n                )\\n                    .decimals();\\n\\n        // ex: step = 1000\\n        step = _step.mul(_assetOracleMultiplier);\\n\\n        assetOracleMultiplier = _assetOracleMultiplier;\\n    }\\n\\n    /**\\n     * @notice Gets the strike price satisfying the delta value\\n     * given the expiry timestamp and whether option is call or put\\n     * @param expiryTimestamp is the unix timestamp of expiration\\n     * @param isPut is whether option is put or call\\n     */\\n\\n    function getStrikePrice(uint256 expiryTimestamp, bool isPut)\\n        external\\n        view\\n        returns (uint256, uint256)\\n    {\\n        require(\\n            expiryTimestamp > block.timestamp,\\n            \\\"Expiry must be in the future!\\\"\\n        );\\n\\n        // asset price\\n        uint256 assetPrice = optionsPremiumPricer.getUnderlyingPrice();\\n\\n        // asset's annualized volatility\\n        uint256 annualizedVol =\\n            volatilityOracle.annualizedVol(optionsPremiumPricer.pool()).mul(\\n                10**10\\n            );\\n\\n        // For each asset prices with step of 'step' (down if put, up if call)\\n        //   if asset's getOptionDelta(currStrikePrice, spotPrice, annualizedVol, t) == (isPut ? 1 - delta:delta)\\n        //   with certain margin of error\\n        //        return strike price\\n\\n        uint256 strike =\\n            isPut\\n                ? assetPrice.sub(assetPrice % step).sub(step)\\n                : assetPrice.add(step - (assetPrice % step)).add(step);\\n        uint256 targetDelta = isPut ? uint256(10000).sub(delta) : delta;\\n        uint256 prevDelta = 10000;\\n\\n        while (true) {\\n            uint256 currDelta =\\n                optionsPremiumPricer.getOptionDelta(\\n                    assetPrice.mul(10**8).div(assetOracleMultiplier),\\n                    strike,\\n                    annualizedVol,\\n                    expiryTimestamp\\n                );\\n            //  If the current delta is between the previous\\n            //  strike price delta and current strike price delta\\n            //  then we are done\\n            bool foundTargetStrikePrice =\\n                isPut\\n                    ? targetDelta >= prevDelta && targetDelta <= currDelta\\n                    : targetDelta <= prevDelta && targetDelta >= currDelta;\\n\\n            if (foundTargetStrikePrice) {\\n                uint256 finalDelta =\\n                    _getBestDelta(prevDelta, currDelta, targetDelta, isPut);\\n                uint256 finalStrike =\\n                    _getBestStrike(finalDelta, prevDelta, strike, isPut);\\n                require(\\n                    isPut\\n                        ? finalStrike <= assetPrice\\n                        : finalStrike >= assetPrice\\n                );\\n                // make decimals consistent with oToken strike price decimals (10 ** 8)\\n                return (\\n                    finalStrike.mul(10**8).div(assetOracleMultiplier),\\n                    finalDelta\\n                );\\n            }\\n\\n            strike = isPut ? strike.sub(step) : strike.add(step);\\n\\n            prevDelta = currDelta;\\n        }\\n    }\\n\\n    /**\\n     * @notice Rounds to best delta value\\n     * @param prevDelta is the delta of the previous strike price\\n     * @param currDelta is delta of the current strike price\\n     * @param targetDelta is the delta we are targeting\\n     * @param isPut is whether its a put\\n     */\\n    function _getBestDelta(\\n        uint256 prevDelta,\\n        uint256 currDelta,\\n        uint256 targetDelta,\\n        bool isPut\\n    ) private pure returns (uint256 finalDelta) {\\n        uint256 upperBoundDiff =\\n            isPut ? sub(currDelta, targetDelta) : sub(prevDelta, targetDelta);\\n        uint256 lowerBoundDiff =\\n            isPut ? sub(targetDelta, prevDelta) : sub(targetDelta, currDelta);\\n\\n        // for tie breaks (ex: 0.05 <= 0.1 <= 0.15) round to higher strike price\\n        // for calls and lower strike price for puts for deltas\\n        finalDelta = lowerBoundDiff <= upperBoundDiff\\n            ? (isPut ? prevDelta : currDelta)\\n            : (isPut ? currDelta : prevDelta);\\n    }\\n\\n    /**\\n     * @notice Rounds to best delta value\\n     * @param finalDelta is the best delta value we found\\n     * @param prevDelta is delta of the previous strike price\\n     * @param strike is the strike of the previous iteration\\n     * @param isPut is whether its a put\\n     */\\n    function _getBestStrike(\\n        uint256 finalDelta,\\n        uint256 prevDelta,\\n        uint256 strike,\\n        bool isPut\\n    ) private view returns (uint256 finalStrike) {\\n        if (isPut) {\\n            if (finalDelta == prevDelta) {\\n                finalStrike = strike.add(step);\\n            } else {\\n                finalStrike = strike;\\n            }\\n        } else {\\n            if (finalDelta == prevDelta) {\\n                finalStrike = strike.sub(step);\\n            } else {\\n                finalStrike = strike;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets new delta value\\n     * @param newDelta is the new delta value\\n     */\\n    function setDelta(uint256 newDelta) external onlyOwner {\\n        uint256 oldDelta = delta;\\n        delta = newDelta;\\n        emit DeltaSet(oldDelta, newDelta, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Sets new step value\\n     * @param newStep is the new step value\\n     */\\n    function setStep(uint256 newStep) external onlyOwner {\\n        uint256 oldStep = step;\\n        step = newStep.mul(assetOracleMultiplier);\\n        emit StepSet(oldStep, newStep, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/DSMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/// math.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >0.4.13;\\n\\ncontract DSMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint256 constant WAD = 10**18;\\n    uint256 constant RAY = 10**27;\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    //rounds to zero if x*y < RAY / 2\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_optionsPremiumPricer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_delta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_step\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"DeltaSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldStep\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStep\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"StepSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"delta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPut\",\"type\":\"bool\"}],\"name\":\"getStrikePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionsPremiumPricer\",\"outputs\":[{\"internalType\":\"contract IOptionsPremiumPricer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDelta\",\"type\":\"uint256\"}],\"name\":\"setDelta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newStep\",\"type\":\"uint256\"}],\"name\":\"setStep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"step\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"volatilityOracle\",\"outputs\":[{\"internalType\":\"contract IVolatilityOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StrikeSelection","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007c24414191e2818a1a8cd995688c9da74faf67a800000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000003e8","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]