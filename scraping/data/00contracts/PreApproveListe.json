[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"PreApproveLister.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title PreApproveLister\\n * @notice A contract that allows the owner to add and remove operators\\n *         to the registry.\\n */\\ncontract PreApproveLister {\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    /**\\n     * @dev The address of the pre-approve registry.\\n     */\\n    address public constant PRE_APPROVE_REGISTRY = 0x000000000000B89C3cBDBBecb313Bd896b09144d;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    /**\\n     * @dev The owner of the contract.\\n     */\\n    address public owner;\\n\\n    /**\\n     * @dev Whether the contract has already been initialized.\\n     */\\n    bool internal _initialized;\\n\\n    /**\\n     * @dev Whether the contract is locked.\\n     *      When a contract is locked:\\n     *      - Operators cannot be added by the owner.\\n     *      - Operators can still be removed by the owner.\\n     *      - Anyone can purge operators.\\n     *      - Contract cannot be unlocked.\\n     */\\n    bool public locked;\\n\\n    /**\\n     * @dev An account authorized to lock the contract, besides the contract owner.\\n     *      This is for the worse case scenario where the contract owner is a\\n     *      multisig and is compromised, with all the signers changed; we still\\n     *      can use an EOA to lock the contract and purge all the operators.\\n     */\\n    address public locker;\\n\\n    /**\\n     * @dev A backup locker in case locker's private key is lost.\\n     */\\n    address public backupLocker;\\n\\n    // =============================================================\\n    //                   CONSTRUCTOR / INITIALIZER\\n    // =============================================================\\n\\n    constructor() payable {}\\n\\n    /**\\n     * @dev Initializer.\\n     */\\n    function initialize(address owner_, address locker_) external payable {\\n        require(!_initialized);\\n        owner = owner_;\\n        _initialized = true;\\n        locker = locker_;\\n    }\\n\\n    // =============================================================\\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Adds the `operator` to the pre-approve list maintained by the caller (lister).\\n     * @param operator The account that can manage NFTs on behalf of\\n     *                 collectors subscribed to the caller.\\n     */\\n    function addOperator(address operator) external payable onlyOwner onlyUnlocked {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Silence compiler warning on unused variable.\\n            let t := operator\\n            // Copy over the function selector and the operator to memory.\\n            calldatacopy(returndatasize(), returndatasize(), 0x24)\\n            if iszero(\\n                call(\\n                    gas(), // Remaining gas.\\n                    PRE_APPROVE_REGISTRY, // The pre-approve registry.\\n                    returndatasize(), // Send 0 ETH.\\n                    returndatasize(), // Start of calldata.\\n                    0x24, // Length of calldata.\\n                    returndatasize(), // Start of returndata in memory.\\n                    returndatasize() // Length of returndata.\\n                )\\n            ) {\\n                // This is to prevent gas under-estimation.\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes the `operator` from the pre-approve list maintained by the caller (lister).\\n     * @param operator The account that can manage NFTs on behalf of\\n     *                 collectors subscribed to the caller.\\n     */\\n    function removeOperator(address operator) external payable onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Silence compiler warning on unused variable.\\n            let t := operator\\n            // Copy over the function selector and the operator to memory.\\n            calldatacopy(returndatasize(), returndatasize(), 0x24)\\n            if iszero(\\n                call(\\n                    gas(), // Remaining gas.\\n                    PRE_APPROVE_REGISTRY, // The pre-approve registry.\\n                    returndatasize(), // Send 0 ETH.\\n                    returndatasize(), // Start of calldata.\\n                    0x24, // Length of calldata.\\n                    returndatasize(), // Start of returndata in memory.\\n                    returndatasize() // Length of returndata.\\n                )\\n            ) {\\n                // This is to prevent gas under-estimation.\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Allows anyone to purge operators when the contract is locked.\\n     * @param count Number of operators to remove.\\n     */\\n    function purgeOperators(uint256 count) external payable onlyLocked {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            let m := mload(0x40)\\n\\n            for {} count { count := sub(count, 1) } {\\n                // Store the function selector of:\\n                // `bytes4(keccak256(\\\"operatorAt(address,uint256)\\\"))`.\\n                mstore(0x00, 0x1085efc7)\\n                mstore(0x20, address()) // Store the address of the contract.\\n                mstore(0x40, 0) // Store 0.\\n                if iszero(\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        PRE_APPROVE_REGISTRY, // The pre-approve registry.\\n                        0x1c, // Start of calldata.\\n                        0x44, // Length of calldata.\\n                        0x20, // Start of returndata in memory.\\n                        0x20 // Length of returndata.\\n                    )\\n                ) {\\n                    // This is to prevent gas under-estimation.\\n                    revert(0, 0)\\n                }\\n                // The operator is already stored in slot 0x20.\\n\\n                // Store the function selector of:\\n                // `bytes4(keccak256(\\\"removeOperator(address)\\\"))`.\\n                mstore(0x00, 0xac8a584a)\\n\\n                if iszero(\\n                    call(\\n                        gas(), // Remaining gas.\\n                        PRE_APPROVE_REGISTRY, // The pre-approve registry.\\n                        0, // Send 0 ETH.\\n                        0x1c, // Start of calldata.\\n                        0x24, // Length of calldata.\\n                        0x00, // Start of returndata in memory.\\n                        0x00 // Length of returndata.\\n                    )\\n                ) {\\n                    // This is to prevent gas under-estimation.\\n                    revert(0, 0)\\n                }\\n            }\\n            // Restore the free memory pointer.\\n            mstore(0x40, m)\\n        }\\n    }\\n\\n    /**\\n     * @dev Allows the contract owner to set a backup locker address.\\n     * @param backup The backup locker address.\\n     */\\n    function setBackupLocker(address backup) external payable onlyOwner {\\n        require(backup != address(0), \\\"Backup cannot be zero.\\\");\\n        require(backupLocker == address(0), \\\"Already set.\\\");\\n        backupLocker = backup;\\n    }\\n\\n    /**\\n     * @dev Locks the ability to add new operators.\\n     *      This function is to be used when the contract owner is compromised.\\n     */\\n    function lock() external payable onlyOwnerOrLocker onlyUnlocked {\\n        locked = true;\\n    }\\n\\n    // =============================================================\\n    //                  INTERNAL / PRIVATE HELPERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Require the caller to be the contract owner.\\n     */\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"Unauthorized.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Require the caller to be either the contract owner or locker.\\n     */\\n    modifier onlyOwnerOrLocker() virtual {\\n        require(\\n            msg.sender == owner || msg.sender == locker || msg.sender == backupLocker,\\n            \\\"Unauthorized.\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Require that the contract is not locked.\\n     */\\n    modifier onlyUnlocked() virtual {\\n        require(!locked, \\\"Locked.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Require that the contract is locked.\\n     */\\n    modifier onlyLocked() virtual {\\n        require(locked, \\\"Not locked.\\\");\\n        _;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"PRE_APPROVE_REGISTRY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backupLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"locker_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"purgeOperators\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"backup\",\"type\":\"address\"}],\"name\":\"setBackupLocker\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"PreApproveLister","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7e2baf8030b48d28a5b3f838fa779e1d462d557c4305aaba2900ec937d6cfb68"}]