[{"SourceCode":"// File: contracts/CoinFlip.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\ncontract CoinFlip {\r\n    struct GameData {\r\n        address p1;\r\n        address p2;\r\n        uint16 status;\r\n        uint wager;\r\n\r\n        bytes32 p1Hash;\r\n        bytes32 p2Hash;\r\n    }\r\n\r\n    address private immutable OWNER_ADDRESS;\r\n\r\n    mapping(uint176 => uint232) games;\r\n    mapping(uint176 => bytes32) playerHashes;\r\n    mapping(uint176 => uint) verifiedNumbers;\r\n\r\n    event GameCreated(uint176 gameId, address player1, uint wager);\r\n    event GameJoined(uint176 gameId, address player1, address player2, uint wager);\r\n    // Between here the house will submit their own random number hash\r\n    event GameRevealStart(uint176 gameId);\r\n    event GameReady(uint176 gameId);\r\n    // After all players have revealed their numbers the house will reveal and complete the game\r\n    event GameCompleted(uint176 gameId, address player1, address player2, uint wager, uint ran);\r\n    event GameCanceled(uint176 gameId);\r\n\r\n    constructor() {\r\n        OWNER_ADDRESS = msg.sender;\r\n    }\r\n\r\n    // ~68k gas\r\n    function createGame(bytes32 hash) payable external returns (uint176 id) {\r\n        // Ensure there isnt more than one decimal point in ETH (So we can pack it into a uint16)\r\n        require(msg.value >= 0.2 ether && msg.value % 0.1 ether == 0, \"Bad Wager Val\");\r\n\r\n        id = encodeGameID(msg.sender, msg.value);\r\n\r\n        // Ensure game id doesn't already exist\r\n        require(games[id] == 0, \"Game exists\");\r\n\r\n        // Fill game data with status 1 (awaiting opponent)\r\n        games[id] = encodeGameData(1, address(0));\r\n        playerHashes[id + 1] = hash;\r\n        emit GameCreated(id, msg.sender, msg.value);\r\n    }\r\n\r\n    // ~52k gas\r\n    function joinGame(uint176 id, bytes32 hash) payable external {\r\n        GameData memory g = getGameData(id, false);\r\n\r\n        require(g.status == 1, \"Bad Status\");\r\n        require(g.wager == msg.value, \"Wrong Wager\");\r\n\r\n        // Update game data with player2 and status 2 (awaiting randomness)\r\n        games[id] = encodeGameData(2, msg.sender);\r\n        playerHashes[id+2] = hash;\r\n\r\n        emit GameJoined(id, g.p1, msg.sender, g.wager);\r\n    }\r\n\r\n    // ~51k gas\r\n    function houseJoinGame(uint176 id, bytes32 hash) external {\r\n        require(msg.sender == OWNER_ADDRESS);\r\n\r\n        GameData memory g = getGameData(id, false);\r\n\r\n        require(g.status == 2, \"Bad Status\");\r\n\r\n        playerHashes[id+3] = hash;\r\n        games[id] = encodeGameData(3, g.p2);\r\n\r\n        emit GameRevealStart(id);\r\n    }\r\n\r\n    // ~50 - 54k gas\r\n    function reveal(uint176 id, uint N) external {\r\n        GameData memory g = getGameData(id, false);\r\n\r\n        require(g.status == 3, \"Bad Status\");\r\n\r\n        if (g.p1 == msg.sender) {\r\n            bytes32 providedHash = playerHashes[id+1];\r\n            bytes32 realHash = getHash(N);\r\n            require(providedHash == realHash, \"Bad Hash\");\r\n\r\n            delete playerHashes[id+1];\r\n            verifiedNumbers[id+1] = N;\r\n            if (verifiedNumbers[id+2] != 0) {\r\n                games[id] = encodeGameData(4, g.p2);\r\n                emit GameReady(id);\r\n            }\r\n            return;\r\n        } else if (g.p2 == msg.sender) {\r\n            bytes32 providedHash = playerHashes[id+2];\r\n            bytes32 realHash = getHash(N);\r\n            require(providedHash == realHash, \"Bad Hash\");\r\n\r\n            delete playerHashes[id+2];\r\n            verifiedNumbers[id+2] = N;\r\n            if (verifiedNumbers[id+1] != 0) {\r\n                games[id] = encodeGameData(4, g.p2);\r\n                emit GameReady(id);\r\n            }\r\n            return;\r\n        }\r\n\r\n        require(false, \"Wrong Sender\");\r\n    }\r\n\r\n    // ~48k gas\r\n    function houseReveal(uint176 id, uint N) external {\r\n        require(msg.sender == OWNER_ADDRESS);\r\n\r\n        GameData memory g = getGameData(id, false);\r\n\r\n        require(g.status == 4, \"Bad Status\");\r\n\r\n        // Verify house hash\r\n        bytes32 providedHash = playerHashes[id+3];\r\n        bytes32 realHash = getHash(N);\r\n        require(providedHash == realHash, \"Bad Hash\");\r\n\r\n        uint ran = uint(keccak256(abi.encodePacked(verifiedNumbers[id+1], verifiedNumbers[id+2], N))) % 10000000;\r\n\r\n        delete games[id];\r\n        delete verifiedNumbers[id+1];\r\n        delete verifiedNumbers[id+2];\r\n\r\n        uint payout = g.wager * 2;\r\n        uint fee = payout * 3 / 100;\r\n        payout -= fee;\r\n\r\n        // Player 1 wins\r\n        if (ran % 2 == 0) {\r\n            payable(g.p1).transfer(payout);\r\n        } else {\r\n            payable(g.p2).transfer(payout);\r\n        }\r\n\r\n        payable(OWNER_ADDRESS).transfer(fee);\r\n\r\n        emit GameCompleted(id, g.p1, g.p2, g.wager, ran);\r\n    }\r\n\r\n    function encodeGameID(address player1, uint wager) pure private returns (uint176 id) {\r\n        // Player1  -  160 bits\r\n        // Wager -  16 bits\r\n\r\n        id = uint176(uint160(player1));\r\n        id |= uint176(wager / 100000000000000000)<<160;\r\n    }\r\n\r\n    function decodeGameID(uint176 encoded) pure private returns (address player1, uint wager) {\r\n        player1 = address(uint160(encoded));\r\n        wager = uint(encoded>>160) * 100000000000000000;\r\n    }\r\n\r\n    function encodeGameData(uint16 status, address player2) pure private returns (uint232) {\r\n        // Status  -  16 bits\r\n        // Player2 -  160 bits\r\n        // Total: 176 bits\r\n\r\n        // Status 0 = no game\r\n        // Status 1 = Awaiting Opponent\r\n        // Status 2 = Awaiting house hash\r\n        // Status 3 = Player Reveal\r\n        // Status 4 = Awaiting house reveal & payout\r\n\r\n        uint232 encoded = uint232(status);\r\n        encoded |= uint232(uint160(player2)) << 16;\r\n\r\n        return encoded;\r\n    }\r\n\r\n    function decodeGameData(uint232 encoded) pure private returns (uint16 status, address player2) {\r\n        status = uint16(encoded);\r\n        player2 = address(uint160(encoded>>16));\r\n    }\r\n\r\n    function getGameData(uint176 id, bool needHash) public view returns (GameData memory g) {\r\n        require(games[id] != 0, \"Game doesn't exist\");\r\n\r\n        (g.p1, g.wager) = decodeGameID(id);\r\n        (g.status, g.p2) = decodeGameData(games[id]);\r\n        if (needHash) {\r\n            (g.p1Hash, g.p2Hash) = (playerHashes[id+1], playerHashes[id+2]);\r\n        }\r\n    }\r\n\r\n    function getHash(uint N) private view returns (bytes32 b) {\r\n        b = keccak256(abi.encodePacked(msg.sender, N));\r\n    }\r\n\r\n    function cancelGame(uint176 id) external {\r\n        GameData memory g = getGameData(id, false);\r\n\r\n        // Take fee (if necessary) from the player that canceled\r\n        if (g.p1 == msg.sender) {\r\n            delete games[id];\r\n            delete playerHashes[id+1];\r\n\r\n            if (g.status == 1) {\r\n                // No player 2 yet\r\n                payable(g.p1).transfer(g.wager);\r\n                return;\r\n            }\r\n\r\n            if (g.status >= 2)\r\n                delete playerHashes[id+2];\r\n\r\n            if (g.status >= 3) {\r\n                delete playerHashes[id+3];\r\n                delete verifiedNumbers[id+1];\r\n                delete verifiedNumbers[id+2];\r\n            }\r\n\r\n            payable(OWNER_ADDRESS).transfer(0.01 ether);\r\n            payable(g.p1).transfer(g.wager - 0.01 ether);\r\n            payable(g.p2).transfer(g.wager);\r\n            emit GameCanceled(id);\r\n            return;\r\n        } else if (g.p2 == msg.sender) {\r\n            delete games[id];\r\n            delete playerHashes[id+1];\r\n            delete playerHashes[id+2];\r\n\r\n            if (g.status >= 3) {\r\n                delete playerHashes[id+3];\r\n                delete verifiedNumbers[id+1];\r\n                delete verifiedNumbers[id+2];\r\n            }\r\n\r\n            payable(OWNER_ADDRESS).transfer(0.01 ether);\r\n            payable(g.p1).transfer(g.wager);\r\n            payable(g.p2).transfer(g.wager - 0.01 ether);\r\n            emit GameCanceled(id);\r\n            return;\r\n        }\r\n\r\n        require(false, \"Wrong Address\");\r\n    }\r\n\r\n    function destruct() external {\r\n        require(msg.sender == OWNER_ADDRESS);\r\n\r\n        selfdestruct(payable(OWNER_ADDRESS));\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint176\",\"name\":\"gameId\",\"type\":\"uint176\"}],\"name\":\"GameCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint176\",\"name\":\"gameId\",\"type\":\"uint176\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wager\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ran\",\"type\":\"uint256\"}],\"name\":\"GameCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint176\",\"name\":\"gameId\",\"type\":\"uint176\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wager\",\"type\":\"uint256\"}],\"name\":\"GameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint176\",\"name\":\"gameId\",\"type\":\"uint176\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wager\",\"type\":\"uint256\"}],\"name\":\"GameJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint176\",\"name\":\"gameId\",\"type\":\"uint176\"}],\"name\":\"GameReady\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint176\",\"name\":\"gameId\",\"type\":\"uint176\"}],\"name\":\"GameRevealStart\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint176\",\"name\":\"id\",\"type\":\"uint176\"}],\"name\":\"cancelGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"createGame\",\"outputs\":[{\"internalType\":\"uint176\",\"name\":\"id\",\"type\":\"uint176\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint176\",\"name\":\"id\",\"type\":\"uint176\"},{\"internalType\":\"bool\",\"name\":\"needHash\",\"type\":\"bool\"}],\"name\":\"getGameData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"p1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"p2\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"status\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"wager\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"p1Hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"p2Hash\",\"type\":\"bytes32\"}],\"internalType\":\"struct CoinFlip.GameData\",\"name\":\"g\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint176\",\"name\":\"id\",\"type\":\"uint176\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"houseJoinGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint176\",\"name\":\"id\",\"type\":\"uint176\"},{\"internalType\":\"uint256\",\"name\":\"N\",\"type\":\"uint256\"}],\"name\":\"houseReveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint176\",\"name\":\"id\",\"type\":\"uint176\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"joinGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint176\",\"name\":\"id\",\"type\":\"uint176\"},{\"internalType\":\"uint256\",\"name\":\"N\",\"type\":\"uint256\"}],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CoinFlip","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c18fbd3d67d0d788a50a8aee451a231f59843a7b5ef1b7c483f90a75e70f4a3b"}]