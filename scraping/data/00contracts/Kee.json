[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice ERC1155 interface to receive tokens.\r\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/tokens/ERC1155/ERC1155.sol)\r\nabstract contract ERC1155TokenReceiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata\r\n    ) public payable virtual returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        bytes calldata\r\n    ) public payable virtual returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n\r\n/// @notice Modern, minimalist, and gas-optimized ERC1155 implementation with Compound-style voting and flexible permissioning scheme.\r\n/// @author Modified from ERC1155V (https://github.com/kalidao/ERC1155V/blob/main/src/ERC1155V.sol)\r\n/// @author Modified from Compound (https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol)\r\nabstract contract KeepToken {\r\n    /// -----------------------------------------------------------------------\r\n    /// Events\r\n    /// -----------------------------------------------------------------------\r\n\r\n    event DelegateChanged(\r\n        address indexed delegator,\r\n        address indexed fromDelegate,\r\n        address indexed toDelegate,\r\n        uint256 id\r\n    );\r\n\r\n    event DelegateVotesChanged(\r\n        address indexed delegate,\r\n        uint256 indexed id,\r\n        uint256 previousBalance,\r\n        uint256 newBalance\r\n    );\r\n\r\n    event TransferSingle(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 id,\r\n        uint256 amount\r\n    );\r\n\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] amounts\r\n    );\r\n\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    event TransferabilitySet(\r\n        address indexed operator,\r\n        uint256 indexed id,\r\n        bool on\r\n    );\r\n\r\n    event PermissionSet(address indexed operator, uint256 indexed id, bool on);\r\n\r\n    event UserPermissionSet(\r\n        address indexed operator,\r\n        address indexed to,\r\n        uint256 indexed id,\r\n        bool on\r\n    );\r\n\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Custom Errors\r\n    /// -----------------------------------------------------------------------\r\n\r\n    error LengthMismatch();\r\n\r\n    error Unauthorized();\r\n\r\n    error NonTransferable();\r\n\r\n    error NotPermitted();\r\n\r\n    error UnsafeRecipient();\r\n\r\n    error InvalidRecipient();\r\n\r\n    error ExpiredSig();\r\n\r\n    error InvalidSig();\r\n\r\n    error Undetermined();\r\n\r\n    error Overflow();\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// ERC1155 Storage\r\n    /// -----------------------------------------------------------------------\r\n\r\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\r\n\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// EIP-712 Storage/Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    // `keccak256(\r\n                    //     \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n                    // )`\r\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\r\n                    // `keccak256(bytes(\"Keep\"))`\r\n                    0x21d66785fec14e4da3d76f3866cf99a28f4da49ec8782c3cab7cf79c1b6fa66b,\r\n                    // `keccak256(\"1\")`\r\n                    0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6,\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// ID Storage\r\n    /// -----------------------------------------------------------------------\r\n\r\n    uint256 internal constant SIGN_KEY = uint32(0x6c4b5546); // `execute()`\r\n\r\n    mapping(uint256 => uint256) public totalSupply;\r\n\r\n    mapping(uint256 => bool) public transferable;\r\n\r\n    mapping(uint256 => bool) public permissioned;\r\n\r\n    mapping(address => mapping(uint256 => bool)) public userPermissioned;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Checkpoint Storage\r\n    /// -----------------------------------------------------------------------\r\n\r\n    mapping(address => mapping(uint256 => address)) internal _delegates;\r\n\r\n    mapping(address => mapping(uint256 => uint256)) public numCheckpoints;\r\n\r\n    mapping(address => mapping(uint256 => mapping(uint256 => Checkpoint)))\r\n        public checkpoints;\r\n\r\n    struct Checkpoint {\r\n        uint40 fromTimestamp;\r\n        uint216 votes;\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Metadata Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function uri(uint256 id) public view virtual returns (string memory);\r\n\r\n    function name() public pure virtual returns (string memory) {\r\n        uint256 placeholder;\r\n\r\n        assembly {\r\n            placeholder := sub(\r\n                calldatasize(),\r\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\r\n            )\r\n\r\n            placeholder := calldataload(add(placeholder, 2))\r\n        }\r\n\r\n        return string(abi.encodePacked(placeholder));\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// ERC165 Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return\r\n            // ERC165 interface ID for ERC165.\r\n            interfaceId == this.supportsInterface.selector ||\r\n            // ERC165 interface ID for ERC1155.\r\n            interfaceId == 0xd9b67a26 ||\r\n            // ERC165 interface ID for ERC1155MetadataURI.\r\n            interfaceId == 0x0e89341c;\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// ERC1155 Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256[] memory balances)\r\n    {\r\n        if (owners.length != ids.length) revert LengthMismatch();\r\n\r\n        balances = new uint256[](owners.length);\r\n\r\n        for (uint256 i; i < owners.length; ) {\r\n            balances[i] = balanceOf[owners[i]][ids[i]];\r\n\r\n            // Unchecked because the only math done is incrementing\r\n            // the array index counter which cannot possibly overflow.\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved)\r\n        public\r\n        payable\r\n        virtual\r\n    {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) public payable virtual {\r\n        if (msg.sender != from)\r\n            if (!isApprovedForAll[from][msg.sender]) revert Unauthorized();\r\n\r\n        if (!transferable[id]) revert NonTransferable();\r\n\r\n        if (permissioned[id])\r\n            if (!userPermissioned[to][id] || !userPermissioned[from][id])\r\n                revert NotPermitted();\r\n\r\n        // If not transferring SIGN_KEY, update delegation balance.\r\n        // Otherwise, prevent transfer to SIGN_KEY holder.\r\n        if (id != SIGN_KEY)\r\n            _moveDelegates(delegates(from, id), delegates(to, id), id, amount);\r\n        else if (balanceOf[to][id] != 0) revert Overflow();\r\n\r\n        balanceOf[from][id] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to][id] += amount;\r\n        }\r\n\r\n        emit TransferSingle(msg.sender, from, to, id, amount);\r\n\r\n        if (to.code.length != 0) {\r\n            if (\r\n                ERC1155TokenReceiver(to).onERC1155Received(\r\n                    msg.sender,\r\n                    from,\r\n                    id,\r\n                    amount,\r\n                    data\r\n                ) != ERC1155TokenReceiver.onERC1155Received.selector\r\n            ) revert UnsafeRecipient();\r\n        } else if (to == address(0)) revert InvalidRecipient();\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) public payable virtual {\r\n        if (ids.length != amounts.length) revert LengthMismatch();\r\n\r\n        if (msg.sender != from)\r\n            if (!isApprovedForAll[from][msg.sender]) revert Unauthorized();\r\n\r\n        // Storing these outside the loop saves ~15 gas per iteration.\r\n        uint256 id;\r\n        uint256 amount;\r\n\r\n        for (uint256 i; i < ids.length; ) {\r\n            id = ids[i];\r\n            amount = amounts[i];\r\n\r\n            if (!transferable[id]) revert NonTransferable();\r\n\r\n            if (permissioned[id])\r\n                if (!userPermissioned[to][id] || !userPermissioned[from][id])\r\n                    revert NotPermitted();\r\n\r\n            // If not transferring SIGN_KEY, update delegation balance.\r\n            // Otherwise, prevent transfer to SIGN_KEY holder.\r\n            if (id != SIGN_KEY)\r\n                _moveDelegates(\r\n                    delegates(from, id),\r\n                    delegates(to, id),\r\n                    id,\r\n                    amount\r\n                );\r\n            else if (balanceOf[to][id] != 0) revert Overflow();\r\n\r\n            balanceOf[from][id] -= amount;\r\n\r\n            // Cannot overflow because the sum of all user\r\n            // balances can't exceed the max uint256 value.\r\n            unchecked {\r\n                balanceOf[to][id] += amount;\r\n            }\r\n\r\n            // An array can't have a total length\r\n            // larger than the max uint256 value.\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\r\n\r\n        if (to.code.length != 0) {\r\n            if (\r\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(\r\n                    msg.sender,\r\n                    from,\r\n                    ids,\r\n                    amounts,\r\n                    data\r\n                ) != ERC1155TokenReceiver.onERC1155BatchReceived.selector\r\n            ) revert UnsafeRecipient();\r\n        } else if (to == address(0)) revert InvalidRecipient();\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// EIP-2612-style Permit Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function permit(\r\n        address owner,\r\n        address operator,\r\n        bool approved,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public payable virtual {\r\n        if (block.timestamp > deadline) revert ExpiredSig();\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                keccak256(\r\n                                    \"Permit(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\"\r\n                                ),\r\n                                owner,\r\n                                operator,\r\n                                approved,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            if (recoveredAddress == address(0)) revert InvalidSig();\r\n\r\n            if (recoveredAddress != owner) revert InvalidSig();\r\n\r\n            isApprovedForAll[recoveredAddress][operator] = approved;\r\n        }\r\n\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Checkpoint Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function getVotes(address account, uint256 id)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return getCurrentVotes(account, id);\r\n    }\r\n\r\n    function getCurrentVotes(address account, uint256 id)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        // Unchecked because subtraction only occurs if positive `nCheckpoints`.\r\n        unchecked {\r\n            uint256 nCheckpoints = numCheckpoints[account][id];\r\n\r\n            uint256 result;\r\n\r\n            if (nCheckpoints != 0)\r\n                result = checkpoints[account][id][nCheckpoints - 1].votes;\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function getPastVotes(\r\n        address account,\r\n        uint256 id,\r\n        uint256 timestamp\r\n    ) public view virtual returns (uint256) {\r\n        return getPriorVotes(account, id, timestamp);\r\n    }\r\n\r\n    function getPriorVotes(\r\n        address account,\r\n        uint256 id,\r\n        uint256 timestamp\r\n    ) public view virtual returns (uint256) {\r\n        if (block.timestamp <= timestamp) revert Undetermined();\r\n\r\n        uint256 nCheckpoints = numCheckpoints[account][id];\r\n\r\n        if (nCheckpoints == 0) return 0;\r\n\r\n        // Unchecked because subtraction only occurs if positive `nCheckpoints`.\r\n        unchecked {\r\n            uint256 prevCheckpoint = nCheckpoints - 1;\r\n\r\n            if (\r\n                checkpoints[account][id][prevCheckpoint].fromTimestamp <=\r\n                timestamp\r\n            ) return checkpoints[account][id][prevCheckpoint].votes;\r\n\r\n            if (checkpoints[account][id][0].fromTimestamp > timestamp) return 0;\r\n\r\n            uint256 lower;\r\n\r\n            uint256 upper = prevCheckpoint;\r\n\r\n            while (upper > lower) {\r\n                uint256 center = upper - (upper - lower) / 2;\r\n\r\n                Checkpoint memory cp = checkpoints[account][id][center];\r\n\r\n                if (cp.fromTimestamp == timestamp) {\r\n                    return cp.votes;\r\n                } else if (cp.fromTimestamp < timestamp) {\r\n                    lower = center;\r\n                } else {\r\n                    upper = center - 1;\r\n                }\r\n            }\r\n\r\n            return checkpoints[account][id][lower].votes;\r\n        }\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Delegation Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function delegates(address account, uint256 id)\r\n        public\r\n        view\r\n        virtual\r\n        returns (address)\r\n    {\r\n        address current = _delegates[account][id];\r\n\r\n        if (current == address(0)) current = account;\r\n\r\n        return current;\r\n    }\r\n\r\n    function delegate(address delegatee, uint256 id) public payable virtual {\r\n        _delegate(msg.sender, delegatee, id);\r\n    }\r\n\r\n    function delegateBySig(\r\n        address delegatee,\r\n        uint256 nonce,\r\n        uint256 deadline,\r\n        uint256 id,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public payable virtual {\r\n        if (block.timestamp > deadline) revert ExpiredSig();\r\n\r\n        address recoveredAddress = ecrecover(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(\r\n                        abi.encode(\r\n                            keccak256(\r\n                                \"Delegation(address delegatee,uint256 nonce,uint256 deadline,uint256 id)\"\r\n                            ),\r\n                            delegatee,\r\n                            nonce,\r\n                            deadline,\r\n                            id\r\n                        )\r\n                    )\r\n                )\r\n            ),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n\r\n        if (recoveredAddress == address(0)) revert InvalidSig();\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the delegator's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            if (nonce != nonces[recoveredAddress]++) revert InvalidSig();\r\n        }\r\n\r\n        _delegate(recoveredAddress, delegatee, id);\r\n    }\r\n\r\n    function _delegate(\r\n        address delegator,\r\n        address delegatee,\r\n        uint256 id\r\n    ) internal virtual {\r\n        address currentDelegate = delegates(delegator, id);\r\n\r\n        _delegates[delegator][id] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee, id);\r\n\r\n        _moveDelegates(\r\n            currentDelegate,\r\n            delegatee,\r\n            id,\r\n            balanceOf[delegator][id]\r\n        );\r\n    }\r\n\r\n    function _moveDelegates(\r\n        address srcRep,\r\n        address dstRep,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        if (srcRep != dstRep) {\r\n            if (amount != 0) {\r\n                if (srcRep != address(0)) {\r\n                    uint256 srcRepNum = numCheckpoints[srcRep][id];\r\n\r\n                    uint256 srcRepOld;\r\n\r\n                    // Unchecked because subtraction only occurs if positive `srcRepNum`.\r\n                    unchecked {\r\n                        srcRepOld = srcRepNum != 0\r\n                            ? checkpoints[srcRep][id][srcRepNum - 1].votes\r\n                            : 0;\r\n                    }\r\n\r\n                    _writeCheckpoint(\r\n                        srcRep,\r\n                        id,\r\n                        srcRepNum,\r\n                        srcRepOld,\r\n                        srcRepOld - amount\r\n                    );\r\n                }\r\n\r\n                if (dstRep != address(0)) {\r\n                    uint256 dstRepNum = numCheckpoints[dstRep][id];\r\n\r\n                    uint256 dstRepOld;\r\n\r\n                    // Unchecked because subtraction only occurs if positive `dstRepNum`.\r\n                    unchecked {\r\n                        if (dstRepNum != 0)\r\n                            dstRepOld = checkpoints[dstRep][id][dstRepNum - 1]\r\n                                .votes;\r\n                    }\r\n\r\n                    _writeCheckpoint(\r\n                        dstRep,\r\n                        id,\r\n                        dstRepNum,\r\n                        dstRepOld,\r\n                        dstRepOld + amount\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(\r\n        address delegatee,\r\n        uint256 id,\r\n        uint256 nCheckpoints,\r\n        uint256 oldVotes,\r\n        uint256 newVotes\r\n    ) internal virtual {\r\n        emit DelegateVotesChanged(delegatee, id, oldVotes, newVotes);\r\n\r\n        // Unchecked because subtraction only occurs if positive `nCheckpoints`.\r\n        unchecked {\r\n            if (nCheckpoints != 0) {\r\n                if (\r\n                    checkpoints[delegatee][id][nCheckpoints - 1]\r\n                        .fromTimestamp == block.timestamp\r\n                ) {\r\n                    checkpoints[delegatee][id][nCheckpoints - 1]\r\n                        .votes = _safeCastTo216(newVotes);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            checkpoints[delegatee][id][nCheckpoints] = Checkpoint(\r\n                _safeCastTo40(block.timestamp),\r\n                _safeCastTo216(newVotes)\r\n            );\r\n\r\n            // Unchecked because the only math done is incrementing\r\n            // checkpoints which cannot realistically overflow.\r\n            ++numCheckpoints[delegatee][id];\r\n        }\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Safecast Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function _safeCastTo40(uint256 x) internal pure virtual returns (uint40) {\r\n        if (x >= (1 << 40)) revert Overflow();\r\n\r\n        return uint40(x);\r\n    }\r\n\r\n    function _safeCastTo216(uint256 x) internal pure virtual returns (uint216) {\r\n        if (x >= (1 << 216)) revert Overflow();\r\n\r\n        return uint216(x);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Internal Mint/Burn Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) internal virtual {\r\n        _safeCastTo216(totalSupply[id] += amount);\r\n\r\n        // If not minting SIGN_KEY, update delegation balance.\r\n        // Otherwise, prevent minting to SIGN_KEY holder.\r\n        if (id != SIGN_KEY)\r\n            _moveDelegates(address(0), delegates(to, id), id, amount);\r\n        else if (balanceOf[to][id] != 0) revert Overflow();\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to][id] += amount;\r\n        }\r\n\r\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\r\n\r\n        if (to.code.length != 0) {\r\n            if (\r\n                ERC1155TokenReceiver(to).onERC1155Received(\r\n                    msg.sender,\r\n                    address(0),\r\n                    id,\r\n                    amount,\r\n                    data\r\n                ) != ERC1155TokenReceiver.onERC1155Received.selector\r\n            ) revert UnsafeRecipient();\r\n        } else if (to == address(0)) revert InvalidRecipient();\r\n    }\r\n\r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        balanceOf[from][id] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply[id] -= amount;\r\n        }\r\n\r\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\r\n\r\n        // If not burning SIGN_KEY, update delegation balance.\r\n        if (id != SIGN_KEY)\r\n            _moveDelegates(delegates(from, id), address(0), id, amount);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Internal Permission Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function _setTransferability(uint256 id, bool on) internal virtual {\r\n        transferable[id] = on;\r\n\r\n        emit TransferabilitySet(msg.sender, id, on);\r\n    }\r\n\r\n    function _setPermission(uint256 id, bool on) internal virtual {\r\n        permissioned[id] = on;\r\n\r\n        emit PermissionSet(msg.sender, id, on);\r\n    }\r\n\r\n    function _setUserPermission(\r\n        address to,\r\n        uint256 id,\r\n        bool on\r\n    ) internal virtual {\r\n        userPermissioned[to][id] = on;\r\n\r\n        emit UserPermissionSet(msg.sender, to, id, on);\r\n    }\r\n}\r\n\r\n/// @notice Contract that enables a single call to call multiple methods on itself.\r\n/// @author Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/Multicallable.sol)\r\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Multicallable.sol)\r\n/// @dev WARNING!\r\n/// Multicallable is NOT SAFE for use in contracts with checks / requires on `msg.value`\r\n/// (e.g. in NFT minting / auction contracts) without a suitable nonce mechanism.\r\n/// It WILL open up your contract to double-spend vulnerabilities / exploits.\r\n/// See: (https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/)\r\nabstract contract Multicallable {\r\n    /// @dev Apply `DELEGATECALL` with the current contract to each calldata in `data`,\r\n    /// and store the `abi.encode` formatted results of each `DELEGATECALL` into `results`.\r\n    /// If any of the `DELEGATECALL`s reverts, the entire transaction is reverted,\r\n    /// and the error is bubbled up.\r\n    function multicall(bytes[] calldata data)\r\n        public\r\n        payable\r\n        returns (bytes[] memory results)\r\n    {\r\n        assembly {\r\n            if data.length {\r\n                results := mload(0x40) // Point `results` to start of free memory.\r\n                mstore(results, data.length) // Store `data.length` into `results`.\r\n                results := add(results, 0x20)\r\n\r\n                // `shl` 5 is equivalent to multiplying by 0x20.\r\n                let end := shl(5, data.length)\r\n                // Copy the offsets from calldata into memory.\r\n                calldatacopy(results, data.offset, end)\r\n                // Pointer to the top of the memory (i.e. start of the free memory).\r\n                let memPtr := add(results, end)\r\n                end := add(results, end)\r\n\r\n                // prettier-ignore\r\n                for {} 1 {} {\r\n                    // The offset of the current bytes in the calldata.\r\n                    let o := add(data.offset, mload(results))\r\n                    // Copy the current bytes from calldata to the memory.\r\n                    calldatacopy(\r\n                        memPtr,\r\n                        add(o, 0x20), // The offset of the current bytes' bytes.\r\n                        calldataload(o) // The length of the current bytes.\r\n                    )\r\n                    if iszero(delegatecall(gas(), address(), memPtr, calldataload(o), 0x00, 0x00)) {\r\n                        // Bubble up the revert if the delegatecall reverts.\r\n                        returndatacopy(0x00, 0x00, returndatasize())\r\n                        revert(0x00, returndatasize())\r\n                    }\r\n                    // Append the current `memPtr` into `results`.\r\n                    mstore(results, memPtr)\r\n                    results := add(results, 0x20)\r\n                    // Append the `returndatasize()`, and the return data.\r\n                    mstore(memPtr, returndatasize())\r\n                    returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\r\n                    // Advance the `memPtr` by `returndatasize() + 0x20`,\r\n                    // rounded up to the next multiple of 32.\r\n                    memPtr := and(add(add(memPtr, returndatasize()), 0x3f), 0xffffffffffffffe0)\r\n                    // prettier-ignore\r\n                    if iszero(lt(results, end)) { break }\r\n                }\r\n                // Restore `results` and allocate memory for it.\r\n                results := mload(0x40)\r\n                mstore(0x40, memPtr)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Keep\r\n/// @notice Tokenized multisig wallet.\r\n/// @author z0r0z.eth\r\n/// @custom:coauthor @ControlCplusControlV\r\n/// @custom:coauthor boredretard.eth\r\n/// @custom:coauthor vectorized.eth\r\n/// @custom:coauthor horsefacts.eth\r\n/// @custom:coauthor shivanshi.eth\r\n/// @custom:coauthor @0xAlcibiades\r\n/// @custom:coauthor LeXpunK Army\r\n/// @custom:coauthor @0xmichalis\r\n/// @custom:coauthor @iFrostizz\r\n/// @custom:coauthor @m1guelpf\r\n/// @custom:coauthor @asnared\r\n/// @custom:coauthor @0xPhaze\r\n/// @custom:coauthor out.eth\r\n\r\nenum Operation {\r\n    call,\r\n    delegatecall,\r\n    create\r\n}\r\n\r\nstruct Call {\r\n    Operation op;\r\n    address to;\r\n    uint256 value;\r\n    bytes data;\r\n}\r\n\r\nstruct Signature {\r\n    address user;\r\n    uint8 v;\r\n    bytes32 r;\r\n    bytes32 s;\r\n}\r\n\r\ncontract Keep is ERC1155TokenReceiver, KeepToken, Multicallable {\r\n    /// -----------------------------------------------------------------------\r\n    /// Events\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @dev Emitted when Keep executes call.\r\n    event Executed(\r\n        uint256 indexed nonce,\r\n        Operation op,\r\n        address to,\r\n        uint256 value,\r\n        bytes data\r\n    );\r\n\r\n    /// @dev Emitted when quorum threshold is updated.\r\n    event QuorumSet(uint256 threshold);\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Custom Errors\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @dev Throws if `initialize()` is called more than once.\r\n    error AlreadyInit();\r\n\r\n    /// @dev Throws if quorum exceeds `totalSupply(SIGN_KEY)`.\r\n    error QuorumOverSupply();\r\n\r\n    /// @dev Throws if quorum with `threshold = 0` is set.\r\n    error InvalidThreshold();\r\n\r\n    /// @dev Throws if `execute()` doesn't complete operation.\r\n    error ExecuteFailed();\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Keep Storage/Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @dev The number which `s` must not exceed in order for\r\n    /// the signature to be non-malleable.\r\n    bytes32 internal constant MALLEABILITY_THRESHOLD =\r\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0;\r\n\r\n    /// @dev Core ID key permission.\r\n    uint256 internal immutable CORE_KEY = uint32(type(KeepToken).interfaceId);\r\n\r\n    /// @dev Default metadata fetcher for `uri()`.\r\n    Keep internal immutable uriFetcher;\r\n\r\n    /// @dev Record of states verifying `execute()`.\r\n    uint120 public nonce;\r\n\r\n    /// @dev SIGN_KEY threshold to `execute()`.\r\n    uint120 public quorum;\r\n\r\n    /// @dev Internal ID metadata mapping.\r\n    mapping(uint256 => string) internal _uris;\r\n\r\n    /// @dev ID metadata fetcher.\r\n    /// @param id ID to fetch from.\r\n    /// @return tokenURI Metadata.\r\n    function uri(uint256 id)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        string memory tokenURI = _uris[id];\r\n\r\n        if (bytes(tokenURI).length > 0) return tokenURI;\r\n        else return uriFetcher.uri(id);\r\n    }\r\n\r\n    /// @dev Access control check for ID key balance holders.\r\n    /// Initalizes with `address(this)` having implicit permission\r\n    /// without writing to storage by checking `totalSupply()` is zero.\r\n    /// Otherwise, this permission can be set to additional accounts,\r\n    /// including retaining `address(this)`, via `mint()`.\r\n    function _authorized() internal view virtual returns (bool) {\r\n        if (\r\n            (totalSupply[CORE_KEY] == 0 && msg.sender == address(this)) ||\r\n            balanceOf[msg.sender][CORE_KEY] != 0 ||\r\n            balanceOf[msg.sender][uint32(msg.sig)] != 0\r\n        ) return true;\r\n        else revert Unauthorized();\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// ERC165 Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @dev ERC165 interface detection.\r\n    /// @param interfaceId ID to check.\r\n    /// @return Fetch detection success.\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return\r\n            // ERC165 Interface ID for ERC721TokenReceiver.\r\n            interfaceId == this.onERC721Received.selector ||\r\n            // ERC165 Interface ID for ERC1155TokenReceiver.\r\n            interfaceId == type(ERC1155TokenReceiver).interfaceId ||\r\n            // ERC165 Interface IDs for ERC1155.\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// ERC721 Receiver Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) public payable virtual returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Initialization Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice Create Keep template.\r\n    /// @param _uriFetcher Metadata default.\r\n    constructor(Keep _uriFetcher) payable {\r\n        uriFetcher = _uriFetcher;\r\n\r\n        // Deploy as singleton.\r\n        quorum = 1;\r\n    }\r\n\r\n    /// @notice Initialize Keep configuration.\r\n    /// @param calls Initial Keep operations.\r\n    /// @param signers Initial signer set.\r\n    /// @param threshold Initial quorum.\r\n    function initialize(\r\n        Call[] calldata calls,\r\n        address[] calldata signers,\r\n        uint256 threshold\r\n    ) public payable virtual {\r\n        if (quorum != 0) revert AlreadyInit();\r\n\r\n        if (threshold == 0) revert InvalidThreshold();\r\n\r\n        if (threshold > signers.length) revert QuorumOverSupply();\r\n\r\n        if (calls.length != 0) {\r\n            for (uint256 i; i < calls.length; ) {\r\n                _execute(\r\n                    calls[i].op,\r\n                    calls[i].to,\r\n                    calls[i].value,\r\n                    calls[i].data\r\n                );\r\n\r\n                // An array can't have a total length\r\n                // larger than the max uint256 value.\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        address previous;\r\n        address signer;\r\n        uint256 supply;\r\n\r\n        for (uint256 i; i < signers.length; ) {\r\n            signer = signers[i];\r\n\r\n            // Prevent zero and duplicate signers.\r\n            if (previous >= signer) revert InvalidSig();\r\n\r\n            previous = signer;\r\n\r\n            emit TransferSingle(tx.origin, address(0), signer, SIGN_KEY, 1);\r\n\r\n            // An array can't have a total length\r\n            // larger than the max uint256 value.\r\n            unchecked {\r\n                ++balanceOf[signer][SIGN_KEY];\r\n                ++supply;\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        totalSupply[SIGN_KEY] = supply;\r\n        quorum = uint120(threshold);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Execution Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice Execute operation from Keep with signatures.\r\n    /// @param op Enum operation to execute.\r\n    /// @param to Address to send operation to.\r\n    /// @param value Amount of ETH to send in operation.\r\n    /// @param data Payload to send in operation.\r\n    /// @param sigs Array of Keep signatures in ascending order by addresses.\r\n    function execute(\r\n        Operation op,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Signature[] calldata sigs\r\n    ) public payable virtual {\r\n        // Begin signature validation with hashed inputs.\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR(),\r\n                keccak256(\r\n                    abi.encode(\r\n                        keccak256(\r\n                            \"Execute(uint8 op,address to,uint256 value,bytes data,uint120 nonce)\"\r\n                        ),\r\n                        op,\r\n                        to,\r\n                        value,\r\n                        keccak256(data),\r\n                        nonce\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        // Start zero in loop to ensure ascending addresses.\r\n        address previous;\r\n\r\n        // Validation is length of quorum threshold.\r\n        uint256 threshold = quorum;\r\n\r\n        // Store outside loop for gas optimization.\r\n        Signature calldata sig;\r\n\r\n        for (uint256 i; i < threshold; ) {\r\n            // Load signature items.\r\n            sig = sigs[i];\r\n            address user = sig.user;\r\n\r\n            // Check SIGN_KEY balance.\r\n            // This also confirms non-zero `user`.\r\n            if (balanceOf[user][SIGN_KEY] == 0) revert InvalidSig();\r\n\r\n            // Check signature recovery.\r\n            _recoverSig(hash, user, sig.v, sig.r, sig.s);\r\n\r\n            // Check against duplicates.\r\n            if (previous >= user) revert InvalidSig();\r\n\r\n            // Memo signature for next iteration until quorum.\r\n            previous = user;\r\n\r\n            // An array can't have a total length\r\n            // larger than the max uint256 value.\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        _execute(op, to, value, data);\r\n    }\r\n\r\n    function _recoverSig(\r\n        bytes32 hash,\r\n        address user,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal view virtual {\r\n        address signer;\r\n\r\n        // Perform signature recovery via ecrecover.\r\n        assembly {\r\n            // Copy the free memory pointer so that we can restore it later.\r\n            let m := mload(0x40)\r\n\r\n            // If `s` in lower half order, such that the signature is not malleable.\r\n            if iszero(gt(s, MALLEABILITY_THRESHOLD)) {\r\n                mstore(0x00, hash)\r\n                mstore(0x20, v)\r\n                mstore(0x40, r)\r\n                mstore(0x60, s)\r\n                pop(\r\n                    staticcall(\r\n                        gas(), // Amount of gas left for the transaction.\r\n                        0x01, // Address of `ecrecover`.\r\n                        0x00, // Start of input.\r\n                        0x80, // Size of input.\r\n                        0x40, // Start of output.\r\n                        0x20 // Size of output.\r\n                    )\r\n                )\r\n                // Restore the zero slot.\r\n                mstore(0x60, 0)\r\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\r\n                signer := mload(sub(0x60, returndatasize()))\r\n            }\r\n            // Restore the free memory pointer.\r\n            mstore(0x40, m)\r\n        }\r\n\r\n        // If recovery doesn't match `user`, verify contract signature with ERC1271.\r\n        if (user != signer) {\r\n            bool valid;\r\n\r\n            assembly {\r\n                // Load the free memory pointer.\r\n                // Simply using the free memory usually costs less if many slots are needed.\r\n                let m := mload(0x40)\r\n\r\n                // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\r\n                let f := shl(224, 0x1626ba7e)\r\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\r\n                mstore(add(m, 0x04), hash)\r\n                mstore(add(m, 0x24), 0x40) // The offset of the `signature` in the calldata.\r\n                mstore(add(m, 0x44), 65) // Store the length of the signature.\r\n                mstore(add(m, 0x64), r) // Store `r` of the signature.\r\n                mstore(add(m, 0x84), s) // Store `s` of the signature.\r\n                mstore8(add(m, 0xa4), v) // Store `v` of the signature.\r\n\r\n                valid := and(\r\n                    and(\r\n                        // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\r\n                        eq(mload(0x00), f),\r\n                        // Whether the returndata is exactly 0x20 bytes (1 word) long.\r\n                        eq(returndatasize(), 0x20)\r\n                    ),\r\n                    // Whether the staticcall does not revert.\r\n                    // This must be placed at the end of the `and` clause,\r\n                    // as the arguments are evaluated from right to left.\r\n                    staticcall(\r\n                        gas(), // Remaining gas.\r\n                        user, // The `user` address.\r\n                        m, // Offset of calldata in memory.\r\n                        0xa5, // Length of calldata in memory.\r\n                        0x00, // Offset of returndata.\r\n                        0x20 // Length of returndata to write.\r\n                    )\r\n                )\r\n            }\r\n\r\n            if (!valid) revert InvalidSig();\r\n        }\r\n    }\r\n\r\n    /// @notice Execute operations from Keep via `execute()` or as ID key holder.\r\n    /// @param calls Keep operations as arrays of `op, to, value, data`.\r\n    function multiexecute(Call[] calldata calls) public payable virtual {\r\n        _authorized();\r\n\r\n        for (uint256 i; i < calls.length; ) {\r\n            _execute(calls[i].op, calls[i].to, calls[i].value, calls[i].data);\r\n\r\n            // An array can't have a total length\r\n            // larger than the max uint256 value.\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _execute(\r\n        Operation op,\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        if (op == Operation.call) {\r\n            // Unchecked because the only math done is incrementing\r\n            // Keep nonce which cannot realistically overflow.\r\n            unchecked {\r\n                emit Executed(nonce++, op, to, value, data);\r\n            }\r\n\r\n            bool success;\r\n\r\n            assembly {\r\n                success := call(\r\n                    gas(),\r\n                    to,\r\n                    value,\r\n                    add(data, 0x20),\r\n                    mload(data),\r\n                    0,\r\n                    0\r\n                )\r\n            }\r\n\r\n            if (!success) revert ExecuteFailed();\r\n        } else if (op == Operation.delegatecall) {\r\n            // Unchecked because the only math done is incrementing\r\n            // Keep nonce which cannot realistically overflow.\r\n            unchecked {\r\n                emit Executed(nonce++, op, to, value, data);\r\n            }\r\n\r\n            bool success;\r\n\r\n            assembly {\r\n                success := delegatecall(\r\n                    gas(),\r\n                    to,\r\n                    add(data, 0x20),\r\n                    mload(data),\r\n                    0,\r\n                    0\r\n                )\r\n            }\r\n\r\n            if (!success) revert ExecuteFailed();\r\n        } else {\r\n            uint256 txNonce;\r\n\r\n            // Unchecked because the only math done is incrementing\r\n            // Keep nonce which cannot realistically overflow.\r\n            unchecked {\r\n                txNonce = nonce++;\r\n            }\r\n\r\n            assembly {\r\n                to := create(value, add(data, 0x20), mload(data))\r\n            }\r\n\r\n            if (to == address(0)) revert ExecuteFailed();\r\n\r\n            emit Executed(txNonce, op, to, value, data);\r\n        }\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Mint/Burn Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice ID minter.\r\n    /// @param to Recipient of mint.\r\n    /// @param id ID to mint.\r\n    /// @param amount ID balance to mint.\r\n    /// @param data Optional data payload.\r\n    function mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) public payable virtual {\r\n        _authorized();\r\n\r\n        _mint(to, id, amount, data);\r\n    }\r\n\r\n    /// @notice ID burner.\r\n    /// @param from Account to burn from.\r\n    /// @param id ID to burn.\r\n    /// @param amount Balance to burn.\r\n    function burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) public payable virtual {\r\n        if (msg.sender != from)\r\n            if (!isApprovedForAll[from][msg.sender])\r\n                if (!_authorized()) revert Unauthorized();\r\n\r\n        _burn(from, id, amount);\r\n\r\n        if (id == SIGN_KEY)\r\n            if (quorum > totalSupply[SIGN_KEY]) revert QuorumOverSupply();\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Threshold Setting Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice Update Keep quorum threshold.\r\n    /// @param threshold Signature threshold for `execute()`.\r\n    function setQuorum(uint256 threshold) public payable virtual {\r\n        _authorized();\r\n\r\n        if (threshold == 0) revert InvalidThreshold();\r\n\r\n        if (threshold > totalSupply[SIGN_KEY]) revert QuorumOverSupply();\r\n\r\n        quorum = uint120(threshold);\r\n\r\n        emit QuorumSet(threshold);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// ID Setting Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice ID transferability setting.\r\n    /// @param id ID to set transferability for.\r\n    /// @param on Transferability setting.\r\n    function setTransferability(uint256 id, bool on) public payable virtual {\r\n        _authorized();\r\n\r\n        _setTransferability(id, on);\r\n    }\r\n\r\n    /// @notice ID transfer permission toggle.\r\n    /// @param id ID to set permission for.\r\n    /// @param on Permission setting.\r\n    /// @dev This sets account-based ID restriction globally.\r\n    function setPermission(uint256 id, bool on) public payable virtual {\r\n        _authorized();\r\n\r\n        _setPermission(id, on);\r\n    }\r\n\r\n    /// @notice ID transfer permission setting.\r\n    /// @param to Account to set permission for.\r\n    /// @param id ID to set permission for.\r\n    /// @param on Permission setting.\r\n    /// @dev This sets account-based ID restriction specifically.\r\n    function setUserPermission(\r\n        address to,\r\n        uint256 id,\r\n        bool on\r\n    ) public payable virtual {\r\n        _authorized();\r\n\r\n        _setUserPermission(to, id, on);\r\n    }\r\n\r\n    /// @notice ID metadata setting.\r\n    /// @param id ID to set metadata for.\r\n    /// @param tokenURI Metadata setting.\r\n    function setURI(uint256 id, string calldata tokenURI)\r\n        public\r\n        payable\r\n        virtual\r\n    {\r\n        _authorized();\r\n\r\n        _uris[id] = tokenURI;\r\n\r\n        emit URI(tokenURI, id);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Keep\",\"name\":\"_uriFetcher\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExecuteFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpiredSig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonTransferable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPermitted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuorumOverSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Undetermined\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsafeRecipient\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toDelegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"DelegateVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Operation\",\"name\":\"op\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"PermissionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"QuorumSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"TransferabilitySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"UserPermissionSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"checkpoints\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"fromTimestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint216\",\"name\":\"votes\",\"type\":\"uint216\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"delegateBySig\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Operation\",\"name\":\"op\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Signature[]\",\"name\":\"sigs\",\"type\":\"tuple[]\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getCurrentVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getPastVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getPriorVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum Operation\",\"name\":\"op\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum Operation\",\"name\":\"op\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"multiexecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint120\",\"name\":\"\",\"type\":\"uint120\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"numCheckpoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"permissioned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorum\",\"outputs\":[{\"internalType\":\"uint120\",\"name\":\"\",\"type\":\"uint120\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"setPermission\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"setQuorum\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"setTransferability\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"setUserPermission\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userPermissioned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Keep","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"9999999","ConstructorArguments":"000000000000000000000000ccfc4897c01e3e0885aee45643868276894c40eb","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://033abf485509f013c8a90b2d568986694f269d6cb361a79c3a9fafc379a23692"}]