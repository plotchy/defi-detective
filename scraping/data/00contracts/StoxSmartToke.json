[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public constant returns (address owner) { owner; }\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public constant returns (string name) { name; }\r\n    function symbol() public constant returns (string symbol) { symbol; }\r\n    function decimals() public constant returns (uint8 decimals) { decimals; }\r\n    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n/*\r\n    Token Holder interface\r\n*/\r\ncontract ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n}\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is ITokenHolder, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n/*\r\n    Overflow protected math functions\r\n*/\r\ncontract SafeMath {\r\n    /**\r\n        constructor\r\n    */\r\n    function SafeMath() {\r\n    }\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\n/**\r\n    ERC20 Standard Token implementation\r\n*/\r\ncontract ERC20Token is IERC20Token, SafeMath {\r\n    string public standard = 'Token 0.1';\r\n    string public name = '';\r\n    string public symbol = '';\r\n    uint8 public decimals = 0;\r\n    uint256 public totalSupply = 0;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /**\r\n        @dev constructor\r\n\r\n        @param _name        token name\r\n        @param _symbol      token symbol\r\n        @param _decimals    decimal points, for display purposes\r\n    */\r\n    function ERC20Token(string _name, string _symbol, uint8 _decimals) {\r\n        require(bytes(_name).length > 0 && bytes(_symbol).length > 0); // validate input\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev send coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev an account/contract attempts to get the coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n\r\n        @param _from    source address\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        validAddress(_from)\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);\r\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev allow another account/contract to spend some tokens on your behalf\r\n        throws on any error rather then return a false flag to minimize user errors\r\n\r\n        also, to minimize the risk of the approve/transferFrom attack vector\r\n        (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\r\n        in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\r\n\r\n        @param _spender approved address\r\n        @param _value   allowance amount\r\n\r\n        @return true if the approval was successful, false if it wasn't\r\n    */\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        validAddress(_spender)\r\n        returns (bool success)\r\n    {\r\n        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\r\n        require(_value == 0 || allowance[msg.sender][_spender] == 0);\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n/*\r\n    Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract ownership\r\n        the new owner still need to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\n/*\r\n    We consider every contract to be a 'token holder' since it's currently not possible\r\n    for a contract to deny receiving tokens.\r\n\r\n    The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n    the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n*/\r\ncontract TokenHolder is ITokenHolder, Owned {\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function TokenHolder() {\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev withdraws tokens held by the contract and sends them to an account\r\n        can only be called by the owner\r\n\r\n        @param _token   ERC20 token contract address\r\n        @param _to      account to receive the new amount\r\n        @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        assert(_token.transfer(_to, _amount));\r\n    }\r\n}\r\n\r\n/*\r\n    Smart Token v0.2\r\n\r\n    'Owned' is specified here for readability reasons\r\n*/\r\ncontract SmartToken is ISmartToken, ERC20Token, Owned, TokenHolder {\r\n    string public version = '0.2';\r\n\r\n    bool public transfersEnabled = true;    // true if transfer/transferFrom are enabled, false if not\r\n\r\n    // triggered when a smart token is deployed - the _token address is defined for forward compatibility, in case we want to trigger the event from a factory\r\n    event NewSmartToken(address _token);\r\n    // triggered when the total supply is increased\r\n    event Issuance(uint256 _amount);\r\n    // triggered when the total supply is decreased\r\n    event Destruction(uint256 _amount);\r\n\r\n    /**\r\n        @dev constructor\r\n\r\n        @param _name       token name\r\n        @param _symbol     token short symbol, 1-6 characters\r\n        @param _decimals   for display purposes only\r\n    */\r\n    function SmartToken(string _name, string _symbol, uint8 _decimals)\r\n        ERC20Token(_name, _symbol, _decimals)\r\n    {\r\n        require(bytes(_symbol).length <= 6); // validate input\r\n        NewSmartToken(address(this));\r\n    }\r\n\r\n    // allows execution only when transfers aren't disabled\r\n    modifier transfersAllowed {\r\n        assert(transfersEnabled);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev disables/enables transfers\r\n        can only be called by the contract owner\r\n\r\n        @param _disable    true to disable transfers, false to enable them\r\n    */\r\n    function disableTransfers(bool _disable) public ownerOnly {\r\n        transfersEnabled = !_disable;\r\n    }\r\n\r\n    /**\r\n        @dev increases the token supply and sends the new tokens to an account\r\n        can only be called by the contract owner\r\n\r\n        @param _to         account to receive the new amount\r\n        @param _amount     amount to increase the supply by\r\n    */\r\n    function issue(address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        totalSupply = safeAdd(totalSupply, _amount);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _amount);\r\n\r\n        Issuance(_amount);\r\n        Transfer(this, _to, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev removes tokens from an account and decreases the token supply\r\n        can only be called by the contract owner\r\n\r\n        @param _from       account to remove the amount from\r\n        @param _amount     amount to decrease the supply by\r\n    */\r\n    function destroy(address _from, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n    {\r\n        balanceOf[_from] = safeSub(balanceOf[_from], _amount);\r\n        totalSupply = safeSub(totalSupply, _amount);\r\n\r\n        Transfer(_from, this, _amount);\r\n        Destruction(_amount);\r\n    }\r\n\r\n    // ERC20 standard method overrides with some extra functionality\r\n\r\n    /**\r\n        @dev send coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n        note that when transferring to the smart token's address, the coins are actually destroyed\r\n\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {\r\n        assert(super.transfer(_to, _value));\r\n\r\n        // transferring to the contract address destroys tokens\r\n        if (_to == address(this)) {\r\n            balanceOf[_to] -= _value;\r\n            totalSupply -= _value;\r\n            Destruction(_value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev an account/contract attempts to get the coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n        note that when transferring to the smart token's address, the coins are actually destroyed\r\n\r\n        @param _from    source address\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) {\r\n        assert(super.transferFrom(_from, _to, _value));\r\n\r\n        // transferring to the contract address destroys tokens\r\n        if (_to == address(this)) {\r\n            balanceOf[_to] -= _value;\r\n            totalSupply -= _value;\r\n            Destruction(_value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/// @title Ownable\r\n/// @dev The Ownable contract has an owner address, and provides basic authorization control functions, this simplifies\r\n/// & the implementation of \"user permissions\".\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed _by, address indexed _to);\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            throw;\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Proposes to transfer control of the contract to a newOwnerCandidate.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    function transferOwnership(address _newOwnerCandidate) onlyOwner {\r\n        require(_newOwnerCandidate != address(0));\r\n\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accept ownership transfer. This method needs to be called by the perviously proposed owner.\r\n    function acceptOwnership() {\r\n        if (msg.sender == newOwnerCandidate) {\r\n            owner = newOwnerCandidate;\r\n            newOwnerCandidate = address(0);\r\n\r\n            OwnershipTransferred(owner, newOwnerCandidate);\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Math operations with safety checks\r\nlibrary SaferMath {\r\n    function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n\r\n/// @title Stox Smart Token\r\ncontract StoxSmartToken is SmartToken {\r\n    function StoxSmartToken() SmartToken('Stox', 'STX', 18) {\r\n        disableTransfers(true);\r\n    }\r\n}\r\n\r\n\r\n/// @title Vesting trustee\r\ncontract Trustee is Ownable {\r\n    using SaferMath for uint256;\r\n\r\n    // The address of the STX ERC20 token.\r\n    StoxSmartToken public stox;\r\n\r\n    struct Grant {\r\n        uint256 value;\r\n        uint256 start;\r\n        uint256 cliff;\r\n        uint256 end;\r\n        uint256 transferred;\r\n        bool revokable;\r\n    }\r\n\r\n    // Grants holder.\r\n    mapping (address => Grant) public grants;\r\n\r\n    // Total tokens available for vesting.\r\n    uint256 public totalVesting;\r\n\r\n    event NewGrant(address indexed _from, address indexed _to, uint256 _value);\r\n    event UnlockGrant(address indexed _holder, uint256 _value);\r\n    event RevokeGrant(address indexed _holder, uint256 _refund);\r\n\r\n    /// @dev Constructor that initializes the address of the StoxSmartToken contract.\r\n    /// @param _stox StoxSmartToken The address of the previously deployed StoxSmartToken smart contract.\r\n    function Trustee(StoxSmartToken _stox) {\r\n        require(_stox != address(0));\r\n\r\n        stox = _stox;\r\n    }\r\n\r\n    /// @dev Grant tokens to a specified address.\r\n    /// @param _to address The address to grant tokens to.\r\n    /// @param _value uint256 The amount of tokens to be granted.\r\n    /// @param _start uint256 The beginning of the vesting period.\r\n    /// @param _cliff uint256 Duration of the cliff period.\r\n    /// @param _end uint256 The end of the vesting period.\r\n    /// @param _revokable bool Whether the grant is revokable or not.\r\n    function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end, bool _revokable)\r\n        public onlyOwner {\r\n        require(_to != address(0));\r\n        require(_value > 0);\r\n\r\n        // Make sure that a single address can be granted tokens only once.\r\n        require(grants[_to].value == 0);\r\n\r\n        // Check for date inconsistencies that may cause unexpected behavior.\r\n        require(_start <= _cliff && _cliff <= _end);\r\n\r\n        // Check that this grant doesn't exceed the total amount of tokens currently available for vesting.\r\n        require(totalVesting.add(_value) <= stox.balanceOf(address(this)));\r\n\r\n        // Assign a new grant.\r\n        grants[_to] = Grant({\r\n            value: _value,\r\n            start: _start,\r\n            cliff: _cliff,\r\n            end: _end,\r\n            transferred: 0,\r\n            revokable: _revokable\r\n        });\r\n\r\n        // Tokens granted, reduce the total amount available for vesting.\r\n        totalVesting = totalVesting.add(_value);\r\n\r\n        NewGrant(msg.sender, _to, _value);\r\n    }\r\n\r\n    /// @dev Revoke the grant of tokens of a specifed address.\r\n    /// @param _holder The address which will have its tokens revoked.\r\n    function revoke(address _holder) public onlyOwner {\r\n        Grant grant = grants[_holder];\r\n\r\n        require(grant.revokable);\r\n\r\n        // Send the remaining STX back to the owner.\r\n        uint256 refund = grant.value.sub(grant.transferred);\r\n\r\n        // Remove the grant.\r\n        delete grants[_holder];\r\n\r\n        totalVesting = totalVesting.sub(refund);\r\n        stox.transfer(msg.sender, refund);\r\n\r\n        RevokeGrant(_holder, refund);\r\n    }\r\n\r\n    /// @dev Calculate the total amount of vested tokens of a holder at a given time.\r\n    /// @param _holder address The address of the holder.\r\n    /// @param _time uint256 The specific time.\r\n    /// @return a uint256 representing a holder's total amount of vested tokens.\r\n    function vestedTokens(address _holder, uint256 _time) public constant returns (uint256) {\r\n        Grant grant = grants[_holder];\r\n        if (grant.value == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return calculateVestedTokens(grant, _time);\r\n    }\r\n\r\n    /// @dev Calculate amount of vested tokens at a specifc time.\r\n    /// @param _grant Grant The vesting grant.\r\n    /// @param _time uint256 The time to be checked\r\n    /// @return An uint256 representing the amount of vested tokens of a specific grant.\r\n    ///   |                         _/--------   vestedTokens rect\r\n    ///   |                       _/\r\n    ///   |                     _/\r\n    ///   |                   _/\r\n    ///   |                 _/\r\n    ///   |                /\r\n    ///   |              .|\r\n    ///   |            .  |\r\n    ///   |          .    |\r\n    ///   |        .      |\r\n    ///   |      .        |\r\n    ///   |    .          |\r\n    ///   +===+===========+---------+----------> time\r\n    ///     Start       Cliff      End\r\n    function calculateVestedTokens(Grant _grant, uint256 _time) private constant returns (uint256) {\r\n        // If we're before the cliff, then nothing is vested.\r\n        if (_time < _grant.cliff) {\r\n            return 0;\r\n        }\r\n\r\n        // If we're after the end of the vesting period - everything is vested;\r\n        if (_time >= _grant.end) {\r\n            return _grant.value;\r\n        }\r\n\r\n        // Interpolate all vested tokens: vestedTokens = tokens/// (time - start) / (end - start)\r\n         return _grant.value.mul(_time.sub(_grant.start)).div(_grant.end.sub(_grant.start));\r\n    }\r\n\r\n    /// @dev Unlock vested tokens and transfer them to their holder.\r\n    /// @return a uint256 representing the amount of vested tokens transferred to their holder.\r\n    function unlockVestedTokens() public {\r\n        Grant grant = grants[msg.sender];\r\n        require(grant.value != 0);\r\n\r\n        // Get the total amount of vested tokens, acccording to grant.\r\n        uint256 vested = calculateVestedTokens(grant, now);\r\n        if (vested == 0) {\r\n            return;\r\n        }\r\n\r\n        // Make sure the holder doesn't transfer more than what he already has.\r\n        uint256 transferable = vested.sub(grant.transferred);\r\n        if (transferable == 0) {\r\n            return;\r\n        }\r\n\r\n        grant.transferred = grant.transferred.add(transferable);\r\n        totalVesting = totalVesting.sub(transferable);\r\n        stox.transfer(msg.sender, transferable);\r\n\r\n        UnlockGrant(msg.sender, transferable);\r\n    }\r\n}\r\n\r\n\r\n/// @title Stox Smart Token sale\r\ncontract StoxSmartTokenSale is Ownable {\r\n    using SaferMath for uint256;\r\n\r\n    uint256 public constant DURATION = 14 days;\r\n\r\n    bool public isFinalized = false;\r\n    bool public isDistributed = false;\r\n\r\n    // The address of the STX ERC20 token.\r\n    StoxSmartToken public stox;\r\n\r\n    // The address of the token allocation trustee;\r\n    Trustee public trustee;\r\n\r\n    uint256 public startTime = 0;\r\n    uint256 public endTime = 0;\r\n    address public fundingRecipient;\r\n\r\n    uint256 public tokensSold = 0;\r\n\r\n    // TODO: update to the correct values.\r\n    uint256 public constant ETH_CAP = 148000;\r\n    uint256 public constant EXCHANGE_RATE = 200; // 200 STX for ETH\r\n    uint256 public constant TOKEN_SALE_CAP = ETH_CAP * EXCHANGE_RATE * 10 ** 18;\r\n\r\n    event TokensIssued(address indexed _to, uint256 _tokens);\r\n\r\n    /// @dev Throws if called when not during sale.\r\n    modifier onlyDuringSale() {\r\n        if (tokensSold >= TOKEN_SALE_CAP || now < startTime || now >= endTime) {\r\n            throw;\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Throws if called before sale ends.\r\n    modifier onlyAfterSale() {\r\n        if (!(tokensSold >= TOKEN_SALE_CAP || now >= endTime)) {\r\n            throw;\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Constructor that initializes the sale conditions.\r\n    /// @param _fundingRecipient address The address of the funding recipient.\r\n    /// @param _startTime uint256 The start time of the token sale.\r\n    function StoxSmartTokenSale(address _stox, address _fundingRecipient, uint256 _startTime) {\r\n        require(_stox != address(0));\r\n        require(_fundingRecipient != address(0));\r\n        require(_startTime > now);\r\n\r\n        stox = StoxSmartToken(_stox);\r\n\r\n        fundingRecipient = _fundingRecipient;\r\n        startTime = _startTime;\r\n        endTime = startTime + DURATION;\r\n    }\r\n\r\n    /// @dev Distributed tokens to the partners who have participated during the pre-sale.\r\n    function distributePartnerTokens() external onlyOwner {\r\n        require(!isDistributed);\r\n\r\n        assert(tokensSold == 0);\r\n        assert(stox.totalSupply() == 0);\r\n\r\n        // Distribute strategic tokens to partners. Please note, that this address doesn't represent a single entity or\r\n        // person and will be only used to distribute tokens to 30~ partners.\r\n        //\r\n        // Please expect to see token transfers from this address in the first 24 hours after the token sale ends.\r\n        issueTokens(0x9065260ef6830f6372F1Bde408DeC57Fe3150530, 14800000 * 10 ** 18);\r\n\r\n        isDistributed = true;\r\n    }\r\n\r\n    /// @dev Finalizes the token sale event.\r\n    function finalize() external onlyAfterSale {\r\n        if (isFinalized) {\r\n            throw;\r\n        }\r\n\r\n        // Grant vesting grants.\r\n        //\r\n        // TODO: use real addresses.\r\n        trustee = new Trustee(stox);\r\n\r\n        // Since only 50% of the tokens will be sold, we will automatically issue the same amount of sold STX to the\r\n        // trustee.\r\n        uint256 unsoldTokens = tokensSold;\r\n\r\n        // Issue 55% of the remaining tokens (== 27.5%) go to strategic parternships.\r\n        uint256 strategicPartnershipTokens = unsoldTokens.mul(55).div(100);\r\n\r\n        // Note: we will substract the bonus tokens from this grant, since they were already issued for the pre-sale\r\n        // strategic partners and should've been taken from this allocation.\r\n        stox.issue(0xbC14105ccDdeAadB96Ba8dCE18b40C45b6bACf58, strategicPartnershipTokens);\r\n\r\n        // Issue the remaining tokens as vesting grants:\r\n        stox.issue(trustee, unsoldTokens.sub(strategicPartnershipTokens));\r\n\r\n        // 25% of the remaining tokens (== 12.5%) go to Invest.com, at uniform 12 months vesting schedule.\r\n        trustee.grant(0xb54c6a870d4aD65e23d471Fb7941aD271D323f5E, unsoldTokens.mul(25).div(100), now, now,\r\n            now.add(1 years), true);\r\n\r\n        // 20% of the remaining tokens (== 10%) go to Stox team, at uniform 24 months vesting schedule.\r\n        trustee.grant(0x4eB4Cd1D125d9d281709Ff38d65b99a6927b46c1, unsoldTokens.mul(20).div(100), now, now,\r\n            now.add(2 years), true);\r\n\r\n        // Re-enable transfers after the token sale.\r\n        stox.disableTransfers(false);\r\n\r\n        isFinalized = true;\r\n    }\r\n\r\n    /// @dev Create and sell tokens to the caller.\r\n    /// @param _recipient address The address of the recipient.\r\n    function create(address _recipient) public payable onlyDuringSale {\r\n        require(_recipient != address(0));\r\n        require(msg.value > 0);\r\n\r\n        assert(isDistributed);\r\n\r\n        uint256 tokens = SaferMath.min256(msg.value.mul(EXCHANGE_RATE), TOKEN_SALE_CAP.sub(tokensSold));\r\n        uint256 contribution = tokens.div(EXCHANGE_RATE);\r\n\r\n        issueTokens(_recipient, tokens);\r\n\r\n        // Transfer the funds to the funding recipient.\r\n        fundingRecipient.transfer(contribution);\r\n\r\n        // Refund the msg.sender, in the case that not all of its ETH was used. This can happen only when selling the\r\n        // last chunk of STX.\r\n        uint256 refund = msg.value.sub(contribution);\r\n        if (refund > 0) {\r\n            msg.sender.transfer(refund);\r\n        }\r\n    }\r\n\r\n    /// @dev Issues tokens for the recipient.\r\n    /// @param _recipient address The address of the recipient.\r\n    /// @param _tokens uint256 The amount of tokens to issue.\r\n    function issueTokens(address _recipient, uint256 _tokens) private {\r\n        // Update total sold tokens.\r\n        tokensSold = tokensSold.add(_tokens);\r\n\r\n        stox.issue(_recipient, _tokens);\r\n\r\n        TokensIssued(_recipient, _tokens);\r\n    }\r\n\r\n    /// @dev Fallback function that will delegate the request to create.\r\n    function () external payable onlyDuringSale {\r\n        create(msg.sender);\r\n    }\r\n\r\n    /// @dev Proposes to transfer control of the StoxSmartToken contract to a new owner.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    ///\r\n    /// Note that:\r\n    ///   1. The new owner will need to call StoxSmartToken's acceptOwnership directly in order to accept the ownership.\r\n    ///   2. Calling this method during the token sale will prevent the token sale to continue, since only the owner of\r\n    ///      the StoxSmartToken contract can issue new tokens.\r\n    function transferSmartTokenOwnership(address _newOwnerCandidate) external onlyOwner {\r\n        stox.transferOwnership(_newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accepts new ownership on behalf of the StoxSmartToken contract. This can be used, by the token sale\r\n    /// contract itself to claim back ownership of the StoxSmartToken contract.\r\n    function acceptSmartTokenOwnership() external onlyOwner {\r\n        stox.acceptOwnership();\r\n    }\r\n\r\n    /// @dev Proposes to transfer control of the Trustee contract to a new owner.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    ///\r\n    /// Note that:\r\n    ///   1. The new owner will need to call Trustee's acceptOwnership directly in order to accept the ownership.\r\n    ///   2. Calling this method during the token sale won't be possible, as the Trustee is only created after its\r\n    ///      finalization.\r\n    function transferTrusteeOwnership(address _newOwnerCandidate) external onlyOwner {\r\n        trustee.transferOwnership(_newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accepts new ownership on behalf of the Trustee contract. This can be used, by the token sale\r\n    /// contract itself to claim back ownership of the Trustee contract.\r\n    function acceptTrusteeOwnership() external onlyOwner {\r\n        trustee.acceptOwnership();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disable\",\"type\":\"bool\"}],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"NewSmartToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Issuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Destruction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"StoxSmartToken","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://7005dfc56dca66631199f0571f344e340c32495dc02b7aa85d189a081bc3d609"}]