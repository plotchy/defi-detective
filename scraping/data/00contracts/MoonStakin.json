[{"SourceCode":"pragma solidity ^0.8.7;\r\n// SPDX-License-Identifier: MIT\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\r\n/**\r\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\r\n *\r\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\r\n * stuck.\r\n *\r\n * @dev _Available since v3.1._\r\n */\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n\r\n\r\ncontract MoonStaking is ERC1155Holder, Ownable, ReentrancyGuard {\r\n    IERC721 public ApeNft;\r\n    IERC721 public LootNft;\r\n    IERC1155 public PetNft;\r\n    IERC721 public TreasuryNft;\r\n    IERC721 public BreedingNft;\r\n\r\n    uint256 public constant SECONDS_IN_DAY = 86400;\r\n\r\n    bool public stakingLaunched;\r\n    bool public depositPaused;\r\n\r\n    mapping(address => mapping(uint256 => uint256)) stakerPetAmounts;\r\n    mapping(address => mapping(uint256 => uint256)) stakerApeLoot;\r\n\r\n    struct Staker {\r\n      uint256 currentYield;\r\n      uint256 accumulatedAmount;\r\n      uint256 lastCheckpoint;\r\n      uint256[] stakedAPE;\r\n      uint256[] stakedTREASURY;\r\n      uint256[] stakedBREEDING;\r\n      uint256[] stakedPET;\r\n    }\r\n\r\n    mapping(address => Staker) private _stakers;\r\n\r\n    enum ContractTypes {\r\n      APE,\r\n      LOOT,\r\n      PET,\r\n      TREASURY,\r\n      BREEDING\r\n    }\r\n\r\n    mapping(address => ContractTypes) private _contractTypes;\r\n\r\n    mapping(address => uint256) public _baseRates;\r\n    mapping(address => mapping(uint256 => uint256)) private _individualRates;\r\n    mapping(address => mapping(uint256 => address)) private _ownerOfToken;\r\n    mapping (address => bool) private _authorised;\r\n    address[] public authorisedLog;\r\n\r\n    event Stake721(address indexed staker,address contractAddress,uint256 tokensAmount);\r\n    event StakeApesWithLoots(address indexed staker,uint256 apesAmount);\r\n    event AddLootToStakedApes(address indexed staker,uint256 apesAmount);\r\n    event RemoveLootFromStakedApes(address indexed staker,uint256 lootsAmount);\r\n    event StakePets(address indexed staker,uint256 numberOfPetIds);\r\n    event Unstake721(address indexed staker,address contractAddress,uint256 tokensAmount);\r\n    event UnstakePets(address indexed staker,uint256 numberOfPetIds);\r\n    event ForceWithdraw721(address indexed receiver, address indexed tokenAddress, uint256 indexed tokenId);\r\n    \r\n\r\n    constructor(address _ape) {\r\n        ApeNft = IERC721(_ape);\r\n        _contractTypes[_ape] = ContractTypes.APE;\r\n        _baseRates[_ape] = 150 ether;\r\n    }\r\n\r\n    modifier authorised() {\r\n      require(_authorised[_msgSender()], \"The token contract is not authorised\");\r\n        _;\r\n    }\r\n\r\n    function stake721(address contractAddress, uint256[] memory tokenIds) public nonReentrant {\r\n      require(!depositPaused, \"Deposit paused\");\r\n      require(stakingLaunched, \"Staking is not launched yet\");\r\n      require(contractAddress != address(0) && contractAddress == address(ApeNft) || contractAddress == address(TreasuryNft) || contractAddress == address(BreedingNft), \"Unknown contract or staking is not yet enabled for this NFT\");\r\n      ContractTypes contractType = _contractTypes[contractAddress];\r\n\r\n      Staker storage user = _stakers[_msgSender()];\r\n      uint256 newYield = user.currentYield;\r\n\r\n      for (uint256 i; i < tokenIds.length; i++) {\r\n        require(IERC721(contractAddress).ownerOf(tokenIds[i]) == _msgSender(), \"Not the owner of staking NFT\");\r\n        IERC721(contractAddress).safeTransferFrom(_msgSender(), address(this), tokenIds[i]);\r\n\r\n        _ownerOfToken[contractAddress][tokenIds[i]] = _msgSender();\r\n\r\n        newYield += getTokenYield(contractAddress, tokenIds[i]);\r\n\r\n        if (contractType == ContractTypes.APE) { user.stakedAPE.push(tokenIds[i]); }\r\n        if (contractType == ContractTypes.BREEDING) { user.stakedBREEDING.push(tokenIds[i]); }\r\n        if (contractType == ContractTypes.TREASURY) { user.stakedTREASURY.push(tokenIds[i]); }\r\n      }\r\n\r\n      accumulate(_msgSender());\r\n      user.currentYield = newYield;\r\n\r\n      emit Stake721(_msgSender(), contractAddress, tokenIds.length);\r\n    }\r\n\r\n    function stake1155(uint256[] memory tokenIds, uint256[] memory amounts) public nonReentrant {\r\n      require(!depositPaused, \"Deposit paused\");\r\n      require(stakingLaunched, \"Staking is not launched yet\");\r\n      require(address(PetNft) != address(0), \"Moon Pets staking is not yet enabled\");\r\n\r\n      Staker storage user = _stakers[_msgSender()];\r\n      uint256 newYield = user.currentYield;\r\n\r\n      for (uint256 i; i < tokenIds.length; i++) {\r\n        require(amounts[i] > 0, \"Invalid amount\");\r\n        require(PetNft.balanceOf(_msgSender(), tokenIds[i]) >= amounts[i], \"Not the owner of staking Pet or insufficiant balance of staking Pet\");\r\n\r\n        newYield += getPetTokenYield(tokenIds[i], amounts[i]);\r\n        if (stakerPetAmounts[_msgSender()][tokenIds[i]] == 0){\r\n            user.stakedPET.push(tokenIds[i]);\r\n        }\r\n        stakerPetAmounts[_msgSender()][tokenIds[i]] += amounts[i];\r\n      }\r\n\r\n      PetNft.safeBatchTransferFrom(_msgSender(), address(this), tokenIds, amounts, \"\");\r\n\r\n      accumulate(_msgSender());\r\n      user.currentYield = newYield;\r\n\r\n      emit StakePets(_msgSender(), tokenIds.length);\r\n    }\r\n\r\n    function addLootToStakedApes(uint256[] memory apeIds, uint256[] memory lootIds) public nonReentrant {\r\n      require(!depositPaused, \"Deposit paused\");\r\n      require(stakingLaunched, \"Staking is not launched yet\");\r\n      require(apeIds.length == lootIds.length, \"Lists not same length\");\r\n      require(address(LootNft) != address(0), \"Loot Bags staking is not yet enabled\");\r\n\r\n      Staker storage user = _stakers[_msgSender()];\r\n      uint256 newYield = user.currentYield;\r\n\r\n      for (uint256 i; i < apeIds.length; i++) {\r\n        require(_ownerOfToken[address(ApeNft)][apeIds[i]] == _msgSender(), \"Not the owner of staked Ape\");\r\n        require(stakerApeLoot[_msgSender()][apeIds[i]] == 0, \"Selected staked Ape already has Loot staked together\");\r\n        require(lootIds[i] > 0, \"Invalid Loot NFT\");\r\n        require(IERC721(address(LootNft)).ownerOf(lootIds[i]) == _msgSender(), \"Not the owner of staking Loot\");\r\n        IERC721(address(LootNft)).safeTransferFrom(_msgSender(), address(this), lootIds[i]);\r\n\r\n        _ownerOfToken[address(LootNft)][lootIds[i]] = _msgSender();\r\n\r\n        newYield += getApeLootTokenYield(apeIds[i], lootIds[i]) - getTokenYield(address(ApeNft), apeIds[i]);\r\n\r\n        stakerApeLoot[_msgSender()][apeIds[i]] = lootIds[i];\r\n      }\r\n\r\n      accumulate(_msgSender());\r\n      user.currentYield = newYield;\r\n\r\n      emit AddLootToStakedApes(_msgSender(), apeIds.length);\r\n    }\r\n\r\n    function removeLootFromStakedApes(uint256[] memory apeIds) public nonReentrant{\r\n       Staker storage user = _stakers[_msgSender()];\r\n       uint256 newYield = user.currentYield;\r\n\r\n       for (uint256 i; i < apeIds.length; i++) {\r\n        require(_ownerOfToken[address(ApeNft)][apeIds[i]] == _msgSender(), \"Not the owner of staked Ape\");\r\n        uint256 ape_loot = stakerApeLoot[_msgSender()][apeIds[i]];\r\n        require(ape_loot > 0, \"Selected staked Ape does not have any Loot staked with\");\r\n        require(_ownerOfToken[address(LootNft)][ape_loot] == _msgSender(), \"Not the owner of staked Ape\");\r\n        IERC721(address(LootNft)).safeTransferFrom(address(this), _msgSender(), ape_loot);\r\n\r\n        _ownerOfToken[address(LootNft)][ape_loot] = address(0);\r\n\r\n        newYield -= getApeLootTokenYield(apeIds[i], ape_loot);\r\n        newYield += getTokenYield(address(ApeNft), apeIds[i]);\r\n\r\n        stakerApeLoot[_msgSender()][apeIds[i]] = 0;\r\n      }\r\n\r\n      accumulate(_msgSender());\r\n      user.currentYield = newYield;\r\n\r\n      emit RemoveLootFromStakedApes(_msgSender(), apeIds.length);\r\n    }\r\n\r\n    function stakeApesWithLoots(uint256[] memory apeIds, uint256[] memory lootIds) public nonReentrant {\r\n      require(!depositPaused, \"Deposit paused\");\r\n      require(stakingLaunched, \"Staking is not launched yet\");\r\n      require(apeIds.length == lootIds.length, \"Lists not same length\");\r\n      require(address(LootNft) != address(0), \"Loot Bags staking is not yet enabled\");\r\n\r\n      Staker storage user = _stakers[_msgSender()];\r\n      uint256 newYield = user.currentYield;\r\n\r\n      for (uint256 i; i < apeIds.length; i++) {\r\n        require(IERC721(address(ApeNft)).ownerOf(apeIds[i]) == _msgSender(), \"Not the owner of staking Ape\");\r\n        if (lootIds[i] > 0){\r\n          require(IERC721(address(LootNft)).ownerOf(lootIds[i]) == _msgSender(), \"Not the owner of staking Loot\");\r\n          IERC721(address(LootNft)).safeTransferFrom(_msgSender(), address(this), lootIds[i]);\r\n          _ownerOfToken[address(LootNft)][lootIds[i]] = _msgSender();\r\n          stakerApeLoot[_msgSender()][apeIds[i]] = lootIds[i];\r\n        }\r\n        \r\n        IERC721(address(ApeNft)).safeTransferFrom(_msgSender(), address(this), apeIds[i]);\r\n        _ownerOfToken[address(ApeNft)][apeIds[i]] = _msgSender();\r\n        \r\n        newYield += getApeLootTokenYield(apeIds[i], lootIds[i]);\r\n        user.stakedAPE.push(apeIds[i]);\r\n      }\r\n\r\n      accumulate(_msgSender());\r\n      user.currentYield = newYield;\r\n\r\n      emit StakeApesWithLoots(_msgSender(), apeIds.length);\r\n    }\r\n\r\n    function unstake721(address contractAddress, uint256[] memory tokenIds) public nonReentrant {\r\n      require(contractAddress != address(0) && contractAddress == address(ApeNft) || contractAddress == address(TreasuryNft) || contractAddress == address(BreedingNft), \"Unknown contract or staking is not yet enabled for this NFT\");\r\n      ContractTypes contractType = _contractTypes[contractAddress];\r\n      Staker storage user = _stakers[_msgSender()];\r\n      uint256 newYield = user.currentYield;\r\n\r\n      for (uint256 i; i < tokenIds.length; i++) {\r\n        require(IERC721(contractAddress).ownerOf(tokenIds[i]) == address(this), \"Not the owner\");\r\n\r\n        _ownerOfToken[contractAddress][tokenIds[i]] = address(0);\r\n\r\n        if (user.currentYield != 0) {\r\n            if (contractType == ContractTypes.APE){\r\n                uint256 ape_loot = stakerApeLoot[_msgSender()][tokenIds[i]];\r\n                uint256 tokenYield = getApeLootTokenYield(tokenIds[i], ape_loot);\r\n                newYield -= tokenYield;\r\n                if (ape_loot > 0){\r\n                  IERC721(address(LootNft)).safeTransferFrom(address(this), _msgSender(), ape_loot);\r\n                  _ownerOfToken[address(LootNft)][ape_loot] = address(0);\r\n                }\r\n                \r\n            } else {\r\n                uint256 tokenYield = getTokenYield(contractAddress, tokenIds[i]);\r\n                newYield -= tokenYield;\r\n            }\r\n        }\r\n\r\n        if (contractType == ContractTypes.APE) {\r\n          user.stakedAPE = _prepareForDeletion(user.stakedAPE, tokenIds[i]);\r\n          user.stakedAPE.pop();\r\n          stakerApeLoot[_msgSender()][tokenIds[i]] = 0;\r\n        }\r\n        if (contractType == ContractTypes.TREASURY) {\r\n          user.stakedTREASURY = _prepareForDeletion(user.stakedTREASURY, tokenIds[i]);\r\n          user.stakedTREASURY.pop();\r\n        }\r\n        if (contractType == ContractTypes.BREEDING) {\r\n          user.stakedBREEDING = _prepareForDeletion(user.stakedBREEDING, tokenIds[i]);\r\n          user.stakedBREEDING.pop();\r\n        }\r\n\r\n        IERC721(contractAddress).safeTransferFrom(address(this), _msgSender(), tokenIds[i]);\r\n      }\r\n\r\n      if (user.stakedAPE.length == 0 && user.stakedTREASURY.length == 0 && user.stakedPET.length == 0 && user.stakedBREEDING.length == 0) {\r\n        newYield = 0;\r\n      }\r\n\r\n      accumulate(_msgSender());\r\n      user.currentYield = newYield;\r\n\r\n      emit Unstake721(_msgSender(), contractAddress, tokenIds.length);\r\n    }\r\n\r\n    function unstake1155(uint256[] memory tokenIds) public nonReentrant {\r\n      Staker storage user = _stakers[_msgSender()];\r\n      uint256 newYield = user.currentYield;\r\n      uint256[] memory transferAmounts = new uint256[](tokenIds.length);\r\n\r\n      for (uint256 i; i < tokenIds.length; i++) {\r\n        require(stakerPetAmounts[_msgSender()][tokenIds[i]] > 0, \"Not the owner of staked Pet\");\r\n        transferAmounts[i] = stakerPetAmounts[_msgSender()][tokenIds[i]];\r\n\r\n        newYield -= getPetTokenYield(tokenIds[i], transferAmounts[i]);\r\n\r\n        user.stakedPET = _prepareForDeletion(user.stakedPET, tokenIds[i]);\r\n        user.stakedPET.pop();\r\n        stakerPetAmounts[_msgSender()][tokenIds[i]] = 0;\r\n      }\r\n\r\n      if (user.stakedAPE.length == 0 && user.stakedTREASURY.length == 0 && user.stakedPET.length == 0 && user.stakedBREEDING.length == 0) {\r\n        newYield = 0;\r\n      }\r\n      PetNft.safeBatchTransferFrom(address(this), _msgSender(), tokenIds, transferAmounts, \"\");\r\n\r\n      accumulate(_msgSender());\r\n      user.currentYield = newYield;\r\n\r\n      emit UnstakePets(_msgSender(), tokenIds.length);\r\n    }\r\n\r\n    function getTokenYield(address contractAddress, uint256 tokenId) public view returns (uint256) {\r\n      uint256 tokenYield = _individualRates[contractAddress][tokenId];\r\n      if (tokenYield == 0) { tokenYield = _baseRates[contractAddress]; }\r\n\r\n      return tokenYield;\r\n    }\r\n\r\n    function getApeLootTokenYield(uint256 apeId, uint256 lootId) public view returns (uint256){\r\n        uint256 apeYield = _individualRates[address(ApeNft)][apeId];\r\n        if (apeYield == 0) { apeYield = _baseRates[address(ApeNft)]; }\r\n\r\n        uint256 lootBoost = _individualRates[address(LootNft)][lootId];\r\n        if (lootId == 0){\r\n            lootBoost = 10;\r\n        } else {\r\n            if (lootBoost == 0) { lootBoost = _baseRates[address(LootNft)]; }\r\n        }\r\n        \r\n        return apeYield * lootBoost / 10;\r\n    }\r\n\r\n    function getPetTokenYield(uint256 petId, uint256 amount) public view returns(uint256){\r\n        uint256 petYield = _individualRates[address(PetNft)][petId];\r\n        if (petYield == 0) { petYield = _baseRates[address(PetNft)]; }\r\n        return petYield * amount;\r\n    }\r\n\r\n    function getStakerYield(address staker) public view returns (uint256) {\r\n      return _stakers[staker].currentYield;\r\n    }\r\n\r\n    function getStakerNFT(address staker) public view returns (uint256[] memory, uint256[] memory, uint256[] memory, uint256[] memory, uint256[] memory) {\r\n        uint256[] memory lootIds = new uint256[](_stakers[staker].stakedAPE.length);\r\n        uint256[] memory petAmounts = new uint256[](8);\r\n        for (uint256 i; i < _stakers[staker].stakedAPE.length; i++){\r\n            lootIds[i] = stakerApeLoot[staker][_stakers[staker].stakedAPE[i]];\r\n        }\r\n        for (uint256 i; i < 8; i++){\r\n            petAmounts[i] = stakerPetAmounts[staker][i];\r\n        }\r\n      return (_stakers[staker].stakedAPE, lootIds, _stakers[staker].stakedTREASURY, petAmounts, _stakers[staker].stakedBREEDING);\r\n    }\r\n\r\n    function _prepareForDeletion(uint256[] memory list, uint256 tokenId) internal pure returns (uint256[] memory) {\r\n      uint256 tokenIndex = 0;\r\n      uint256 lastTokenIndex = list.length - 1;\r\n      uint256 length = list.length;\r\n\r\n      for(uint256 i = 0; i < length; i++) {\r\n        if (list[i] == tokenId) {\r\n          tokenIndex = i + 1;\r\n          break;\r\n        }\r\n      }\r\n      require(tokenIndex != 0, \"Not the owner or duplicate NFT in list\");\r\n\r\n      tokenIndex -= 1;\r\n\r\n      if (tokenIndex != lastTokenIndex) {\r\n        list[tokenIndex] = list[lastTokenIndex];\r\n        list[lastTokenIndex] = tokenId;\r\n      }\r\n\r\n      return list;\r\n    }\r\n\r\n    function getCurrentReward(address staker) public view returns (uint256) {\r\n      Staker memory user = _stakers[staker];\r\n      if (user.lastCheckpoint == 0) { return 0; }\r\n      return (block.timestamp - user.lastCheckpoint) * user.currentYield / SECONDS_IN_DAY;\r\n    }\r\n\r\n    function getAccumulatedAmount(address staker) external view returns (uint256) {\r\n      return _stakers[staker].accumulatedAmount + getCurrentReward(staker);\r\n    }\r\n\r\n    function accumulate(address staker) internal {\r\n      _stakers[staker].accumulatedAmount += getCurrentReward(staker);\r\n      _stakers[staker].lastCheckpoint = block.timestamp;\r\n    }\r\n\r\n    /**\r\n    * CONTRACTS\r\n    */\r\n    function ownerOf(address contractAddress, uint256 tokenId) public view returns (address) {\r\n      return _ownerOfToken[contractAddress][tokenId];\r\n    }\r\n\r\n    function balanceOf(address user) public view returns (uint256){\r\n      return _stakers[user].stakedAPE.length;\r\n    }\r\n\r\n    function setTREASURYContract(address _treasury, uint256 _baseReward) public onlyOwner {\r\n      TreasuryNft = IERC721(_treasury);\r\n      _contractTypes[_treasury] = ContractTypes.TREASURY;\r\n      _baseRates[_treasury] = _baseReward;\r\n    }\r\n\r\n    function setPETContract(address _pet, uint256 _baseReward) public onlyOwner {\r\n      PetNft = IERC1155(_pet);\r\n      _contractTypes[_pet] = ContractTypes.PET;\r\n      _baseRates[_pet] = _baseReward;\r\n    }\r\n\r\n    function setLOOTContract(address _loot, uint256 _baseBoost) public onlyOwner {\r\n      LootNft = IERC721(_loot);\r\n      _contractTypes[_loot] = ContractTypes.LOOT;\r\n      _baseRates[_loot] = _baseBoost;\r\n    }\r\n\r\n    function setBREEDING(address _breeding, uint256 _baseReward) public onlyOwner{\r\n      BreedingNft = IERC721(_breeding);\r\n      _contractTypes[_breeding] = ContractTypes.BREEDING;\r\n      _baseRates[_breeding] = _baseReward;\r\n    }\r\n\r\n    /**\r\n    * ADMIN\r\n    */\r\n    function authorise(address toAuth) public onlyOwner {\r\n      _authorised[toAuth] = true;\r\n      authorisedLog.push(toAuth);\r\n    }\r\n\r\n    function unauthorise(address addressToUnAuth) public onlyOwner {\r\n      _authorised[addressToUnAuth] = false;\r\n    }\r\n\r\n    function forceWithdraw721(address tokenAddress, uint256[] memory tokenIds) public onlyOwner {\r\n      require(tokenIds.length <= 50, \"50 is max per tx\");\r\n      pauseDeposit(true);\r\n      for (uint256 i; i < tokenIds.length; i++) {\r\n        address receiver = _ownerOfToken[tokenAddress][tokenIds[i]];\r\n        if (receiver != address(0) && IERC721(tokenAddress).ownerOf(tokenIds[i]) == address(this)) {\r\n          IERC721(tokenAddress).transferFrom(address(this), receiver, tokenIds[i]);\r\n          emit ForceWithdraw721(receiver, tokenAddress, tokenIds[i]);\r\n        }\r\n      }\r\n    }\r\n\r\n    function pauseDeposit(bool _pause) public onlyOwner {\r\n      depositPaused = _pause;\r\n    }\r\n\r\n    function launchStaking() public onlyOwner {\r\n      require(!stakingLaunched, \"Staking has been launched already\");\r\n      stakingLaunched = true;\r\n    }\r\n\r\n    function updateBaseYield(address _contract, uint256 _yield) public onlyOwner {\r\n      _baseRates[_contract] = _yield;\r\n    }\r\n\r\n    function setIndividualRates(address contractAddress, uint256[] memory tokenIds, uint256[] memory rates) public onlyOwner{\r\n        require(contractAddress != address(0) && contractAddress == address(ApeNft) || contractAddress == address(LootNft) || contractAddress == address(TreasuryNft) || contractAddress == address(PetNft), \"Unknown contract\");\r\n        require(tokenIds.length == rates.length, \"Lists not same length\");\r\n        for (uint256 i; i < tokenIds.length; i++){\r\n            _individualRates[contractAddress][tokenIds[i]] = rates[i];\r\n        }\r\n    }\r\n\r\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns(bytes4){\r\n      return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n    }\r\n\r\n    function withdrawETH() external onlyOwner {\r\n      payable(owner()).transfer(address(this).balance);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ape\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"apesAmount\",\"type\":\"uint256\"}],\"name\":\"AddLootToStakedApes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ForceWithdraw721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lootsAmount\",\"type\":\"uint256\"}],\"name\":\"RemoveLootFromStakedApes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"Stake721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"apesAmount\",\"type\":\"uint256\"}],\"name\":\"StakeApesWithLoots\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfPetIds\",\"type\":\"uint256\"}],\"name\":\"StakePets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"Unstake721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfPetIds\",\"type\":\"uint256\"}],\"name\":\"UnstakePets\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ApeNft\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BreedingNft\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LootNft\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PetNft\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_IN_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TreasuryNft\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_baseRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"apeIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"lootIds\",\"type\":\"uint256[]\"}],\"name\":\"addLootToStakedApes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toAuth\",\"type\":\"address\"}],\"name\":\"authorise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorisedLog\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"forceWithdraw721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getAccumulatedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"apeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootId\",\"type\":\"uint256\"}],\"name\":\"getApeLootTokenYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getCurrentReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"petId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPetTokenYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStakerNFT\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStakerYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"pauseDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"apeIds\",\"type\":\"uint256[]\"}],\"name\":\"removeLootFromStakedApes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_breeding\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_baseReward\",\"type\":\"uint256\"}],\"name\":\"setBREEDING\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rates\",\"type\":\"uint256[]\"}],\"name\":\"setIndividualRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loot\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_baseBoost\",\"type\":\"uint256\"}],\"name\":\"setLOOTContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_baseReward\",\"type\":\"uint256\"}],\"name\":\"setPETContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_baseReward\",\"type\":\"uint256\"}],\"name\":\"setTREASURYContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"stake1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"stake721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"apeIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"lootIds\",\"type\":\"uint256[]\"}],\"name\":\"stakeApesWithLoots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingLaunched\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToUnAuth\",\"type\":\"address\"}],\"name\":\"unauthorise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstake1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstake721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_yield\",\"type\":\"uint256\"}],\"name\":\"updateBaseYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MoonStaking","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000034c4eba1966b502dfcf0868b6f271d85cc8a2312","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fb7f8024407fec63d9df809435555d69d0e345b4211f2e3e780057cf144aa823"}]