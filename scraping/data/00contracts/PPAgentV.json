[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/powerpool-agent-v2/contracts/PPAgentV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./PPAgentV2Flags.sol\\\";\\n\\nlibrary ConfigFlags {\\n  function check(uint256 cfg, uint256 flag) internal pure returns (bool) {\\n    return (cfg & flag) != 0;\\n  }\\n}\\n\\ninterface IPPAgentV2Executor {\\n  function execute_44g58pv() external;\\n}\\n\\ninterface IPPAgentV2Viewer {\\n  struct Job {\\n    uint8 config;\\n    bytes4 selector;\\n    uint88 credits;\\n    uint16 maxBaseFeeGwei;\\n    uint16 rewardPct;\\n    uint32 fixedReward;\\n    uint8 calldataSource;\\n\\n    // For interval jobs\\n    uint24 intervalSeconds;\\n    uint32 lastExecutionAt;\\n  }\\n\\n  struct Resolver {\\n    address resolverAddress;\\n    bytes resolverCalldata;\\n  }\\n\\n  function getConfig() external view returns (\\n    uint256 minKeeperCvp_,\\n    uint256 pendingWithdrawalTimeoutSeconds_,\\n    uint256 feeTotal_,\\n    uint256 feePpm_,\\n    uint256 lastKeeperId_\\n  );\\n  function getKeeper(uint256 keeperId_) external view returns (\\n    address admin,\\n    address worker,\\n    uint256 currentStake,\\n    uint256 slashedStake,\\n    uint256 compensation,\\n    uint256 pendingWithdrawalAmount,\\n    uint256 pendingWithdrawalEndAt\\n  );\\n  function getKeeperWorkerAndStake(uint256 keeperId_) external view returns (\\n    address worker,\\n    uint256 currentStake\\n  );\\n  function getJob(bytes32 jobKey_) external view returns (\\n    address owner,\\n    address pendingTransfer,\\n    uint256 jobLevelMinKeeperCvp,\\n    Job memory details,\\n    bytes memory preDefinedCalldata,\\n    Resolver memory resolver\\n  );\\n  function getJobRaw(bytes32 jobKey_) external view returns (uint256 rawJob);\\n  function jobOwnerCredits(address owner_) external view returns (uint256 credits);\\n}\\n\\n/**\\n * @title PowerAgentLite\\n * @author PowerPool\\n */\\ncontract PPAgentV2 is IPPAgentV2Executor, IPPAgentV2Viewer, PPAgentV2Flags, Ownable {\\n  error OnlyOwner();\\n  error NonEOASender();\\n  error InsufficientKeeperStake();\\n  error InsufficientJobScopedKeeperStake();\\n  error KeeperWorkerNotAuthorized();\\n  error InsufficientJobCredits(uint256 actual, uint256 wanted);\\n  error InsufficientJobOwnerCredits(uint256 actual, uint256 wanted);\\n  error InactiveJob(bytes32 jobKey);\\n  error JobIdOverflow();\\n  error OnlyJobOwner();\\n  error JobWithoutOwner();\\n  error MissingJobAddress();\\n  error MissingMaxBaseFeeGwei();\\n  error NoFixedNorPremiumPctReward();\\n  error CreditsDepositOverflow();\\n  error CreditsWithdrawalUnderflow();\\n  error MissingDeposit();\\n  error IntervalNotReached(uint256 lastExecutedAt, uint256 interval, uint256 _now);\\n  error BaseFeeGtGasPrice(uint256 baseFee, uint256 jobMaxBaseFeeGwei);\\n  error InvalidCalldataSource();\\n  error MissingInputCalldata();\\n  error SelectorCheckFailed();\\n  error JobCallRevertedWithoutDetails();\\n  error InsufficientAmountToCoverSlashedStake(uint256 wanted, uint256 actual);\\n  error AmountGtStake(uint256 wanted, uint256 actualStake, uint256 actualSlashedStake);\\n  error WithdrawalTimoutNotReached();\\n  error NoPendingWithdrawal();\\n  error MissingAmount();\\n  error WithdrawAmountExceedsAvailable(uint256 wanted, uint256 actual);\\n  error JobShouldHaveInterval();\\n  error InvalidJobAddress();\\n  error MissingResolverAddress();\\n  error NotSupportedByJobCalldataSource();\\n  error OnlyKeeperAdmin();\\n  error OnlyKeeperAdminOrWorker();\\n  error TimeoutTooBig();\\n  error FeeTooBig();\\n  error InsufficientAmount();\\n  error OnlyPendingOwner();\\n  error WorkerAlreadyAssigned();\\n\\n  string public constant VERSION = \\\"2.2.0\\\";\\n  uint256 internal constant MAX_PENDING_WITHDRAWAL_TIMEOUT_SECONDS = 30 days;\\n  uint256 internal constant MAX_FEE_PPM = 5e4;\\n  uint256 internal constant FIXED_PAYMENT_MULTIPLIER = 1e15;\\n  uint256 internal constant JOB_RUN_GAS_OVERHEAD = 40_000;\\n\\n  enum CalldataSourceType {\\n    SELECTOR,\\n    PRE_DEFINED,\\n    RESOLVER\\n  }\\n\\n  IERC20 public immutable CVP;\\n\\n  event Execute(\\n    bytes32 indexed jobKey,\\n    address indexed job,\\n    uint256 keeperId,\\n    uint256 gasUsed,\\n    uint256 baseFee,\\n    uint256 gasPrice,\\n    uint256 compensation,\\n    bytes32 binJobAfter\\n  );\\n  event WithdrawFees(address indexed to, uint256 amount);\\n  event Slash(uint256 indexed keeperId, address indexed to, uint256 currentAmount, uint256 pendingAmount);\\n  event RegisterAsKeeper(uint256 indexed keeperId, address indexed keeperAdmin, address indexed keeperWorker);\\n  event SetWorkerAddress(uint256 indexed keeperId, address indexed prev, address indexed worker);\\n  event Stake(uint256 indexed keeperId, uint256 amount, address staker);\\n  event InitiateRedeem(uint256 indexed keeperId, uint256 redeemAmount, uint256 stakeAmount, uint256 slashedStakeAmount);\\n  event FinalizeRedeem(uint256 indexed keeperId, address indexed beneficiary, uint256 amount);\\n  event WithdrawCompensation(uint256 indexed keeperId, address indexed to, uint256 amount);\\n  event DepositJobCredits(bytes32 indexed jobKey, address indexed depositor, uint256 amount, uint256 fee);\\n  event WithdrawJobCredits(bytes32 indexed jobKey, address indexed owner, address indexed to, uint256 amount);\\n  event DepositJobOwnerCredits(address indexed jobOwner, address indexed depositor, uint256 amount, uint256 fee);\\n  event WithdrawJobOwnerCredits(address indexed jobOwner, address indexed to, uint256 amount);\\n  event InitiateJobTransfer(bytes32 indexed jobKey, address indexed from, address indexed to);\\n  event AcceptJobTransfer(bytes32 indexed jobKey_, address indexed to_);\\n  event SetJobConfig(bytes32 indexed jobKey, bool isActive_, bool useJobOwnerCredits_, bool assertResolverSelector_);\\n  event SetJobResolver(bytes32 indexed jobKey, address resolverAddress, bytes resolverCalldata);\\n  event SetJobPreDefinedCalldata(bytes32 indexed jobKey, bytes preDefinedCalldata);\\n  event SetAgentParams(uint256 minKeeperCvp_, uint256 timeoutSeconds_, uint256 feePct_);\\n  event RegisterJob(\\n    bytes32 indexed jobKey,\\n    address indexed jobAddress,\\n    uint256 indexed jobId,\\n    address owner,\\n    RegisterJobParams params\\n  );\\n  event JobUpdate(\\n    bytes32 indexed jobKey,\\n    uint256 maxBaseFeeGwei,\\n    uint256 rewardPct,\\n    uint256 fixedReward,\\n    uint256 jobMinCvp,\\n    uint256 intervalSeconds\\n  );\\n\\n  struct Keeper {\\n    address worker;\\n    uint96 cvpStake;\\n  }\\n\\n  uint256 internal minKeeperCvp;\\n  uint256 internal pendingWithdrawalTimeoutSeconds;\\n  uint256 internal feeTotal;\\n  uint256 internal feePpm;\\n  uint256 internal lastKeeperId;\\n\\n  // keccak256(jobAddress, id) => ethBalance\\n  mapping(bytes32 => Job) internal jobs;\\n  // keccak256(jobAddress, id) => customCalldata\\n  mapping(bytes32 => bytes) internal preDefinedCalldatas;\\n  // keccak256(jobAddress, id) => minKeeperCvpStake\\n  mapping(bytes32 => uint256) internal jobMinKeeperCvp;\\n  // keccak256(jobAddress, id) => owner\\n  mapping(bytes32 => address) internal jobOwners;\\n  // keccak256(jobAddress, id) => resolver(address,calldata)\\n  mapping(bytes32 => Resolver) internal resolvers;\\n  // keccak256(jobAddress, id) => pendingAddress\\n  mapping(bytes32 => address) internal jobPendingTransfers;\\n\\n  // jobAddress => lastIdRegistered(actually uint24)\\n  mapping(address => uint256) public jobLastIds;\\n\\n  // keeperId => (worker,CVP stake)\\n  mapping(uint256 => Keeper) internal keepers;\\n  // keeperId => admin\\n  mapping(uint256 => address) internal keeperAdmins;\\n  // keeperId => the slashed CVP amount\\n  mapping(uint256 => uint256) internal slashedStakeOf;\\n  // keeperId => native token compensation\\n  mapping(uint256 => uint256) internal compensations;\\n\\n  // keeperId => pendingWithdrawalCVP amount\\n  mapping(uint256 => uint256) internal pendingWithdrawalAmounts;\\n  // keeperId => pendingWithdrawalEndsAt timestamp\\n  mapping(uint256 => uint256) internal pendingWithdrawalEndsAt;\\n\\n  // owner => credits\\n  mapping(address => uint256) public jobOwnerCredits;\\n\\n  // worker => keeperIs\\n  mapping(address => uint256) public workerKeeperIds;\\n\\n  /*** PSEUDO-MODIFIERS ***/\\n\\n  function _assertOnlyOwner() internal view {\\n    if (msg.sender != owner()) {\\n      revert OnlyOwner();\\n    }\\n  }\\n\\n  function _assertOnlyJobOwner(bytes32 jobKey_) internal view {\\n    if (msg.sender != jobOwners[jobKey_]) {\\n      revert OnlyJobOwner();\\n    }\\n  }\\n\\n  function _assertOnlyKeeperAdmin(uint256 keeperId_) internal view {\\n    if (msg.sender != keeperAdmins[keeperId_]) {\\n      revert OnlyKeeperAdmin();\\n    }\\n  }\\n\\n  function _assertOnlyKeeperAdminOrWorker(uint256 keeperId_) internal view {\\n    if (msg.sender != keeperAdmins[keeperId_] && msg.sender != keepers[keeperId_].worker) {\\n      revert OnlyKeeperAdminOrWorker();\\n    }\\n  }\\n\\n  function _assertWorkerNotAssigned(address worker_) internal view {\\n    if (workerKeeperIds[worker_] != 0) {\\n      revert WorkerAlreadyAssigned();\\n    }\\n  }\\n\\n  function _assertNonZeroAmount(uint256 amount_) internal pure {\\n    if (amount_ == 0) {\\n      revert MissingAmount();\\n    }\\n  }\\n\\n  function _assertNonZeroValue() internal view {\\n    if (msg.value == 0) {\\n      revert MissingDeposit();\\n    }\\n  }\\n\\n  function _assertJobCalldataSource(bytes32 jobKey_, CalldataSourceType source_) internal view {\\n    if (CalldataSourceType(jobs[jobKey_].calldataSource) != source_) {\\n      revert NotSupportedByJobCalldataSource();\\n    }\\n  }\\n\\n  function _assertJobParams(uint256 maxBaseFeeGwei_, uint256 fixedReward_, uint256 rewardPct_) internal pure {\\n    if (maxBaseFeeGwei_ == 0) {\\n      revert MissingMaxBaseFeeGwei();\\n    }\\n\\n    if (fixedReward_ == 0 && rewardPct_ == 0) {\\n      revert NoFixedNorPremiumPctReward();\\n    }\\n  }\\n\\n  function _assertInterval(uint256 interval_, CalldataSourceType calldataSource_) internal pure {\\n    if (interval_ == 0 &&\\n      (calldataSource_ == CalldataSourceType.SELECTOR || calldataSource_ == CalldataSourceType.PRE_DEFINED)) {\\n      revert JobShouldHaveInterval();\\n    }\\n  }\\n\\n  constructor(address owner_, address cvp_, uint256 minKeeperCvp_, uint256 pendingWithdrawalTimeoutSeconds_) {\\n    minKeeperCvp = minKeeperCvp_;\\n    CVP = IERC20(cvp_);\\n    pendingWithdrawalTimeoutSeconds = pendingWithdrawalTimeoutSeconds_;\\n    _transferOwnership(owner_);\\n  }\\n\\n  /*** UPKEEP INTERFACE ***/\\n\\n  /**\\n   * Executes a job.\\n   * The method arguments a tightly coupled with a custom layout in order to save some gas.\\n   * The calldata has the following layout :\\n   *  0x      00000000 1b48315d66ba5267aac8d0ab63c49038b56b1dbc 0000f1 03     00001a    402b2eed11\\n   *  name    selector jobContractAddress                       jobId  config keeperId  calldata (optional)\\n   *  size b  bytes4   bytes20                                  uint24 uint8  uint24    any\\n   *  size u  uint32   uint160                                  bytes3 bytes1 bytes3    any\\n   *  bits    0-3      4-23                                     24-26  27-27  28-30     31+\\n   */\\n  function execute_44g58pv() external {\\n    uint256 gasStart = gasleft();\\n    bytes32 jobKey;\\n\\n    assembly (\\\"memory-safe\\\") {\\n      // size of (address(bytes20)+id(uint24/bytes3))\\n      let size := 23\\n\\n      // keccack256(address+id(uint24)) to memory to generate jobKey\\n      calldatacopy(0, 4, size)\\n      jobKey := keccak256(0, size)\\n    }\\n\\n    address jobAddress;\\n    uint256 keeperId;\\n    uint256 cfg;\\n\\n    assembly (\\\"memory-safe\\\") {\\n      // load jobAddress, cfg, and keeperId from calldata to the stack\\n      jobAddress := shr(96, calldataload(4))\\n      cfg := shr(248, calldataload(27))\\n      keeperId := shr(232, calldataload(28))\\n    }\\n\\n    // 0. Keeper has sufficient stake\\n    {\\n      Keeper memory keeper = keepers[keeperId];\\n      if (keeper.worker != msg.sender) {\\n        revert KeeperWorkerNotAuthorized();\\n      }\\n      if (keeper.cvpStake < minKeeperCvp) {\\n        revert InsufficientKeeperStake();\\n      }\\n    }\\n\\n    uint256 binJob = getJobRaw(jobKey);\\n\\n    // 1. Assert the job is active\\n    {\\n      if (!ConfigFlags.check(binJob, CFG_ACTIVE)) {\\n        revert InactiveJob(jobKey);\\n      }\\n    }\\n\\n    // 2. Assert job-scoped keeper's minimum CVP deposit\\n    if (ConfigFlags.check(binJob, CFG_CHECK_KEEPER_MIN_CVP_DEPOSIT) && keepers[keeperId].cvpStake < jobMinKeeperCvp[jobKey]) {\\n      revert InsufficientJobScopedKeeperStake();\\n    }\\n\\n    // 3. For interval job ensure the interval has passed\\n    {\\n      uint256 intervalSeconds = (binJob << 32) >> 232;\\n\\n      if (intervalSeconds > 0) {\\n        uint256 lastExecutionAt = binJob >> 224;\\n        if (lastExecutionAt > 0) {\\n          uint256 nextExecutionAt;\\n          unchecked {\\n            nextExecutionAt = lastExecutionAt + intervalSeconds;\\n          }\\n          if (nextExecutionAt > block.timestamp) {\\n            revert IntervalNotReached(lastExecutionAt, intervalSeconds, block.timestamp);\\n          }\\n        }\\n      }\\n    }\\n\\n    // 4. Ensure gas price fits base fee\\n    uint256 maxBaseFee;\\n    {\\n      unchecked {\\n        maxBaseFee = ((binJob << 112) >> 240)  * 1 gwei;\\n      }\\n      if (block.basefee > maxBaseFee && !ConfigFlags.check(cfg, FLAG_ACCEPT_MAX_BASE_FEE_LIMIT)) {\\n        revert BaseFeeGtGasPrice(block.basefee, maxBaseFee);\\n      }\\n    }\\n\\n    // 5. Ensure msg.sender is EOA\\n    if (msg.sender != tx.origin) {\\n      revert NonEOASender();\\n    }\\n\\n    bool ok;\\n    uint256 jobGas = gasleft() - 50_000;\\n\\n    // Source: Selector\\n    CalldataSourceType calldataSource = CalldataSourceType((binJob << 56) >> 248);\\n    if (calldataSource == CalldataSourceType.SELECTOR) {\\n      bytes4 selector;\\n      assembly {\\n        selector := shl(224, shr(8, binJob))\\n      }\\n      (ok,) = jobAddress.call{ gas: jobGas }(abi.encode(selector));\\n    // Source: Bytes\\n    } else if (calldataSource == CalldataSourceType.PRE_DEFINED) {\\n      (ok,) = jobAddress.call{ gas: jobGas }(preDefinedCalldatas[jobKey]);\\n    // Source: Resolver\\n    } else if (calldataSource == CalldataSourceType.RESOLVER) {\\n      assembly (\\\"memory-safe\\\") {\\n        let cdInCdSize := calldatasize()\\n        // calldata offset is 31\\n        let beforeCdSize := 31\\n        let ptr := mload(0x40)\\n        if lt(cdInCdSize, beforeCdSize) {\\n          // revert MissingInputCalldata()\\n          mstore(ptr, 0x47a0bafb00000000000000000000000000000000000000000000000000000000)\\n          revert(ptr, 4)\\n        }\\n        let cdSize := sub(cdInCdSize, beforeCdSize)\\n        mstore(0x40, add(ptr, cdSize))\\n        calldatacopy(ptr, beforeCdSize, cdSize)\\n        // CFG_ASSERT_RESOLVER_SELECTOR = 0x04 from PPAgentLiteFlags\\n        if and(binJob, 0x04) {\\n          if iszero(eq(\\n            // actual\\n            shl(224, shr(224, calldataload(31))),\\n            // expected\\n            shl(224, shr(8, binJob))\\n          )) {\\n            // revert SelectorCheckFailed()\\n            mstore(ptr, 0x84fb827500000000000000000000000000000000000000000000000000000000)\\n            revert(ptr, 4)\\n          }\\n        }\\n        // The remaining gas could not be less than 50_000\\n        ok := call(jobGas, jobAddress, 0, ptr, cdSize, 0x0, 0x0)\\n      }\\n    } else {\\n      // Should never be reached\\n      revert InvalidCalldataSource();\\n    }\\n\\n    // Transaction succeeded\\n    if (ok) {\\n      binJob = getJobRaw(jobKey);\\n      uint256 gasUsed;\\n      unchecked {\\n        gasUsed = gasStart - gasleft();\\n      }\\n\\n      uint256 compensation;\\n      {\\n        uint256 min = block.basefee;\\n        if (maxBaseFee < min) {\\n          min = maxBaseFee;\\n        }\\n\\n        compensation = _calculateCompensation(binJob, min, gasUsed);\\n      }\\n      {\\n        bool jobChanged;\\n\\n        if (ConfigFlags.check(binJob, CFG_USE_JOB_OWNER_CREDITS)) {\\n          // use job owner credits\\n          _useJobOwnerCredits(jobKey, compensation);\\n        } else {\\n          // use job credits\\n          uint256 creditsBefore = (binJob << 128) >> 168;\\n          if (creditsBefore < compensation) {\\n            revert InsufficientJobCredits(creditsBefore, compensation);\\n          }\\n\\n          uint256 creditsAfter;\\n          unchecked {\\n            creditsAfter = creditsBefore - compensation;\\n          }\\n          // update job credits\\n          binJob = binJob & BM_CLEAR_CREDITS | (creditsAfter << 40);\\n          jobChanged = true;\\n        }\\n\\n        if (ConfigFlags.check(cfg, FLAG_ACCRUE_REWARD)) {\\n          compensations[keeperId] += compensation;\\n        } else {\\n          payable(msg.sender).transfer(compensation);\\n        }\\n\\n        // Update lastExecutionAt for interval jobs\\n        {\\n          uint256 intervalSeconds = (binJob << 32) >> 232;\\n          if (intervalSeconds > 0) {\\n            uint256 lastExecutionAt = uint32(block.timestamp);\\n            binJob = binJob & BM_CLEAR_LAST_UPDATE_AT | (lastExecutionAt << 224);\\n            jobChanged = true;\\n          }\\n        }\\n\\n        if (jobChanged) {\\n          _updateRawJob(jobKey, binJob);\\n        }\\n      }\\n\\n      emit Execute(\\n        jobKey,\\n        jobAddress,\\n        keeperId,\\n        gasUsed,\\n        block.basefee,\\n        tx.gasprice,\\n        compensation,\\n        bytes32(binJob)\\n      );\\n    // Tx reverted\\n    } else {\\n      uint256 size;\\n      assembly (\\\"memory-safe\\\") {\\n        size := returndatasize()\\n      }\\n\\n      if (size == 0) {\\n        revert JobCallRevertedWithoutDetails();\\n      }\\n\\n      assembly (\\\"memory-safe\\\") {\\n        let p := mload(0x40)\\n        returndatacopy(p, 0, size)\\n        revert(p, size)\\n      }\\n    }\\n  }\\n\\n  function _calculateCompensation(uint256 job_, uint256 gasPrice_, uint256 gasUsed_) internal pure returns (uint256) {\\n    uint256 fixedReward = (job_ << 64) >> 224;\\n    uint256 rewardPct = (job_ << 96) >> 240;\\n    return calculateCompensationPure(rewardPct, fixedReward, gasPrice_, gasUsed_);\\n  }\\n\\n  function _useJobOwnerCredits(bytes32 jobKey_, uint256 compensation_) internal {\\n    uint256 jobOwnerCreditsBefore = jobOwnerCredits[jobOwners[jobKey_]];\\n    if (jobOwnerCreditsBefore < compensation_) {\\n      revert InsufficientJobOwnerCredits(jobOwnerCreditsBefore, compensation_);\\n    }\\n\\n    unchecked {\\n      jobOwnerCredits[jobOwners[jobKey_]] = jobOwnerCreditsBefore - compensation_;\\n    }\\n  }\\n\\n  struct RegisterJobParams {\\n    address jobAddress;\\n    bytes4 jobSelector;\\n    bool useJobOwnerCredits;\\n    bool assertResolverSelector;\\n    uint16 maxBaseFeeGwei;\\n    uint16 rewardPct;\\n    uint32 fixedReward;\\n    uint256 jobMinCvp;\\n    uint8 calldataSource;\\n    uint24 intervalSeconds;\\n  }\\n\\n  /*** JOB OWNER INTERFACE ***/\\n\\n  /**\\n   * Registers a new job.\\n   *\\n   * Job id is unique counter for a given job address. Up to 2**24-1 jobs per address.\\n   * Job key is a keccak256(address, jobId).\\n   * The following options are immutable:\\n   *  - `params_.jobaddress`\\n   *  - `params_.calldataSource`\\n   * If you need to modify one of the immutable options above later consider creating a new job.\\n   *\\n   * @param params_ Job-specific params\\n   * @param resolver_ Resolver details(address, calldata), required only for CALLDATA_SOURCE_RESOLVER\\n   *                  job type. Use empty values for the other job types.\\n   * @param preDefinedCalldata_ Calldata to call a job with, required only for CALLDATA_SOURCE_PRE_DEFINED\\n   *              job type. Keep empty for the other job types.\\n   */\\n  function registerJob(\\n    RegisterJobParams calldata params_,\\n    Resolver calldata resolver_,\\n    bytes calldata preDefinedCalldata_\\n  ) external payable returns (bytes32 jobKey, uint256 jobId){\\n    jobId = jobLastIds[params_.jobAddress] + 1;\\n\\n    if (jobId > type(uint24).max) {\\n      revert JobIdOverflow();\\n    }\\n\\n    if (msg.value > type(uint88).max) {\\n      revert CreditsDepositOverflow();\\n    }\\n\\n    if (params_.jobAddress == address(0)) {\\n      revert MissingJobAddress();\\n    }\\n\\n    if (params_.calldataSource > 2) {\\n      revert InvalidCalldataSource();\\n    }\\n\\n    if (params_.jobAddress == address(CVP)) {\\n      revert InvalidJobAddress();\\n    }\\n\\n    _assertInterval(params_.intervalSeconds, CalldataSourceType(params_.calldataSource));\\n    _assertJobParams(params_.maxBaseFeeGwei, params_.fixedReward, params_.rewardPct);\\n    jobKey = getJobKey(params_.jobAddress, jobId);\\n\\n    emit RegisterJob(\\n      jobKey,\\n      params_.jobAddress,\\n      jobId,\\n      msg.sender,\\n      params_\\n    );\\n\\n    if (CalldataSourceType(params_.calldataSource) == CalldataSourceType.PRE_DEFINED) {\\n      _setJobPreDefinedCalldata(jobKey, preDefinedCalldata_);\\n    } else if (CalldataSourceType(params_.calldataSource) == CalldataSourceType.RESOLVER) {\\n      _setJobResolver(jobKey, resolver_);\\n    }\\n\\n    {\\n      bytes4 selector = 0x00000000;\\n      if (CalldataSourceType(params_.calldataSource) != CalldataSourceType.PRE_DEFINED) {\\n        selector = params_.jobSelector;\\n      }\\n\\n      uint256 config = CFG_ACTIVE;\\n      if (params_.useJobOwnerCredits) {\\n        config = config | CFG_USE_JOB_OWNER_CREDITS;\\n      }\\n      if (params_.assertResolverSelector) {\\n        config = config | CFG_ASSERT_RESOLVER_SELECTOR;\\n      }\\n      if (params_.jobMinCvp > 0) {\\n        config = config | CFG_CHECK_KEEPER_MIN_CVP_DEPOSIT;\\n      }\\n\\n      jobs[jobKey] = Job({\\n        config: uint8(config),\\n        selector: selector,\\n        credits: 0,\\n        maxBaseFeeGwei: params_.maxBaseFeeGwei,\\n        fixedReward: params_.fixedReward,\\n        rewardPct: params_.rewardPct,\\n        calldataSource: params_.calldataSource,\\n\\n        // For interval jobs\\n        intervalSeconds: params_.intervalSeconds,\\n        lastExecutionAt: 0\\n      });\\n      jobMinKeeperCvp[jobKey] = params_.jobMinCvp;\\n    }\\n\\n    jobLastIds[params_.jobAddress] = jobId;\\n    jobOwners[jobKey] = msg.sender;\\n\\n    if (msg.value > 0) {\\n      if (params_.useJobOwnerCredits) {\\n        _processJobOwnerCreditsDeposit(msg.sender);\\n      } else {\\n        _processJobCreditsDeposit(jobKey);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Updates a job details.\\n   *\\n   * The following options are immutable:\\n   *  - `jobAddress`\\n   *  - `job.selector`\\n   *  - `job.calldataSource`\\n   * If you need to modify one of the immutable options above later consider creating a new job.\\n   *\\n   * @param jobKey_ The job key\\n   * @param maxBaseFeeGwei_ The maximum basefee in gwei to use for a job compensation\\n   * @param rewardPct_ The reward premium in pct, where 1 == 1%\\n   * @param fixedReward_ The fixed reward divided by FIXED_PAYMENT_MULTIPLIER\\n   * @param jobMinCvp_ The keeper minimal CVP stake to be eligible to execute this job\\n   * @param intervalSeconds_ The interval for a job execution\\n   */\\n  function updateJob(\\n    bytes32 jobKey_,\\n    uint16 maxBaseFeeGwei_,\\n    uint16 rewardPct_,\\n    uint32 fixedReward_,\\n    uint256 jobMinCvp_,\\n    uint24 intervalSeconds_\\n  ) external {\\n    _assertOnlyJobOwner(jobKey_);\\n    _assertJobParams(maxBaseFeeGwei_, fixedReward_, rewardPct_);\\n\\n    Job memory job = jobs[jobKey_];\\n\\n    _assertInterval(intervalSeconds_, CalldataSourceType(job.calldataSource));\\n\\n    uint256 cfg = job.config;\\n\\n    if (jobMinCvp_ > 0 && !ConfigFlags.check(job.config, CFG_CHECK_KEEPER_MIN_CVP_DEPOSIT)) {\\n      cfg = cfg | CFG_CHECK_KEEPER_MIN_CVP_DEPOSIT;\\n    }\\n    if (jobMinCvp_ == 0 && ConfigFlags.check(job.config, CFG_CHECK_KEEPER_MIN_CVP_DEPOSIT)) {\\n      cfg = cfg ^ CFG_CHECK_KEEPER_MIN_CVP_DEPOSIT;\\n    }\\n\\n    jobs[jobKey_].config = uint8(cfg);\\n    jobMinKeeperCvp[jobKey_] = jobMinCvp_;\\n\\n    jobs[jobKey_].maxBaseFeeGwei = maxBaseFeeGwei_;\\n    jobs[jobKey_].rewardPct = rewardPct_;\\n    jobs[jobKey_].fixedReward = fixedReward_;\\n    jobs[jobKey_].intervalSeconds = intervalSeconds_;\\n\\n    emit JobUpdate(jobKey_, maxBaseFeeGwei_, rewardPct_, fixedReward_, jobMinCvp_, intervalSeconds_);\\n  }\\n\\n  /**\\n   * A job owner updates job resolver details.\\n   *\\n   * @param jobKey_ The jobKey\\n   * @param resolver_ The new job resolver details\\n   */\\n  function setJobResolver(bytes32 jobKey_, Resolver calldata resolver_) external {\\n    _assertOnlyJobOwner(jobKey_);\\n    _assertJobCalldataSource(jobKey_, CalldataSourceType.RESOLVER);\\n\\n    _setJobResolver(jobKey_, resolver_);\\n  }\\n\\n  function _setJobResolver(bytes32 jobKey_, Resolver calldata resolver_) internal {\\n    if (resolver_.resolverAddress == address(0)) {\\n      revert MissingResolverAddress();\\n    }\\n    resolvers[jobKey_] = resolver_;\\n    emit SetJobResolver(jobKey_, resolver_.resolverAddress, resolver_.resolverCalldata);\\n  }\\n\\n  /**\\n   * A job owner updates pre-defined calldata.\\n   *\\n   * @param jobKey_ The jobKey\\n   * @param preDefinedCalldata_ The new job pre-defined calldata\\n   */\\n  function setJobPreDefinedCalldata(bytes32 jobKey_, bytes calldata preDefinedCalldata_) external {\\n    _assertOnlyJobOwner(jobKey_);\\n    _assertJobCalldataSource(jobKey_, CalldataSourceType.PRE_DEFINED);\\n\\n    _setJobPreDefinedCalldata(jobKey_, preDefinedCalldata_);\\n  }\\n\\n  function _setJobPreDefinedCalldata(bytes32 jobKey_, bytes calldata preDefinedCalldata_) internal {\\n    preDefinedCalldatas[jobKey_] = preDefinedCalldata_;\\n    emit SetJobPreDefinedCalldata(jobKey_, preDefinedCalldata_);\\n  }\\n\\n  /**\\n   * A job owner updates a job config flag.\\n   *\\n   * @param jobKey_ The jobKey\\n   * @param isActive_ Whether the job is active or not\\n   * @param useJobOwnerCredits_ The useJobOwnerCredits flag\\n   * @param assertResolverSelector_ The assertResolverSelector flag\\n   */\\n  function setJobConfig(\\n    bytes32 jobKey_,\\n    bool isActive_,\\n    bool useJobOwnerCredits_,\\n    bool assertResolverSelector_\\n  ) external {\\n    _assertOnlyJobOwner(jobKey_);\\n    uint256 newConfig = 0;\\n\\n    if (isActive_) {\\n      newConfig = newConfig | CFG_ACTIVE;\\n    }\\n    if (useJobOwnerCredits_) {\\n      newConfig = newConfig | CFG_USE_JOB_OWNER_CREDITS;\\n    }\\n    if (assertResolverSelector_) {\\n      newConfig = newConfig | CFG_ASSERT_RESOLVER_SELECTOR;\\n    }\\n\\n    uint256 job = getJobRaw(jobKey_) & BM_CLEAR_CONFIG | newConfig;\\n    _updateRawJob(jobKey_, job);\\n\\n    emit SetJobConfig(jobKey_, isActive_, useJobOwnerCredits_, assertResolverSelector_);\\n  }\\n\\n  function _updateRawJob(bytes32 jobKey_, uint256 job_) internal {\\n    Job storage job = jobs[jobKey_];\\n    assembly {\\n      sstore(job.slot, job_)\\n    }\\n  }\\n\\n  /**\\n   * A job owner initiates the job transfer to a new owner.\\n   * The actual owner doesn't update until the pending owner accepts the transfer.\\n   *\\n   * @param jobKey_ The jobKey\\n   * @param to_ The new job owner\\n   */\\n  function initiateJobTransfer(bytes32 jobKey_, address to_) external {\\n    _assertOnlyJobOwner(jobKey_);\\n    jobPendingTransfers[jobKey_] = to_;\\n    emit InitiateJobTransfer(jobKey_, msg.sender, to_);\\n  }\\n\\n  /**\\n   * A pending job owner accepts the job transfer.\\n   *\\n   * @param jobKey_ The jobKey\\n   */\\n  function acceptJobTransfer(bytes32 jobKey_) external {\\n    if (msg.sender != jobPendingTransfers[jobKey_]) {\\n      revert OnlyPendingOwner();\\n    }\\n\\n    jobOwners[jobKey_] = msg.sender;\\n    delete jobPendingTransfers[jobKey_];\\n\\n    emit AcceptJobTransfer(jobKey_, msg.sender);\\n  }\\n\\n  /**\\n   * Top-ups the job credits in NATIVE tokens.\\n   *\\n   * @param jobKey_ The jobKey to deposit for\\n   */\\n  function depositJobCredits(bytes32 jobKey_) external payable {\\n    _assertNonZeroValue();\\n\\n    if (jobOwners[jobKey_] == address(0)) {\\n      revert JobWithoutOwner();\\n    }\\n\\n    _processJobCreditsDeposit(jobKey_);\\n  }\\n\\n  function _processJobCreditsDeposit(bytes32 jobKey_) internal {\\n    (uint256 fee, uint256 amount) = _calculateDepositFee();\\n    uint256 creditsAfter = jobs[jobKey_].credits + amount;\\n    if (creditsAfter > type(uint88).max) {\\n      revert CreditsDepositOverflow();\\n    }\\n\\n    unchecked {\\n      feeTotal += fee;\\n    }\\n    jobs[jobKey_].credits = uint88(creditsAfter);\\n\\n    emit DepositJobCredits(jobKey_, msg.sender, amount, fee);\\n  }\\n\\n  function _calculateDepositFee() internal view returns (uint256 fee, uint256 amount) {\\n    fee = msg.value * feePpm / 1e6 /* 100% in ppm */;\\n    amount = msg.value - fee;\\n  }\\n\\n  /**\\n   * A job owner withdraws the job credits in NATIVE tokens.\\n   *\\n   * @param jobKey_ The jobKey\\n   * @param to_ The address to send NATIVE tokens to\\n   * @param amount_ The amount to withdraw. Use type(uint256).max for the total available credits withdrawal.\\n   */\\n  function withdrawJobCredits(\\n    bytes32 jobKey_,\\n    address payable to_,\\n    uint256 amount_\\n  ) external {\\n    uint88 creditsBefore = jobs[jobKey_].credits;\\n    if (amount_ == type(uint256).max) {\\n      amount_ = creditsBefore;\\n    }\\n\\n    _assertOnlyJobOwner(jobKey_);\\n    _assertNonZeroAmount(amount_);\\n\\n    if (creditsBefore < amount_) {\\n      revert CreditsWithdrawalUnderflow();\\n    }\\n\\n    unchecked {\\n      jobs[jobKey_].credits = creditsBefore - uint88(amount_);\\n    }\\n\\n    to_.transfer(amount_);\\n\\n    emit WithdrawJobCredits(jobKey_, msg.sender, to_, amount_);\\n  }\\n\\n  /**\\n   * Top-ups the job owner credits in NATIVE tokens.\\n   *\\n   * @param for_ The job owner address to deposit for\\n   */\\n  function depositJobOwnerCredits(address for_) external payable {\\n    _assertNonZeroValue();\\n\\n    _processJobOwnerCreditsDeposit(for_);\\n  }\\n\\n  function _processJobOwnerCreditsDeposit(address for_) internal {\\n    (uint256 fee, uint256 amount) = _calculateDepositFee();\\n\\n    unchecked {\\n      feeTotal += fee;\\n      jobOwnerCredits[for_] += amount;\\n    }\\n\\n    emit DepositJobOwnerCredits(for_, msg.sender, amount, fee);\\n  }\\n\\n  /**\\n   * A job owner withdraws the job owner credits in NATIVE tokens.\\n   *\\n   * @param to_ The address to send NATIVE tokens to\\n   * @param amount_ The amount to withdraw. Use type(uint256).max for the total available credits withdrawal.\\n   */\\n  function withdrawJobOwnerCredits(address payable to_, uint256 amount_) external {\\n    uint256 creditsBefore = jobOwnerCredits[msg.sender];\\n    if (amount_ == type(uint256).max) {\\n      amount_ = creditsBefore;\\n    }\\n\\n    _assertNonZeroAmount(amount_);\\n\\n    if (creditsBefore < amount_) {\\n      revert CreditsWithdrawalUnderflow();\\n    }\\n\\n    unchecked {\\n      jobOwnerCredits[msg.sender] = creditsBefore - amount_;\\n    }\\n\\n    to_.transfer(amount_);\\n\\n    emit WithdrawJobOwnerCredits(msg.sender, to_, amount_);\\n  }\\n\\n  /*** KEEPER INTERFACE ***/\\n\\n  /**\\n   * Actor registers as a keeper.\\n   * One keeper address could have multiple keeper IDs. Requires at least `minKeepCvp` as an initial CVP deposit.\\n   *\\n   * @dev Overflow-safe only for CVP which total supply is less than type(uint96).max\\n   * @dev Maximum 2^24-1 keepers supported. There is no explicit check for overflow, but the keepers with ID >= 2^24\\n   *         won't be able to perform upkeep operations.\\n   *\\n   * @param worker_ The worker address\\n   * @param initialDepositAmount_ The initial CVP deposit. Should be no less than `minKeepCvp`\\n   * @return keeperId The registered keeper ID\\n   */\\n  function registerAsKeeper(address worker_, uint256 initialDepositAmount_) external returns (uint256 keeperId) {\\n    _assertWorkerNotAssigned(worker_);\\n\\n    if (initialDepositAmount_ < minKeeperCvp) {\\n      revert InsufficientAmount();\\n    }\\n\\n    keeperId = ++lastKeeperId;\\n    keeperAdmins[keeperId] = msg.sender;\\n    keepers[keeperId] = Keeper(worker_, 0);\\n    workerKeeperIds[worker_] = keeperId;\\n    emit RegisterAsKeeper(keeperId, msg.sender, worker_);\\n\\n    _stake(keeperId, initialDepositAmount_);\\n  }\\n\\n  /**\\n   * A keeper updates a keeper worker address\\n   *\\n   * @param keeperId_ The keeper ID\\n   * @param worker_ The new worker address\\n   */\\n  function setWorkerAddress(uint256 keeperId_, address worker_) external {\\n    _assertOnlyKeeperAdmin(keeperId_);\\n    _assertWorkerNotAssigned(worker_);\\n\\n    address prev = keepers[keeperId_].worker;\\n    delete workerKeeperIds[prev];\\n    workerKeeperIds[worker_] = keeperId_;\\n    keepers[keeperId_].worker = worker_;\\n\\n    emit SetWorkerAddress(keeperId_, prev, worker_);\\n  }\\n\\n  /**\\n   * A keeper withdraws NATIVE token rewards.\\n   *\\n   * @param keeperId_ The keeper ID\\n   * @param to_ The address to withdraw to\\n   * @param amount_ The amount to withdraw. Use type(uint256).max for the total available compensation withdrawal.\\n   */\\n  function withdrawCompensation(uint256 keeperId_, address payable to_, uint256 amount_) external {\\n    uint256 available = compensations[keeperId_];\\n    if (amount_ == type(uint256).max) {\\n      amount_ = available;\\n    }\\n\\n    _assertNonZeroAmount(amount_);\\n    _assertOnlyKeeperAdminOrWorker(keeperId_);\\n\\n    if (amount_ > available) {\\n      revert WithdrawAmountExceedsAvailable(amount_, available);\\n    }\\n\\n    unchecked {\\n      compensations[keeperId_] = available - amount_;\\n    }\\n\\n    to_.transfer(amount_);\\n\\n    emit WithdrawCompensation(keeperId_, to_, amount_);\\n  }\\n\\n  /**\\n   * Deposits CVP for the given keeper ID. The beneficiary receives a derivative erc20 token in exchange of CVP.\\n   *   Accounts the staking amount on the beneficiary's stakeOf balance.\\n   *\\n   * @param keeperId_ The keeper ID\\n   * @param amount_ The amount to stake\\n   */\\n  function stake(uint256 keeperId_, uint256 amount_) external {\\n    _assertNonZeroAmount(amount_);\\n    _stake(keeperId_, amount_);\\n  }\\n\\n  function _stake(uint256 keeperId_, uint256 amount_) internal {\\n    CVP.transferFrom(msg.sender, address(this), amount_);\\n    keepers[keeperId_].cvpStake += uint96(amount_);\\n\\n    emit Stake(keeperId_, amount_, msg.sender);\\n  }\\n\\n  /**\\n   * A keeper initiates CVP withdrawal.\\n   * The given CVP amount needs to go through the cooldown stage. After the cooldown is complete this amount could be\\n   * withdrawn using `finalizeRedeem()` method.\\n   * The msg.sender burns the paCVP token in exchange of the corresponding CVP amount.\\n   * Accumulates the existing pending for withdrawal amounts and re-initiates cooldown period.\\n   * If there is any slashed amount for the msg.sender, it should be compensated within the first initiateRedeem transaction\\n   * by burning the equivalent amount of paCVP tokens. The remaining CVP tokens won't be redeemed unless the slashed\\n   * amount is compensated.\\n   *\\n   * @param keeperId_ The keeper ID\\n   * @param amount_ The amount to cooldown\\n   * @return pendingWithdrawalAfter The total pending for withdrawal amount\\n   */\\n  function initiateRedeem(uint256 keeperId_, uint256 amount_) external returns (uint256 pendingWithdrawalAfter) {\\n    _assertOnlyKeeperAdmin(keeperId_);\\n    _assertNonZeroAmount(amount_);\\n\\n    uint256 stakeOfBefore = keepers[keeperId_].cvpStake;\\n    uint256 slashedStakeOfBefore = slashedStakeOf[keeperId_];\\n    uint256 totalStakeBefore = stakeOfBefore + slashedStakeOfBefore;\\n\\n    // Should burn at least the total slashed stake\\n    if (amount_ < slashedStakeOfBefore) {\\n      revert InsufficientAmountToCoverSlashedStake(amount_, slashedStakeOfBefore);\\n    }\\n\\n    if (amount_ > totalStakeBefore) {\\n      revert AmountGtStake(amount_, stakeOfBefore, slashedStakeOfBefore);\\n    }\\n\\n    slashedStakeOf[keeperId_] = 0;\\n    uint256 stakeOfToReduceAmount;\\n    unchecked {\\n      stakeOfToReduceAmount = amount_ - slashedStakeOfBefore;\\n      keepers[keeperId_].cvpStake = uint96(stakeOfBefore - stakeOfToReduceAmount);\\n      pendingWithdrawalAmounts[keeperId_] += stakeOfToReduceAmount;\\n    }\\n\\n    pendingWithdrawalAfter = block.timestamp + pendingWithdrawalTimeoutSeconds;\\n    pendingWithdrawalEndsAt[keeperId_] = pendingWithdrawalAfter;\\n\\n    emit InitiateRedeem(keeperId_, amount_, stakeOfToReduceAmount, slashedStakeOfBefore);\\n  }\\n\\n  /**\\n   * A keeper finalizes CVP withdrawal and receives the staked CVP tokens.\\n   *\\n   * @param keeperId_ The keeper ID\\n   * @param to_ The address to transfer CVP to\\n   * @return redeemedCvp The redeemed CVP amount\\n   */\\n  function finalizeRedeem(uint256 keeperId_, address to_) external returns (uint256 redeemedCvp) {\\n    _assertOnlyKeeperAdmin(keeperId_);\\n\\n    if (pendingWithdrawalEndsAt[keeperId_] > block.timestamp) {\\n      revert WithdrawalTimoutNotReached();\\n    }\\n\\n    redeemedCvp = pendingWithdrawalAmounts[keeperId_];\\n    if (redeemedCvp == 0) {\\n      revert NoPendingWithdrawal();\\n    }\\n\\n    pendingWithdrawalAmounts[keeperId_] = 0;\\n    CVP.transfer(to_, redeemedCvp);\\n\\n    emit FinalizeRedeem(keeperId_, to_, redeemedCvp);\\n  }\\n\\n  /*** CONTRACT OWNER INTERFACE ***/\\n  /**\\n   * Slashes any keeper_ for an amount within keeper's deposit.\\n   * Penalises a keeper for malicious behaviour like sandwitching upkeep transactions.\\n   *\\n   * @param keeperId_ The keeper ID to slash\\n   * @param to_ The address to send the slashed CVP to\\n   * @param currentAmount_ The amount to slash from the current keeper.cvpStake balance\\n   * @param pendingAmount_ The amount to slash from the pendingWithdrawals balance\\n   */\\n  function slash(uint256 keeperId_, address to_, uint256 currentAmount_, uint256 pendingAmount_) external {\\n    _assertOnlyOwner();\\n    uint256 totalAmount = currentAmount_ + pendingAmount_;\\n    _assertNonZeroAmount(totalAmount);\\n\\n    if (currentAmount_ > 0) {\\n      keepers[keeperId_].cvpStake -= uint96(currentAmount_);\\n      slashedStakeOf[keeperId_] += currentAmount_;\\n    }\\n\\n    if (pendingAmount_ > 0) {\\n      pendingWithdrawalAmounts[keeperId_] -= pendingAmount_;\\n    }\\n\\n    CVP.transfer(to_, totalAmount);\\n\\n    emit Slash(keeperId_, to_, currentAmount_, pendingAmount_);\\n  }\\n\\n  /**\\n   * Owner withdraws all the accrued rewards in native tokens to the provided address.\\n   *\\n   * @param to_ The address to send rewards to\\n   */\\n  function withdrawFees(address payable to_) external {\\n    _assertOnlyOwner();\\n\\n    uint256 amount = feeTotal;\\n    feeTotal = 0;\\n\\n    to_.transfer(amount);\\n\\n    emit WithdrawFees(to_, amount);\\n  }\\n\\n  /**\\n   * Owner updates minKeeperCVP value\\n   *\\n   * @param minKeeperCvp_ The new minKeeperCVP value\\n   */\\n  function setAgentParams(\\n    uint256 minKeeperCvp_,\\n    uint256 timeoutSeconds_,\\n    uint256 feePpm_\\n  ) external {\\n    _assertOnlyOwner();\\n\\n    if (timeoutSeconds_ > MAX_PENDING_WITHDRAWAL_TIMEOUT_SECONDS) {\\n      revert TimeoutTooBig();\\n    }\\n    if (feePpm_ > MAX_FEE_PPM) {\\n      revert FeeTooBig();\\n    }\\n\\n    minKeeperCvp = minKeeperCvp_;\\n    pendingWithdrawalTimeoutSeconds = timeoutSeconds_;\\n    feePpm = feePpm_;\\n\\n    emit SetAgentParams(minKeeperCvp_, timeoutSeconds_, feePpm_);\\n  }\\n\\n  /*** GETTERS ***/\\n\\n  /**\\n   * Pure method that calculates keeper compensation based on a dynamic and a fixed multipliers.\\n   * DANGER: could overflow when used externally\\n   *\\n   * @param rewardPct_ The fixed percent. uint16. 0 == 0%, 100 == 100%, 500 == 500%, max 56535 == 56535%\\n   * @param fixedReward_ The fixed reward. uint32. Always multiplied by 1e15 (FIXED_PAYMENT_MULTIPLIER).\\n   *                     For ex. 2 == 2e15, 1_000 = 1e18, max 4294967295 == 4_294_967.295e18\\n   * @param blockBaseFee_ The block.basefee value.\\n   * @param gasUsed_ The gas used in wei.\\n   *\\n   */\\n  function calculateCompensationPure(\\n    uint256 rewardPct_,\\n    uint256 fixedReward_,\\n    uint256 blockBaseFee_,\\n    uint256 gasUsed_\\n  ) public pure returns (uint256) {\\n    unchecked {\\n      return (gasUsed_ + JOB_RUN_GAS_OVERHEAD) * blockBaseFee_ * rewardPct_ / 100\\n             + fixedReward_ * FIXED_PAYMENT_MULTIPLIER;\\n    }\\n  }\\n\\n  function getKeeperWorkerAndStake(uint256 keeperId_)\\n    external view returns (\\n      address worker,\\n      uint256 currentStake\\n    )\\n  {\\n    Keeper memory keeper = keepers[keeperId_];\\n\\n    return (\\n      keeper.worker,\\n      keeper.cvpStake\\n    );\\n  }\\n\\n  function getConfig()\\n    external view returns (\\n      uint256 minKeeperCvp_,\\n      uint256 pendingWithdrawalTimeoutSeconds_,\\n      uint256 feeTotal_,\\n      uint256 feePpm_,\\n      uint256 lastKeeperId_\\n    )\\n  {\\n    return (\\n      minKeeperCvp,\\n      pendingWithdrawalTimeoutSeconds,\\n      feeTotal,\\n      feePpm,\\n      lastKeeperId\\n    );\\n  }\\n\\n  function getKeeper(uint256 keeperId_)\\n    external view returns (\\n      address admin,\\n      address worker,\\n      uint256 currentStake,\\n      uint256 slashedStake,\\n      uint256 compensation,\\n      uint256 pendingWithdrawalAmount,\\n      uint256 pendingWithdrawalEndAt\\n    )\\n  {\\n    return (\\n      keeperAdmins[keeperId_],\\n      keepers[keeperId_].worker,\\n      keepers[keeperId_].cvpStake,\\n      slashedStakeOf[keeperId_],\\n      compensations[keeperId_],\\n      pendingWithdrawalAmounts[keeperId_],\\n      pendingWithdrawalEndsAt[keeperId_]\\n    );\\n  }\\n\\n  function getJob(bytes32 jobKey_)\\n    external view returns (\\n      address owner,\\n      address pendingTransfer,\\n      uint256 jobLevelMinKeeperCvp,\\n      Job memory details,\\n      bytes memory preDefinedCalldata,\\n      Resolver memory resolver\\n    )\\n  {\\n    return (\\n      jobOwners[jobKey_],\\n      jobPendingTransfers[jobKey_],\\n      jobMinKeeperCvp[jobKey_],\\n      jobs[jobKey_],\\n      preDefinedCalldatas[jobKey_],\\n      resolvers[jobKey_]\\n    );\\n  }\\n\\n  /**\\n   * Returns the principal job data stored in a single EVM slot.\\n   * @notice To get parsed job data use `getJob()` method instead.\\n   *\\n   * The job slot data layout:\\n   *  0x0000000000000a000000000a002300640000000de0b6b3a7640000d09de08a01\\n   *  0x      00000000   00000a   00             0000000a    0023      0064           0000000de0b6b3a7640000 d09de08a 01\\n   *  name    lastExecAt interval calldataSource fixedReward rewardPct maxBaseFeeGwei nativeCredits          selector config bitmask\\n   *  size b  bytes4     bytes3   bytes4         bytes4      bytes2    bytes2         bytes11                bytes4   bytes1\\n   *  size u  uint32     uint24   uint8          uint32      uint16    uint16         uint88                 uint32   uint8\\n   *  bits    0-3        4-6      7-7            8-11        12-13     14-15          16-26                  27-30    31-31\\n   */\\n  function getJobRaw(bytes32 jobKey_) public view returns (uint256 rawJob) {\\n    Job storage job = jobs[jobKey_];\\n    assembly {\\n      rawJob := sload(job.slot)\\n    }\\n  }\\n\\n  function getJobKey(address jobAddress_, uint256 jobId_) public pure returns (bytes32 jobKey) {\\n    assembly {\\n      mstore(0, shl(96, jobAddress_))\\n      mstore(20, shl(232, jobId_))\\n      jobKey := keccak256(0, 23)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/powerpool-agent-v2/contracts/PPAgentV2Flags.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ncontract PPAgentV2Flags {\\n  // Keeper pass this flags withing execute() transaction\\n  uint256 internal constant FLAG_ACCEPT_MAX_BASE_FEE_LIMIT = 0x01;\\n  uint256 internal constant FLAG_ACCRUE_REWARD = 0x02;\\n\\n  // Job owner uses CFG_* flags to configure a job options\\n  uint256 internal constant CFG_ACTIVE = 0x01;\\n  uint256 internal constant CFG_USE_JOB_OWNER_CREDITS = 0x02;\\n  uint256 internal constant CFG_ASSERT_RESOLVER_SELECTOR = 0x04;\\n  uint256 internal constant CFG_CHECK_KEEPER_MIN_CVP_DEPOSIT = 0x08;\\n\\n  uint256 internal constant BM_CLEAR_CONFIG = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00;\\n  uint256 internal constant BM_CLEAR_CREDITS = 0xffffffffffffffffffffffffffffffff0000000000000000000000ffffffffff;\\n  uint256 internal constant BM_CLEAR_LAST_UPDATE_AT = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": false,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cvp_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minKeeperCvp_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingWithdrawalTimeoutSeconds_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wanted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualSlashedStake\",\"type\":\"uint256\"}],\"name\":\"AmountGtStake\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jobMaxBaseFeeGwei\",\"type\":\"uint256\"}],\"name\":\"BaseFeeGtGasPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CreditsDepositOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CreditsWithdrawalUnderflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeeTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey\",\"type\":\"bytes32\"}],\"name\":\"InactiveJob\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wanted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InsufficientAmountToCoverSlashedStake\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wanted\",\"type\":\"uint256\"}],\"name\":\"InsufficientJobCredits\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wanted\",\"type\":\"uint256\"}],\"name\":\"InsufficientJobOwnerCredits\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientJobScopedKeeperStake\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientKeeperStake\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastExecutedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"IntervalNotReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCalldataSource\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidJobAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobCallRevertedWithoutDetails\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobIdOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobShouldHaveInterval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobWithoutOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"KeeperWorkerNotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingDeposit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingInputCalldata\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingJobAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingMaxBaseFeeGwei\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingResolverAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoFixedNorPremiumPctReward\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoPendingWithdrawal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonEOASender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSupportedByJobCalldataSource\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyJobOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyKeeperAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyKeeperAdminOrWorker\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyPendingOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SelectorCheckFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TimeoutTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wanted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"WithdrawAmountExceedsAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalTimoutNotReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WorkerAlreadyAssigned\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"jobKey_\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"}],\"name\":\"AcceptJobTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"jobKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"DepositJobCredits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"jobOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"DepositJobOwnerCredits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"jobKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"job\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"keeperId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"compensation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"binJobAfter\",\"type\":\"bytes32\"}],\"name\":\"Execute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"keeperId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FinalizeRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"jobKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"InitiateJobTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"keeperId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slashedStakeAmount\",\"type\":\"uint256\"}],\"name\":\"InitiateRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"jobKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBaseFeeGwei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPct\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fixedReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"jobMinCvp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"intervalSeconds\",\"type\":\"uint256\"}],\"name\":\"JobUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"keeperId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeperAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeperWorker\",\"type\":\"address\"}],\"name\":\"RegisterAsKeeper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"jobKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"jobAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"jobId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jobAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"jobSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"useJobOwnerCredits\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"assertResolverSelector\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"maxBaseFeeGwei\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rewardPct\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"fixedReward\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"jobMinCvp\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"calldataSource\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"intervalSeconds\",\"type\":\"uint24\"}],\"indexed\":false,\"internalType\":\"struct PPAgentV2.RegisterJobParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"RegisterJob\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minKeeperCvp_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeoutSeconds_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePct_\",\"type\":\"uint256\"}],\"name\":\"SetAgentParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"jobKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive_\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"useJobOwnerCredits_\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"assertResolverSelector_\",\"type\":\"bool\"}],\"name\":\"SetJobConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"jobKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"preDefinedCalldata\",\"type\":\"bytes\"}],\"name\":\"SetJobPreDefinedCalldata\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"jobKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"resolverAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"resolverCalldata\",\"type\":\"bytes\"}],\"name\":\"SetJobResolver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"keeperId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prev\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"worker\",\"type\":\"address\"}],\"name\":\"SetWorkerAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"keeperId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pendingAmount\",\"type\":\"uint256\"}],\"name\":\"Slash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"keeperId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"keeperId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawCompensation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"jobKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawJobCredits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"jobOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawJobOwnerCredits\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CVP\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey_\",\"type\":\"bytes32\"}],\"name\":\"acceptJobTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardPct_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedReward_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockBaseFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasUsed_\",\"type\":\"uint256\"}],\"name\":\"calculateCompensationPure\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey_\",\"type\":\"bytes32\"}],\"name\":\"depositJobCredits\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"for_\",\"type\":\"address\"}],\"name\":\"depositJobOwnerCredits\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"execute_44g58pv\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keeperId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"}],\"name\":\"finalizeRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemedCvp\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minKeeperCvp_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingWithdrawalTimeoutSeconds_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeTotal_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePpm_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastKeeperId_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey_\",\"type\":\"bytes32\"}],\"name\":\"getJob\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pendingTransfer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"jobLevelMinKeeperCvp\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"config\",\"type\":\"uint8\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"uint88\",\"name\":\"credits\",\"type\":\"uint88\"},{\"internalType\":\"uint16\",\"name\":\"maxBaseFeeGwei\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rewardPct\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"fixedReward\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"calldataSource\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"intervalSeconds\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"lastExecutionAt\",\"type\":\"uint32\"}],\"internalType\":\"struct IPPAgentV2Viewer.Job\",\"name\":\"details\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"preDefinedCalldata\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"resolverAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"resolverCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct IPPAgentV2Viewer.Resolver\",\"name\":\"resolver\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"jobAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"jobId_\",\"type\":\"uint256\"}],\"name\":\"getJobKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey_\",\"type\":\"bytes32\"}],\"name\":\"getJobRaw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rawJob\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keeperId_\",\"type\":\"uint256\"}],\"name\":\"getKeeper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"worker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slashedStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compensation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingWithdrawalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingWithdrawalEndAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keeperId_\",\"type\":\"uint256\"}],\"name\":\"getKeeperWorkerAndStake\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"worker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentStake\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"}],\"name\":\"initiateJobTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keeperId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"initiateRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingWithdrawalAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"jobLastIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"jobOwnerCredits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"worker_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialDepositAmount_\",\"type\":\"uint256\"}],\"name\":\"registerAsKeeper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"keeperId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"jobAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"jobSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"useJobOwnerCredits\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"assertResolverSelector\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"maxBaseFeeGwei\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rewardPct\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"fixedReward\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"jobMinCvp\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"calldataSource\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"intervalSeconds\",\"type\":\"uint24\"}],\"internalType\":\"struct PPAgentV2.RegisterJobParams\",\"name\":\"params_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"resolverAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"resolverCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct IPPAgentV2Viewer.Resolver\",\"name\":\"resolver_\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"preDefinedCalldata_\",\"type\":\"bytes\"}],\"name\":\"registerJob\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"jobId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minKeeperCvp_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeoutSeconds_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePpm_\",\"type\":\"uint256\"}],\"name\":\"setAgentParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey_\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isActive_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useJobOwnerCredits_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"assertResolverSelector_\",\"type\":\"bool\"}],\"name\":\"setJobConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"preDefinedCalldata_\",\"type\":\"bytes\"}],\"name\":\"setJobPreDefinedCalldata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey_\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"resolverAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"resolverCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct IPPAgentV2Viewer.Resolver\",\"name\":\"resolver_\",\"type\":\"tuple\"}],\"name\":\"setJobResolver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keeperId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"worker_\",\"type\":\"address\"}],\"name\":\"setWorkerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keeperId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingAmount_\",\"type\":\"uint256\"}],\"name\":\"slash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keeperId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey_\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"maxBaseFeeGwei_\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rewardPct_\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"fixedReward_\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"jobMinCvp_\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"intervalSeconds_\",\"type\":\"uint24\"}],\"name\":\"updateJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keeperId_\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdrawCompensation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to_\",\"type\":\"address\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobKey_\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdrawJobCredits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdrawJobOwnerCredits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"workerKeeperIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PPAgentV2","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"200000","ConstructorArguments":"000000000000000000000000b258302c3f209491d604165549079680708581cc00000000000000000000000038e4adb44ef08f22f5b5b76a8f0c2d0dcbe7dca100000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000069780","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]