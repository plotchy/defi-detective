[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"PreApproveRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./EnumerableAddressSetMap.sol\\\";\\n\\n/**\\n * @title PreApproveRegistry\\n * @notice A on-chain registry where listers can create lists\\n *         of pre-approved operators, which NFT collectors can subscribe to.\\n *         When a collector is subscribed to a list by a lister,\\n *         they can use pre-approved operators to manage their NFTs\\n *         if the NFT contracts consult this registry on whether the operator\\n *         is in the pre-approved list by lister.\\n *\\n *         For safety, newly added operators will need to wait some time\\n *         before they take effect.\\n */\\ncontract PreApproveRegistry {\\n    using EnumerableAddressSetMap for *;\\n\\n    // =============================================================\\n    //                            EVENTS\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `collector` subscribes to `lister`.\\n     * @param collector The NFT collector using the registry.\\n     * @param lister    The maintainer of the pre-approve list.\\n     */\\n    event Subscribed(address indexed collector, address indexed lister);\\n\\n    /**\\n     * @dev Emitted when `collector` unsubscribes from `lister`.\\n     * @param collector The NFT collector using the registry.\\n     * @param lister    The maintainer of the pre-approve list.\\n     */\\n    event Unsubscribed(address indexed collector, address indexed lister);\\n\\n    /**\\n     * @dev Emitted when `lister` adds `operator` to their pre-approve list.\\n     * @param lister    The maintainer of the pre-approve list.\\n     * @param operator  The account that can manage NFTs on behalf of\\n     *                  collectors subscribed to `lister`.\\n     * @param startTime The Unix timestamp when the `operator` can begin to manage\\n     *                  NFTs on on behalf of collectors subscribed to `lister`.\\n     */\\n    event OperatorAdded(\\n        address indexed lister, address indexed operator, uint256 indexed startTime\\n    );\\n\\n    /**\\n     * @dev Emitted when `lister` removes `operator` from their pre-approve list.\\n     * The `operator` will be immediately removed from the list.\\n     * @param lister    The maintainer of the pre-approve list.\\n     * @param operator  The account that can manage NFTs on behalf of\\n     *                  collectors subscribed to `lister`.\\n     */\\n    event OperatorRemoved(address indexed lister, address indexed operator);\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    /**\\n     * @dev The amount of time before a newly added `operator` becomes effective.\\n     */\\n    uint256 public constant START_DELAY = 86400 * 7;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    /**\\n     * @dev Mapping of `collector => EnumerableSet.AddressSet(lister => exists)`.\\n     */\\n    EnumerableAddressSetMap.Map internal _subscriptions;\\n\\n    /**\\n     * @dev Mapping of `lister => EnumerableSet.AddressSet(operator => exists)`.\\n     */\\n    EnumerableAddressSetMap.Map internal _operators;\\n\\n    /**\\n     * @dev For extra efficiency, we use our own custom mapping for the mapping of\\n     * (`lister`, `operator`) => `startTime`.\\n     * If `startTime` is zero, it is disabled.\\n     * Note: It is not possible for any added `operator` to have a `startTime` of zero,\\n     * since we are already past the Unix epoch.\\n     */\\n    uint256 internal _startTimes;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor() payable {}\\n\\n    // =============================================================\\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Subscribes the caller (collector) from `lister`.\\n     * @param lister The maintainer of the pre-approve list.\\n     */\\n    function subscribe(address lister) external payable {\\n        _subscriptions.add(msg.sender, lister);\\n        emit Subscribed(msg.sender, lister);\\n    }\\n\\n    /**\\n     * @dev Unsubscribes the caller (collector) from `lister`.\\n     * @param lister The maintainer of the pre-approve list.\\n     */\\n    function unsubscribe(address lister) external payable {\\n        _subscriptions.remove(msg.sender, lister);\\n        emit Unsubscribed(msg.sender, lister);\\n    }\\n\\n    /**\\n     * @dev Adds the `operator` to the pre-approve list maintained by the caller (lister).\\n     * @param operator The account that can manage NFTs on behalf of\\n     *                 collectors subscribed to the caller.\\n     */\\n    function addOperator(address operator) external payable {\\n        _operators.add(msg.sender, operator);\\n        uint256 begins;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            begins := add(timestamp(), START_DELAY)\\n            // The sequence of overlays automatically cleans the upper bits of `operator`.\\n            // Equivalent to:\\n            // `_startTimes[lister][operator] = begins`.\\n            mstore(0x20, operator)\\n            mstore(0x0c, _startTimes.slot)\\n            mstore(returndatasize(), caller())\\n            sstore(keccak256(0x0c, 0x34), begins)\\n        }\\n        emit OperatorAdded(msg.sender, operator, begins);\\n    }\\n\\n    /**\\n     * @dev Removes the `operator` from the pre-approve list maintained by the caller (lister).\\n     * @param operator The account that can manage NFTs on behalf of\\n     *                 collectors subscribed to the caller.\\n     */\\n    function removeOperator(address operator) external payable {\\n        _operators.remove(msg.sender, operator);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The sequence of overlays automatically cleans the upper bits of `operator`.\\n            // Equivalent to:\\n            // `_startTimes[lister][operator] = 0`.\\n            mstore(0x20, operator)\\n            mstore(0x0c, _startTimes.slot)\\n            mstore(returndatasize(), caller())\\n            sstore(keccak256(0x0c, 0x34), returndatasize())\\n        }\\n        emit OperatorRemoved(msg.sender, operator);\\n    }\\n\\n    // =============================================================\\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns whether `collector` is subscribed to `lister`.\\n     * @param collector The NFT collector using the registry.\\n     * @param lister    The maintainer of the pre-approve list.\\n     * @return has Whether the `collector` is subscribed.\\n     */\\n    function hasSubscription(address collector, address lister) external view returns (bool has) {\\n        has = _subscriptions.contains(collector, lister);\\n    }\\n\\n    /**\\n     * @dev Returns an array of all the listers which `collector` is subscribed to.\\n     * @param collector The NFT collector using the registry.\\n     * @return list The list of listers.\\n     */\\n    function subscriptions(address collector) external view returns (address[] memory list) {\\n        list = _subscriptions.values(collector);\\n    }\\n\\n    /**\\n     * @dev Returns the total number of listers `collector` is subscribed to.\\n     * @param collector The NFT collector using the registry.\\n     * @return total The length of the list of listers subscribed by `collector`.\\n     */\\n    function totalSubscriptions(address collector) external view returns (uint256 total) {\\n        total = _subscriptions.length(collector);\\n    }\\n\\n    /**\\n     * @dev Returns the `lister` which `collector` is subscribed to at `index`.\\n     * @param collector The NFT collector using the registry.\\n     * @param index     The index of the enumerable set.\\n     * @return lister The mainter of the pre-approve list.\\n     */\\n    function subscriptionAt(address collector, uint256 index)\\n        external\\n        view\\n        returns (address lister)\\n    {\\n        lister = _subscriptions.at(collector, index);\\n    }\\n\\n    /**\\n     * @dev Returns the list of operators in the pre-approve list by `lister`.\\n     * @param lister The maintainer of the pre-approve list.\\n     * @return list  The list of operators.\\n     */\\n    function operators(address lister) external view returns (address[] memory list) {\\n        list = _operators.values(lister);\\n    }\\n\\n    /**\\n     * @dev Returns the list of operators in the pre-approve list by `lister`.\\n     * @param lister The maintainer of the pre-approve list.\\n     * @return total The length of the list of operators.\\n     */\\n    function totalOperators(address lister) external view returns (uint256 total) {\\n        total = _operators.length(lister);\\n    }\\n\\n    /**\\n     * @dev Returns the operator at `index` of the pre-approve list by `lister`.\\n     * @param lister The maintainer of the pre-approve list.\\n     * @param index  The index of the list.\\n     * @param operator The account that can manage NFTs on behalf of\\n     *                 collectors subscribed to `lister`.\\n     */\\n    function operatorAt(address lister, uint256 index)\\n        external\\n        view\\n        returns (address operator, uint256 begins)\\n    {\\n        operator = _operators.at(lister, index);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to:\\n            // `begins = _startTimes[lister][operator]`.\\n            mstore(0x20, operator)\\n            mstore(0x0c, _startTimes.slot)\\n            mstore(returndatasize(), lister)\\n            begins := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the Unix timestamp when `operator` is able to start managing\\n     *      the NFTs of collectors subscribed to `lister`.\\n     * @param lister   The maintainer of the pre-approve list.\\n     * @param operator The account that can manage NFTs on behalf of\\n     *                 collectors subscribed to `lister`.\\n     * @return begins The Unix timestamp.\\n     */\\n    function startTime(address lister, address operator) external view returns (uint256 begins) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to:\\n            // `begins = _startTimes[lister][operator]`.\\n            mstore(0x20, operator)\\n            mstore(0x0c, _startTimes.slot)\\n            mstore(returndatasize(), lister)\\n            begins := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether the `operator` can manage NFTs on the behalf\\n     *      of `collector` if `collector` is subscribed to `lister`.\\n     * @param operator  The account that can manage NFTs on behalf of\\n     *                  collectors subscribed to `lister`.\\n     * @param collector The NFT collector using the registry.\\n     * @param lister    The maintainer of the pre-approve list.\\n     * @return Whether `operator` is effectively pre-approved.\\n     */\\n    function isPreApproved(address operator, address collector, address lister)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to:\\n            // `if (!_subscriptions.contains(collector, lister)) returns false;`.\\n            mstore(0x20, lister)\\n            mstore(0x0c, returndatasize())\\n            mstore(returndatasize(), collector)\\n            if iszero(sload(keccak256(0x0c, 0x34))) { return(0x60, 0x20) }\\n\\n            // Equivalent to:\\n            // `return _startTimes[lister][operator] != 0 &&\\n            //         _startTimes[lister][operator] >= block.timestamp`.\\n            mstore(0x20, operator)\\n            mstore(0x0c, _startTimes.slot)\\n            mstore(returndatasize(), lister)\\n            let begins := sload(keccak256(0x0c, 0x34))\\n            mstore(returndatasize(), iszero(or(iszero(begins), lt(timestamp(), begins))))\\n            return(returndatasize(), 0x20)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"EnumerableAddressSetMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title PreApproveRegistry\\n * @notice This library enumlates a `mapping(address => EnumerableSet.AddressSet())`.\\n *         For gas savings, we shall use `returndatasize()` as a replacement for 0.\\n *         Modified from OpenZeppelin's EnumerableSet (MIT Licensed).\\n *         https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol\\n */\\nlibrary EnumerableAddressSetMap {\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    /**\\n     * @dev A storage mapping of enumerable address sets.\\n     */\\n    struct Map {\\n        // Mapping of keys to the values of the enumerable address sets.\\n        mapping(address => address[]) _values;\\n    }\\n\\n    // =============================================================\\n    //                        WRITE FUNCTIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Adds `value` into the enumerable address set at `key` to `map`.\\n     *      Does not revert if the `value` exists.\\n     * @param map   The mapping of enumerable address sets.\\n     * @param key   The key into the mapping.\\n     * @param value The value to add.\\n     */\\n    function add(Map storage map, address key, address value) internal {\\n        if (!contains(map, key, value)) {\\n            address[] storage currValues = map._values[key];\\n            currValues.push(value);\\n\\n            uint256 n = currValues.length;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // The value is stored at length-1, but we add 1 to all indexes\\n                // and use 0 as a sentinel value.\\n                // Equivalent to:\\n                // `_indexes[key][value] = n`.\\n                mstore(0x20, value)\\n                mstore(0x0c, map.slot)\\n                mstore(returndatasize(), key)\\n                sstore(keccak256(0x0c, 0x34), n)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes `value` into the enumerable address set at `key` to `map`.\\n     *      Does not revert if the `value` does not exist.\\n     * @param map   The mapping of enumerable address sets.\\n     * @param key   The key into the mapping.\\n     * @param value The value to remove.\\n     */\\n    function remove(Map storage map, address key, address value) internal {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex;\\n        uint256 valueSlot;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value.\\n            // Equivalent to:\\n            // `valueIndex = _indexes[key][value]`.\\n            mstore(0x20, value)\\n            mstore(0x0c, map.slot)\\n            mstore(returndatasize(), key)\\n            valueSlot := keccak256(0x0c, 0x34)\\n            valueIndex := sload(valueSlot)\\n        }\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(map, value)\\n            // To delete an element from the _values array in O(1),\\n            // we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n            unchecked {\\n                address[] storage currValues = map._values[key];\\n                uint256 lastIndex = currValues.length - 1;\\n                uint256 toDeleteIndex = valueIndex - 1;\\n\\n                if (lastIndex != toDeleteIndex) {\\n                    address lastValue = currValues[lastIndex];\\n\\n                    // Move the last value to the index where the value to delete is.\\n                    currValues[toDeleteIndex] = lastValue;\\n\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        // Update the index for the moved value.\\n                        // Equivalent to:\\n                        // `_indexes[key][lastValue] = valueIndex`.\\n                        mstore(0x20, lastValue)\\n                        mstore(0x0c, map.slot)\\n                        mstore(returndatasize(), key)\\n                        // Replace lastValue's index to valueIndex\\n                        sstore(keccak256(0x0c, 0x34), valueIndex)\\n                    }\\n                }\\n                // Delete the slot where the moved value was stored\\n                currValues.pop();\\n\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    // Delete the index for the deleted slot\\n                    // Equivalent to:\\n                    // `_indexes[key][value] = 0`.\\n                    sstore(valueSlot, 0)\\n                }\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        VIEW FUNCTIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns whether `value` is in the enumerable address set\\n     *      at `key` in `map`.\\n     * @param map   The mapping of enumerable address sets.\\n     * @param key   The key into the mapping.\\n     * @param value The value to check.\\n     * @return result The result.\\n     */\\n    function contains(Map storage map, address key, address value)\\n        internal\\n        view\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value.\\n            // Equivalent to:\\n            // `result = _indexes[key][lastValue] != 0`.\\n            mstore(0x20, value)\\n            mstore(0x0c, map.slot)\\n            mstore(returndatasize(), key)\\n            result := iszero(iszero(sload(keccak256(0x0c, 0x34))))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the length of the enumerable address set\\n     *      at `key` in `map`.\\n     * @param map The mapping of enumerable address sets.\\n     * @param key The key into the mapping.\\n     * @return The length.\\n     */\\n    function length(Map storage map, address key) internal view returns (uint256) {\\n        return map._values[key].length;\\n    }\\n\\n    /**\\n     * @dev Returns the value at `index` of the enumerable address set\\n     *      at `key` in `map`.\\n     * @param map   The mapping of enumerable address sets.\\n     * @param key   The key into the mapping.\\n     * @param index The index of the enumerable address set.\\n     * @return The value.\\n     */\\n    function at(Map storage map, address key, uint256 index) internal view returns (address) {\\n        return map._values[key][index];\\n    }\\n\\n    /**\\n     * @dev Returns all the values of the enumerable address set\\n     *      at `key` in `map`.\\n     * @param map The mapping of enumerable address sets.\\n     * @param key The key into the mapping.\\n     * @return The values.\\n     */\\n    function values(Map storage map, address key) internal view returns (address[] memory) {\\n        return map._values[key];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"}],\"name\":\"Subscribed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"}],\"name\":\"Unsubscribed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"START_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"}],\"name\":\"hasSubscription\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"has\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"}],\"name\":\"isPreApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"operatorAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"begins\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"begins\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"}],\"name\":\"subscribe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"subscriptionAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"}],\"name\":\"subscriptions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"}],\"name\":\"totalOperators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"}],\"name\":\"totalSubscriptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"}],\"name\":\"unsubscribe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"PreApproveRegistry","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]