[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/AvnNftListingsV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.14;\\r\\n\\r\\nimport \\\"./interfaces/IAvnNftListingsV1.sol\\\";\\r\\n\\r\\ncontract AvnNftListingsV1 is IAvnNftListingsV1 {\\r\\n\\r\\n  string public clientName;\\r\\n  string constant private AUCTION_CONTEXT = \\\"AVN_START_AUCTION\\\";\\r\\n  string constant private BATCH_CONTEXT = \\\"AVN_START_BATCH\\\";\\r\\n  string constant private SALE_CONTEXT = \\\"AVN_START_SALE\\\";\\r\\n  uint32 constant private ONE_MILLION = 1000000;\\r\\n  bytes16 constant private HEX_BASE = \\\"0123456789abcdef\\\";\\r\\n\\r\\n  bool private payingOut;\\r\\n  bool private initialized;\\r\\n  uint256 private rId;\\r\\n\\r\\n  mapping (uint256 => Royalty[]) private royalties;\\r\\n  mapping (uint256 => Listing) private listing;\\r\\n  mapping (uint256 => Batch) private batch;\\r\\n  mapping (uint256 => Bid) private highBid;\\r\\n  mapping (uint256 => uint256) private royaltiesId;\\r\\n  mapping (address => bool) public isAuthority;\\r\\n  mapping (bytes32 => bool) private proofUsed;\\r\\n  address[] private authorities;\\r\\n\\r\\n  modifier isNotListed(uint256 _batchIdOrNftId) {\\r\\n    require(listing[_batchIdOrNftId].state == State.Unlisted, \\\"Listing already exists\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier isListedForAuction(uint256 _nftId) {\\r\\n    require(listing[_nftId].state == State.Auction, \\\"Auction not listed\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier isListedForBatchSale(uint256 _batchId) {\\r\\n    require(listing[_batchId].state == State.Batch, \\\"Batch not listed\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier isListedForSale(uint256 _nftId) {\\r\\n    require(listing[_nftId].state == State.Sale, \\\"Sale not listed\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier hasAvnPublicKey(bytes32 _avnPublicKey) {\\r\\n    require(_avnPublicKey != 0, \\\"Missing AVN public key\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier onlySeller(uint256 _nftId) {\\r\\n    require(listing[_nftId].seller == msg.sender, \\\"Only seller\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier onlyAuthority() {\\r\\n    require(isAuthority[msg.sender], \\\"Only authority\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier onlySellerOrAuthority(uint256 _batchIdOrNftId) {\\r\\n    require(msg.sender == listing[_batchIdOrNftId].seller || isAuthority[msg.sender], \\\"Only seller or authority\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  // Only runs to lock the implementation\\r\\n  constructor() {\\r\\n    initialized = true;\\r\\n  }\\r\\n\\r\\n  function initialize(string calldata _clientName, address _initialAuthority)\\r\\n    external\\r\\n  {\\r\\n    require(!initialized, \\\"Already initialized\\\");\\r\\n    require(keccak256(abi.encodePacked(_clientName)) != keccak256(abi.encodePacked(\\\"\\\")), \\\"Missing client name\\\");\\r\\n    isAuthority[_initialAuthority] = true;\\r\\n    authorities.push(_initialAuthority);\\r\\n    clientName = _clientName;\\r\\n    initialized = true;\\r\\n  }\\r\\n\\r\\n  function setAuthority(address _authority, bool _isAuthorised)\\r\\n    external\\r\\n    onlyAuthority\\r\\n  {\\r\\n    require(_authority != msg.sender, \\\"Cannot set self\\\");\\r\\n    require(_authority != address(0), \\\"Cannot be zero address\\\");\\r\\n\\r\\n    if (_isAuthorised == isAuthority[_authority])\\r\\n      return;\\r\\n    else if (_isAuthorised) {\\r\\n      isAuthority[_authority] = true;\\r\\n      authorities.push(_authority);\\r\\n    } else {\\r\\n      isAuthority[_authority] = false;\\r\\n      uint256 endAuthority = authorities.length - 1;\\r\\n      for (uint256 i; i < endAuthority;) {\\r\\n        if (authorities[i] == _authority) {\\r\\n          authorities[i] = authorities[endAuthority];\\r\\n          break;\\r\\n        }\\r\\n        unchecked { i++; }\\r\\n      }\\r\\n      authorities.pop();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function getAuthorities()\\r\\n    external\\r\\n    view\\r\\n    returns (address[] memory)\\r\\n  {\\r\\n    return authorities;\\r\\n  }\\r\\n\\r\\n  function getRoyalties(uint256 _batchIdOrNftId)\\r\\n    external\\r\\n    view\\r\\n    returns(Royalty[] memory)\\r\\n  {\\r\\n    return royalties[royaltiesId[_batchIdOrNftId]];\\r\\n  }\\r\\n\\r\\n  function startAuction(uint256 _nftId, bytes32 _avnPublicKey, uint256 _reservePrice, uint256 _endTime, uint64 _avnOpId,\\r\\n      Royalty[] calldata _royalties, bytes calldata _proof)\\r\\n    external\\r\\n    hasAvnPublicKey(_avnPublicKey)\\r\\n    isNotListed(_nftId)\\r\\n  {\\r\\n    require(_nftId != 0, \\\"Missing NFT ID\\\");\\r\\n    checkProof(keccak256(abi.encode(AUCTION_CONTEXT, address(this), _nftId, _avnPublicKey, msg.sender, _endTime, _avnOpId,\\r\\n        _royalties)), _proof);\\r\\n    setRoyalties(_nftId, _royalties);\\r\\n    emit LogStartAuction(_nftId, _avnPublicKey, _reservePrice, _endTime);\\r\\n\\r\\n    if (block.timestamp > _endTime) {\\r\\n      emit LogAuctionCancelled(_nftId);\\r\\n      emit AvnCancelNftListing(_nftId, _avnOpId);\\r\\n    } else {\\r\\n      listing[_nftId].state = State.Auction;\\r\\n      listing[_nftId].seller = msg.sender;\\r\\n      listing[_nftId].avnOpId = _avnOpId;\\r\\n      listing[_nftId].endTime = _endTime;\\r\\n      if (_reservePrice > 0) {\\r\\n        unchecked { highBid[_nftId].amount = _reservePrice - 1; }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function bid(uint256 _nftId, bytes32 _avnPublicKey)\\r\\n    external\\r\\n    payable\\r\\n    hasAvnPublicKey(_avnPublicKey)\\r\\n    isListedForAuction(_nftId)\\r\\n  {\\r\\n    require(block.timestamp <= listing[_nftId].endTime, \\\"Bidding has ended\\\");\\r\\n    require(msg.value > highBid[_nftId].amount, \\\"Bid too low\\\");\\r\\n\\r\\n    refundAnyExistingBid(_nftId);\\r\\n    highBid[_nftId].bidder = msg.sender;\\r\\n    highBid[_nftId].avnPublicKey = _avnPublicKey;\\r\\n    highBid[_nftId].amount = msg.value;\\r\\n    emit LogBid(_nftId, _avnPublicKey, msg.value);\\r\\n  }\\r\\n\\r\\n  function endAuction(uint256 _nftId)\\r\\n    external\\r\\n    isListedForAuction(_nftId)\\r\\n    onlySeller(_nftId)\\r\\n  {\\r\\n    require(block.timestamp > listing[_nftId].endTime, \\\"Cannot end auction yet\\\");\\r\\n\\r\\n    if (highBid[_nftId].bidder == address(0)) {\\r\\n      emit LogAuctionCancelled(_nftId);\\r\\n      emit AvnCancelNftListing(_nftId, listing[_nftId].avnOpId);\\r\\n    } else {\\r\\n      uint256 amount = highBid[_nftId].amount;\\r\\n      bytes32 avnPublicKey = highBid[_nftId].avnPublicKey;\\r\\n      delete highBid[_nftId];\\r\\n      distributeFunds(royalties[royaltiesId[_nftId]], amount, msg.sender);\\r\\n      emit LogAuctionComplete(_nftId, avnPublicKey, amount);\\r\\n      emit AvnTransferTo(_nftId, avnPublicKey, listing[_nftId].avnOpId);\\r\\n    }\\r\\n\\r\\n    delete listing[_nftId];\\r\\n  }\\r\\n\\r\\n  function cancelAuction(uint256 _nftId)\\r\\n    external\\r\\n    isListedForAuction(_nftId)\\r\\n    onlySellerOrAuthority(_nftId)\\r\\n  {\\r\\n    uint64 opId = listing[_nftId].avnOpId;\\r\\n    delete listing[_nftId];\\r\\n    refundAnyExistingBid(_nftId);\\r\\n    highBid[_nftId].avnPublicKey = 0;\\r\\n    highBid[_nftId].amount = 0;\\r\\n    emit LogAuctionCancelled(_nftId);\\r\\n    emit AvnCancelNftListing(_nftId, opId);\\r\\n  }\\r\\n\\r\\n  function startBatchSale(uint256 _batchId, bytes32 _avnPublicKey, uint256 _price, Batch calldata _batchData,\\r\\n      Royalty[] calldata _royalties, bytes calldata _proof)\\r\\n    external\\r\\n    hasAvnPublicKey(_avnPublicKey)\\r\\n    isNotListed(_batchId)\\r\\n  {\\r\\n    checkProof(keccak256(abi.encode(BATCH_CONTEXT, address(this), _batchId, _avnPublicKey, msg.sender, _batchData, _royalties)),\\r\\n        _proof);\\r\\n    setRoyalties(_batchId, _royalties);\\r\\n    emit LogStartBatchSale(_batchId, _avnPublicKey, _price, setBatchListing(_batchId, _price, _batchData.supply, _batchData.saleIndex));\\r\\n  }\\r\\n\\r\\n  function buyFromBatch(uint256 _batchId, bytes32 _avnPublicKey)\\r\\n    external\\r\\n    payable\\r\\n    hasAvnPublicKey(_avnPublicKey)\\r\\n    isListedForBatchSale(_batchId)\\r\\n  {\\r\\n    require(msg.value == listing[_batchId].price, \\\"Incorrect price\\\");\\r\\n    uint64 saleIndex;\\r\\n    unchecked { saleIndex = ++batch[_batchId].saleIndex; }\\r\\n    require(saleIndex <= batch[_batchId].supply, \\\"Sold out\\\");\\r\\n    uint256 nftId = uint256(keccak256(abi.encode(\\\"B\\\", _batchId, saleIndex)));\\r\\n    royaltiesId[nftId] = royaltiesId[_batchId];\\r\\n    unchecked { listing[_batchId].saleFunds += msg.value; }\\r\\n\\r\\n    emit AvnMintTo(_batchId, saleIndex, _avnPublicKey, formatAsUUID(nftId));\\r\\n  }\\r\\n\\r\\n  function endBatchSale(uint256 _batchId)\\r\\n    external\\r\\n    isListedForBatchSale(_batchId)\\r\\n    onlySeller(_batchId)\\r\\n  {\\r\\n    uint256 totalSalesAmount = listing[_batchId].saleFunds;\\r\\n    delete listing[_batchId];\\r\\n    if (totalSalesAmount > 0) distributeFunds(royalties[royaltiesId[_batchId]], totalSalesAmount, msg.sender);\\r\\n    uint64 remaining;\\r\\n    unchecked { remaining = batch[_batchId].supply - batch[_batchId].saleIndex; }\\r\\n    emit LogBatchSaleEnded(_batchId, remaining);\\r\\n    emit AvnEndBatchListing(_batchId);\\r\\n  }\\r\\n\\r\\n  function cancelBatchSale(uint256 _batchId)\\r\\n    external\\r\\n    isListedForBatchSale(_batchId)\\r\\n    onlyAuthority()\\r\\n  {\\r\\n    uint256 salesToRefund = listing[_batchId].saleFunds;\\r\\n    delete listing[_batchId];\\r\\n    if (salesToRefund > 0) sendFunds(msg.sender, salesToRefund);\\r\\n    emit LogBatchSaleCancelled(_batchId);\\r\\n    emit AvnEndBatchListing(_batchId);\\r\\n  }\\r\\n\\r\\n  function startNftSale(uint256 _nftId, bytes32 _avnPublicKey, uint256 _price, uint64 _avnOpId,\\r\\n      Royalty[] calldata _royalties, bytes calldata _proof)\\r\\n    external\\r\\n    hasAvnPublicKey(_avnPublicKey)\\r\\n    isNotListed(_nftId)\\r\\n  {\\r\\n    require(_nftId != 0, \\\"Missing NFT ID\\\");\\r\\n    require(_price != 0, \\\"Missing price\\\");\\r\\n    checkProof(keccak256(abi.encode(SALE_CONTEXT, address(this), _nftId, _avnPublicKey, msg.sender, _avnOpId, _royalties)),\\r\\n        _proof);\\r\\n    setRoyalties(_nftId, _royalties);\\r\\n    listing[_nftId].state = State.Sale;\\r\\n    listing[_nftId].seller = msg.sender;\\r\\n    listing[_nftId].avnOpId = _avnOpId;\\r\\n    listing[_nftId].price = _price;\\r\\n    emit LogStartNftSale(_nftId, _avnPublicKey, _price);\\r\\n  }\\r\\n\\r\\n  function buyNft(uint256 _nftId, bytes32 _avnPublicKey)\\r\\n    external\\r\\n    payable\\r\\n    hasAvnPublicKey(_avnPublicKey)\\r\\n    isListedForSale(_nftId)\\r\\n  {\\r\\n    require(msg.value == listing[_nftId].price, \\\"Incorrect price\\\");\\r\\n    distributeFunds(royalties[royaltiesId[_nftId]], msg.value, listing[_nftId].seller);\\r\\n    emit LogSold(_nftId, _avnPublicKey);\\r\\n    emit AvnTransferTo(_nftId, _avnPublicKey, listing[_nftId].avnOpId);\\r\\n    delete listing[_nftId];\\r\\n  }\\r\\n\\r\\n  function cancelNftSale(uint256 _nftId)\\r\\n    external\\r\\n    isListedForSale(_nftId)\\r\\n    onlySellerOrAuthority(_nftId)\\r\\n  {\\r\\n    emit LogNftSaleCancelled(_nftId);\\r\\n    emit AvnCancelNftListing(_nftId, listing[_nftId].avnOpId);\\r\\n    delete listing[_nftId];\\r\\n  }\\r\\n\\r\\n  function sendFunds(address _recipient, uint256 _amount)\\r\\n    private\\r\\n  {\\r\\n    bool success = payable(_recipient).send(_amount);\\r\\n    if (!success) {\\r\\n      payable(authorities[0]).transfer(_amount);\\r\\n      emit LogFundsDivertedOnFailure(_recipient, authorities[0], _amount);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function checkProof(bytes32 _msgHash, bytes memory _proof)\\r\\n    private\\r\\n  {\\r\\n    require(!proofUsed[_msgHash], \\\"Proof already used\\\");\\r\\n    proofUsed[_msgHash] = true;\\r\\n    address signer = recover(keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _msgHash)), _proof);\\r\\n    require(isAuthority[signer], \\\"Invalid proof\\\");\\r\\n  }\\r\\n\\r\\n  function recover(bytes32 hash, bytes memory signature)\\r\\n    private\\r\\n    pure\\r\\n    returns (address)\\r\\n  {\\r\\n    if (signature.length != 65) return address(0);\\r\\n\\r\\n    bytes32 r;\\r\\n    bytes32 s;\\r\\n    uint8 v;\\r\\n\\r\\n    assembly {\\r\\n      r := mload(add(signature, 0x20))\\r\\n      s := mload(add(signature, 0x40))\\r\\n      v := byte(0, mload(add(signature, 0x60)))\\r\\n    }\\r\\n\\r\\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) return address(0);\\r\\n    if (v < 27) v += 27;\\r\\n    if (v != 27 && v != 28) return address(0);\\r\\n\\r\\n    return ecrecover(hash, v, r, s);\\r\\n  }\\r\\n\\r\\n  function refundAnyExistingBid(uint256 _nftId)\\r\\n    private\\r\\n  {\\r\\n    address bidder = highBid[_nftId].bidder;\\r\\n    if (bidder == address(0)) return;\\r\\n    highBid[_nftId].bidder = address(0);\\r\\n    sendFunds(bidder, highBid[_nftId].amount);\\r\\n  }\\r\\n\\r\\n  function distributeFunds(Royalty[] memory _royalties, uint256 _amount, address _seller)\\r\\n    private\\r\\n  {\\r\\n    assert(!payingOut);\\r\\n    payingOut = true;\\r\\n    uint256 remaining = _amount;\\r\\n\\r\\n    if (_royalties.length > 0) {\\r\\n      uint256 royaltyPayment;\\r\\n      for (uint256 i; i < _royalties.length;) {\\r\\n        royaltyPayment = _amount * _royalties[i].partsPerMil / ONE_MILLION;\\r\\n        unchecked { remaining -= royaltyPayment; }\\r\\n        sendFunds(_royalties[i].recipient, royaltyPayment);\\r\\n        unchecked { i++; }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    sendFunds(_seller, remaining);\\r\\n    payingOut = false;\\r\\n  }\\r\\n\\r\\n  function setBatchListing(uint256 _batchId, uint256 _price, uint64 _supply, uint64 _saleIndex)\\r\\n    private\\r\\n    returns (uint64 amountAvailable_)\\r\\n  {\\r\\n    require(_batchId != 0, \\\"Missing batch ID\\\");\\r\\n    require(_price != 0, \\\"Missing price\\\");\\r\\n    require(_supply != 0, \\\"Missing supply\\\");\\r\\n\\r\\n    uint64 supply = batch[_batchId].supply;\\r\\n\\r\\n    if (supply == 0) {\\r\\n      batch[_batchId].supply = _supply;\\r\\n      supply = _supply;\\r\\n    } else {\\r\\n      require(supply == _supply, \\\"Cannot alter supply\\\");\\r\\n    }\\r\\n\\r\\n    uint64 saleIndex = batch[_batchId].saleIndex;\\r\\n    require(supply > saleIndex, \\\"None to sell\\\");\\r\\n    require(_saleIndex >= saleIndex, \\\"Cannot reduce sales\\\");\\r\\n    batch[_batchId].saleIndex = _saleIndex;\\r\\n\\r\\n    listing[_batchId].state = State.Batch;\\r\\n    listing[_batchId].seller = msg.sender;\\r\\n    listing[_batchId].price = _price;\\r\\n\\r\\n    unchecked { amountAvailable_ = supply - saleIndex; }\\r\\n  }\\r\\n\\r\\n  function setRoyalties(uint256 _id, Royalty[] memory _royalties)\\r\\n    private\\r\\n  {\\r\\n    if (_royalties.length == 0 || royaltiesId[_id] != 0) return;\\r\\n    uint256 next_rId = rId;\\r\\n    unchecked { next_rId++; }\\r\\n    rId = next_rId;\\r\\n    royaltiesId[_id] = next_rId;\\r\\n    uint64 totalRoyalties;\\r\\n\\r\\n    for (uint256 i; i < _royalties.length;) {\\r\\n      if (_royalties[i].recipient != address(0) && _royalties[i].partsPerMil != 0) {\\r\\n        totalRoyalties += _royalties[i].partsPerMil;\\r\\n        require(totalRoyalties <= ONE_MILLION, \\\"Royalties too high\\\");\\r\\n        royalties[next_rId].push(_royalties[i]);\\r\\n      }\\r\\n      unchecked { i++; }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function formatAsUUID(uint256 _nftId)\\r\\n    private\\r\\n    pure\\r\\n    returns(string memory uuid_)\\r\\n  {\\r\\n    bytes16 halfNftId = bytes16(uint128(_nftId >> 128));\\r\\n\\r\\n    uuid_ = string(abi.encodePacked(\\r\\n      hexSlice(0, 4, 8, halfNftId), \\\"-\\\",\\r\\n      hexSlice(4, 6, 4, halfNftId), \\\"-\\\",\\r\\n      hexSlice(6, 8, 4, halfNftId), \\\"-\\\",\\r\\n      hexSlice(8, 10, 4, halfNftId), \\\"-\\\",\\r\\n      hexSlice(10, 16, 12, halfNftId)));\\r\\n  }\\r\\n\\r\\n  function hexSlice(uint256 _start, uint256 _end, uint256 _size, bytes16 _halfNftId)\\r\\n    private\\r\\n    pure\\r\\n    returns (bytes memory result)\\r\\n  {\\r\\n    result = new bytes(_size);\\r\\n    uint256 j;\\r\\n\\r\\n    for (_start; _start < _end;) {\\r\\n      unchecked {\\r\\n        result[j * 2] = HEX_BASE[uint8(_halfNftId[_start]) / 16];\\r\\n        result[j * 2 + 1] = HEX_BASE[uint8(_halfNftId[_start]) % 16];\\r\\n        _start++;\\r\\n        j++;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IAvnNftListingsV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.14;\\r\\n\\r\\ninterface IAvnNftListingsV1 {\\r\\n\\r\\n  enum State {\\r\\n    Unlisted,\\r\\n    Auction,\\r\\n    Batch,\\r\\n    Sale\\r\\n  }\\r\\n\\r\\n  struct Royalty {\\r\\n    address recipient;\\r\\n    uint32 partsPerMil;\\r\\n  }\\r\\n\\r\\n  struct Batch {\\r\\n    uint64 supply;\\r\\n    uint64 saleIndex;\\r\\n    uint64 listingNumber;\\r\\n  }\\r\\n\\r\\n  struct Listing {\\r\\n    uint256 price;\\r\\n    uint256 endTime;\\r\\n    uint256 saleFunds;\\r\\n    address seller;\\r\\n    uint64 avnOpId;\\r\\n    State state;\\r\\n  }\\r\\n\\r\\n  struct Bid {\\r\\n    address bidder;\\r\\n    bytes32 avnPublicKey;\\r\\n    uint256 amount;\\r\\n  }\\r\\n\\r\\n  event AvnTransferTo(uint256 indexed nftId, bytes32 indexed avnPublicKey, uint64 indexed avnOpId);\\r\\n  event AvnMintTo(uint256 indexed batchId, uint64 indexed saleIndex, bytes32 indexed avnPublicKey, string uuid);\\r\\n  event AvnEndBatchListing(uint256 indexed batchId);\\r\\n  event AvnCancelNftListing(uint256 indexed nftId, uint64 indexed avnOpId);\\r\\n\\r\\n  event LogStartAuction(uint256 indexed nftId, bytes32 indexed avnPublicKey, uint256 reservePrice, uint256 endTime);\\r\\n  event LogBid(uint256 indexed nftId, bytes32 indexed avnPublicKey, uint256 amount);\\r\\n  event LogAuctionComplete(uint256 indexed nftId, bytes32 indexed avnPublicKey, uint256 winningBid);\\r\\n  event LogAuctionCancelled(uint256 indexed nftId);\\r\\n  event LogStartBatchSale(uint256 indexed batchId, bytes32 indexed avnPublicKey, uint256 price, uint64 amountAvailable);\\r\\n  event LogBatchSaleEnded(uint256 indexed batchId, uint64 amountRemaining);\\r\\n  event LogBatchSaleCancelled(uint256 indexed batchId);\\r\\n  event LogStartNftSale(uint256 indexed nftId, bytes32 indexed avnPublicKey, uint256 price);\\r\\n  event LogSold(uint256 indexed nftId, bytes32 indexed avnPublicKey);\\r\\n  event LogNftSaleCancelled(uint256 indexed nftId);\\r\\n  event LogFundsDivertedOnFailure(address indexed intendedRecipient, address indexed authority, uint256 amount);\\r\\n\\r\\n  function setAuthority(address authority, bool isAuthorised) external; // only Authority\\r\\n  function getAuthorities() external view returns(address[] memory);\\r\\n  function getRoyalties(uint256 batchIdOrNftId) external view returns(Royalty[] memory);\\r\\n  function startAuction(uint256 nftId, bytes32 avnPublicKey, uint256 reservePrice, uint256 endTime, uint64 avnOpId,\\r\\n      Royalty[] calldata royalties, bytes calldata proof) external;\\r\\n  function bid(uint256 nftId, bytes32 avnPublicKey) external payable;\\r\\n  function endAuction(uint256 nftId) external; // only Seller\\r\\n  function cancelAuction(uint256 nftId) external; // either Seller or Authority\\r\\n  function startBatchSale(uint256 batchId, bytes32 avnPublicKey, uint256 price, Batch calldata batchData,\\r\\n      Royalty[] calldata royalties, bytes calldata proof) external;\\r\\n  function buyFromBatch(uint256 batchId, bytes32 avnPublicKey) external payable;\\r\\n  function endBatchSale(uint256 batchId) external; // only Seller\\r\\n  function cancelBatchSale(uint256 batchId) external; // only Authority\\r\\n  function startNftSale(uint256 nftId, bytes32 avnPublicKey, uint256 price, uint64 avnOpId, Royalty[] calldata royalties,\\r\\n      bytes calldata proof) external;\\r\\n  function buyNft(uint256 nftId, bytes32 avnPublicKey) external payable;\\r\\n  function cancelNftSale(uint256 nftId) external; // either Seller or Authority\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"avnOpId\",\"type\":\"uint64\"}],\"name\":\"AvnCancelNftListing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"name\":\"AvnEndBatchListing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"saleIndex\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"avnPublicKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uuid\",\"type\":\"string\"}],\"name\":\"AvnMintTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"avnPublicKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"avnOpId\",\"type\":\"uint64\"}],\"name\":\"AvnTransferTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"LogAuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"avnPublicKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningBid\",\"type\":\"uint256\"}],\"name\":\"LogAuctionComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"name\":\"LogBatchSaleCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"amountRemaining\",\"type\":\"uint64\"}],\"name\":\"LogBatchSaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"avnPublicKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"intendedRecipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogFundsDivertedOnFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"LogNftSaleCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"avnPublicKey\",\"type\":\"bytes32\"}],\"name\":\"LogSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"avnPublicKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"LogStartAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"avnPublicKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"amountAvailable\",\"type\":\"uint64\"}],\"name\":\"LogStartBatchSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"avnPublicKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"LogStartNftSale\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_avnPublicKey\",\"type\":\"bytes32\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_batchId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_avnPublicKey\",\"type\":\"bytes32\"}],\"name\":\"buyFromBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_avnPublicKey\",\"type\":\"bytes32\"}],\"name\":\"buyNft\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_batchId\",\"type\":\"uint256\"}],\"name\":\"cancelBatchSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"cancelNftSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clientName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"endAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_batchId\",\"type\":\"uint256\"}],\"name\":\"endBatchSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthorities\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_batchIdOrNftId\",\"type\":\"uint256\"}],\"name\":\"getRoyalties\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"partsPerMil\",\"type\":\"uint32\"}],\"internalType\":\"struct IAvnNftListingsV1.Royalty[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_clientName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_initialAuthority\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAuthority\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authority\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isAuthorised\",\"type\":\"bool\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_avnPublicKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_reservePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_avnOpId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"partsPerMil\",\"type\":\"uint32\"}],\"internalType\":\"struct IAvnNftListingsV1.Royalty[]\",\"name\":\"_royalties\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"startAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_batchId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_avnPublicKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"supply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"saleIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"listingNumber\",\"type\":\"uint64\"}],\"internalType\":\"struct IAvnNftListingsV1.Batch\",\"name\":\"_batchData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"partsPerMil\",\"type\":\"uint32\"}],\"internalType\":\"struct IAvnNftListingsV1.Royalty[]\",\"name\":\"_royalties\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"startBatchSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_avnPublicKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_avnOpId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"partsPerMil\",\"type\":\"uint32\"}],\"internalType\":\"struct IAvnNftListingsV1.Royalty[]\",\"name\":\"_royalties\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"startNftSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AvnNftListingsV1","CompilerVersion":"v0.8.14+commit.80d49f37","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]