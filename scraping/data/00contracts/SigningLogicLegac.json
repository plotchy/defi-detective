[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @dev Pulled from OpenZeppelin: https://git.io/vbaRf\r\n *   When this is in a public release we will switch to not vendoring this file\r\n *\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Extracting these values isn't possible without assembly\r\n    // solhint-disable no-inline-assembly\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract SigningLogicInterface {\r\n  function recoverSigner(bytes32 _hash, bytes _sig) external pure returns (address);\r\n  function generateRequestAttestationSchemaHash(\r\n    address _subject,\r\n    address _attester,\r\n    address _requester,\r\n    bytes32 _dataHash,\r\n    uint256[] _typeIds,\r\n    bytes32 _nonce\r\n    ) external view returns (bytes32);\r\n  function generateAttestForDelegationSchemaHash(\r\n    address _subject,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _paymentNonce,\r\n    bytes32 _dataHash,\r\n    uint256[] _typeIds,\r\n    bytes32 _requestNonce\r\n    ) external view returns (bytes32);\r\n  function generateContestForDelegationSchemaHash(\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _paymentNonce\r\n  ) external view returns (bytes32);\r\n  function generateStakeForDelegationSchemaHash(\r\n    address _subject,\r\n    uint256 _value,\r\n    bytes32 _paymentNonce,\r\n    bytes32 _dataHash,\r\n    uint256[] _typeIds,\r\n    bytes32 _requestNonce,\r\n    uint256 _stakeDuration\r\n    ) external view returns (bytes32);\r\n  function generateRevokeStakeForDelegationSchemaHash(\r\n    uint256 _subjectId,\r\n    uint256 _attestationId\r\n    ) external view returns (bytes32);\r\n  function generateAddAddressSchemaHash(\r\n    address _senderAddress,\r\n    bytes32 _nonce\r\n    ) external view returns (bytes32);\r\n  function generateVoteForDelegationSchemaHash(\r\n    uint16 _choice,\r\n    address _voter,\r\n    bytes32 _nonce,\r\n    address _poll\r\n    ) external view returns (bytes32);\r\n  function generateReleaseTokensSchemaHash(\r\n    address _sender,\r\n    address _receiver,\r\n    uint256 _amount,\r\n    bytes32 _uuid\r\n    ) external view returns (bytes32);\r\n  function generateLockupTokensDelegationSchemaHash(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n    ) external view returns (bytes32);\r\n}\r\n\r\n/**\r\n * @title SigningLogic is an upgradeable contract implementing signature recovery from typed data signatures\r\n * @notice Recovers signatures based on the SignTypedData implementation provided by Metamask\r\n * @dev This contract is deployed separately and is referenced by other contracts.\r\n *  The other contracts have functions that allow this contract to be swapped out\r\n *  They will continue to work as long as this contract implements at least the functions in SigningLogicInterface\r\n */\r\ncontract SigningLogicLegacy is SigningLogicInterface{\r\n\r\n  bytes32 constant ATTESTATION_REQUEST_TYPEHASH = keccak256(\r\n      abi.encodePacked(\r\n        \"address subject\",\r\n        \"address attester\",\r\n        \"address requester\",\r\n        \"bytes32 dataHash\",\r\n        \"bytes32 typeHash\",\r\n        \"bytes32 nonce\"\r\n      )\r\n  );\r\n\r\n  bytes32 constant ADD_ADDRESS_TYPEHASH = keccak256(\r\n      abi.encodePacked(\r\n        \"address sender\",\r\n        \"bytes32 nonce\"\r\n      )\r\n  );\r\n\r\n  bytes32 constant RELEASE_TOKENS_TYPEHASH = keccak256(\r\n      abi.encodePacked(\r\n        \"string action\",\r\n        \"address sender\",\r\n        \"address receiver\",\r\n        \"uint256 amount\",\r\n        \"bytes32 nonce\"\r\n      )\r\n  );\r\n\r\n  bytes32 constant ATTEST_FOR_TYPEHASH = keccak256(\r\n      abi.encodePacked(\r\n        \"string action\",\r\n        \"address subject\",\r\n        \"address requester\",\r\n        \"uint256 reward\", \r\n        \"bytes32 paymentNonce\",\r\n        \"bytes32 dataHash\",\r\n        \"bytes32 typeHash\",\r\n        \"bytes32 requestNonce\"\r\n      )\r\n  );\r\n\r\n  bytes32 constant CONTEST_FOR_TYPEHASH = keccak256(\r\n      abi.encodePacked(\r\n        \"string action\",\r\n        \"address requester\",\r\n        \"uint256 reward\", \r\n        \"bytes32 paymentNonce\"\r\n      )\r\n  );\r\n\r\n  bytes32 constant STAKE_FOR_TYPEHASH = keccak256(\r\n      abi.encodePacked(\r\n        \"string action\",\r\n        \"address subject\",\r\n        \"uint256 value\", \r\n        \"bytes32 paymentNonce\",\r\n        \"bytes32 dataHash\",\r\n        \"bytes32 typeHash\",\r\n        \"bytes32 requestNonce\",\r\n        \"uint256 stakeDuration\"\r\n      )\r\n  );\r\n\r\n  bytes32 constant REVOKE_STAKE_FOR_TYPEHASH = keccak256(\r\n      abi.encodePacked(\r\n        \"string action\",\r\n        \"uint256 subjectId\",\r\n        \"uint256 attestationId\"\r\n      )\r\n  );\r\n\r\n  bytes32 constant VOTE_FOR_TYPEHASH = keccak256(\r\n      abi.encodePacked(\r\n        \"uint16 choice\",\r\n        \"address voter\",\r\n        \"bytes32 nonce\",\r\n        \"address poll\"\r\n      )\r\n  );\r\n\r\n  bytes32 constant LOCKUP_TOKENS_FOR = keccak256(\r\n      abi.encodePacked(\r\n        \"string action\",\r\n        \"address sender\",\r\n        \"uint256 amount\",\r\n        \"bytes32 nonce\"\r\n      )\r\n  );\r\n\r\n  struct AttestationRequest {\r\n      address subject;\r\n      address attester;\r\n      address requester;\r\n      bytes32 dataHash;\r\n      bytes32 typeHash;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(AttestationRequest request) internal pure returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        ATTESTATION_REQUEST_TYPEHASH,\r\n        keccak256(\r\n          abi.encodePacked(\r\n            request.subject,\r\n            request.attester,\r\n            request.requester,\r\n            request.dataHash,\r\n            request.typeHash,\r\n            request.nonce\r\n          )\r\n        )\r\n    ));\r\n  }\r\n\r\n  struct AddAddress {\r\n      address sender;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(AddAddress request) internal pure returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        ADD_ADDRESS_TYPEHASH,\r\n        keccak256(\r\n          abi.encodePacked(\r\n            request.sender,\r\n            request.nonce\r\n          )\r\n        )\r\n    ));\r\n  }\r\n\r\n  struct ReleaseTokens {\r\n      address sender;\r\n      address receiver;\r\n      uint256 amount;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(ReleaseTokens request) internal pure returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        RELEASE_TOKENS_TYPEHASH,\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"pay\",\r\n            request.sender,\r\n            request.receiver,\r\n            request.amount,\r\n            request.nonce\r\n          )\r\n        )\r\n    ));\r\n  }\r\n\r\n  struct AttestFor {\r\n      address subject;\r\n      address requester;\r\n      uint256 reward;\r\n      bytes32 paymentNonce;\r\n      bytes32 dataHash;\r\n      bytes32 typeHash;\r\n      bytes32 requestNonce;\r\n  }\r\n\r\n  function hash(AttestFor request) internal pure returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        ATTEST_FOR_TYPEHASH,\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"attest\",\r\n            request.subject,\r\n            request.requester,\r\n            request.reward,\r\n            request.paymentNonce,\r\n            request.dataHash,\r\n            request.typeHash,\r\n            request.requestNonce\r\n          )\r\n        )\r\n    ));\r\n  }\r\n\r\n  struct ContestFor {\r\n      address requester;\r\n      uint256 reward;\r\n      bytes32 paymentNonce;\r\n  }\r\n\r\n  function hash(ContestFor request) internal pure returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        CONTEST_FOR_TYPEHASH,\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"contest\",\r\n            request.requester,\r\n            request.reward,\r\n            request.paymentNonce\r\n          )\r\n        )\r\n    ));\r\n  }\r\n\r\n  struct StakeFor {\r\n      address subject;\r\n      uint256 value;\r\n      bytes32 paymentNonce;\r\n      bytes32 dataHash;\r\n      bytes32 typeHash;\r\n      bytes32 requestNonce;\r\n      uint256 stakeDuration;\r\n  }\r\n\r\n  function hash(StakeFor request) internal pure returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        STAKE_FOR_TYPEHASH,\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"stake\",\r\n            request.subject,\r\n            request.value,\r\n            request.paymentNonce,\r\n            request.dataHash,\r\n            request.typeHash,\r\n            request.requestNonce,\r\n            request.stakeDuration\r\n          )\r\n        )\r\n    ));\r\n  }\r\n\r\n  struct RevokeStakeFor {\r\n      uint256 subjectId;\r\n      uint256 attestationId;\r\n  }\r\n\r\n  function hash(RevokeStakeFor request) internal pure returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        REVOKE_STAKE_FOR_TYPEHASH,\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"revokeStake\",\r\n            request.subjectId,\r\n            request.attestationId\r\n          )\r\n        )\r\n    ));\r\n  }\r\n\r\n  struct VoteFor {\r\n      uint16 choice;\r\n      address voter;\r\n      bytes32 nonce;\r\n      address poll;\r\n  }\r\n\r\n  function hash(VoteFor request) internal pure returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        VOTE_FOR_TYPEHASH,\r\n        keccak256(\r\n          abi.encodePacked(\r\n            request.choice,\r\n            request.voter,\r\n            request.nonce,\r\n            request.poll\r\n          )\r\n        )\r\n    ));\r\n  }\r\n\r\n  struct LockupTokensFor {\r\n    address sender;\r\n    uint256 amount;\r\n    bytes32 nonce;\r\n  }\r\n\r\n  function hash(LockupTokensFor request) internal pure returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        LOCKUP_TOKENS_FOR,\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"lockup\",\r\n            request.sender,\r\n            request.amount,\r\n            request.nonce\r\n          )\r\n        )\r\n    ));\r\n  }\r\n\r\n  function generateRequestAttestationSchemaHash(\r\n    address _subject,\r\n    address _attester,\r\n    address _requester,\r\n    bytes32 _dataHash,\r\n    uint256[] _typeIds,\r\n    bytes32 _nonce\r\n  ) external view returns (bytes32) {\r\n    return hash(\r\n      AttestationRequest(\r\n        _subject,\r\n        _attester,\r\n        _requester,\r\n        _dataHash,\r\n        keccak256(abi.encodePacked(_typeIds)),\r\n        _nonce\r\n      )\r\n    );\r\n  }\r\n\r\n  function generateAddAddressSchemaHash(\r\n    address _senderAddress,\r\n    bytes32 _nonce\r\n  ) external view returns (bytes32) {\r\n    return hash(\r\n      AddAddress(\r\n        _senderAddress,\r\n        _nonce\r\n      )\r\n    );\r\n  }\r\n\r\n  function generateReleaseTokensSchemaHash(\r\n    address _sender,\r\n    address _receiver,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) external view returns (bytes32) {\r\n    return hash(\r\n      ReleaseTokens(\r\n        _sender,\r\n        _receiver,\r\n        _amount,\r\n        _nonce\r\n      )\r\n    );\r\n  }\r\n\r\n  function generateAttestForDelegationSchemaHash(\r\n    address _subject,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _paymentNonce,\r\n    bytes32 _dataHash,\r\n    uint256[] _typeIds,\r\n    bytes32 _requestNonce\r\n  ) external view returns (bytes32) {\r\n    return hash(\r\n      AttestFor(\r\n        _subject,\r\n        _requester,\r\n        _reward,\r\n        _paymentNonce,\r\n        _dataHash,\r\n        keccak256(abi.encodePacked(_typeIds)),\r\n        _requestNonce\r\n      )\r\n    );\r\n  }\r\n\r\n  function generateContestForDelegationSchemaHash(\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _paymentNonce\r\n  ) external view returns (bytes32) {\r\n    return hash(\r\n      ContestFor(\r\n        _requester,\r\n        _reward,\r\n        _paymentNonce\r\n      )\r\n    );\r\n  }\r\n\r\n  function generateStakeForDelegationSchemaHash(\r\n    address _subject,\r\n    uint256 _value,\r\n    bytes32 _paymentNonce,\r\n    bytes32 _dataHash,\r\n    uint256[] _typeIds,\r\n    bytes32 _requestNonce,\r\n    uint256 _stakeDuration\r\n  ) external view returns (bytes32) {\r\n    return hash(\r\n      StakeFor(\r\n        _subject,\r\n        _value,\r\n        _paymentNonce,\r\n        _dataHash,\r\n        keccak256(abi.encodePacked(_typeIds)),\r\n        _requestNonce,\r\n        _stakeDuration\r\n      )\r\n    );\r\n  }\r\n\r\n  function generateRevokeStakeForDelegationSchemaHash(\r\n    uint256 _subjectId,\r\n    uint256 _attestationId\r\n  ) external view returns (bytes32) {\r\n    return hash(\r\n      RevokeStakeFor(\r\n        _subjectId,\r\n        _attestationId\r\n      )\r\n    );\r\n  }\r\n\r\n  function generateVoteForDelegationSchemaHash(\r\n    uint16 _choice,\r\n    address _voter,\r\n    bytes32 _nonce,\r\n    address _poll\r\n  ) external view returns (bytes32) {\r\n    return hash(\r\n      VoteFor(\r\n        _choice,\r\n        _voter,\r\n        _nonce,\r\n        _poll\r\n      )\r\n    );\r\n  }\r\n\r\n  function generateLockupTokensDelegationSchemaHash(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) external view returns (bytes32) {\r\n    return hash(\r\n      LockupTokensFor(\r\n        _sender,\r\n        _amount,\r\n        _nonce\r\n      )\r\n    );\r\n  }\r\n\r\n  function recoverSigner(bytes32 _hash, bytes _sig) external pure returns (address) {\r\n    address signer = ECRecovery.recover(_hash, _sig);\r\n    require(signer != address(0));\r\n\r\n    return signer;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_senderAddress\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"bytes32\"}],\"name\":\"generateAddAddressSchemaHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_subject\",\"type\":\"address\"},{\"name\":\"_attester\",\"type\":\"address\"},{\"name\":\"_requester\",\"type\":\"address\"},{\"name\":\"_dataHash\",\"type\":\"bytes32\"},{\"name\":\"_typeIds\",\"type\":\"uint256[]\"},{\"name\":\"_nonce\",\"type\":\"bytes32\"}],\"name\":\"generateRequestAttestationSchemaHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_subject\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_paymentNonce\",\"type\":\"bytes32\"},{\"name\":\"_dataHash\",\"type\":\"bytes32\"},{\"name\":\"_typeIds\",\"type\":\"uint256[]\"},{\"name\":\"_requestNonce\",\"type\":\"bytes32\"},{\"name\":\"_stakeDuration\",\"type\":\"uint256\"}],\"name\":\"generateStakeForDelegationSchemaHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_subject\",\"type\":\"address\"},{\"name\":\"_requester\",\"type\":\"address\"},{\"name\":\"_reward\",\"type\":\"uint256\"},{\"name\":\"_paymentNonce\",\"type\":\"bytes32\"},{\"name\":\"_dataHash\",\"type\":\"bytes32\"},{\"name\":\"_typeIds\",\"type\":\"uint256[]\"},{\"name\":\"_requestNonce\",\"type\":\"bytes32\"}],\"name\":\"generateAttestForDelegationSchemaHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_subjectId\",\"type\":\"uint256\"},{\"name\":\"_attestationId\",\"type\":\"uint256\"}],\"name\":\"generateRevokeStakeForDelegationSchemaHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_choice\",\"type\":\"uint16\"},{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"name\":\"_poll\",\"type\":\"address\"}],\"name\":\"generateVoteForDelegationSchemaHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requester\",\"type\":\"address\"},{\"name\":\"_reward\",\"type\":\"uint256\"},{\"name\":\"_paymentNonce\",\"type\":\"bytes32\"}],\"name\":\"generateContestForDelegationSchemaHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"bytes32\"}],\"name\":\"generateReleaseTokensSchemaHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"bytes32\"}],\"name\":\"generateLockupTokensDelegationSchemaHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SigningLogicLegacy","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"ECRecovery:eD6671c01f0b60ed39900E671aEb70ACa008fbac","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c1f9cab22639489c8c37f4e1a952c5a40a7226e8c8d3c08ce7bd95977e3b0dff"}]