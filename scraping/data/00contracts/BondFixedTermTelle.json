[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/BondFixedTermTeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.15;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\nimport {BondBaseTeller, IBondAggregator, Authority} from \\\"./bases/BondBaseTeller.sol\\\";\\nimport {IBondFixedTermTeller} from \\\"./interfaces/IBondFixedTermTeller.sol\\\";\\n\\nimport {TransferHelper} from \\\"./lib/TransferHelper.sol\\\";\\nimport {FullMath} from \\\"./lib/FullMath.sol\\\";\\nimport {ERC1155} from \\\"./lib/ERC1155.sol\\\";\\n\\n/// @title Bond Fixed Term Teller\\n/// @notice Bond Fixed Term Teller Contract\\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\\n///      for any token pair. The markets do not require maintenance and will manage\\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\\n///      receive Bond Tokens to represent their position while their bond vests.\\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\\n///\\n/// @dev The Bond Fixed Term Teller is an implementation of the\\n///      Bond Base Teller contract specific to handling user bond transactions\\n///      and tokenizing bond markets where purchases vest in a fixed amount of time\\n///      (rounded to the day) as ERC1155 tokens.\\n///\\n/// @author Oighty, Zeus, Potted Meat, indigo\\ncontract BondFixedTermTeller is BondBaseTeller, IBondFixedTermTeller, ERC1155 {\\n    using TransferHelper for ERC20;\\n    using FullMath for uint256;\\n\\n    /* ========== EVENTS ========== */\\n    event ERC1155BondTokenCreated(\\n        uint256 tokenId,\\n        ERC20 indexed payoutToken,\\n        uint48 indexed expiry\\n    );\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(uint256 => TokenMetadata) public tokenMetadata; // metadata for bond tokens\\n\\n    /* ========== CONSTRUCTOR ========== */\\n    constructor(\\n        address protocol_,\\n        IBondAggregator aggregator_,\\n        address guardian_,\\n        Authority authority_\\n    ) BondBaseTeller(protocol_, aggregator_, guardian_, authority_) {}\\n\\n    /* ========== PURCHASE ========== */\\n\\n    /// @notice             Handle payout to recipient\\n    /// @param recipient_   Address to receive payout\\n    /// @param payout_      Amount of payoutToken to be paid\\n    /// @param payoutToken_   Token to be paid out\\n    /// @param vesting_     Amount of time to vest from current timestamp\\n    /// @return expiry      Timestamp when the payout will vest\\n    function _handlePayout(\\n        address recipient_,\\n        uint256 payout_,\\n        ERC20 payoutToken_,\\n        uint48 vesting_\\n    ) internal override returns (uint48 expiry) {\\n        // If there is no vesting time, the deposit is treated as an instant swap.\\n        // otherwise, deposit info is stored and payout is available at a future timestamp.\\n        // instant swap is denoted by expiry == 0.\\n        //\\n        // bonds mature with a cliff at a set timestamp\\n        // prior to the expiry timestamp, no payout tokens are accessible to the user\\n        // after the expiry timestamp, the entire payout can be redeemed\\n        //\\n        // fixed-term bonds mature in a set amount of time from deposit\\n        // i.e. term = 1 week. when alice deposits on day 1, her bond\\n        // expires on day 8. when bob deposits on day 2, his bond expires day 9.\\n        if (vesting_ != 0) {\\n            // Normalizing fixed term vesting timestamps to the same time each day\\n            expiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\\n\\n            // Fixed-term user payout information is handled in BondTeller.\\n            // Teller mints ERC-1155 bond tokens for user.\\n            uint256 tokenId = getTokenId(payoutToken_, expiry);\\n\\n            // Create new bond token if it doesn't exist yet\\n            if (!tokenMetadata[tokenId].active) {\\n                _deploy(tokenId, payoutToken_, expiry);\\n            }\\n\\n            // Mint bond token to recipient\\n            _mintToken(recipient_, tokenId, payout_);\\n        } else {\\n            // If no expiry, then transfer payout directly to user\\n            payoutToken_.safeTransfer(recipient_, payout_);\\n        }\\n    }\\n\\n    /* ========== DEPOSIT/MINT ========== */\\n\\n    /// @inheritdoc IBondFixedTermTeller\\n    function create(\\n        ERC20 underlying_,\\n        uint48 expiry_,\\n        uint256 amount_\\n    ) external override nonReentrant returns (uint256, uint256) {\\n        uint256 tokenId = getTokenId(underlying_, expiry_);\\n\\n        // Revert if no token exists, must call deploy first\\n        if (!tokenMetadata[tokenId].active) revert Teller_TokenDoesNotExist(underlying_, expiry_);\\n\\n        // Transfer in underlying\\n        // Check that amount received is not less than amount expected\\n        // Handles edge cases like fee-on-transfer tokens (which are not supported)\\n        uint256 oldBalance = underlying_.balanceOf(address(this));\\n        underlying_.transferFrom(msg.sender, address(this), amount_);\\n        if (underlying_.balanceOf(address(this)) < oldBalance + amount_)\\n            revert Teller_UnsupportedToken();\\n\\n        // If fee is greater than the create discount, then calculate the fee and store it\\n        // Otherwise, fee is zero.\\n        if (protocolFee > createFeeDiscount) {\\n            // Calculate fee amount\\n            uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\\n            rewards[_protocol][underlying_] += feeAmount;\\n\\n            // Mint new bond tokens\\n            _mintToken(msg.sender, tokenId, amount_ - feeAmount);\\n\\n            return (tokenId, amount_ - feeAmount);\\n        } else {\\n            // Mint new bond tokens\\n            _mintToken(msg.sender, tokenId, amount_);\\n\\n            return (tokenId, amount_);\\n        }\\n    }\\n\\n    /* ========== REDEEM ========== */\\n\\n    function _redeem(uint256 tokenId_, uint256 amount_) internal {\\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\\n\\n        if (block.timestamp < meta.expiry) revert Teller_TokenNotMatured(meta.expiry);\\n\\n        _burnToken(msg.sender, tokenId_, amount_);\\n        meta.payoutToken.safeTransfer(msg.sender, amount_);\\n    }\\n\\n    /// @inheritdoc IBondFixedTermTeller\\n    function redeem(uint256 tokenId_, uint256 amount_) public override nonReentrant {\\n        _redeem(tokenId_, amount_);\\n    }\\n\\n    /// @inheritdoc IBondFixedTermTeller\\n    function batchRedeem(uint256[] calldata tokenIds_, uint256[] calldata amounts_)\\n        external\\n        override\\n        nonReentrant\\n    {\\n        uint256 len = tokenIds_.length;\\n        for (uint256 i; i < len; ++i) {\\n            _redeem(tokenIds_[i], amounts_[i]);\\n        }\\n    }\\n\\n    /* ========== TOKENIZATION ========== */\\n\\n    /// @inheritdoc IBondFixedTermTeller\\n    function deploy(ERC20 underlying_, uint48 expiry_)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256)\\n    {\\n        uint256 tokenId = getTokenId(underlying_, expiry_);\\n        // Only creates token if it does not exist\\n        if (!tokenMetadata[tokenId].active) {\\n            _deploy(tokenId, underlying_, expiry_);\\n        }\\n        return tokenId;\\n    }\\n\\n    /// @notice             \\\"Deploy\\\" a new ERC1155 bond token and stores its ID\\n    /// @dev                ERC1155 tokens used for fixed term bonds\\n    /// @param tokenId_     Calculated ID of new bond token (from getTokenId)\\n    /// @param underlying_  Underlying token to be paid out when the bond token vests\\n    /// @param expiry_      Timestamp that the token will vest at\\n    function _deploy(\\n        uint256 tokenId_,\\n        ERC20 underlying_,\\n        uint48 expiry_\\n    ) internal {\\n        tokenMetadata[tokenId_] = TokenMetadata(true, underlying_, expiry_, 0);\\n\\n        emit ERC1155BondTokenCreated(tokenId_, underlying_, expiry_);\\n    }\\n\\n    /// @notice             Mint bond token and update supply\\n    /// @param to_          Address to mint tokens to\\n    /// @param tokenId_     ID of bond token to mint\\n    /// @param amount_      Amount of bond tokens to mint\\n    function _mintToken(\\n        address to_,\\n        uint256 tokenId_,\\n        uint256 amount_\\n    ) internal {\\n        _mint(to_, tokenId_, amount_, bytes(\\\"\\\"));\\n        tokenMetadata[tokenId_].supply += amount_;\\n    }\\n\\n    /// @notice             Burn bond token and update supply\\n    /// @param from_        Address to burn tokens from\\n    /// @param tokenId_     ID of bond token to burn\\n    /// @param amount_      Amount of bond token to burn\\n    function _burnToken(\\n        address from_,\\n        uint256 tokenId_,\\n        uint256 amount_\\n    ) internal {\\n        _burn(from_, tokenId_, amount_);\\n        tokenMetadata[tokenId_].supply -= amount_;\\n    }\\n\\n    /* ========== TOKEN NAMING ========== */\\n\\n    /// @inheritdoc IBondFixedTermTeller\\n    function getTokenId(ERC20 underlying_, uint48 expiry_) public pure override returns (uint256) {\\n        // Vesting is divided by 1 day (in seconds) since bond tokens are only unique\\n        // to a day, not a specific timestamp.\\n        uint256 tokenId = uint256(\\n            keccak256(abi.encodePacked(underlying_, expiry_ / uint48(1 days)))\\n        );\\n        return tokenId;\\n    }\\n\\n    /// @inheritdoc IBondFixedTermTeller\\n    function getTokenNameAndSymbol(uint256 tokenId_)\\n        external\\n        view\\n        override\\n        returns (string memory, string memory)\\n    {\\n        TokenMetadata memory meta = tokenMetadata[tokenId_];\\n        (string memory name, string memory symbol) = _getNameAndSymbol(\\n            meta.payoutToken,\\n            meta.expiry\\n        );\\n        return (name, symbol);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bases/BondBaseTeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.15;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {ReentrancyGuard} from \\\"solmate/utils/ReentrancyGuard.sol\\\";\\nimport {Auth, Authority} from \\\"solmate/auth/Auth.sol\\\";\\n\\nimport {IBondTeller} from \\\"../interfaces/IBondTeller.sol\\\";\\nimport {IBondCallback} from \\\"../interfaces/IBondCallback.sol\\\";\\nimport {IBondAggregator} from \\\"../interfaces/IBondAggregator.sol\\\";\\nimport {IBondAuctioneer} from \\\"../interfaces/IBondAuctioneer.sol\\\";\\n\\nimport {TransferHelper} from \\\"../lib/TransferHelper.sol\\\";\\nimport {FullMath} from \\\"../lib/FullMath.sol\\\";\\n\\n/// @title Bond Teller\\n/// @notice Bond Teller Base Contract\\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\\n///      for any token pair. The markets do not require maintenance and will manage\\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\\n///      receive Bond Tokens to represent their position while their bond vests.\\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\\n///\\n/// @dev The Teller contract handles all interactions with end users and manages tokens\\n///      issued to represent bond positions. Users purchase bonds by depositing Quote Tokens\\n///      and receive a Bond Token (token type is implementation-specific) that represents\\n///      their payout and the designated expiry. Once a bond vests, Investors can redeem their\\n///      Bond Tokens for the underlying Payout Token. A Teller requires one or more Auctioneer\\n///      contracts to be deployed to provide markets for users to purchase bonds from.\\n///\\n/// @author Oighty, Zeus, Potted Meat, indigo\\nabstract contract BondBaseTeller is IBondTeller, Auth, ReentrancyGuard {\\n    using TransferHelper for ERC20;\\n    using FullMath for uint256;\\n\\n    /* ========== ERRORS ========== */\\n\\n    error Teller_InvalidCallback();\\n    error Teller_TokenNotMatured(uint48 maturesOn);\\n    error Teller_NotAuthorized();\\n    error Teller_TokenDoesNotExist(ERC20 underlying, uint48 expiry);\\n    error Teller_UnsupportedToken();\\n    error Teller_InvalidParams();\\n\\n    /* ========== EVENTS ========== */\\n    event Bonded(uint256 indexed id, address indexed referrer, uint256 amount, uint256 payout);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    /// @notice Fee paid to a front end operator. Set by the referrer, must be less than or equal to 5e4.\\n    /// @dev There are some situations where the fees may round down to zero if quantity of baseToken\\n    ///      is < 1e5 wei (can happen with big price differences on small decimal tokens). This is purely\\n    ///      a theoretical edge case, as the bond amount would not be practical.\\n    mapping(address => uint48) public referrerFees;\\n\\n    /// @notice Fee paid to protocol. Configurable by policy, must be greater than 30 bps.\\n    uint48 public protocolFee;\\n\\n    /// @notice 'Create' function fee discount. Amount standard fee is reduced by for partners who just want to use the 'create' function to issue bond tokens. Configurable by policy.\\n    uint48 public createFeeDiscount;\\n\\n    uint48 public constant FEE_DECIMALS = 1e5; // one percent equals 1000.\\n\\n    /// @notice Fees earned by an address, by token\\n    mapping(address => mapping(ERC20 => uint256)) public rewards;\\n\\n    // Address the protocol receives fees at\\n    address internal immutable _protocol;\\n\\n    // BondAggregator contract with utility functions\\n    IBondAggregator internal immutable _aggregator;\\n\\n    constructor(\\n        address protocol_,\\n        IBondAggregator aggregator_,\\n        address guardian_,\\n        Authority authority_\\n    ) Auth(guardian_, authority_) {\\n        _protocol = protocol_;\\n        _aggregator = aggregator_;\\n\\n        protocolFee = 0;\\n    }\\n\\n    /// @inheritdoc IBondTeller\\n    function setReferrerFee(uint48 fee_) external override {\\n        if (fee_ > 5e4) revert Teller_InvalidParams();\\n        referrerFees[msg.sender] = fee_;\\n    }\\n\\n    /// @inheritdoc IBondTeller\\n    function setProtocolFee(uint48 fee_) external override requiresAuth {\\n        protocolFee = fee_;\\n    }\\n\\n    /// @inheritdoc IBondTeller\\n    function claimFees(ERC20[] memory tokens_, address to_) external override {\\n        uint256 len = tokens_.length;\\n        for (uint256 i; i < len; ++i) {\\n            ERC20 token = tokens_[i];\\n            uint256 send = rewards[msg.sender][token];\\n\\n            rewards[msg.sender][token] = 0;\\n            token.safeTransfer(to_, send);\\n        }\\n    }\\n\\n    /// @inheritdoc IBondTeller\\n    function getFee(address referrer_) external view returns (uint48) {\\n        return protocolFee + referrerFees[referrer_];\\n    }\\n\\n    /* ========== USER FUNCTIONS ========== */\\n\\n    /// @inheritdoc IBondTeller\\n    function purchase(\\n        address recipient_,\\n        address referrer_,\\n        uint256 id_,\\n        uint256 amount_,\\n        uint256 minAmountOut_\\n    ) external virtual nonReentrant returns (uint256, uint48) {\\n        ERC20 payoutToken;\\n        ERC20 quoteToken;\\n        uint48 vesting;\\n        uint256 payout;\\n\\n        // Calculate fees for purchase\\n        // 1. Calculate referrer fee\\n        // 2. Calculate protocol fee as the total expected fee amount minus the referrer fee\\n        //    to avoid issues with rounding from separate fee calculations\\n        uint256 toReferrer = amount_.mulDiv(referrerFees[referrer_], FEE_DECIMALS);\\n        uint256 toProtocol = amount_.mulDiv(protocolFee + referrerFees[referrer_], FEE_DECIMALS) -\\n            toReferrer;\\n\\n        {\\n            IBondAuctioneer auctioneer = _aggregator.getAuctioneer(id_);\\n            address owner;\\n            (owner, , payoutToken, quoteToken, vesting, ) = auctioneer.getMarketInfoForPurchase(\\n                id_\\n            );\\n\\n            // Auctioneer handles bond pricing, capacity, and duration\\n            uint256 amountLessFee = amount_ - toReferrer - toProtocol;\\n            payout = auctioneer.purchaseBond(id_, amountLessFee, minAmountOut_);\\n        }\\n\\n        // Allocate fees to protocol and referrer\\n        rewards[referrer_][quoteToken] += toReferrer;\\n        rewards[_protocol][quoteToken] += toProtocol;\\n\\n        // Ensure enough payout tokens are available\\n        _handleTransfers(id_, amount_, payout, toReferrer + toProtocol);\\n\\n        // Handle payout to user (either transfer tokens if instant swap or issue bond token)\\n        uint48 expiry = _handlePayout(recipient_, payout, payoutToken, vesting);\\n\\n        emit Bonded(id_, referrer_, amount_, payout);\\n\\n        return (payout, expiry);\\n    }\\n\\n    /// @notice     Handles transfer of funds from user and market owner/callback\\n    function _handleTransfers(\\n        uint256 id_,\\n        uint256 amount_,\\n        uint256 payout_,\\n        uint256 feePaid_\\n    ) internal {\\n        // Get info from auctioneer\\n        (address owner, address callbackAddr, ERC20 payoutToken, ERC20 quoteToken, , ) = _aggregator\\n            .getAuctioneer(id_)\\n            .getMarketInfoForPurchase(id_);\\n\\n        // Calculate amount net of fees\\n        uint256 amountLessFee = amount_ - feePaid_;\\n\\n        // Have to transfer to teller first since fee is in quote token\\n        // Check balance before and after to ensure full amount received, revert if not\\n        // Handles edge cases like fee-on-transfer tokens (which are not supported)\\n        uint256 quoteBalance = quoteToken.balanceOf(address(this));\\n        quoteToken.safeTransferFrom(msg.sender, address(this), amount_);\\n        if (quoteToken.balanceOf(address(this)) < quoteBalance + amount_)\\n            revert Teller_UnsupportedToken();\\n\\n        // If callback address supplied, transfer tokens from user to callback, then execute callback function,\\n        // and ensure proper amount of tokens transferred in.\\n        if (callbackAddr != address(0)) {\\n            // Send quote token to callback transferred in first to allow use during callback\\n            quoteToken.safeTransfer(callbackAddr, amountLessFee);\\n\\n            // Call the callback function to receive payout tokens for payout\\n            uint256 payoutBalance = payoutToken.balanceOf(address(this));\\n            IBondCallback(callbackAddr).callback(id_, amountLessFee, payout_);\\n\\n            if (payoutToken.balanceOf(address(this)) < (payoutBalance + payout_))\\n                revert Teller_InvalidCallback();\\n        } else {\\n            // If no callback is provided, transfer tokens from market owner to this contract\\n            // for payout.\\n            // Check balance before and after to ensure full amount received, revert if not\\n            // Handles edge cases like fee-on-transfer tokens (which are not supported)\\n            uint256 payoutBalance = payoutToken.balanceOf(address(this));\\n            payoutToken.safeTransferFrom(owner, address(this), payout_);\\n            if (payoutToken.balanceOf(address(this)) < (payoutBalance + payout_))\\n                revert Teller_UnsupportedToken();\\n\\n            quoteToken.safeTransfer(owner, amountLessFee);\\n        }\\n    }\\n\\n    /// @notice             Handle payout to recipient\\n    /// @dev                Implementation-agnostic. Must be implemented in contracts that\\n    ///                     extend this base since it is called by purchase.\\n    /// @param recipient_   Address to receive payout\\n    /// @param payout_      Amount of payoutToken to be paid\\n    /// @param underlying_   Token to be paid out\\n    /// @param vesting_     Time parameter for when the payout is available, could be a\\n    ///                     timestamp or duration depending on the implementation\\n    /// @return expiry      Timestamp when the payout will vest\\n    function _handlePayout(\\n        address recipient_,\\n        uint256 payout_,\\n        ERC20 underlying_,\\n        uint48 vesting_\\n    ) internal virtual returns (uint48 expiry);\\n\\n    /// @notice             Derive name and symbol of token for market\\n    /// @param underlying_   Underlying token to be paid out when the Bond Token vests\\n    /// @param expiry_      Timestamp that the Bond Token vests at\\n    /// @return name        Bond token name, format is \\\"Token YYYY-MM-DD\\\"\\n    /// @return symbol      Bond token symbol, format is \\\"TKN-YYYYMMDD\\\"\\n    function _getNameAndSymbol(ERC20 underlying_, uint256 expiry_)\\n        internal\\n        view\\n        returns (string memory name, string memory symbol)\\n    {\\n        // Convert a number of days into a human-readable date, courtesy of BokkyPooBah.\\n        // Source: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\\n\\n        uint256 year;\\n        uint256 month;\\n        uint256 day;\\n        {\\n            int256 __days = int256(expiry_ / 1 days);\\n\\n            int256 num1 = __days + 68569 + 2440588; // 2440588 = OFFSET19700101\\n            int256 num2 = (4 * num1) / 146097;\\n            num1 = num1 - (146097 * num2 + 3) / 4;\\n            int256 _year = (4000 * (num1 + 1)) / 1461001;\\n            num1 = num1 - (1461 * _year) / 4 + 31;\\n            int256 _month = (80 * num1) / 2447;\\n            int256 _day = num1 - (2447 * _month) / 80;\\n            num1 = _month / 11;\\n            _month = _month + 2 - 12 * num1;\\n            _year = 100 * (num2 - 49) + _year + num1;\\n\\n            year = uint256(_year);\\n            month = uint256(_month);\\n            day = uint256(_day);\\n        }\\n\\n        string memory yearStr = _uint2str(year % 10000);\\n        string memory monthStr = month < 10\\n            ? string(abi.encodePacked(\\\"0\\\", _uint2str(month)))\\n            : _uint2str(month);\\n        string memory dayStr = day < 10\\n            ? string(abi.encodePacked(\\\"0\\\", _uint2str(day)))\\n            : _uint2str(day);\\n\\n        // Construct name/symbol strings.\\n        name = string(\\n            abi.encodePacked(underlying_.name(), \\\" \\\", yearStr, \\\"-\\\", monthStr, \\\"-\\\", dayStr)\\n        );\\n        symbol = string(abi.encodePacked(underlying_.symbol(), \\\"-\\\", yearStr, monthStr, dayStr));\\n    }\\n\\n    // Some fancy math to convert a uint into a string, courtesy of Provable Things.\\n    // Updated to work with solc 0.8.0.\\n    // https://github.com/provable-things/ethereum-api/blob/master/provableAPI_0.6.sol\\n    function _uint2str(uint256 _i) internal pure returns (string memory) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len;\\n        while (_i != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondFixedTermTeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\ninterface IBondFixedTermTeller {\\n    // Info for bond token\\n    struct TokenMetadata {\\n        bool active;\\n        ERC20 payoutToken;\\n        uint48 expiry;\\n        uint256 supply;\\n    }\\n\\n    /// @notice              Deposit an ERC20 token and mint a future-dated ERC1155 bond token\\n    /// @param underlying_   ERC20 token redeemable when the bond token vests\\n    /// @param expiry_       Timestamp at which the bond token can be redeemed for the underlying token\\n    /// @param amount_       Amount of underlying tokens to deposit\\n    /// @return              ID of the ERC1155 bond token received\\n    /// @return              Amount of the ERC1155 bond token received\\n    function create(\\n        ERC20 underlying_,\\n        uint48 expiry_,\\n        uint256 amount_\\n    ) external returns (uint256, uint256);\\n\\n    /// @notice             \\\"Deploy\\\" a new ERC1155 bond token for an (underlying, expiry) pair and return its address\\n    /// @dev                ERC1155 used for fixed-term\\n    /// @dev                If a bond token exists for the (underlying, expiry) pair, it returns that address\\n    /// @param underlying_  ERC20 token redeemable when the bond token vests\\n    /// @param expiry_      Timestamp at which the bond token can be redeemed for the underlying token\\n    /// @return             ID of the ERC1155 bond token being created\\n    function deploy(ERC20 underlying_, uint48 expiry_) external returns (uint256);\\n\\n    /// @notice          Redeem a fixed-term bond token for the underlying token (bond token must have matured)\\n    /// @param tokenId_  ID of the bond token to redeem\\n    /// @param amount_   Amount of bond token to redeem\\n    function redeem(uint256 tokenId_, uint256 amount_) external;\\n\\n    /// @notice          Redeem multiple fixed-term bond tokens for the underlying tokens (bond tokens must have matured)\\n    /// @param tokenIds_ Array of bond token ids\\n    /// @param amounts_  Array of amounts of bond tokens to redeem\\n    function batchRedeem(uint256[] memory tokenIds_, uint256[] memory amounts_) external;\\n\\n    /// @notice             Get token ID from token and expiry\\n    /// @param payoutToken_ Payout token of bond\\n    /// @param expiry_      Expiry of the bond\\n    /// @return             ID of the bond token\\n    function getTokenId(ERC20 payoutToken_, uint48 expiry_) external pure returns (uint256);\\n\\n    /// @notice             Get the token name and symbol for a bond token\\n    /// @param tokenId_     ID of the bond token\\n    /// @return name        Bond token name\\n    /// @return symbol      Bond token symbol\\n    function getTokenNameAndSymbol(uint256 tokenId_)\\n        external\\n        view\\n        returns (string memory, string memory);\\n}\\n\"\r\n    },\r\n    \"src/lib/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ERC20 and ETH transfer library that safely handles missing return values.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\n/// @author Taken from Solmate.\\nlibrary TransferHelper {\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(ERC20.transferFrom.selector, from, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(ERC20.transfer.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    // function safeApprove(\\n    //     ERC20 token,\\n    //     address to,\\n    //     uint256 amount\\n    // ) internal {\\n    //     (bool success, bytes memory data) = address(token).call(\\n    //         abi.encodeWithSelector(ERC20.approve.selector, to, amount)\\n    //     );\\n\\n    //     require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\n    // }\\n\\n    // function safeTransferETH(address to, uint256 amount) internal {\\n    //     (bool success, ) = to.call{value: amount}(new bytes(0));\\n\\n    //     require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    // }\\n}\\n\"\r\n    },\r\n    \"src/lib/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        unchecked {\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @dev    Removed `uri()` function. Unnecessary for our use case.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*///////////////////////////////////////////////////////////////\\n                                EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    // event URI(string value, uint256 indexed id);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\\n                    msg.sender,\\n                    from,\\n                    ids,\\n                    amounts,\\n                    data\\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        uint256 ownersLength = owners.length; // Saves MLOADs.\\n\\n        require(ownersLength == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](ownersLength);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < ownersLength; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(\\n                    msg.sender,\\n                    address(0),\\n                    id,\\n                    amount,\\n                    data\\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\\n                    msg.sender,\\n                    address(0),\\n                    ids,\\n                    amounts,\\n                    data\\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\ninterface ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondTeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\ninterface IBondTeller {\\n    /// @notice                 Exchange quote tokens for a bond in a specified market\\n    /// @param recipient_       Address of recipient of bond. Allows deposits for other addresses\\n    /// @param referrer_        Address of referrer who will receive referral fee. For frontends to fill.\\n    ///                         Direct calls can use the zero address for no referrer fee.\\n    /// @param id_              ID of the Market the bond is being purchased from\\n    /// @param amount_          Amount to deposit in exchange for bond\\n    /// @param minAmountOut_    Minimum acceptable amount of bond to receive. Prevents frontrunning\\n    /// @return                 Amount of payout token to be received from the bond\\n    /// @return                 Timestamp at which the bond token can be redeemed for the underlying token\\n    function purchase(\\n        address recipient_,\\n        address referrer_,\\n        uint256 id_,\\n        uint256 amount_,\\n        uint256 minAmountOut_\\n    ) external returns (uint256, uint48);\\n\\n    /// @notice          Get current fee charged by the teller based on the combined protocol and referrer fee\\n    /// @param referrer_ Address of the referrer\\n    /// @return          Fee in basis points (3 decimal places)\\n    function getFee(address referrer_) external view returns (uint48);\\n\\n    /// @notice         Set protocol fee\\n    /// @notice         Must be guardian\\n    /// @param fee_     Protocol fee in basis points (3 decimal places)\\n    function setProtocolFee(uint48 fee_) external;\\n\\n    /// @notice         Set your fee as a referrer to the protocol\\n    /// @notice         Fee is set for sending address\\n    /// @param fee_     Referrer fee in basis points (3 decimal places)\\n    function setReferrerFee(uint48 fee_) external;\\n\\n    /// @notice         Claim fees accrued for input tokens and sends to protocol\\n    /// @notice         Must be guardian\\n    /// @param tokens_  Array of tokens to claim fees for\\n    /// @param to_      Address to send fees to\\n    function claimFees(ERC20[] memory tokens_, address to_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\ninterface IBondCallback {\\n    /// @notice                 Send payout tokens to Teller while allowing market owners to perform custom logic on received or paid out tokens\\n    /// @notice                 Market ID on Teller must be whitelisted\\n    /// @param id_              ID of the market\\n    /// @param inputAmount_     Amount of quote tokens bonded to the market\\n    /// @param outputAmount_    Amount of payout tokens to be paid out to the market\\n    /// @dev Must transfer the output amount of payout tokens back to the Teller\\n    /// @dev Should check that the quote tokens have been transferred to the contract in the _callback function\\n    function callback(\\n        uint256 id_,\\n        uint256 inputAmount_,\\n        uint256 outputAmount_\\n    ) external;\\n\\n    /// @notice         Returns the number of quote tokens received and payout tokens paid out for a market\\n    /// @param id_      ID of the market\\n    /// @return in_     Amount of quote tokens bonded to the market\\n    /// @return out_    Amount of payout tokens paid out to the market\\n    function amountsForMarket(uint256 id_) external view returns (uint256 in_, uint256 out_);\\n\\n    /// @notice         Whitelist a teller and market ID combination\\n    /// @notice         Must be callback owner\\n    /// @param teller_  Address of the Teller contract which serves the market\\n    /// @param id_      ID of the market\\n    function whitelist(address teller_, uint256 id_) external;\\n\\n    /// @notice         Withdraw tokens from the callback and update balances\\n    /// @notice         Only callback owner\\n    /// @param to_      Address of the recipient\\n    /// @param token_   Address of the token to withdraw\\n    /// @param amount_  Amount of tokens to withdraw\\n    function withdraw(\\n        address to_,\\n        ERC20 token_,\\n        uint256 amount_\\n    ) external;\\n\\n    /// @notice         Deposit tokens to the callback and update balances\\n    /// @notice         Only callback owner\\n    /// @param token_   Address of the token to deposit\\n    /// @param amount_  Amount of tokens to deposit\\n    function deposit(ERC20 token_, uint256 amount_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {IBondAuctioneer} from \\\"../interfaces/IBondAuctioneer.sol\\\";\\nimport {IBondTeller} from \\\"../interfaces/IBondTeller.sol\\\";\\n\\ninterface IBondAggregator {\\n    /// @notice             Register a auctioneer with the aggregator\\n    /// @notice             Only Guardian\\n    /// @param auctioneer_  Address of the Auctioneer to register\\n    /// @dev                A auctioneer must be registered with an aggregator to create markets\\n    function registerAuctioneer(IBondAuctioneer auctioneer_) external;\\n\\n    /// @notice             Register a new market with the aggregator\\n    /// @notice             Only registered depositories\\n    /// @param payoutToken_ Token to be paid out by the market\\n    /// @param quoteToken_  Token to be accepted by the market\\n    /// @param marketId     ID of the market being created\\n    function registerMarket(ERC20 payoutToken_, ERC20 quoteToken_)\\n        external\\n        returns (uint256 marketId);\\n\\n    /// @notice     Get the auctioneer for the provided market ID\\n    /// @param id_  ID of Market\\n    function getAuctioneer(uint256 id_) external view returns (IBondAuctioneer);\\n\\n    /// @notice             Calculate current market price of payout token in quote tokens\\n    /// @dev                Accounts for debt and control variable decay since last deposit (vs _marketPrice())\\n    /// @param id_          ID of market\\n    /// @return             Price for market (see the specific auctioneer for units)\\n    //\\n    // if price is below minimum price, minimum price is returned\\n    // this is enforced on deposits by manipulating total debt (see _decay())\\n    function marketPrice(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Scale value to use when converting between quote token and payout token amounts with marketPrice()\\n    /// @param id_          ID of market\\n    /// @return             Scaling factor for market in configured decimals\\n    function marketScale(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Payout due for amount of quote tokens\\n    /// @dev                Accounts for debt and control variable decay so it is up to date\\n    /// @param amount_      Amount of quote tokens to spend\\n    /// @param id_          ID of market\\n    /// @param referrer_    Address of referrer, used to get fees to calculate accurate payout amount.\\n    ///                     Inputting the zero address will take into account just the protocol fee.\\n    /// @return             amount of payout tokens to be paid\\n    function payoutFor(\\n        uint256 amount_,\\n        uint256 id_,\\n        address referrer_\\n    ) external view returns (uint256);\\n\\n    /// @notice             Returns maximum amount of quote token accepted by the market\\n    /// @param id_          ID of market\\n    /// @param referrer_    Address of referrer, used to get fees to calculate accurate payout amount.\\n    ///                     Inputting the zero address will take into account just the protocol fee.\\n    function maxAmountAccepted(uint256 id_, address referrer_) external view returns (uint256);\\n\\n    /// @notice             Does market send payout immediately\\n    /// @param id_          Market ID to search for\\n    function isInstantSwap(uint256 id_) external view returns (bool);\\n\\n    /// @notice             Is a given market accepting deposits\\n    /// @param id_          ID of market\\n    function isLive(uint256 id_) external view returns (bool);\\n\\n    /// @notice             Returns array of active market IDs within a range\\n    /// @dev                Should be used if length exceeds max to query entire array\\n    function liveMarketsBetween(uint256 firstIndex_, uint256 lastIndex_)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /// @notice             Returns an array of all active market IDs for a given quote token\\n    /// @param token_       Address of token to query by\\n    /// @param isPayout_    If true, search by payout token, else search for quote token\\n    function liveMarketsFor(address token_, bool isPayout_)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /// @notice             Returns an array of all active market IDs for a given owner\\n    /// @param owner_       Address of owner to query by\\n    function liveMarketsBy(address owner_) external view returns (uint256[] memory);\\n\\n    /// @notice             Returns an array of all active market IDs for a given payout and quote token\\n    /// @param payout_      Address of payout token\\n    /// @param quote_       Address of quote token\\n    function marketsFor(address payout_, address quote_) external view returns (uint256[] memory);\\n\\n    /// @notice                 Returns the market ID with the highest current payoutToken payout for depositing quoteToken\\n    /// @param payout_          Address of payout token\\n    /// @param quote_           Address of quote token\\n    /// @param amountIn_        Amount of quote tokens to deposit\\n    /// @param minAmountOut_    Minimum amount of payout tokens to receive as payout\\n    /// @param maxExpiry_       Latest acceptable vesting timestamp for bond\\n    ///                         Inputting the zero address will take into account just the protocol fee.\\n    function findMarketFor(\\n        address payout_,\\n        address quote_,\\n        uint256 amountIn_,\\n        uint256 minAmountOut_,\\n        uint256 maxExpiry_\\n    ) external view returns (uint256 id);\\n\\n    /// @notice             Returns the Teller that services the market ID\\n    function getTeller(uint256 id_) external view returns (IBondTeller);\\n\\n    /// @notice             Returns current capacity of a market\\n    function currentCapacity(uint256 id_) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondAuctioneer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {IBondTeller} from \\\"../interfaces/IBondTeller.sol\\\";\\nimport {IBondAggregator} from \\\"../interfaces/IBondAggregator.sol\\\";\\n\\ninterface IBondAuctioneer {\\n    /// @notice                 Creates a new bond market\\n    /// @param params_          Configuration data needed for market creation, encoded in a bytes array\\n    /// @dev                    See specific auctioneer implementations for details on encoding the parameters.\\n    /// @return id              ID of new bond market\\n    function createMarket(bytes memory params_) external returns (uint256);\\n\\n    /// @notice                 Disable existing bond market\\n    /// @notice                 Must be market owner\\n    /// @param id_              ID of market to close\\n    function closeMarket(uint256 id_) external;\\n\\n    /// @notice                 Exchange quote tokens for a bond in a specified market\\n    /// @notice                 Must be teller\\n    /// @param id_              ID of the Market the bond is being purchased from\\n    /// @param amount_          Amount to deposit in exchange for bond (after fee has been deducted)\\n    /// @param minAmountOut_    Minimum acceptable amount of bond to receive. Prevents frontrunning\\n    /// @return payout          Amount of payout token to be received from the bond\\n    function purchaseBond(\\n        uint256 id_,\\n        uint256 amount_,\\n        uint256 minAmountOut_\\n    ) external returns (uint256 payout);\\n\\n    /// @notice                         Set market intervals to different values than the defaults\\n    /// @notice                         Must be market owner\\n    /// @dev                            Changing the intervals could cause markets to behave in unexpected way\\n    ///                                 tuneInterval should be greater than tuneAdjustmentDelay\\n    /// @param id_                      Market ID\\n    /// @param intervals_               Array of intervals (3)\\n    ///                                 1. Tune interval - Frequency of tuning\\n    ///                                 2. Tune adjustment delay - Time to implement downward tuning adjustments\\n    ///                                 3. Debt decay interval - Interval over which debt should decay completely\\n    function setIntervals(uint256 id_, uint32[3] calldata intervals_) external;\\n\\n    /// @notice                      Designate a new owner of a market\\n    /// @notice                      Must be market owner\\n    /// @dev                         Doesn't change permissions until newOwner calls pullOwnership\\n    /// @param id_                   Market ID\\n    /// @param newOwner_             New address to give ownership to\\n    function pushOwnership(uint256 id_, address newOwner_) external;\\n\\n    /// @notice                      Accept ownership of a market\\n    /// @notice                      Must be market newOwner\\n    /// @dev                         The existing owner must call pushOwnership prior to the newOwner calling this function\\n    /// @param id_                   Market ID\\n    function pullOwnership(uint256 id_) external;\\n\\n    /// @notice             Set the auctioneer defaults\\n    /// @notice             Must be policy\\n    /// @param defaults_    Array of default values\\n    ///                     1. Tune interval - amount of time between tuning adjustments\\n    ///                     2. Tune adjustment delay - amount of time to apply downward tuning adjustments\\n    ///                     3. Minimum debt decay interval - minimum amount of time to let debt decay to zero\\n    ///                     4. Minimum deposit interval - minimum amount of time to wait between deposits\\n    ///                     5. Minimum market duration - minimum amount of time a market can be created for\\n    ///                     6. Minimum debt buffer - the minimum amount of debt over the initial debt to trigger a market shutdown\\n    /// @dev                The defaults set here are important to avoid edge cases in market behavior, e.g. a very short market reacts doesn't tune well\\n    /// @dev                Only applies to new markets that are created after the change\\n    function setDefaults(uint32[6] memory defaults_) external;\\n\\n    /// @notice             Change the status of the auctioneer to allow creation of new markets\\n    /// @dev                Setting to false and allowing active markets to end will sunset the auctioneer\\n    /// @param status_      Allow market creation (true) : Disallow market creation (false)\\n    function setAllowNewMarkets(bool status_) external;\\n\\n    /// @notice             Change whether a market creator is allowed to use a callback address in their markets or not\\n    /// @notice             Must be guardian\\n    /// @dev                Callback is believed to be safe, but a whitelist is implemented to prevent abuse\\n    /// @param creator_     Address of market creator\\n    /// @param status_      Allow callback (true) : Disallow callback (false)\\n    function setCallbackAuthStatus(address creator_, bool status_) external;\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /// @notice                 Provides information for the Teller to execute purchases on a Market\\n    /// @param id_              Market ID\\n    /// @return owner           Address of the market owner (tokens transferred from this address if no callback)\\n    /// @return callbackAddr    Address of the callback contract to get tokens for payouts\\n    /// @return payoutToken     Payout Token (token paid out) for the Market\\n    /// @return quoteToken      Quote Token (token received) for the Market\\n    /// @return vesting         Timestamp or duration for vesting, implementation-dependent\\n    /// @return maxPayout       Maximum amount of payout tokens you can purchase in one transaction\\n    function getMarketInfoForPurchase(uint256 id_)\\n        external\\n        view\\n        returns (\\n            address owner,\\n            address callbackAddr,\\n            ERC20 payoutToken,\\n            ERC20 quoteToken,\\n            uint48 vesting,\\n            uint256 maxPayout\\n        );\\n\\n    /// @notice             Calculate current market price of payout token in quote tokens\\n    /// @param id_          ID of market\\n    /// @return             Price for market in configured decimals\\n    //\\n    // if price is below minimum price, minimum price is returned\\n    // this is enforced on deposits by manipulating total debt (see _decay())\\n    function marketPrice(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Scale value to use when converting between quote token and payout token amounts with marketPrice()\\n    /// @param id_          ID of market\\n    /// @return             Scaling factor for market in configured decimals\\n    function marketScale(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Payout due for amount of quote tokens\\n    /// @dev                Accounts for debt and control variable decay so it is up to date\\n    /// @param amount_      Amount of quote tokens to spend\\n    /// @param id_          ID of market\\n    /// @param referrer_    Address of referrer, used to get fees to calculate accurate payout amount.\\n    ///                     Inputting the zero address will take into account just the protocol fee.\\n    /// @return             amount of payout tokens to be paid\\n    function payoutFor(\\n        uint256 amount_,\\n        uint256 id_,\\n        address referrer_\\n    ) external view returns (uint256);\\n\\n    /// @notice             Returns maximum amount of quote token accepted by the market\\n    /// @param id_          ID of market\\n    /// @param referrer_    Address of referrer, used to get fees to calculate accurate payout amount.\\n    ///                     Inputting the zero address will take into account just the protocol fee.\\n    function maxAmountAccepted(uint256 id_, address referrer_) external view returns (uint256);\\n\\n    /// @notice             Does market send payout immediately\\n    /// @param id_          Market ID to search for\\n    function isInstantSwap(uint256 id_) external view returns (bool);\\n\\n    /// @notice             Is a given market accepting deposits\\n    /// @param id_          ID of market\\n    function isLive(uint256 id_) external view returns (bool);\\n\\n    /// @notice             Returns the address of the market owner\\n    /// @param id_          ID of market\\n    function ownerOf(uint256 id_) external view returns (address);\\n\\n    /// @notice             Returns the Teller that services the Auctioneer\\n    function getTeller() external view returns (IBondTeller);\\n\\n    /// @notice             Returns the Aggregator that services the Auctioneer\\n    function getAggregator() external view returns (IBondAggregator);\\n\\n    /// @notice             Returns current capacity of a market\\n    function currentCapacity(uint256 id_) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"clones-with-immutable-args/=lib/clones-with-immutable-args/src/\",\r\n      \"clones/=lib/clones-with-immutable-args/src/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"weird-erc20/=lib/solmate/lib/weird-erc20/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"protocol_\",\"type\":\"address\"},{\"internalType\":\"contract IBondAggregator\",\"name\":\"aggregator_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardian_\",\"type\":\"address\"},{\"internalType\":\"contract Authority\",\"name\":\"authority_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Teller_InvalidCallback\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Teller_InvalidParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Teller_NotAuthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"expiry\",\"type\":\"uint48\"}],\"name\":\"Teller_TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"maturesOn\",\"type\":\"uint48\"}],\"name\":\"Teller_TokenNotMatured\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Teller_UnsupportedToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"Bonded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract ERC20\",\"name\":\"payoutToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint48\",\"name\":\"expiry\",\"type\":\"uint48\"}],\"name\":\"ERC1155BondTokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_DECIMALS\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts_\",\"type\":\"uint256[]\"}],\"name\":\"batchRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20[]\",\"name\":\"tokens_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"}],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"underlying_\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"expiry_\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createFeeDiscount\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"underlying_\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"expiry_\",\"type\":\"uint48\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer_\",\"type\":\"address\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"underlying_\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"expiry_\",\"type\":\"uint48\"}],\"name\":\"getTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getTokenNameAndSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut_\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrerFees\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"fee_\",\"type\":\"uint48\"}],\"name\":\"setProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"fee_\",\"type\":\"uint48\"}],\"name\":\"setReferrerFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"contract ERC20\",\"name\":\"payoutToken\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"expiry\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BondFixedTermTeller","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"000000000000000000000000007bd11fca0daaeadd455b51826f9a015f2f0969000000000000000000000000007a66b9e719b3abb2f3917eb47d4231a17f5a0d000000000000000000000000007bd11fca0daaeadd455b51826f9a015f2f0969000000000000000000000000007a0f3b057945db86408197daa7c04373b5a94a","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]