{"IERC677.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IERC677 is IERC20 {\n    function transferAndCall(address recipient, uint amount, bytes memory data) external returns (bool success);\n    \n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\n\ninterface IERC677Receiver {\n    function onTokenTransfer(address sender, uint value, bytes memory data) external;\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a % b;\n    }\n}"},"Varen.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/*\n ____   ____        __        _______      _________   ____  _____ \n|_  _| |_  _|      /  \\      |_   __ \\    |_   ___  | |_   \\|_   _|\n  \\ \\   / /       / /\\ \\       | |__) |     | |_  \\_|   |   \\ | |  \n   \\ \\ / /       / ____ \\      |  __ /      |  _|  _    | |\\ \\| |  \n    \\ \u0027 /      _/ /    \\ \\_   _| |  \\ \\_   _| |___/ |  _| |_\\   |_ \n     \\_/      |____|  |____| |____| |___| |_________| |_____|\\____|\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npragma solidity 0.8.4;\n\nimport \"./IERC677.sol\";\nimport \"./SafeMath.sol\";\n\ncontract Varen is IERC677 {\n    using SafeMath for uint256;\n    \n    /// @notice EIP-20 token name for this token\n    string public constant override name = \u0027Varen\u0027;\n    \n    /// @notice EIP-20 token symbol for this token\n    string public constant override symbol = \u0027VRN\u0027;\n    \n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant override decimals = 18;\n    \n    /// @notice Total number of tokens in circulation: 88,888\n    uint256 public constant override totalSupply = 88888e18;\n    \n    /// @notice Allowance amounts on behalf of others\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n    \n    /// @notice Official record of token balances for each account\n    mapping (address =\u003e uint256) private _balances;\n    \n    /// @notice Initial treasury of Varen \n    address private constant TREASURY = 0xE69A81b96FBF5Cb6CAe95d2cE5323Eff2bA0EAE4;\n    \n    /// @notice Construct Varen token and allocate all tokens to treasury\n    constructor() {\n        _balances[TREASURY] = totalSupply;\n        emit Transfer(address(0), TREASURY, totalSupply);\n    }\n    \n    /**\n     * @notice Get the number of tokens held by `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n    \n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `owner`\n     * @param owner The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    \n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `recipient`\n     * @param recipient The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    \n    \n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `recipient` and call the recipient if it is a contract\n     * @param recipient The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @param data The extra data to be passed to the receiving contract.\n     * @return Whether or not the transfer succeeded\n     */\n    function transferAndCall(address recipient, uint amount, bytes memory data) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        emit Transfer(msg.sender, recipient, amount, data);\n        \n        if (_isContract(recipient)) {\n          IERC677Receiver(recipient).onTokenTransfer(msg.sender, amount, data);\n        }\n        \n        return true;\n    }\n    \n    /**\n     * @notice Transfer `amount` tokens from `sender` to `recipient`\n     * @param sender The address of the source account\n     * @param recipient The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `msg.sender`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * \n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    \n    /**\n     * @notice Atomically increase the allowance granted to `spender` by msg.sender. \n     * @dev This is an alternative to {approve} that can be used as a mitigation for\n     *  problems described [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * \n     * @param spender The address of the account for which the allowance has to be increased\n     * @param addedValue The number of tokens to increase the allowance by\n     * @return Whether or not the allowance was successfully increased\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n    \n    /**\n     * @notice Atomically decrease the allowance granted to `spender` by msg.sender. \n     * @dev This is an alternative to {approve} that can be used as a mitigation for\n     *  problems described [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * \n     * @param spender The address of the account for which the allowance has to be decreased\n     * @param subtractedValue The number of tokens to decrease the allowance by\n     * @return Whether or not the allowance was successfully decreased\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"decreased allowance below zero\"));\n        return true;\n    }\n    \n    function _transfer(address sender, address recipient, uint256 amount) private {\n        _balances[sender] = _balances[sender].sub(amount, \"amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n    \n    function _approve(address owner, address spender, uint256 amount) private {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _isContract(address addr) private view returns (bool) {\n        uint256 length;\n        assembly { length := extcodesize(addr) }\n        return length \u003e 0;\n    }\n}\n"}}