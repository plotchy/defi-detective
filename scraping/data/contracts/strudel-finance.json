[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/balancer/BMath.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General internal License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General internal License for more details.\\n\\n// You should have received a copy of the GNU General internal License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.6;\\n\\nimport \\\"./BNum.sol\\\";\\n\\ncontract BMath is BNum {\\n  /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcInGivenOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountIn) {\\n    uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n    uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\\n    uint256 y = bdiv(tokenBalanceOut, diff);\\n    uint256 foo = bpow(y, weightRatio);\\n    foo = bsub(foo, BONE);\\n    tokenAmountIn = bsub(BONE, swapFee);\\n    tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n    return tokenAmountIn;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n  function calcPoolOutGivenSingleIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 poolAmountOut) {\\n    // Charge the trading fee for the proportion of tokenAi\\n    ///  which is implicitly traded to the other pool tokens.\\n    // That proportion is (1- weightTokenIn)\\n    // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n    uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n    uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n    uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n    uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n    // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n    uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\\n    uint256 newPoolSupply = bmul(poolRatio, poolSupply);\\n    poolAmountOut = bsub(newPoolSupply, poolSupply);\\n    return poolAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n  function calcSingleInGivenPoolOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountIn) {\\n    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n    uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\\n    uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n    //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n    uint256 boo = bdiv(BONE, normalizedWeight);\\n    uint256 tokenInRatio = bpow(poolRatio, boo);\\n    uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n    uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n    // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\\n    //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n    //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n    uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n    tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n    return tokenAmountIn;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n  function calcSingleOutGivenPoolIn(\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountOut) {\\n    uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n    // charge exit fee on the pool token side\\n    // pAiAfterExitFee = pAi*(1-exitFee)\\n    uint256 poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\\n    uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\\n    uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n    // newBalTo = poolRatio^(1/weightTo) * balTo;\\n    uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n    uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n    uint256 tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\\n\\n    // charge swap fee on the output token side\\n    //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n    uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n    tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n    return tokenAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight           -------------------------------------------------------------  //\\n    // sF = swapFee                                        ( 1 - eF )                            //\\n    // eF = exitFee                                                                              //\\n    **********************************************************************************************/\\n  function calcPoolInGivenSingleOut(\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 poolAmountIn) {\\n    // charge swap fee on the output token side\\n    uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n    //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n    uint256 zoo = bsub(BONE, normalizedWeight);\\n    uint256 zar = bmul(zoo, swapFee);\\n    uint256 tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n    uint256 newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\\n    uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n    //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n    uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n    uint256 newPoolSupply = bmul(poolRatio, poolSupply);\\n    uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\\n\\n    // charge exit fee on the pool token side\\n    // pAi = pAiAfterExitFee/(1-exitFee)\\n    poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\\n    return poolAmountIn;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/balancer/BNum.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.6;\\n\\nimport \\\"./libraries/BConst.sol\\\";\\n\\ncontract BNum is BConst {\\n  function btoi(uint256 a) internal pure returns (uint256) {\\n    return a / BONE;\\n  }\\n\\n  function bfloor(uint256 a) internal pure returns (uint256) {\\n    return btoi(a) * BONE;\\n  }\\n\\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n    return c;\\n  }\\n\\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    (uint256 c, bool flag) = bsubSign(a, b);\\n    require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n    return c;\\n  }\\n\\n  function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\\n    if (a >= b) {\\n      return (a - b, false);\\n    } else {\\n      return (b - a, true);\\n    }\\n  }\\n\\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c0 = a * b;\\n    require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n    uint256 c1 = c0 + (BONE / 2);\\n    require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n    uint256 c2 = c1 / BONE;\\n    return c2;\\n  }\\n\\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n    uint256 c0 = a * BONE;\\n    require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n    uint256 c1 = c0 + (b / 2);\\n    require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n    uint256 c2 = c1 / b;\\n    return c2;\\n  }\\n\\n  // DSMath.wpow\\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\\n    uint256 z = n % 2 != 0 ? a : BONE;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n      a = bmul(a, a);\\n\\n      if (n % 2 != 0) {\\n        z = bmul(z, a);\\n      }\\n    }\\n    return z;\\n  }\\n\\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n  // of approximation of b^0.w\\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\\n    require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n    require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n    uint256 whole = bfloor(exp);\\n    uint256 remain = bsub(exp, whole);\\n\\n    uint256 wholePow = bpowi(base, btoi(whole));\\n\\n    if (remain == 0) {\\n      return wholePow;\\n    }\\n\\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n    return bmul(wholePow, partialResult);\\n  }\\n\\n  function bpowApprox(\\n    uint256 base,\\n    uint256 exp,\\n    uint256 precision\\n  ) internal pure returns (uint256) {\\n    // term 0:\\n    uint256 a = exp;\\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\\n    uint256 term = BONE;\\n    uint256 sum = term;\\n    bool negative = false;\\n\\n    // term(k) = numer / denom\\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\\n    // continue until term is less than precision\\n    for (uint256 i = 1; term >= precision; i++) {\\n      uint256 bigK = i * BONE;\\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n      term = bmul(term, bmul(c, x));\\n      term = bdiv(term, bigK);\\n      if (term == 0) break;\\n\\n      if (xneg) negative = !negative;\\n      if (cneg) negative = !negative;\\n      if (negative) {\\n        sum = bsub(sum, term);\\n      } else {\\n        sum = badd(sum, term);\\n      }\\n    }\\n\\n    return sum;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/balancer/libraries/BConst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.6;\\n\\n/**\\n * @author Balancer Labs\\n * @title Put all the constants in one place\\n */\\n\\ncontract BConst {\\n  // State variables (must be constant in a library)\\n\\n  // B \\\"ONE\\\" - all math is in the \\\"realm\\\" of 10 ** 18;\\n  // where numeric 1 = 10 ** 18\\n  uint256 internal constant BONE = 10**18;\\n  uint256 internal constant MIN_WEIGHT = BONE;\\n  uint256 internal constant MAX_WEIGHT = BONE * 50;\\n  uint256 internal constant MAX_TOTAL_WEIGHT = BONE * 50;\\n  uint256 internal constant MIN_BALANCE = BONE / 10**6;\\n  uint256 internal constant MAX_BALANCE = BONE * 10**12;\\n  uint256 internal constant MIN_POOL_SUPPLY = BONE * 100;\\n  uint256 internal constant MAX_POOL_SUPPLY = BONE * 10**9;\\n  uint256 internal constant MIN_FEE = BONE / 10**6;\\n  uint256 internal constant MAX_FEE = BONE / 10;\\n  // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\\n  uint256 internal constant EXIT_FEE = 0;\\n  uint256 internal constant MAX_IN_RATIO = BONE / 2;\\n  uint256 internal constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n  // Must match BConst.MIN_BOUND_TOKENS and BConst.MAX_BOUND_TOKENS\\n  uint256 internal constant MIN_ASSET_LIMIT = 2;\\n  uint256 internal constant MAX_ASSET_LIMIT = 8;\\n  uint256 internal constant MAX_UINT = uint256(-1);\\n\\n  uint256 internal constant MIN_BPOW_BASE = 1 wei;\\n  uint256 internal constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\\n  uint256 internal constant BPOW_PRECISION = BONE / 10**10;\\n}\\n\"\r\n    },\r\n    \"contracts/balancer/IBFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.6;\\n\\nimport \\\"./IBPool.sol\\\";\\n\\ninterface IBFactory {\\n  function newBPool() external returns (IBPool);\\n\\n  function setBLabs(address b) external;\\n\\n  function collect(IBPool pool) external;\\n\\n  function isBPool(address b) external view returns (bool);\\n\\n  function getBLabs() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/balancer/IBPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.6;\\n\\ninterface IBPool {\\n  function rebind(\\n    address token,\\n    uint256 balance,\\n    uint256 denorm\\n  ) external;\\n\\n  function setSwapFee(uint256 swapFee) external;\\n\\n  function setPublicSwap(bool publicSwap) external;\\n\\n  function bind(\\n    address token,\\n    uint256 balance,\\n    uint256 denorm\\n  ) external;\\n\\n  function unbind(address token) external;\\n\\n  function gulp(address token) external;\\n\\n  function isBound(address token) external view returns (bool);\\n\\n  function getBalance(address token) external view returns (uint256);\\n\\n  function getSwapFee() external view returns (uint256);\\n\\n  function isPublicSwap() external view returns (bool);\\n\\n  function getDenormalizedWeight(address token) external view returns (uint256);\\n\\n  function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n  function getCurrentTokens() external view returns (address[] memory tokens);\\n\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n}\\n\"\r\n    },\r\n    \"contracts/balancer/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.6;\\n\\n/**\\n * @author Balancer Labs (and OpenZeppelin)\\n * @title Protect against reentrant calls (and also selectively protect view functions)\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {_lock_} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `_lock_` guard, functions marked as\\n * `_lock_` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `_lock_` entry\\n * points to them.\\n *\\n * Also adds a _lockview_ modifier, which doesn't create a lock, but fails\\n *   if another _lock_ call is in progress\\n */\\ncontract ReentrancyGuard {\\n  // Booleans are more expensive than uint256 or any type that takes up a full\\n  // word because each write operation emits an extra SLOAD to first read the\\n  // slot's contents, replace the bits taken up by the boolean, and then write\\n  // back. This is the compiler's defense against contract upgrades and\\n  // pointer aliasing, and it cannot be disabled.\\n\\n  // The values being non-zero value makes deployment a bit more expensive,\\n  // but in exchange the refund on every call to nonReentrant will be lower in\\n  // amount. Since refunds are capped to a percentage of the total\\n  // transaction's gas, it is best to keep them low in cases like this one, to\\n  // increase the likelihood of the full refund coming into effect.\\n  uint256 private constant _NOT_ENTERED = 1;\\n  uint256 private constant _ENTERED = 2;\\n\\n  uint256 private _status;\\n\\n  constructor() internal {\\n    _status = _NOT_ENTERED;\\n  }\\n\\n  /**\\n   * @dev Prevents a contract from calling itself, directly or indirectly.\\n   * Calling a `_lock_` function from another `_lock_`\\n   * function is not supported. It is possible to prevent this from happening\\n   * by making the `_lock_` function external, and make it call a\\n   * `private` function that does the actual work.\\n   */\\n  modifier lock() {\\n    // On the first call to _lock_, _notEntered will be true\\n    require(_status != _ENTERED, \\\"ERR_REENTRY\\\");\\n\\n    // Any calls to _lock_ after this point will fail\\n    _status = _ENTERED;\\n    _;\\n    // By storing the original value once again, a refund is triggered (see\\n    // https://eips.ethereum.org/EIPS/eip-2200)\\n    _status = _NOT_ENTERED;\\n  }\\n\\n  /**\\n   * @dev Also add a modifier that doesn't create a lock, but protects functions that\\n   *      should not be called while a _lock_ function is running\\n   */\\n  modifier viewlock() {\\n    require(_status != _ENTERED, \\\"ERR_REENTRY_VIEW\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/BtcPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity 0.6.6;\\n\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@uniswap/lib/contracts/libraries/FixedPoint.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol\\\";\\nimport \\\"./IBtcPriceOracle.sol\\\";\\n\\n// fixed window oracle that recomputes the average price for the entire period once every period\\n// note that the price average is only guaranteed to be over at least 1 period, but may be over a longer period\\ncontract BtcPriceOracle is OwnableUpgradeSafe, IBtcPriceOracle {\\n  using FixedPoint for *;\\n\\n  uint256 public constant PERIOD = 20 minutes;\\n\\n  event Price(uint256 price);\\n\\n  address public immutable weth;\\n  address public immutable factory;\\n\\n  // governance params\\n  address[] public referenceTokens;\\n\\n  // working memory\\n  mapping(address => uint256) public priceCumulativeLast;\\n  uint32 public blockTimestampLast;\\n  FixedPoint.uq112x112 public priceAverage;\\n\\n  constructor(\\n    address _factory,\\n    address _weth,\\n    address[] memory tokenizedBtcs\\n  ) public {\\n    __Ownable_init();\\n    factory = _factory;\\n    weth = _weth;\\n    for (uint256 i = 0; i < tokenizedBtcs.length; i++) {\\n      _addPair(tokenizedBtcs[i], _factory, _weth);\\n    }\\n  }\\n\\n  function _addPair(\\n    address tokenizedBtc,\\n    address _factory,\\n    address _weth\\n  ) internal {\\n    // check inputs\\n    require(tokenizedBtc != address(0), \\\"zero token\\\");\\n    require(priceCumulativeLast[tokenizedBtc] == 0, \\\"already known\\\");\\n\\n    // check pair\\n    IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(_factory, _weth, tokenizedBtc));\\n    require(address(pair) != address(0), \\\"no pair\\\");\\n    uint112 reserve0;\\n    uint112 reserve1;\\n    (reserve0, reserve1, ) = pair.getReserves();\\n    require(reserve0 != 0 && reserve1 != 0, \\\"BtcOracle: NO_RESERVES\\\"); // ensure that there's liquidity in the pair\\n\\n    // fetch the current accumulated price value (0 / 1)\\n    priceCumulativeLast[tokenizedBtc] = (pair.token0() == _weth)\\n      ? pair.price1CumulativeLast()\\n      : pair.price0CumulativeLast();\\n    // add to storage\\n    referenceTokens.push(tokenizedBtc);\\n  }\\n\\n  function update() external {\\n    uint32 blockTimestamp;\\n    uint224 priceSum = 0;\\n    for (uint256 i = 0; i < referenceTokens.length; i++) {\\n      address tokenizedBtc = referenceTokens[i];\\n      IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, weth, tokenizedBtc));\\n      uint256 price0Cumulative;\\n      uint256 price1Cumulative;\\n      (price0Cumulative, price1Cumulative, blockTimestamp) = UniswapV2OracleLibrary\\n        .currentCumulativePrices(address(pair));\\n      uint256 priceCumulative = (pair.token0() == weth) ? price1Cumulative : price0Cumulative;\\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n\\n      // ensure that at least one full period has passed since the last update\\n      require(timeElapsed >= PERIOD, \\\"ExampleOracleSimple: PERIOD_NOT_ELAPSED\\\");\\n\\n      // overflow is desired, casting never truncates\\n      // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\n      uint256 price = (priceCumulative - priceCumulativeLast[tokenizedBtc]) / timeElapsed;\\n      emit Price(price);\\n      priceSum += FixedPoint.uq112x112(uint224(price))._x;\\n\\n      priceCumulativeLast[tokenizedBtc] = priceCumulative;\\n    }\\n    // TODO: use weights\\n    // TODO: use geometric\\n    priceAverage = FixedPoint.uq112x112(priceSum).div(uint112(referenceTokens.length));\\n    blockTimestampLast = blockTimestamp;\\n  }\\n\\n  // note this will always return 0 before update has been called successfully for the first time.\\n  function consult(uint256 amountIn) external override view returns (uint256 amountOut) {\\n    require(referenceTokens.length > 0, \\\"nothing to track\\\");\\n    return priceAverage.mul(amountIn / 10**10).decode144();\\n  }\\n\\n  // governance functions\\n  function addPair(address tokenizedBtc) external onlyOwner {\\n    _addPair(tokenizedBtc, factory, weth);\\n  }\\n\\n  function removePair(address tokenizedBtc) external onlyOwner {\\n    for (uint256 i = 0; i < referenceTokens.length; i++) {\\n      if (referenceTokens[i] == tokenizedBtc) {\\n        priceCumulativeLast[tokenizedBtc] = 0;\\n        referenceTokens[i] = referenceTokens[referenceTokens.length - 1];\\n        referenceTokens.pop();\\n        return;\\n      }\\n    }\\n    require(false, \\\"remove not found\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.4.0;\\n\\nimport './Babylonian.sol';\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n    uint private constant Q112 = uint(1) << RESOLUTION;\\n    uint private constant Q224 = Q112 << RESOLUTION;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n\\n    // take the reciprocal of a UQ112x112\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\\n        return uq112x112(uint224(Q224 / self._x));\\n    }\\n\\n    // square root of a UQ112x112\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/Babylonian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.4.0;\\n\\n// computes square roots using the babylonian method\\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\\nlibrary Babylonian {\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n        // else z = 0\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n\\n\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n\\n    }\\n\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\nimport \\\"../Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract ContextUpgradeSafe is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n\\n\\n    }\\n\\n\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary UniswapV2Library {\\n    using SafeMath for uint;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n            ))));\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        uint amountInWithFee = amountIn.mul(997);\\n        uint numerator = amountInWithFee.mul(reserveOut);\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint i; i < path.length - 1; i++) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint i = path.length - 1; i > 0; i--) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.6.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IBtcPriceOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n// fixed window oracle that recomputes the average price for the entire period once every period\\n// note that the price average is only guaranteed to be over at least 1 period, but may be over a longer period\\ninterface IBtcPriceOracle {\\n  // note this will always return 0 before update has been called successfully for the first time.\\n  function consult(uint256 amountIn) external view returns (uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/erc20/ITokenRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity 0.6.6;\\n\\n/// @title Interface of recipient contract for `approveAndCall` pattern.\\n///        Implementors will be able to be used in an `approveAndCall`\\n///        interaction with a supporting contract, such that a token approval\\n///        can call the contract acting on that approval in a single\\n///        transaction.\\n///\\n///        See the `FundingScript` and `RedemptionScript` contracts as examples.\\ninterface ITokenRecipient {\\n  /// Typically called from a token contract's `approveAndCall` method, this\\n  /// method will receive the original owner of the token (`_from`), the\\n  /// transferred `_value` (in the case of an ERC721, the token id), the token\\n  /// address (`_token`), and a blob of `_extraData` that is informally\\n  /// specified by the implementor of this method as a way to communicate\\n  /// additional parameters.\\n  ///\\n  /// Token calls to `receiveApproval` should revert if `receiveApproval`\\n  /// reverts, and reverts should remove the approval.\\n  ///\\n  /// @param _from The original owner of the token approved for transfer.\\n  /// @param _value For an ERC20, the amount approved for transfer; for an\\n  ///        ERC721, the id of the token approved for transfer.\\n  /// @param _token The address of the contract for the token whose transfer\\n  ///        was approved.\\n  /// @param _extraData An additional data blob forwarded unmodified through\\n  ///        `approveAndCall`, used to allow the token owner to pass\\n  ///         additional parameters and data to this method. The structure of\\n  ///         the extra data is informally specified by the implementor of\\n  ///         this interface.\\n  function receiveApproval(\\n    address _from,\\n    uint256 _value,\\n    address _token,\\n    bytes calldata _extraData\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/erc20/MinterRole.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\nimport \\\"./Roles.sol\\\";\\n\\ncontract MinterRole is ContextUpgradeSafe, OwnableUpgradeSafe {\\n  using Roles for Roles.Role;\\n\\n  event MinterAdded(address indexed account);\\n  event MinterRemoved(address indexed account);\\n\\n  Roles.Role private _minters;\\n\\n  modifier onlyMinter() {\\n    require(isMinter(_msgSender()), \\\"MinterRole: caller does not have the Minter role\\\");\\n    _;\\n  }\\n\\n  function isMinter(address account) public view returns (bool) {\\n    return _minters.has(account);\\n  }\\n\\n  function addMinter(address account) public onlyOwner {\\n    _addMinter(account);\\n  }\\n\\n  function renounceMinter() public {\\n    _removeMinter(_msgSender());\\n  }\\n\\n  function _addMinter(address account) internal {\\n    _minters.add(account);\\n    emit MinterAdded(account);\\n  }\\n\\n  function _removeMinter(address account) internal {\\n    _minters.remove(account);\\n    emit MinterRemoved(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/erc20/Roles.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n  struct Role {\\n    mapping(address => bool) bearer;\\n  }\\n\\n  /**\\n   * @dev Give an account access to this role.\\n   */\\n  function add(Role storage role, address account) internal {\\n    require(!has(role, account), \\\"Roles: account already has role\\\");\\n    role.bearer[account] = true;\\n  }\\n\\n  /**\\n   * @dev Remove an account's access to this role.\\n   */\\n  function remove(Role storage role, address account) internal {\\n    require(has(role, account), \\\"Roles: account does not have role\\\");\\n    role.bearer[account] = false;\\n  }\\n\\n  /**\\n   * @dev Check if an account has this role.\\n   * @return bool\\n   */\\n  function has(Role storage role, address account) internal view returns (bool) {\\n    require(account != address(0), \\\"Roles: account is the zero address\\\");\\n    return role.bearer[account];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/FlashERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\nimport \\\"./IBorrower.sol\\\";\\nimport \\\"./ILender.sol\\\";\\n\\n// inspired by https://github.com/Austin-Williams/flash-mintable-tokens/blob/master/FlashERC20/FlashERC20.sol\\ncontract FlashERC20 is\\n  Initializable,\\n  ContextUpgradeSafe,\\n  ERC20UpgradeSafe,\\n  ILender,\\n  OwnableUpgradeSafe\\n{\\n  uint256 constant BTC_CAP = 21 * 10**24;\\n  uint256 constant FEE_FACTOR = 100;\\n\\n  // used for reentrance guard\\n  uint256 private constant _NOT_ENTERED = 1;\\n  uint256 private constant _ENTERED = 2;\\n\\n  event FlashMint(address indexed src, uint256 wad, bytes32 data, uint256 fee);\\n\\n  // working memory\\n  uint256 private _status;\\n  // Dev fund\\n  uint256 public devFundDivRate;\\n\\n  function __Flash_init(string memory name, string memory symbol) internal initializer {\\n    devFundDivRate = 17;\\n    _status = _NOT_ENTERED;\\n    __ERC20_init(name, symbol);\\n    __Ownable_init();\\n  }\\n\\n  /**\\n   * @dev Prevents a contract from calling itself, directly or indirectly.\\n   * Calling a `_lock_` function from another `_lock_`\\n   * function is not supported. It is possible to prevent this from happening\\n   * by making the `_lock_` function external, and make it call a\\n   * `private` function that does the actual work.\\n   */\\n  modifier lock() {\\n    // On the first call to _lock_, _notEntered will be true\\n    require(_status != _ENTERED, \\\"ERR_REENTRY\\\");\\n\\n    // Any calls to _lock_ after this point will fail\\n    _status = _ENTERED;\\n    _;\\n    // By storing the original value once again, a refund is triggered (see\\n    // https://eips.ethereum.org/EIPS/eip-2200)\\n    _status = _NOT_ENTERED;\\n  }\\n\\n  // Allows anyone to mint tokens as long as it gets burned by the end of the transaction.\\n  function flashMint(uint256 amount, bytes32 data) external override lock {\\n    // do not exceed cap\\n    require(totalSupply().add(amount) <= BTC_CAP, \\\"can not borrow more than BTC cap\\\");\\n\\n    // mint tokens\\n    _mint(msg.sender, amount);\\n\\n    // hand control to borrower\\n    IBorrower(msg.sender).executeOnFlashMint(amount, data);\\n\\n    uint256 fee = amount.div(devFundDivRate.mul(FEE_FACTOR));\\n\\n    // burn tokens\\n    _burn(msg.sender, amount.add(fee)); // reverts if `msg.sender` does not have enough\\n    _mint(owner(), fee);\\n\\n    emit FlashMint(msg.sender, amount, data, fee);\\n  }\\n\\n  // governance function\\n  function setDevFundDivRate(uint256 _devFundDivRate) external onlyOwner {\\n    require(_devFundDivRate > 0, \\\"!devFundDivRate-0\\\");\\n    devFundDivRate = _devFundDivRate;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20MinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20UpgradeSafe is Initializable, ContextUpgradeSafe, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n\\n    function __ERC20_init(string memory name, string memory symbol) internal initializer {\\n        __Context_init_unchained();\\n        __ERC20_init_unchained(name, symbol);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name, string memory symbol) internal initializer {\\n\\n\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n\\n    }\\n\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n\\n    uint256[44] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IBorrower.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface IBorrower {\\n  function executeOnFlashMint(uint256 amount, bytes32 data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ILender.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ncontract ILender {\\n  function flashMint(uint256 amount, bytes32 data) external virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/BPool.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../balancer/BMath.sol\\\";\\nimport \\\"../balancer/IBPool.sol\\\";\\n\\ncontract BPool is ERC20UpgradeSafe, BMath, IBPool {\\n  struct Record {\\n    bool bound; // is token bound to pool\\n    uint256 index; // private\\n    uint256 denorm; // denormalized weight\\n    uint256 balance;\\n  }\\n\\n  event LOG_SWAP(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    address indexed tokenOut,\\n    uint256 tokenAmountIn,\\n    uint256 tokenAmountOut\\n  );\\n\\n  event LOG_JOIN(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\\n\\n  event LOG_EXIT(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\\n\\n  event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data);\\n\\n  modifier _logs_() {\\n    emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n    _;\\n  }\\n\\n  modifier _lock_() {\\n    require(!_mutex, \\\"ERR_REENTRY\\\");\\n    _mutex = true;\\n    _;\\n    _mutex = false;\\n  }\\n\\n  modifier _viewlock_() {\\n    require(!_mutex, \\\"ERR_REENTRY\\\");\\n    _;\\n  }\\n\\n  bool private _mutex;\\n\\n  address private _factory; // BFactory address to push token exitFee to\\n  address private _controller; // has CONTROL role\\n  bool private _publicSwap; // true if PUBLIC can call SWAP functions\\n\\n  // `setSwapFee` and `finalize` require CONTROL\\n  // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\n  uint256 private _swapFee;\\n  bool private _finalized;\\n\\n  address[] private _tokens;\\n  mapping(address => Record) private _records;\\n  uint256 private _totalWeight;\\n\\n  constructor(address controller) public {\\n    _controller = controller;\\n    _factory = msg.sender;\\n    _swapFee = MIN_FEE;\\n    _publicSwap = false;\\n    _finalized = false;\\n    __ERC20_init(\\\"poolName\\\", \\\"POS\\\");\\n  }\\n\\n  /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcSpotPrice(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 spotPrice) {\\n    uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n    uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n    uint256 ratio = bdiv(numer, denom);\\n    uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\\n    return (spotPrice = bmul(ratio, scale));\\n  }\\n\\n  /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcOutGivenIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountOut) {\\n    uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n    uint256 adjustedIn = bsub(BONE, swapFee);\\n    adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n    uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n    uint256 foo = bpow(y, weightRatio);\\n    uint256 bar = bsub(BONE, foo);\\n    tokenAmountOut = bmul(tokenBalanceOut, bar);\\n    return tokenAmountOut;\\n  }\\n\\n  function isPublicSwap() external override view returns (bool) {\\n    return _publicSwap;\\n  }\\n\\n  function isFinalized() external view returns (bool) {\\n    return _finalized;\\n  }\\n\\n  function isBound(address t) external override view returns (bool) {\\n    return _records[t].bound;\\n  }\\n\\n  function getNumTokens() external view returns (uint256) {\\n    return _tokens.length;\\n  }\\n\\n  function getCurrentTokens() external override view _viewlock_ returns (address[] memory tokens) {\\n    return _tokens;\\n  }\\n\\n  function getFinalTokens() external view _viewlock_ returns (address[] memory tokens) {\\n    require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n    return _tokens;\\n  }\\n\\n  function getDenormalizedWeight(address token)\\n    external\\n    override\\n    view\\n    _viewlock_\\n    returns (uint256)\\n  {\\n    require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n    return _records[token].denorm;\\n  }\\n\\n  function getTotalDenormalizedWeight() external override view _viewlock_ returns (uint256) {\\n    return _totalWeight;\\n  }\\n\\n  function getNormalizedWeight(address token) external view _viewlock_ returns (uint256) {\\n    require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n    uint256 denorm = _records[token].denorm;\\n    return bdiv(denorm, _totalWeight);\\n  }\\n\\n  function getBalance(address token) external override view _viewlock_ returns (uint256) {\\n    require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n    return _records[token].balance;\\n  }\\n\\n  function getSwapFee() external override view _viewlock_ returns (uint256) {\\n    return _swapFee;\\n  }\\n\\n  function getController() external view _viewlock_ returns (address) {\\n    return _controller;\\n  }\\n\\n  function setSwapFee(uint256 swapFee) external override _logs_ _lock_ {\\n    require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n    require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n    require(swapFee >= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n    require(swapFee <= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n    _swapFee = swapFee;\\n  }\\n\\n  function setController(address manager) external _logs_ _lock_ {\\n    require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n    _controller = manager;\\n  }\\n\\n  function setPublicSwap(bool public_) external override _logs_ _lock_ {\\n    require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n    require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n    _publicSwap = public_;\\n  }\\n\\n  function finalize() external _logs_ _lock_ {\\n    require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n    require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n    require(_tokens.length >= MIN_ASSET_LIMIT, \\\"ERR_MIN_TOKENS\\\");\\n\\n    _finalized = true;\\n    _publicSwap = true;\\n\\n    _mintPoolShare(MIN_POOL_SUPPLY);\\n    _pushPoolShare(msg.sender, MIN_POOL_SUPPLY);\\n  }\\n\\n  function bind(\\n    address token,\\n    uint256 balance,\\n    uint256 denorm\\n  )\\n    external\\n    override\\n    _logs_ // _lock_  Bind does not lock because it jumps to `rebind`, which does\\n  {\\n    require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n    require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\n    require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n    require(_tokens.length < MAX_ASSET_LIMIT, \\\"ERR_MAX_TOKENS\\\");\\n\\n    _records[token] = Record({\\n      bound: true,\\n      index: _tokens.length,\\n      denorm: 0, // balance and denorm will be validated\\n      balance: 0 // and set by `rebind`\\n    });\\n    _tokens.push(token);\\n    rebind(token, balance, denorm);\\n  }\\n\\n  function rebind(\\n    address token,\\n    uint256 balance,\\n    uint256 denorm\\n  ) public override _logs_ _lock_ {\\n    require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n    require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n    require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n    require(denorm >= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n    require(denorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n    require(balance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n    // Adjust the denorm and totalWeight\\n    uint256 oldWeight = _records[token].denorm;\\n    if (denorm > oldWeight) {\\n      _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\\n      require(_totalWeight <= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n    } else if (denorm < oldWeight) {\\n      _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\\n    }\\n    _records[token].denorm = denorm;\\n\\n    // Adjust the balance record and actual token balance\\n    uint256 oldBalance = _records[token].balance;\\n    _records[token].balance = balance;\\n    if (balance > oldBalance) {\\n      _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\\n    } else if (balance < oldBalance) {\\n      // In this case liquidity is being withdrawn, so charge EXIT_FEE\\n      uint256 tokenBalanceWithdrawn = bsub(oldBalance, balance);\\n      uint256 tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\\n      _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\\n      _pushUnderlying(token, _factory, tokenExitFee);\\n    }\\n  }\\n\\n  function unbind(address token) external override _logs_ _lock_ {\\n    require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n    require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n    require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n    uint256 tokenBalance = _records[token].balance;\\n    uint256 tokenExitFee = bmul(tokenBalance, EXIT_FEE);\\n\\n    _totalWeight = bsub(_totalWeight, _records[token].denorm);\\n\\n    // Swap the token-to-unbind with the last token,\\n    // then delete the last token\\n    uint256 index = _records[token].index;\\n    uint256 last = _tokens.length - 1;\\n    _tokens[index] = _tokens[last];\\n    _records[_tokens[index]].index = index;\\n    _tokens.pop();\\n    _records[token] = Record({bound: false, index: 0, denorm: 0, balance: 0});\\n\\n    _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\\n    _pushUnderlying(token, _factory, tokenExitFee);\\n  }\\n\\n  // Absorb any tokens that have been sent to this contract into the pool\\n  function gulp(address token) external override _logs_ _lock_ {\\n    require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n    _records[token].balance = IERC20(token).balanceOf(address(this));\\n  }\\n\\n  function getSpotPrice(address tokenIn, address tokenOut)\\n    external\\n    view\\n    _viewlock_\\n    returns (uint256 spotPrice)\\n  {\\n    require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n    require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n    Record storage inRecord = _records[tokenIn];\\n    Record storage outRecord = _records[tokenOut];\\n    return\\n      calcSpotPrice(\\n        inRecord.balance,\\n        inRecord.denorm,\\n        outRecord.balance,\\n        outRecord.denorm,\\n        _swapFee\\n      );\\n  }\\n\\n  function getSpotPriceSansFee(address tokenIn, address tokenOut)\\n    external\\n    view\\n    _viewlock_\\n    returns (uint256 spotPrice)\\n  {\\n    require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n    require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n    Record storage inRecord = _records[tokenIn];\\n    Record storage outRecord = _records[tokenOut];\\n    return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\\n  }\\n\\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external _logs_ _lock_ {\\n    require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n    uint256 poolTotal = totalSupply();\\n    uint256 ratio = bdiv(poolAmountOut, poolTotal);\\n    require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n    for (uint256 i = 0; i < _tokens.length; i++) {\\n      address t = _tokens[i];\\n      uint256 bal = _records[t].balance;\\n      uint256 tokenAmountIn = bmul(ratio, bal);\\n      require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n      require(tokenAmountIn <= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n      _records[t].balance = badd(_records[t].balance, tokenAmountIn);\\n      emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n      _pullUnderlying(t, msg.sender, tokenAmountIn);\\n    }\\n    _mintPoolShare(poolAmountOut);\\n    _pushPoolShare(msg.sender, poolAmountOut);\\n  }\\n\\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external _logs_ _lock_ {\\n    require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n    uint256 poolTotal = totalSupply();\\n    uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\\n    uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\\n    uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\\n    require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n    _pullPoolShare(msg.sender, poolAmountIn);\\n    _pushPoolShare(_factory, exitFee);\\n    _burnPoolShare(pAiAfterExitFee);\\n\\n    for (uint256 i = 0; i < _tokens.length; i++) {\\n      address t = _tokens[i];\\n      uint256 bal = _records[t].balance;\\n      uint256 tokenAmountOut = bmul(ratio, bal);\\n      require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n      require(tokenAmountOut >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n      _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\\n      emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n      _pushUnderlying(t, msg.sender, tokenAmountOut);\\n    }\\n  }\\n\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  ) external override _logs_ _lock_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\\n    require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n    require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n    require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\n\\n    Record storage inRecord = _records[address(tokenIn)];\\n    Record storage outRecord = _records[address(tokenOut)];\\n\\n    require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n    uint256 spotPriceBefore = calcSpotPrice(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n    require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n    tokenAmountOut = calcOutGivenIn(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      tokenAmountIn,\\n      _swapFee\\n    );\\n    require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n    inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n    outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n    spotPriceAfter = calcSpotPrice(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n    require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n    require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n    require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n    emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n    return (tokenAmountOut, spotPriceAfter);\\n  }\\n\\n  function swapExactAmountOut(\\n    address tokenIn,\\n    uint256 maxAmountIn,\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPrice\\n  ) external _logs_ _lock_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\\n    require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n    require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n    require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\n\\n    Record storage inRecord = _records[address(tokenIn)];\\n    Record storage outRecord = _records[address(tokenOut)];\\n\\n    require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n    uint256 spotPriceBefore = calcSpotPrice(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n    require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n    tokenAmountIn = calcInGivenOut(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      tokenAmountOut,\\n      _swapFee\\n    );\\n    require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n    inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n    outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n    spotPriceAfter = calcSpotPrice(\\n      inRecord.balance,\\n      inRecord.denorm,\\n      outRecord.balance,\\n      outRecord.denorm,\\n      _swapFee\\n    );\\n    require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n    require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n    require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n    emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n    _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n    return (tokenAmountIn, spotPriceAfter);\\n  }\\n\\n  // ==\\n  // 'Underlying' token-manipulation functions make external calls but are NOT locked\\n  // You must `_lock_` or otherwise ensure reentry-safety\\n\\n  function _pullUnderlying(\\n    address erc20,\\n    address from,\\n    uint256 amount\\n  ) internal {\\n    bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\\n    require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n  }\\n\\n  function _pushUnderlying(\\n    address erc20,\\n    address to,\\n    uint256 amount\\n  ) internal {\\n    bool xfer = IERC20(erc20).transfer(to, amount);\\n    require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n  }\\n\\n  function _pullPoolShare(address from, uint256 amount) internal {\\n    _transfer(from, address(this), amount);\\n  }\\n\\n  function _pushPoolShare(address to, uint256 amount) internal {\\n    _transfer(address(this), to, amount);\\n  }\\n\\n  function _mintPoolShare(uint256 amount) internal {\\n    _mint(address(this), amount);\\n  }\\n\\n  function _burnPoolShare(uint256 amount) internal {\\n    _burn(address(this), amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockBFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.6;\\n\\nimport {IBPool} from \\\"../balancer/IBPool.sol\\\";\\nimport {BPool} from \\\"./BPool.sol\\\";\\n\\ncontract MockBFactory {\\n  function newBPool() external returns (IBPool) {\\n    return new BPool(msg.sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockBorrower.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../IBorrower.sol\\\";\\nimport \\\"../ILender.sol\\\";\\n\\ncontract MockBorrower is IBorrower {\\n  address lender;\\n  bool reentrance;\\n\\n  constructor(address _lender) public {\\n    lender = _lender;\\n  }\\n\\n  event Data(uint256 amount, bytes32 data);\\n\\n  function executeOnFlashMint(uint256 amount, bytes32 data) external override {\\n    emit Data(amount, data);\\n    if (reentrance) {\\n      ILender(lender).flashMint(amount, data);\\n    }\\n  }\\n\\n  function flashMint(\\n    uint256 amount,\\n    bytes32 data,\\n    bool _reentrance\\n  ) external {\\n    reentrance = _reentrance;\\n    ILender(lender).flashMint(amount, data);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract MockERC20 is ERC20UpgradeSafe {\\n  constructor(\\n    string memory name,\\n    string memory symbol,\\n    uint8 decimals,\\n    uint256 supply\\n  ) public {\\n    _mint(msg.sender, supply);\\n    __ERC20_init(name, symbol);\\n    _setupDecimals(decimals);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockFlashERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport {FlashERC20} from \\\"../FlashERC20.sol\\\";\\n\\ncontract MockFlashERC20 is FlashERC20 {\\n  bytes32 public DOMAIN_SEPARATOR;\\n\\n  // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n  bytes32\\n    public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n  mapping(address => uint256) public nonces;\\n\\n  constructor(\\n    string memory name,\\n    string memory symbol,\\n    uint256 supply\\n  ) public {\\n    _mint(msg.sender, supply);\\n    __Flash_init(name, symbol);\\n    uint256 chainId;\\n    assembly {\\n      chainId := chainid()\\n    }\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(\\n        keccak256(\\n          \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        ),\\n        keccak256(bytes(\\\"Strudel BTC\\\")),\\n        keccak256(bytes(\\\"1\\\")),\\n        chainId,\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  function deposit() public payable {\\n    _mint(msg.sender, msg.value);\\n  }\\n\\n  event Data(bytes);\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external {\\n    require(deadline >= block.timestamp, \\\"vBTC: EXPIRED\\\");\\n    bytes memory msg = abi.encode(\\n      PERMIT_TYPEHASH,\\n      owner,\\n      spender,\\n      value,\\n      nonces[owner]++,\\n      deadline\\n    );\\n    emit Data(msg);\\n    bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR, keccak256(msg)));\\n    address recoveredAddress = ecrecover(digest, v, r, s);\\n    require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"VBTC: INVALID_SIGNATURE\\\");\\n    _approve(owner, spender, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockRelay.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport {TypedMemView} from \\\"../summa-tx/TypedMemView.sol\\\";\\nimport {ViewBTC} from \\\"../summa-tx/ViewBTC.sol\\\";\\nimport {ViewSPV} from \\\"../summa-tx/ViewSPV.sol\\\";\\nimport {IRelay} from \\\"../summa-tx/IRelay.sol\\\";\\n\\n/** @title MockRelay */\\n/** half-hearted implementation for testing */\\n\\ncontract MockRelay is IRelay {\\n  using TypedMemView for bytes;\\n  using TypedMemView for bytes29;\\n  using ViewBTC for bytes29;\\n  using ViewSPV for bytes29;\\n\\n  bytes32 bestKnownDigest;\\n  bytes32 lastReorgCommonAncestor;\\n  uint256 public currentEpochDiff;\\n  mapping(bytes32 => uint256) public heights;\\n\\n  constructor(\\n    bytes32 _bestKnownDigest,\\n    uint256 _bestKnownHeight,\\n    bytes32 _lastReorgCommonAncestor,\\n    uint256 _lastReorgHeight\\n  ) public {\\n    bestKnownDigest = _bestKnownDigest;\\n    heights[_bestKnownDigest] = _bestKnownHeight;\\n    lastReorgCommonAncestor = _lastReorgCommonAncestor;\\n    heights[_lastReorgCommonAncestor] = _lastReorgHeight;\\n  }\\n\\n  function addHeader(bytes32 _digest, uint256 _height) external {\\n    heights[_digest] = _height;\\n  }\\n\\n  /// @notice     Getter for bestKnownDigest\\n  /// @dev        This updated only by calling markNewHeaviest\\n  /// @return     The hash of the best marked chain tip\\n  function getBestKnownDigest() public override view returns (bytes32) {\\n    return bestKnownDigest;\\n  }\\n\\n  /// @notice     Getter for relayGenesis\\n  /// @dev        This is updated only by calling markNewHeaviest\\n  /// @return     The hash of the shared ancestor of the most recent fork\\n  function getLastReorgCommonAncestor() public override view returns (bytes32) {\\n    return lastReorgCommonAncestor;\\n  }\\n\\n  /// @notice     Getter for bestKnownDigest\\n  /// @dev        This updated only by calling markNewHeaviest\\n\\n  function setBestKnownDigest(bytes32 _bestKnownDigest) external {\\n    require(heights[_bestKnownDigest] > 0, \\\"not found\\\");\\n    bestKnownDigest = _bestKnownDigest;\\n  }\\n\\n  /// @notice     Getter for relayGenesis\\n  /// @dev        This is updated only by calling markNewHeaviest\\n\\n  function setLastReorgCommonAncestor(bytes32 _lrca) external {\\n    require(heights[_lrca] > 0, \\\"not found\\\");\\n    require(heights[_lrca] <= heights[bestKnownDigest], \\\"ahead of tip\\\");\\n    lastReorgCommonAncestor = _lrca;\\n  }\\n\\n  /// @notice         Finds the height of a header by its digest\\n  /// @dev            Will fail if the header is unknown\\n  /// @param _digest  The header digest to search for\\n  /// @return         The height of the header, or error if unknown\\n  function findHeight(bytes32 _digest) external override view returns (uint256) {\\n    return heights[_digest];\\n  }\\n\\n  /// @notice             Checks if a digest is an ancestor of the current one\\n  /// @dev                Limit the amount of lookups (and thus gas usage) with _limit\\n  /// @return             true if ancestor is at most limit blocks lower than descendant, otherwise false\\n  function isAncestor(\\n    bytes32,\\n    bytes32,\\n    uint256\\n  ) external override view returns (bool) {\\n    return true;\\n  }\\n\\n  function addHeaders(bytes calldata _anchor, bytes calldata _headers)\\n    external\\n    override\\n    returns (bool)\\n  {\\n    require(_headers.length % 80 == 0, \\\"Header array length must be divisible by 80\\\");\\n    bytes29 _headersView = _headers.ref(0).tryAsHeaderArray();\\n    bytes29 _anchorView = _anchor.ref(0).tryAsHeader();\\n\\n    require(_headersView.notNull(), \\\"Header array length must be divisible by 80\\\");\\n    require(_anchorView.notNull(), \\\"Anchor must be 80 bytes\\\");\\n    return _addHeaders(_anchorView, _headersView);\\n  }\\n\\n  /// @notice             Adds headers to storage after validating\\n  /// @dev                We check integrity and consistency of the header chain\\n  /// @param  _anchor     The header immediately preceeding the new chain\\n  /// @param  _headers    A tightly-packed list of new 80-byte Bitcoin headers to record\\n  /// @return             True if successfully written, error otherwise\\n  function _addHeaders(bytes29 _anchor, bytes29 _headers) internal returns (bool) {\\n    uint256 _height;\\n    bytes32 _currentDigest;\\n    bytes32 _previousDigest = _anchor.hash256();\\n\\n    uint256 _anchorHeight = heights[_previousDigest]; /* NB: errors if unknown */\\n    require(_anchorHeight > 0, \\\"anchor height can not be 0\\\");\\n\\n    /*\\n    NB:\\n    1. check that the header has sufficient work\\n    2. check that headers are in a coherent chain (no retargets, hash links good)\\n    3. Store the block connection\\n    4. Store the height\\n    */\\n    for (uint256 i = 0; i < _headers.len() / 80; i += 1) {\\n      bytes29 _header = _headers.indexHeaderArray(i);\\n      _height = _anchorHeight + (i + 1);\\n      _currentDigest = _header.hash256();\\n      heights[_currentDigest] = _height;\\n      require(_header.checkParent(_previousDigest), \\\"Headers do not form a consistent chain\\\");\\n      _previousDigest = _currentDigest;\\n    }\\n\\n    emit Extension(_anchor.hash256(), _currentDigest);\\n    return true;\\n  }\\n\\n  function addHeadersWithRetarget(\\n    bytes calldata,\\n    bytes calldata _oldPeriodEndHeader,\\n    bytes calldata _headers\\n  ) external override returns (bool) {\\n    bytes29 _headersView = _headers.ref(0).tryAsHeaderArray();\\n    bytes29 _anchorView = _oldPeriodEndHeader.ref(0).tryAsHeader();\\n\\n    require(_headersView.notNull(), \\\"Header array length must be divisible by 80\\\");\\n    require(_anchorView.notNull(), \\\"Anchor must be 80 bytes\\\");\\n    return _addHeaders(_anchorView, _headersView);\\n  }\\n\\n  function markNewHeaviest(\\n    bytes32 _ancestor,\\n    bytes calldata _currentBest,\\n    bytes calldata _newBest,\\n    uint256 _limit\\n  ) external override returns (bool) {\\n    bytes29 _new = _newBest.ref(0).tryAsHeader();\\n    bytes29 _current = _currentBest.ref(0).tryAsHeader();\\n    require(_new.notNull() && _current.notNull(), \\\"Bad args. Check header and array byte lengths.\\\");\\n    return _markNewHeaviest(_ancestor, _current, _new, _limit);\\n  }\\n\\n  /// @notice                   Marks the new best-known chain tip\\n  /// @param  _ancestor         The digest of the most recent common ancestor\\n  /// @param  _current          The 80-byte header referenced by bestKnownDigest\\n  /// @param  _new              The 80-byte header to mark as the new best\\n  /// @param  _limit            Limit the amount of traversal of the chain\\n  /// @return                   True if successfully updates bestKnownDigest, error otherwise\\n  function _markNewHeaviest(\\n    bytes32 _ancestor,\\n    bytes29 _current, // Header\\n    bytes29 _new, // Header\\n    uint256 _limit\\n  ) internal returns (bool) {\\n    require(_limit <= 2016, \\\"Requested limit is greater than 1 difficulty period\\\");\\n    bytes32 _newBestDigest = _new.hash256();\\n    bytes32 _currentBestDigest = _current.hash256();\\n    require(_currentBestDigest == bestKnownDigest, \\\"Passed in best is not best known\\\");\\n    require(heights[_newBestDigest] > 0, \\\"New best is unknown\\\");\\n\\n    bestKnownDigest = _newBestDigest;\\n    lastReorgCommonAncestor = _ancestor;\\n\\n    uint256 _newDiff = _new.diff();\\n    if (_newDiff != currentEpochDiff) {\\n      currentEpochDiff = _newDiff;\\n    }\\n\\n    emit NewTip(_currentBestDigest, _newBestDigest, _ancestor);\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/summa-tx/TypedMemView.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\nlibrary TypedMemView {\\n  using SafeMath for uint256;\\n\\n  // Why does this exist?\\n  // the solidity `bytes memory` type has a few weaknesses.\\n  // 1. You can't index ranges effectively\\n  // 2. You can't slice without copying\\n  // 3. The underlying data may represent any type\\n  // 4. Solidity never deallocates memory, and memory costs grow\\n  //    superlinearly\\n\\n  // By using a memory view instead of a `bytes memory` we get the following\\n  // advantages:\\n  // 1. Slices are done on the stack, by manipulating the pointer\\n  // 2. We can index arbitrary ranges and quickly convert them to stack types\\n  // 3. We can insert type info into the pointer, and typecheck at runtime\\n\\n  // This makes `TypedMemView` a useful tool for efficient zero-copy\\n  // algorithms.\\n\\n  // Why bytes29?\\n  // We want to avoid confusion between views, digests, and other common\\n  // types so we chose a large and uncommonly used odd number of bytes\\n  //\\n  // Note that while bytes are left-aligned in a word, integers and addresses\\n  // are right-aligned. This means when working in assembly we have to\\n  // account for the 3 unused bytes on the righthand side\\n  //\\n  // First 5 bytes are a type flag.\\n  // - ff_ffff_fffe is reserved for unknown type.\\n  // - ff_ffff_ffff is reserved for invalid types/errors.\\n  // next 12 are memory address\\n  // next 12 are len\\n  // bottom 3 bytes are empty\\n\\n  // Assumptions:\\n  // - non-modification of memory.\\n  // - No Solidity updates\\n  // - - wrt free mem point\\n  // - - wrt bytes representation in memory\\n  // - - wrt memory addressing in general\\n\\n  // Usage:\\n  // - create type constants\\n  // - use `assertType` for runtime type assertions\\n  // - - unfortunately we can't do this at compile time yet :(\\n  // - recommended: implement modifiers that perform type checking\\n  // - - e.g.\\n  // - - `uint40 constant MY_TYPE = 3;`\\n  // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\\n  // - instantiate a typed view from a bytearray using `ref`\\n  // - use `index` to inspect the contents of the view\\n  // - use `slice` to create smaller views into the same memory\\n  // - - `slice` can increase the offset\\n  // - - `slice can decrease the length`\\n  // - - must specify the output type of `slice`\\n  // - - `slice` will return a null view if you try to overrun\\n  // - - make sure to explicitly check for this with `notNull` or `assertType`\\n  // - use `equal` for typed comparisons.\\n\\n  // The null view\\n  bytes29 public constant NULL = hex\\\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\";\\n  uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\\n  uint8 constant TWELVE_BYTES = 96;\\n\\n  // Returns the encoded hex charcter that represents the lower 4 bits of the argument.\\n  function nibbleHex(uint8 _b) internal pure returns (uint8) {\\n    // This can probably be done more efficiently, but it's only in error\\n    // paths, so we don't really care :)\\n    uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\\n    if (_nibble == 0xf0) {\\n      return 0x30;\\n    } // 0\\n    if (_nibble == 0xf1) {\\n      return 0x31;\\n    } // 1\\n    if (_nibble == 0xf2) {\\n      return 0x32;\\n    } // 2\\n    if (_nibble == 0xf3) {\\n      return 0x33;\\n    } // 3\\n    if (_nibble == 0xf4) {\\n      return 0x34;\\n    } // 4\\n    if (_nibble == 0xf5) {\\n      return 0x35;\\n    } // 5\\n    if (_nibble == 0xf6) {\\n      return 0x36;\\n    } // 6\\n    if (_nibble == 0xf7) {\\n      return 0x37;\\n    } // 7\\n    if (_nibble == 0xf8) {\\n      return 0x38;\\n    } // 8\\n    if (_nibble == 0xf9) {\\n      return 0x39;\\n    } // 9\\n    if (_nibble == 0xfa) {\\n      return 0x61;\\n    } // a\\n    if (_nibble == 0xfb) {\\n      return 0x62;\\n    } // b\\n    if (_nibble == 0xfc) {\\n      return 0x63;\\n    } // c\\n    if (_nibble == 0xfd) {\\n      return 0x64;\\n    } // d\\n    if (_nibble == 0xfe) {\\n      return 0x65;\\n    } // e\\n    if (_nibble == 0xff) {\\n      return 0x66;\\n    } // f\\n  }\\n\\n  // Returns a uint16 containing the hex-encoded byte\\n  function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\\n    encoded |= nibbleHex(_b >> 4); // top 4 bits\\n    encoded <<= 8;\\n    encoded |= nibbleHex(_b); // lower 4 bits\\n  }\\n\\n  // Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\\n  // `second` contains the encoded lower 16 bytes.\\n  function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\\n    for (uint8 i = 31; i > 15; i -= 1) {\\n      uint8 _byte = uint8(_b >> (i * 8));\\n      first |= byteHex(_byte);\\n      if (i != 16) {\\n        first <<= 16;\\n      }\\n    }\\n\\n    // abusing underflow here =_=\\n    for (uint8 i = 15; i < 255; i -= 1) {\\n      uint8 _byte = uint8(_b >> (i * 8));\\n      second |= byteHex(_byte);\\n      if (i != 0) {\\n        second <<= 16;\\n      }\\n    }\\n  }\\n\\n  /// @notice          Changes the endianness of a uint256\\n  /// @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\n  /// @param _b        The unsigned integer to reverse\\n  /// @return v        The reversed value\\n  function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\\n    v = _b;\\n\\n    // swap bytes\\n    v =\\n      ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\\n      ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n    // swap 2-byte long pairs\\n    v =\\n      ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\\n      ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n    // swap 4-byte long pairs\\n    v =\\n      ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\\n      ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n    // swap 8-byte long pairs\\n    v =\\n      ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\\n      ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n    // swap 16-byte long pairs\\n    v = (v >> 128) | (v << 128);\\n  }\\n\\n  /// Create a mask with the highest `_len` bits set\\n  function leftMask(uint8 _len) private pure returns (uint256 mask) {\\n    // ugly. redo without assembly?\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      mask := sar(sub(_len, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\\n    }\\n  }\\n\\n  /// Return the null view\\n  function nullView() internal pure returns (bytes29) {\\n    return NULL;\\n  }\\n\\n  /// Check if the view is null\\n  function isNull(bytes29 memView) internal pure returns (bool) {\\n    return memView == NULL;\\n  }\\n\\n  /// Check if the view is not null\\n  function notNull(bytes29 memView) internal pure returns (bool) {\\n    return !isNull(memView);\\n  }\\n\\n  /// Check if the view is of a valid type and points to a valid location in\\n  /// memory. We perform this check by examining solidity's unallocated\\n  /// memory pointer and ensuring that the view's upper bound is less than\\n  /// that.\\n  function isValid(bytes29 memView) internal pure returns (bool ret) {\\n    if (typeOf(memView) == 0xffffffffff) {\\n      return false;\\n    }\\n    uint256 _end = end(memView);\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      ret := not(gt(_end, mload(0x40)))\\n    }\\n  }\\n\\n  /// Require that a typed memory view be valid.\\n  /// Returns the view for easy chaining\\n  function assertValid(bytes29 memView) internal pure returns (bytes29) {\\n    require(isValid(memView), \\\"Validity assertion failed\\\");\\n    return memView;\\n  }\\n\\n  /// Return true if the memview is of the expected type. Otherwise false.\\n  function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\\n    return typeOf(memView) == _expected;\\n  }\\n\\n  /// Require that a typed memory view has a specific type.\\n  /// Returns the view for easy chaining\\n  function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\\n    if (!isType(memView, _expected)) {\\n      (, uint256 g) = encodeHex(uint256(typeOf(memView)));\\n      (, uint256 e) = encodeHex(uint256(_expected));\\n      string memory err = string(\\n        abi.encodePacked(\\\"Type assertion failed. Got 0x\\\", uint80(g), \\\". Expected 0x\\\", uint80(e))\\n      );\\n      revert(err);\\n    }\\n    return memView;\\n  }\\n\\n  /// Return an identical view with a different type\\n  function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\\n    // then | in the new type\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      // shift off the top 5 bytes\\n      newView := or(newView, shr(40, shl(40, memView)))\\n      newView := or(newView, shl(216, _newType))\\n    }\\n  }\\n\\n  /// Unsafe raw pointer construction. This should generally not be called\\n  /// directly. Prefer `ref` wherever possible.\\n  function buildUnchecked(\\n    uint256 _type,\\n    uint256 _loc,\\n    uint256 _len\\n  ) private pure returns (bytes29 newView) {\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      newView := shl(96, or(newView, _type)) // insert type\\n      newView := shl(96, or(newView, _loc)) // insert loc\\n      newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\\n    }\\n  }\\n\\n  /// Instantiate a new memory view. This should generally not be called\\n  /// directly. Prefer `ref` wherever possible.\\n  function build(\\n    uint256 _type,\\n    uint256 _loc,\\n    uint256 _len\\n  ) internal pure returns (bytes29 newView) {\\n    uint256 _end = _loc.add(_len);\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      if gt(_end, mload(0x40)) {\\n        _end := 0\\n      }\\n    }\\n    if (_end == 0) {\\n      return NULL;\\n    }\\n    newView = buildUnchecked(_type, _loc, _len);\\n  }\\n\\n  /// Instantiate a memory view from a byte array.\\n  ///\\n  /// Note that due to Solidity memory representation, it is not possible to\\n  /// implement a deref, as the `bytes` type stores its len in memory.\\n  function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\\n    uint256 _len = arr.length;\\n\\n    uint256 _loc;\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      _loc := add(arr, 0x20) // our view is of the data, not the struct\\n    }\\n\\n    return build(newType, _loc, _len);\\n  }\\n\\n  /// Return the associated type information\\n  function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      // 216 == 256 - 40\\n      _type := shr(216, memView) // shift out lower 24 bytes\\n    }\\n  }\\n\\n  /// Optimized type comparison. Checks that the 5-byte type flag is equal.\\n  function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\\n  }\\n\\n  /// Return the memory address of the underlying bytes\\n  function loc(bytes29 memView) internal pure returns (uint96 _loc) {\\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\\n      _loc := and(shr(120, memView), _mask)\\n    }\\n  }\\n\\n  /// The number of memory words this memory view occupies, rounded up\\n  function words(bytes29 memView) internal pure returns (uint256) {\\n    return uint256(len(memView)).add(32) / 32;\\n  }\\n\\n  /// The in-memory footprint of a fresh copy of the view\\n  function footprint(bytes29 memView) internal pure returns (uint256) {\\n    return words(memView) * 32;\\n  }\\n\\n  /// The number of bytes of the view\\n  function len(bytes29 memView) internal pure returns (uint96 _len) {\\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      _len := and(shr(24, memView), _mask)\\n    }\\n  }\\n\\n  /// Returns the endpoint of the `memView`\\n  function end(bytes29 memView) internal pure returns (uint256) {\\n    return loc(memView) + len(memView);\\n  }\\n\\n  /// Safe slicing without memory modification.\\n  function slice(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint256 _len,\\n    uint40 newType\\n  ) internal pure returns (bytes29) {\\n    uint256 _loc = loc(memView);\\n\\n    // Ensure it doesn't overrun the view\\n    if (_loc.add(_index).add(_len) > end(memView)) {\\n      return NULL;\\n    }\\n\\n    _loc = _loc.add(_index);\\n    return build(newType, _loc, _len);\\n  }\\n\\n  /// Shortcut to `slice`. Gets a view representing the first `_len` bytes\\n  function prefix(\\n    bytes29 memView,\\n    uint256 _len,\\n    uint40 newType\\n  ) internal pure returns (bytes29) {\\n    return slice(memView, 0, _len, newType);\\n  }\\n\\n  /// Shortcut to `slice`. Gets a view representing the last `_len` byte\\n  function postfix(\\n    bytes29 memView,\\n    uint256 _len,\\n    uint40 newType\\n  ) internal pure returns (bytes29) {\\n    return slice(memView, uint256(len(memView)).sub(_len), _len, newType);\\n  }\\n\\n  /// Construct an error message for an indexing overrun.\\n  function indexErrOverrun(\\n    uint256 _loc,\\n    uint256 _len,\\n    uint256 _index,\\n    uint256 _slice\\n  ) internal pure returns (string memory err) {\\n    (, uint256 a) = encodeHex(_loc);\\n    (, uint256 b) = encodeHex(_len);\\n    (, uint256 c) = encodeHex(_index);\\n    (, uint256 d) = encodeHex(_slice);\\n    err = string(\\n      abi.encodePacked(\\n        \\\"TypedMemView/index - Overran the view. Slice is at 0x\\\",\\n        uint48(a),\\n        \\\" with length 0x\\\",\\n        uint48(b),\\n        \\\". Attempted to index at offset 0x\\\",\\n        uint48(c),\\n        \\\" with length 0x\\\",\\n        uint48(d),\\n        \\\".\\\"\\n      )\\n    );\\n  }\\n\\n  /// Load up to 32 bytes from the view onto the stack.\\n  ///\\n  /// Returns a bytes32 with only the `_bytes` highest bytes set.\\n  /// This can be immediately cast to a smaller fixed-length byte array.\\n  /// To automatically cast to an integer, use `indexUint` or `indexInt`.\\n  function index(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint8 _bytes\\n  ) internal pure returns (bytes32 result) {\\n    if (_bytes == 0) {\\n      return bytes32(0);\\n    }\\n    if (_index.add(_bytes) > len(memView)) {\\n      revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\\n    }\\n    require(_bytes <= 32, \\\"TypedMemView/index - Attempted to index more than 32 bytes\\\");\\n\\n    uint8 bitLength = _bytes * 8;\\n    uint256 _loc = loc(memView);\\n    uint256 _mask = leftMask(bitLength);\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      result := and(mload(add(_loc, _index)), _mask)\\n    }\\n  }\\n\\n  /// Parse an unsigned integer from the view at `_index`. Requires that the\\n  /// view have >= `_bytes` bytes following that index.\\n  function indexUint(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint8 _bytes\\n  ) internal pure returns (uint256 result) {\\n    return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\\n  }\\n\\n  /// Parse an unsigned integer from LE bytes.\\n  function indexLEUint(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint8 _bytes\\n  ) internal pure returns (uint256 result) {\\n    return reverseUint256(uint256(index(memView, _index, _bytes)));\\n  }\\n\\n  /// Parse a signed integer from the view at `_index`. Requires that the\\n  /// view have >= `_bytes` bytes following that index.\\n  function indexInt(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint8 _bytes\\n  ) internal pure returns (int256 result) {\\n    return int256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\\n  }\\n\\n  /// Parse an address from the view at `_index`. Requires that the view have >= 20 bytes following that index.\\n  function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\\n    return address(uint160(indexInt(memView, _index, 20)));\\n  }\\n\\n  /// Return the keccak256 hash of the underlying memory\\n  function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\\n    uint256 _loc = loc(memView);\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      digest := keccak256(_loc, _len)\\n    }\\n  }\\n\\n  /// Return the sha2 digest of the underlying memory. We explicitly deallocate memory afterwards\\n  function sha2(bytes29 memView) internal view returns (bytes32 digest) {\\n    uint256 _loc = loc(memView);\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      let ptr := mload(0x40)\\n      pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n      digest := mload(ptr)\\n    }\\n  }\\n\\n  /// @notice          Implements bitcoin's hash160 (rmd160(sha2()))\\n  /// @param memView   The pre-image\\n  /// @return digest   The digest\\n  function hash160(bytes29 memView) internal view returns (bytes20 digest) {\\n    uint256 _loc = loc(memView);\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      let ptr := mload(0x40)\\n      pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\\n      pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\\n      digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\\n    }\\n  }\\n\\n  /// @notice          Implements bitcoin's hash256 (double sha2)\\n  /// @param memView   A view of the preimage\\n  /// @return digest   The digest\\n  function hash256(bytes29 memView) internal view returns (bytes32 digest) {\\n    uint256 _loc = loc(memView);\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      let ptr := mload(0x40)\\n      pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n      pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n      digest := mload(ptr)\\n    }\\n  }\\n\\n  /// Return true if the underlying memory is equal. Else false.\\n  function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\\n  }\\n\\n  /// Return false if the underlying memory is equal. Else true.\\n  function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return !untypedEqual(left, right);\\n  }\\n\\n  /// Typed equality. Shortcuts if the pointers are identical, otherwise\\n  /// compares type and digest\\n  function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\\n  }\\n\\n  /// Typed inequality. Shortcuts if the pointers are identical, otherwise\\n  /// compares type and digest\\n  function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return !equal(left, right);\\n  }\\n\\n  /// Copy the view to a location, return an unsafe memory reference\\n  ///\\n  /// Super Dangerous direct memory access.\\n  /// This reference can be overwritten if anything else modifies memory (!!!).\\n  /// As such it MUST be consumed IMMEDIATELY.\\n  /// This function is private to prevent unsafe usage by callers\\n  function copyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\\n    require(notNull(memView), \\\"TypedMemView/copyTo - Null pointer deref\\\");\\n    require(isValid(memView), \\\"TypedMemView/copyTo - Invalid pointer deref\\\");\\n    uint256 _len = len(memView);\\n    uint256 _oldLoc = loc(memView);\\n\\n    uint256 ptr;\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      ptr := mload(0x40)\\n      // revert if we're writing in occupied memory\\n      if gt(ptr, _newLoc) {\\n        revert(0x60, 0x20) // empty revert message\\n      }\\n\\n      // use the identity precompile to copy\\n      // guaranteed not to fail, so pop the success\\n      pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\\n    }\\n\\n    written = buildUnchecked(typeOf(memView), _newLoc, _len);\\n  }\\n\\n  /// Copies the referenced memory to a new loc in memory, returning a\\n  /// `bytes` pointing to the new memory\\n  function clone(bytes29 memView) internal view returns (bytes memory ret) {\\n    uint256 ptr;\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      ptr := mload(0x40) // load unused memory pointer\\n      ret := ptr\\n    }\\n    copyTo(memView, ptr + 0x20);\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\\n      mstore(ptr, _len) // write len of new array (in bytes)\\n    }\\n  }\\n\\n  /// Join the views in memory, return an unsafe reference to the memory.\\n  ///\\n  /// Super Dangerous direct memory access.\\n  /// This reference can be overwritten if anything else modifies memory (!!!).\\n  /// As such it MUST be consumed IMMEDIATELY.\\n  /// This function is private to prevent unsafe usage by callers\\n  function unsafeJoin(bytes29[] memory memViews, uint256 _location)\\n    private\\n    view\\n    returns (bytes29 unsafeView)\\n  {\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      let ptr := mload(0x40)\\n      // revert if we're writing in occupied memory\\n      if gt(ptr, _location) {\\n        revert(0x60, 0x20) // empty revert message\\n      }\\n    }\\n\\n    uint256 _offset = 0;\\n    for (uint256 i = 0; i < memViews.length; i++) {\\n      bytes29 memView = memViews[i];\\n      copyTo(memView, _location + _offset);\\n      _offset += len(memView);\\n    }\\n    unsafeView = buildUnchecked(0, _location, _offset);\\n  }\\n\\n  /// Produce the keccak256 digest of the concatenated contents of multiple views\\n  function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\\n    uint256 ptr;\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      ptr := mload(0x40) // load unused memory pointer\\n    }\\n    return keccak(unsafeJoin(memViews, ptr));\\n  }\\n\\n  /// Produce the sha256 digest of the concatenated contents of multiple views\\n  function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\\n    uint256 ptr;\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      ptr := mload(0x40) // load unused memory pointer\\n    }\\n    return sha2(unsafeJoin(memViews, ptr));\\n  }\\n\\n  /// copies all views, joins them into a new bytearray\\n  function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\\n    uint256 ptr;\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      ptr := mload(0x40) // load unused memory pointer\\n    }\\n\\n    bytes29 _newView = unsafeJoin(memViews, ptr + 0x20);\\n    uint256 _written = len(_newView);\\n    uint256 _footprint = footprint(_newView);\\n\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      // store the legnth\\n      mstore(ptr, _written)\\n      // new pointer is old + 0x20 + the footprint of the body\\n      mstore(0x40, add(add(ptr, _footprint), 0x20))\\n      ret := ptr\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/summa-tx/ViewBTC.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n/** @title BitcoinSPV */\\n/** @author Summa (https://summa.one) */\\n\\nimport {TypedMemView} from \\\"./TypedMemView.sol\\\";\\nimport {SafeMath} from \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\nlibrary ViewBTC {\\n  using TypedMemView for bytes29;\\n  using SafeMath for uint256;\\n\\n  // The target at minimum Difficulty. Also the target of the genesis block\\n  uint256 public constant DIFF1_TARGET = 0xffff0000000000000000000000000000000000000000000000000000;\\n\\n  uint256 public constant RETARGET_PERIOD = 2 * 7 * 24 * 60 * 60; // 2 weeks in seconds\\n  uint256 public constant RETARGET_PERIOD_BLOCKS = 2016; // 2 weeks in blocks\\n\\n  enum BTCTypes {\\n    Unknown, // 0x0\\n    CompactInt, // 0x1\\n    ScriptSig, // 0x2 - with length prefix\\n    Outpoint, // 0x3\\n    TxIn, // 0x4\\n    IntermediateTxIns, // 0x5 - used in vin parsing\\n    Vin, // 0x6\\n    ScriptPubkey, // 0x7 - with length prefix\\n    PKH, // 0x8 - the 20-byte payload digest\\n    WPKH, // 0x9 - the 20-byte payload digest\\n    WSH, // 0xa - the 32-byte payload digest\\n    SH, // 0xb - the 20-byte payload digest\\n    OpReturnPayload, // 0xc\\n    TxOut, // 0xd\\n    IntermediateTxOuts, // 0xe - used in vout parsing\\n    Vout, // 0xf\\n    Header, // 0x10\\n    HeaderArray, // 0x11\\n    MerkleNode, // 0x12\\n    MerkleStep, // 0x13\\n    MerkleArray // 0x14\\n  }\\n\\n  // TODO: any way to bubble up more info?\\n  /// @notice             requires `memView` to be of a specified type\\n  /// @param memView      a 29-byte view with a 5-byte type\\n  /// @param t            the expected type (e.g. BTCTypes.Outpoint, BTCTypes.TxIn, etc)\\n  /// @return             passes if it is the correct type, errors if not\\n  modifier typeAssert(bytes29 memView, BTCTypes t) {\\n    memView.assertType(uint40(t));\\n    _;\\n  }\\n\\n  /// Revert with an error message re: non-minimal VarInts\\n  function revertNonMinimal(bytes29 ref) private pure returns (string memory) {\\n    (, uint256 g) = TypedMemView.encodeHex(ref.indexUint(0, uint8(ref.len())));\\n    string memory err = string(abi.encodePacked(\\\"Non-minimal var int. Got 0x\\\", uint144(g)));\\n    revert(err);\\n  }\\n\\n  /// @notice             reads a compact int from the view at the specified index\\n  /// @param memView      a 29-byte view with a 5-byte type\\n  /// @param _index       the index\\n  /// @return number      the compact int at the specified index\\n  function indexCompactInt(bytes29 memView, uint256 _index) internal pure returns (uint64 number) {\\n    uint256 flag = memView.indexUint(_index, 1);\\n    if (flag <= 0xfc) {\\n      return uint64(flag);\\n    } else if (flag == 0xfd) {\\n      number = uint64(memView.indexLEUint(_index + 1, 2));\\n      if (compactIntLength(number) != 3) {\\n        revertNonMinimal(memView.slice(_index, 3, 0));\\n      }\\n    } else if (flag == 0xfe) {\\n      number = uint64(memView.indexLEUint(_index + 1, 4));\\n      if (compactIntLength(number) != 5) {\\n        revertNonMinimal(memView.slice(_index, 5, 0));\\n      }\\n    } else if (flag == 0xff) {\\n      number = uint64(memView.indexLEUint(_index + 1, 8));\\n      if (compactIntLength(number) != 9) {\\n        revertNonMinimal(memView.slice(_index, 9, 0));\\n      }\\n    }\\n  }\\n\\n  /// @notice         gives the total length (in bytes) of a CompactInt-encoded number\\n  /// @param number   the number as uint64\\n  /// @return         the compact integer as uint8\\n  function compactIntLength(uint64 number) internal pure returns (uint8) {\\n    if (number <= 0xfc) {\\n      return 1;\\n    } else if (number <= 0xffff) {\\n      return 3;\\n    } else if (number <= 0xffffffff) {\\n      return 5;\\n    } else {\\n      return 9;\\n    }\\n  }\\n\\n  /// @notice             extracts the LE txid from an outpoint\\n  /// @param _outpoint    the outpoint\\n  /// @return             the LE txid\\n  function txidLE(bytes29 _outpoint)\\n    internal\\n    pure\\n    typeAssert(_outpoint, BTCTypes.Outpoint)\\n    returns (bytes32)\\n  {\\n    return _outpoint.index(0, 32);\\n  }\\n\\n  /// @notice             extracts the index as an integer from the outpoint\\n  /// @param _outpoint    the outpoint\\n  /// @return             the index\\n  function outpointIdx(bytes29 _outpoint)\\n    internal\\n    pure\\n    typeAssert(_outpoint, BTCTypes.Outpoint)\\n    returns (uint32)\\n  {\\n    return uint32(_outpoint.indexLEUint(32, 4));\\n  }\\n\\n  /// @notice          extracts the outpoint from an input\\n  /// @param _input    the input\\n  /// @return          the outpoint as a typed memory\\n  function outpoint(bytes29 _input)\\n    internal\\n    pure\\n    typeAssert(_input, BTCTypes.TxIn)\\n    returns (bytes29)\\n  {\\n    return _input.slice(0, 36, uint40(BTCTypes.Outpoint));\\n  }\\n\\n  /// @notice           extracts the script sig from an input\\n  /// @param _input     the input\\n  /// @return           the script sig as a typed memory\\n  function scriptSig(bytes29 _input)\\n    internal\\n    pure\\n    typeAssert(_input, BTCTypes.TxIn)\\n    returns (bytes29)\\n  {\\n    uint64 scriptLength = indexCompactInt(_input, 36);\\n    return\\n      _input.slice(36, compactIntLength(scriptLength) + scriptLength, uint40(BTCTypes.ScriptSig));\\n  }\\n\\n  /// @notice         extracts the sequence from an input\\n  /// @param _input   the input\\n  /// @return         the sequence\\n  function sequence(bytes29 _input)\\n    internal\\n    pure\\n    typeAssert(_input, BTCTypes.TxIn)\\n    returns (uint32)\\n  {\\n    uint64 scriptLength = indexCompactInt(_input, 36);\\n    uint256 scriptEnd = 36 + compactIntLength(scriptLength) + scriptLength;\\n    return uint32(_input.indexLEUint(scriptEnd, 4));\\n  }\\n\\n  /// @notice         determines the length of the first input in an array of inputs\\n  /// @param _inputs  the vin without its length prefix\\n  /// @return         the input length\\n  function inputLength(bytes29 _inputs)\\n    internal\\n    pure\\n    typeAssert(_inputs, BTCTypes.IntermediateTxIns)\\n    returns (uint256)\\n  {\\n    uint64 scriptLength = indexCompactInt(_inputs, 36);\\n    return uint256(compactIntLength(scriptLength)) + uint256(scriptLength) + 36 + 4;\\n  }\\n\\n  /// @notice         extracts the input at a specified index\\n  /// @param _vin     the vin\\n  /// @param _index   the index of the desired input\\n  /// @return         the desired input\\n  function indexVin(bytes29 _vin, uint256 _index)\\n    internal\\n    pure\\n    typeAssert(_vin, BTCTypes.Vin)\\n    returns (bytes29)\\n  {\\n    uint256 _nIns = uint256(indexCompactInt(_vin, 0));\\n    uint256 _viewLen = _vin.len();\\n    require(_index < _nIns, \\\"Vin read overrun\\\");\\n\\n    uint256 _offset = uint256(compactIntLength(uint64(_nIns)));\\n    bytes29 _remaining;\\n    for (uint256 _i = 0; _i < _index; _i += 1) {\\n      _remaining = _vin.postfix(_viewLen.sub(_offset), uint40(BTCTypes.IntermediateTxIns));\\n      _offset += inputLength(_remaining);\\n    }\\n\\n    _remaining = _vin.postfix(_viewLen.sub(_offset), uint40(BTCTypes.IntermediateTxIns));\\n    uint256 _len = inputLength(_remaining);\\n    return _vin.slice(_offset, _len, uint40(BTCTypes.TxIn));\\n  }\\n\\n  /// @notice         extracts the raw LE bytes of the output value\\n  /// @param _output  the output\\n  /// @return         the raw LE bytes of the output value\\n  function valueBytes(bytes29 _output)\\n    internal\\n    pure\\n    typeAssert(_output, BTCTypes.TxOut)\\n    returns (bytes8)\\n  {\\n    return bytes8(_output.index(0, 8));\\n  }\\n\\n  /// @notice         extracts the value from an output\\n  /// @param _output  the output\\n  /// @return         the value\\n  function value(bytes29 _output)\\n    internal\\n    pure\\n    typeAssert(_output, BTCTypes.TxOut)\\n    returns (uint64)\\n  {\\n    return uint64(_output.indexLEUint(0, 8));\\n  }\\n\\n  /// @notice             extracts the scriptPubkey from an output\\n  /// @param _output      the output\\n  /// @return             the scriptPubkey\\n  function scriptPubkey(bytes29 _output)\\n    internal\\n    pure\\n    typeAssert(_output, BTCTypes.TxOut)\\n    returns (bytes29)\\n  {\\n    uint64 scriptLength = indexCompactInt(_output, 8);\\n    return\\n      _output.slice(\\n        8,\\n        compactIntLength(scriptLength) + scriptLength,\\n        uint40(BTCTypes.ScriptPubkey)\\n      );\\n  }\\n\\n  /// @notice             determines the length of the first output in an array of outputs\\n  /// @param _outputs     the vout without its length prefix\\n  /// @return             the output length\\n  function outputLength(bytes29 _outputs)\\n    internal\\n    pure\\n    typeAssert(_outputs, BTCTypes.IntermediateTxOuts)\\n    returns (uint256)\\n  {\\n    uint64 scriptLength = indexCompactInt(_outputs, 8);\\n    return uint256(compactIntLength(scriptLength)) + uint256(scriptLength) + 8;\\n  }\\n\\n  /// @notice         extracts the output at a specified index\\n  /// @param _vout    the vout\\n  /// @param _index   the index of the desired output\\n  /// @return         the desired output\\n  function indexVout(bytes29 _vout, uint256 _index)\\n    internal\\n    pure\\n    typeAssert(_vout, BTCTypes.Vout)\\n    returns (bytes29)\\n  {\\n    uint256 _nOuts = uint256(indexCompactInt(_vout, 0));\\n    uint256 _viewLen = _vout.len();\\n    require(_index < _nOuts, \\\"Vout read overrun\\\");\\n\\n    uint256 _offset = uint256(compactIntLength(uint64(_nOuts)));\\n    bytes29 _remaining;\\n    for (uint256 _i = 0; _i < _index; _i += 1) {\\n      _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n      _offset += outputLength(_remaining);\\n    }\\n\\n    _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n    uint256 _len = outputLength(_remaining);\\n    return _vout.slice(_offset, _len, uint40(BTCTypes.TxOut));\\n  }\\n\\n  /// @notice         extracts the Op Return Payload\\n  /// @param _spk     the scriptPubkey\\n  /// @return         the Op Return Payload (or null if not a valid Op Return output)\\n  function opReturnPayload(bytes29 _spk)\\n    internal\\n    pure\\n    typeAssert(_spk, BTCTypes.ScriptPubkey)\\n    returns (bytes29)\\n  {\\n    uint64 _bodyLength = indexCompactInt(_spk, 0);\\n    uint64 _payloadLen = uint64(_spk.indexUint(2, 1));\\n    if (\\n      _bodyLength > 77 ||\\n      _bodyLength < 4 ||\\n      _spk.indexUint(1, 1) != 0x6a ||\\n      _spk.indexUint(2, 1) != _bodyLength - 2\\n    ) {\\n      return TypedMemView.nullView();\\n    }\\n    return _spk.slice(3, _payloadLen, uint40(BTCTypes.OpReturnPayload));\\n  }\\n\\n  /// @notice         extracts the payload from a scriptPubkey\\n  /// @param _spk     the scriptPubkey\\n  /// @return         the payload (or null if not a valid PKH, SH, WPKH, or WSH output)\\n  function payload(bytes29 _spk)\\n    internal\\n    pure\\n    typeAssert(_spk, BTCTypes.ScriptPubkey)\\n    returns (bytes29)\\n  {\\n    uint256 _spkLength = _spk.len();\\n    uint256 _bodyLength = indexCompactInt(_spk, 0);\\n    if (_bodyLength > 0x22 || _bodyLength < 0x16 || _bodyLength + 1 != _spkLength) {\\n      return TypedMemView.nullView();\\n    }\\n\\n    // Legacy\\n    if (\\n      _bodyLength == 0x19 &&\\n      _spk.indexUint(0, 4) == 0x1976a914 &&\\n      _spk.indexUint(_spkLength - 2, 2) == 0x88ac\\n    ) {\\n      return _spk.slice(4, 20, uint40(BTCTypes.PKH));\\n    } else if (\\n      _bodyLength == 0x17 &&\\n      _spk.indexUint(0, 3) == 0x17a914 &&\\n      _spk.indexUint(_spkLength - 1, 1) == 0x87\\n    ) {\\n      return _spk.slice(3, 20, uint40(BTCTypes.SH));\\n    }\\n\\n    // Witness v0\\n    if (_spk.indexUint(1, 1) == 0) {\\n      uint256 _payloadLen = _spk.indexUint(2, 1);\\n      if ((_bodyLength != 0x22 && _bodyLength != 0x16) || _payloadLen != _bodyLength - 2) {\\n        return TypedMemView.nullView();\\n      }\\n      uint40 newType = uint40(_payloadLen == 0x20 ? BTCTypes.WSH : BTCTypes.WPKH);\\n      return _spk.slice(3, _payloadLen, newType);\\n    }\\n\\n    return TypedMemView.nullView();\\n  }\\n\\n  /// @notice     (loosely) verifies an spk and converts to a typed memory\\n  /// @dev        will return null in error cases. Will not check for disabled opcodes.\\n  /// @param _spk the spk\\n  /// @return     the typed spk (or null if error)\\n  function tryAsSPK(bytes29 _spk)\\n    internal\\n    pure\\n    typeAssert(_spk, BTCTypes.Unknown)\\n    returns (bytes29)\\n  {\\n    if (_spk.len() == 0) {\\n      return TypedMemView.nullView();\\n    }\\n    uint64 _len = indexCompactInt(_spk, 0);\\n    if (_spk.len() == compactIntLength(_len) + _len) {\\n      return _spk.castTo(uint40(BTCTypes.ScriptPubkey));\\n    } else {\\n      return TypedMemView.nullView();\\n    }\\n  }\\n\\n  /// @notice     verifies the vin and converts to a typed memory\\n  /// @dev        will return null in error cases\\n  /// @param _vin the vin\\n  /// @return     the typed vin (or null if error)\\n  function tryAsVin(bytes29 _vin)\\n    internal\\n    pure\\n    typeAssert(_vin, BTCTypes.Unknown)\\n    returns (bytes29)\\n  {\\n    if (_vin.len() == 0) {\\n      return TypedMemView.nullView();\\n    }\\n    uint64 _nIns = indexCompactInt(_vin, 0);\\n    uint256 _viewLen = _vin.len();\\n    if (_nIns == 0) {\\n      return TypedMemView.nullView();\\n    }\\n\\n    uint256 _offset = uint256(compactIntLength(_nIns));\\n    for (uint256 i = 0; i < _nIns; i++) {\\n      if (_offset >= _viewLen) {\\n        // We've reached the end, but are still trying to read more\\n        return TypedMemView.nullView();\\n      }\\n      bytes29 _remaining = _vin.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxIns));\\n      _offset += inputLength(_remaining);\\n    }\\n    if (_offset != _viewLen) {\\n      return TypedMemView.nullView();\\n    }\\n    return _vin.castTo(uint40(BTCTypes.Vin));\\n  }\\n\\n  /// @notice         verifies the vout and converts to a typed memory\\n  /// @dev            will return null in error cases\\n  /// @param _vout    the vout\\n  /// @return         the typed vout (or null if error)\\n  function tryAsVout(bytes29 _vout)\\n    internal\\n    pure\\n    typeAssert(_vout, BTCTypes.Unknown)\\n    returns (bytes29)\\n  {\\n    if (_vout.len() == 0) {\\n      return TypedMemView.nullView();\\n    }\\n    uint64 _nOuts = indexCompactInt(_vout, 0);\\n    uint256 _viewLen = _vout.len();\\n    if (_nOuts == 0) {\\n      return TypedMemView.nullView();\\n    }\\n\\n    uint256 _offset = uint256(compactIntLength(_nOuts));\\n    for (uint256 i = 0; i < _nOuts; i++) {\\n      if (_offset >= _viewLen) {\\n        // We've reached the end, but are still trying to read more\\n        return TypedMemView.nullView();\\n      }\\n      bytes29 _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n      _offset += outputLength(_remaining);\\n    }\\n    if (_offset != _viewLen) {\\n      return TypedMemView.nullView();\\n    }\\n    return _vout.castTo(uint40(BTCTypes.Vout));\\n  }\\n\\n  /// @notice         verifies the header and converts to a typed memory\\n  /// @dev            will return null in error cases\\n  /// @param _header  the header\\n  /// @return         the typed header (or null if error)\\n  function tryAsHeader(bytes29 _header)\\n    internal\\n    pure\\n    typeAssert(_header, BTCTypes.Unknown)\\n    returns (bytes29)\\n  {\\n    if (_header.len() != 80) {\\n      return TypedMemView.nullView();\\n    }\\n    return _header.castTo(uint40(BTCTypes.Header));\\n  }\\n\\n  /// @notice         Index a header array.\\n  /// @dev            Errors on overruns\\n  /// @param _arr     The header array\\n  /// @param index    The 0-indexed location of the header to get\\n  /// @return         the typed header at `index`\\n  function indexHeaderArray(bytes29 _arr, uint256 index)\\n    internal\\n    pure\\n    typeAssert(_arr, BTCTypes.HeaderArray)\\n    returns (bytes29)\\n  {\\n    uint256 _start = index.mul(80);\\n    return _arr.slice(_start, 80, uint40(BTCTypes.Header));\\n  }\\n\\n  /// @notice     verifies the header array and converts to a typed memory\\n  /// @dev        will return null in error cases\\n  /// @param _arr the header array\\n  /// @return     the typed header array (or null if error)\\n  function tryAsHeaderArray(bytes29 _arr)\\n    internal\\n    pure\\n    typeAssert(_arr, BTCTypes.Unknown)\\n    returns (bytes29)\\n  {\\n    if (_arr.len() % 80 != 0) {\\n      return TypedMemView.nullView();\\n    }\\n    return _arr.castTo(uint40(BTCTypes.HeaderArray));\\n  }\\n\\n  /// @notice     verifies the merkle array and converts to a typed memory\\n  /// @dev        will return null in error cases\\n  /// @param _arr the merkle array\\n  /// @return     the typed merkle array (or null if error)\\n  function tryAsMerkleArray(bytes29 _arr)\\n    internal\\n    pure\\n    typeAssert(_arr, BTCTypes.Unknown)\\n    returns (bytes29)\\n  {\\n    if (_arr.len() % 32 != 0) {\\n      return TypedMemView.nullView();\\n    }\\n    return _arr.castTo(uint40(BTCTypes.MerkleArray));\\n  }\\n\\n  /// @notice         extracts the merkle root from the header\\n  /// @param _header  the header\\n  /// @return         the merkle root\\n  function merkleRoot(bytes29 _header)\\n    internal\\n    pure\\n    typeAssert(_header, BTCTypes.Header)\\n    returns (bytes32)\\n  {\\n    return _header.index(36, 32);\\n  }\\n\\n  /// @notice         extracts the target from the header\\n  /// @param _header  the header\\n  /// @return         the target\\n  function target(bytes29 _header)\\n    internal\\n    pure\\n    typeAssert(_header, BTCTypes.Header)\\n    returns (uint256)\\n  {\\n    uint256 _mantissa = _header.indexLEUint(72, 3);\\n    uint256 _exponent = _header.indexUint(75, 1).sub(3);\\n    return _mantissa.mul(256**_exponent);\\n  }\\n\\n  /// @notice         calculates the difficulty from a target\\n  /// @param _target  the target\\n  /// @return         the difficulty\\n  function toDiff(uint256 _target) internal pure returns (uint256) {\\n    return DIFF1_TARGET.div(_target);\\n  }\\n\\n  /// @notice         extracts the difficulty from the header\\n  /// @param _header  the header\\n  /// @return         the difficulty\\n  function diff(bytes29 _header)\\n    internal\\n    pure\\n    typeAssert(_header, BTCTypes.Header)\\n    returns (uint256)\\n  {\\n    return toDiff(target(_header));\\n  }\\n\\n  /// @notice         extracts the timestamp from the header\\n  /// @param _header  the header\\n  /// @return         the timestamp\\n  function time(bytes29 _header)\\n    internal\\n    pure\\n    typeAssert(_header, BTCTypes.Header)\\n    returns (uint32)\\n  {\\n    return uint32(_header.indexLEUint(68, 4));\\n  }\\n\\n  /// @notice         extracts the parent hash from the header\\n  /// @param _header  the header\\n  /// @return         the parent hash\\n  function parent(bytes29 _header)\\n    internal\\n    pure\\n    typeAssert(_header, BTCTypes.Header)\\n    returns (bytes32)\\n  {\\n    return _header.index(4, 32);\\n  }\\n\\n  /// @notice         calculates the Proof of Work hash of the header\\n  /// @param _header  the header\\n  /// @return         the Proof of Work hash\\n  function workHash(bytes29 _header)\\n    internal\\n    view\\n    typeAssert(_header, BTCTypes.Header)\\n    returns (bytes32)\\n  {\\n    return _header.hash256();\\n  }\\n\\n  /// @notice         calculates the Proof of Work hash of the header, and converts to an integer\\n  /// @param _header  the header\\n  /// @return         the Proof of Work hash as an integer\\n  function work(bytes29 _header)\\n    internal\\n    view\\n    typeAssert(_header, BTCTypes.Header)\\n    returns (uint256)\\n  {\\n    return TypedMemView.reverseUint256(uint256(workHash(_header)));\\n  }\\n\\n  /// @notice          Concatenates and hashes two inputs for merkle proving\\n  /// @dev             Not recommended to call directly.\\n  /// @param _a        The first hash\\n  /// @param _b        The second hash\\n  /// @return digest   The double-sha256 of the concatenated hashes\\n  function _merkleStep(bytes32 _a, bytes32 _b) internal view returns (bytes32 digest) {\\n    assembly {\\n      // solium-disable-previous-line security/no-inline-assembly\\n      let ptr := mload(0x40)\\n      mstore(ptr, _a)\\n      mstore(add(ptr, 0x20), _b)\\n      pop(staticcall(gas(), 2, ptr, 0x40, ptr, 0x20)) // sha2 #1\\n      pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n      digest := mload(ptr)\\n    }\\n  }\\n\\n  /// @notice         verifies a merkle proof\\n  /// @param _leaf    the leaf\\n  /// @param _proof   the merkle proof\\n  /// @param _root    the merkle root\\n  /// @param _index   the index\\n  /// @return         true if valid, false if otherwise\\n  function checkMerkle(\\n    bytes32 _leaf,\\n    bytes29 _proof,\\n    bytes32 _root,\\n    uint256 _index\\n  ) internal view typeAssert(_proof, BTCTypes.MerkleArray) returns (bool) {\\n    uint256 nodes = _proof.len() / 32;\\n    if (nodes == 0) {\\n      return _leaf == _root;\\n    }\\n\\n    uint256 _idx = _index;\\n    bytes32 _current = _leaf;\\n\\n    for (uint256 i = 0; i < nodes; i++) {\\n      bytes32 _next = _proof.index(i * 32, 32);\\n      if (_idx % 2 == 1) {\\n        _current = _merkleStep(_next, _current);\\n      } else {\\n        _current = _merkleStep(_current, _next);\\n      }\\n      _idx >>= 1;\\n    }\\n\\n    return _current == _root;\\n  }\\n\\n  /// @notice                 performs the bitcoin difficulty retarget\\n  /// @dev                    implements the Bitcoin algorithm precisely\\n  /// @param _previousTarget  the target of the previous period\\n  /// @param _firstTimestamp  the timestamp of the first block in the difficulty period\\n  /// @param _secondTimestamp the timestamp of the last block in the difficulty period\\n  /// @return                 the new period's target threshold\\n  function retargetAlgorithm(\\n    uint256 _previousTarget,\\n    uint256 _firstTimestamp,\\n    uint256 _secondTimestamp\\n  ) internal pure returns (uint256) {\\n    uint256 _elapsedTime = _secondTimestamp.sub(_firstTimestamp);\\n\\n    // Normalize ratio to factor of 4 if very long or very short\\n    if (_elapsedTime < RETARGET_PERIOD.div(4)) {\\n      _elapsedTime = RETARGET_PERIOD.div(4);\\n    }\\n    if (_elapsedTime > RETARGET_PERIOD.mul(4)) {\\n      _elapsedTime = RETARGET_PERIOD.mul(4);\\n    }\\n\\n    /*\\n            NB: high targets e.g. ffff0020 can cause overflows here\\n                so we divide it by 256**2, then multiply by 256**2 later\\n                we know the target is evenly divisible by 256**2, so this isn't an issue\\n        */\\n    uint256 _adjusted = _previousTarget.div(65536).mul(_elapsedTime);\\n    return _adjusted.div(RETARGET_PERIOD).mul(65536);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/summa-tx/ViewSPV.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n/** @title ViewSPV */\\n/** @author Summa (https://summa.one) */\\n\\nimport {TypedMemView} from \\\"./TypedMemView.sol\\\";\\nimport {ViewBTC} from \\\"./ViewBTC.sol\\\";\\nimport {SafeMath} from \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\nlibrary ViewSPV {\\n  using TypedMemView for bytes;\\n  using TypedMemView for bytes29;\\n  using ViewBTC for bytes29;\\n  using SafeMath for uint256;\\n\\n  uint256 constant ERR_BAD_LENGTH = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n  uint256 constant ERR_INVALID_CHAIN = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe;\\n  uint256 constant ERR_LOW_WORK = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd;\\n\\n  function getErrBadLength() internal pure returns (uint256) {\\n    return ERR_BAD_LENGTH;\\n  }\\n\\n  function getErrInvalidChain() internal pure returns (uint256) {\\n    return ERR_INVALID_CHAIN;\\n  }\\n\\n  function getErrLowWork() internal pure returns (uint256) {\\n    return ERR_LOW_WORK;\\n  }\\n\\n  /// @notice             requires `memView` to be of a specified type\\n  /// @param memView      a 29-byte view with a 5-byte type\\n  /// @param t            the expected type (e.g. BTCTypes.Outpoint, BTCTypes.TxIn, etc)\\n  /// @return             passes if it is the correct type, errors if not\\n  modifier typeAssert(bytes29 memView, ViewBTC.BTCTypes t) {\\n    memView.assertType(uint40(t));\\n    _;\\n  }\\n\\n  /// @notice                     Validates a tx inclusion in the block\\n  /// @dev                        `index` is not a reliable indicator of location within a block\\n  /// @param _txid                The txid (LE)\\n  /// @param _merkleRoot          The merkle root (as in the block header)\\n  /// @param _intermediateNodes   The proof's intermediate nodes (digests between leaf and root)\\n  /// @param _index               The leaf's index in the tree (0-indexed)\\n  /// @return                     true if fully valid, false otherwise\\n  function prove(\\n    bytes32 _txid,\\n    bytes32 _merkleRoot,\\n    bytes29 _intermediateNodes,\\n    uint256 _index\\n  ) internal view typeAssert(_intermediateNodes, ViewBTC.BTCTypes.MerkleArray) returns (bool) {\\n    // Shortcut the empty-block case\\n    if (_txid == _merkleRoot && _index == 0 && _intermediateNodes.len() == 0) {\\n      return true;\\n    }\\n\\n    return ViewBTC.checkMerkle(_txid, _intermediateNodes, _merkleRoot, _index);\\n  }\\n\\n  /// @notice             Hashes transaction to get txid\\n  /// @dev                Supports Legacy and Witness\\n  /// @param _version     4-bytes version\\n  /// @param _vin         Raw bytes length-prefixed input vector\\n  /// @param _vout        Raw bytes length-prefixed output vector\\n  /// @param _locktime    4-byte tx locktime\\n  /// @return             32-byte transaction id, little endian\\n  function calculateTxId(\\n    bytes4 _version,\\n    bytes29 _vin,\\n    bytes29 _vout,\\n    bytes4 _locktime\\n  )\\n    internal\\n    view\\n    typeAssert(_vin, ViewBTC.BTCTypes.Vin)\\n    typeAssert(_vout, ViewBTC.BTCTypes.Vout)\\n    returns (bytes32)\\n  {\\n    // TODO: write in assembly\\n    return abi.encodePacked(_version, _vin.clone(), _vout.clone(), _locktime).ref(0).hash256();\\n  }\\n\\n  // TODO: add test for checkWork\\n  /// @notice             Checks validity of header work\\n  /// @param _header      Header view\\n  /// @param _target      The target threshold\\n  /// @return             true if header work is valid, false otherwise\\n  function checkWork(bytes29 _header, uint256 _target)\\n    internal\\n    view\\n    typeAssert(_header, ViewBTC.BTCTypes.Header)\\n    returns (bool)\\n  {\\n    return _header.work() < _target;\\n  }\\n\\n  /// @notice                     Checks validity of header chain\\n  /// @dev                        Compares current header parent to previous header's digest\\n  /// @param _header              The raw bytes header\\n  /// @param _prevHeaderDigest    The previous header's digest\\n  /// @return                     true if the connect is valid, false otherwise\\n  function checkParent(bytes29 _header, bytes32 _prevHeaderDigest)\\n    internal\\n    pure\\n    typeAssert(_header, ViewBTC.BTCTypes.Header)\\n    returns (bool)\\n  {\\n    return _header.parent() == _prevHeaderDigest;\\n  }\\n\\n  /// @notice                     Checks validity of header chain\\n  /// @notice                     Compares the hash of each header to the prevHash in the next header\\n  /// @param _headers             Raw byte array of header chain\\n  /// @return _totalDifficulty    The total accumulated difficulty of the header chain, or an error code\\n  function checkChain(bytes29 _headers)\\n    internal\\n    view\\n    typeAssert(_headers, ViewBTC.BTCTypes.HeaderArray)\\n    returns (uint256 _totalDifficulty)\\n  {\\n    bytes32 _digest;\\n    uint256 _headerCount = _headers.len() / 80;\\n    for (uint256 i = 0; i < _headerCount; i += 1) {\\n      bytes29 _header = _headers.indexHeaderArray(i);\\n      if (i != 0) {\\n        if (!checkParent(_header, _digest)) {\\n          return ERR_INVALID_CHAIN;\\n        }\\n      }\\n      _digest = _header.workHash();\\n      uint256 _work = TypedMemView.reverseUint256(uint256(_digest));\\n      uint256 _target = _header.target();\\n\\n      if (_work > _target) {\\n        return ERR_LOW_WORK;\\n      }\\n\\n      _totalDifficulty += ViewBTC.toDiff(_target);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/summa-tx/IRelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL\\n\\npragma solidity 0.6.6;\\n\\n/** @title IRelay */\\n\\ninterface IRelay {\\n  event Extension(bytes32 indexed _first, bytes32 indexed _last);\\n  event NewTip(bytes32 indexed _from, bytes32 indexed _to, bytes32 indexed _gcd);\\n\\n  /// @notice     Getter for bestKnownDigest\\n  /// @dev        This updated only by calling markNewHeaviest\\n  /// @return     The hash of the best marked chain tip\\n  function getBestKnownDigest() external view returns (bytes32);\\n\\n  /// @notice     Getter for relayGenesis\\n  /// @dev        This is updated only by calling markNewHeaviest\\n  /// @return     The hash of the shared ancestor of the most recent fork\\n  function getLastReorgCommonAncestor() external view returns (bytes32);\\n\\n  /// @notice         Finds the height of a header by its digest\\n  /// @dev            Will fail if the header is unknown\\n  /// @param _digest  The header digest to search for\\n  /// @return         The height of the header, or error if unknown\\n  function findHeight(bytes32 _digest) external view returns (uint256);\\n\\n  /// @notice             Checks if a digest is an ancestor of the current one\\n  /// @dev                Limit the amount of lookups (and thus gas usage) with _limit\\n  /// @param _ancestor    The prospective ancestor\\n  /// @param _descendant  The descendant to check\\n  /// @param _limit       The maximum number of blocks to check\\n  /// @return             true if ancestor is at most limit blocks lower than descendant, otherwise false\\n  function isAncestor(\\n    bytes32 _ancestor,\\n    bytes32 _descendant,\\n    uint256 _limit\\n  ) external view returns (bool);\\n\\n  function addHeaders(bytes calldata _anchor, bytes calldata _headers) external returns (bool);\\n\\n  function addHeadersWithRetarget(\\n    bytes calldata _oldPeriodStartHeader,\\n    bytes calldata _oldPeriodEndHeader,\\n    bytes calldata _headers\\n  ) external returns (bool);\\n\\n  function markNewHeaviest(\\n    bytes32 _ancestor,\\n    bytes calldata _currentBest,\\n    bytes calldata _newBest,\\n    uint256 _limit\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockVbtcUpgraded.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity 0.6.6;\\n\\nimport \\\"../VbtcToken.sol\\\";\\n\\n/// @title  VBTC Token.\\n/// @notice This is the VBTC ERC20 contract.\\ncontract MockVbtcUpgraded is VbtcToken {\\n  // TODO: implement\\n  // bytes calldata _header,\\n  // bytes calldata _proof,\\n  // uint256 _index,\\n  // bytes32 _txid,\\n  function proofP2FSHAndMint(\\n    bytes calldata _header,\\n    bytes calldata _proof,\\n    uint256 _index,\\n    bytes32 _txid\\n  ) external override returns (bool) {\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/VbtcToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Capped.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@uniswap/lib/contracts/libraries/Babylonian.sol\\\";\\nimport {TypedMemView} from \\\"./summa-tx/TypedMemView.sol\\\";\\nimport {ViewBTC} from \\\"./summa-tx/ViewBTC.sol\\\";\\nimport {ViewSPV} from \\\"./summa-tx/ViewSPV.sol\\\";\\nimport \\\"./erc20/ITokenRecipient.sol\\\";\\nimport \\\"./summa-tx/IRelay.sol\\\";\\nimport \\\"./StrudelToken.sol\\\";\\nimport \\\"./FlashERC20.sol\\\";\\n\\n/// @title  VBTC Token.\\n/// @notice This is the VBTC ERC20 contract.\\ncontract VbtcToken is FlashERC20, ERC20CappedUpgradeSafe {\\n  using SafeMath for uint256;\\n  using TypedMemView for bytes;\\n  using TypedMemView for bytes29;\\n  using ViewBTC for bytes29;\\n  using ViewSPV for bytes29;\\n\\n  event Crossing(\\n    bytes32 indexed btcTxHash,\\n    address indexed receiver,\\n    uint256 amount,\\n    uint32 outputIndex\\n  );\\n\\n  uint8 constant ADDR_LEN = 20;\\n  uint256 constant BTC_CAP_SQRT = 4582575700000; // sqrt(BTC_CAP)\\n  bytes3 constant PROTOCOL_ID = 0x07ffff; // a mersenne prime\\n  bytes32 public DOMAIN_SEPARATOR;\\n\\n  // immutable\\n  StrudelToken private strudel;\\n  // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n  bytes32\\n    public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n  // gov params\\n  IRelay public relay;\\n  uint256 public numConfs;\\n  uint256 public relayReward;\\n\\n  // working memory\\n  // marking all sucessfully processed outputs\\n  mapping(bytes32 => bool) public knownOutpoints;\\n  mapping(address => uint256) public nonces;\\n\\n  function initialize(\\n    address _relay,\\n    address _strudel,\\n    uint256 _minConfs,\\n    uint256 _relayReward\\n  ) public initializer {\\n    relay = IRelay(_relay);\\n    strudel = StrudelToken(_strudel);\\n    numConfs = _minConfs;\\n    relayReward = _relayReward;\\n    // chain constructors?\\n    __Flash_init(\\\"Strudel BTC\\\", \\\"VBTC\\\");\\n    __ERC20Capped_init(BTC_CAP);\\n    uint256 chainId;\\n    assembly {\\n      chainId := chainid()\\n    }\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(\\n        keccak256(\\n          \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        ),\\n        keccak256(bytes(\\\"Strudel BTC\\\")),\\n        keccak256(bytes(\\\"1\\\")),\\n        chainId,\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual override(ERC20CappedUpgradeSafe, ERC20UpgradeSafe) {\\n    super._beforeTokenTransfer(from, to, amount);\\n  }\\n\\n  function makeCompressedOutpoint(bytes32 _txid, uint32 _index) internal pure returns (bytes32) {\\n    // sacrifice 4 bytes instead of hashing\\n    return ((_txid >> 32) << 32) | bytes32(uint256(_index));\\n  }\\n\\n  /// @notice             Verifies inclusion of a tx in a header, and that header in the Relay chain\\n  /// @dev                Specifically we check that both the best tip and the heaviest common header confirm it\\n  /// @param  _header     The header containing the merkleroot committing to the tx\\n  /// @param  _proof      The merkle proof intermediate nodes\\n  /// @param  _index      The index of the tx in the merkle tree's leaves\\n  /// @param  _txid       The txid that is the proof leaf\\n  function _checkInclusion(\\n    bytes29 _header, // Header\\n    bytes29 _proof, // MerkleArray\\n    uint256 _index,\\n    bytes32 _txid\\n  ) internal view returns (bool) {\\n    // check the txn is included in the header\\n    require(ViewSPV.prove(_txid, _header.merkleRoot(), _proof, _index), \\\"Bad inclusion proof\\\");\\n\\n    // check the header is included in the chain\\n    bytes32 headerHash = _header.hash256();\\n    bytes32 GCD = relay.getLastReorgCommonAncestor();\\n    require(relay.isAncestor(headerHash, GCD, 2500), \\\"GCD does not confirm header\\\");\\n\\n    // check offset to tip\\n    bytes32 bestKnownDigest = relay.getBestKnownDigest();\\n    uint256 height = relay.findHeight(headerHash);\\n    require(height > 0, \\\"height not found in relay\\\");\\n    uint256 offset = relay.findHeight(bestKnownDigest).sub(height);\\n    require(offset >= numConfs, \\\"Insufficient confirmations\\\");\\n\\n    return true;\\n  }\\n\\n  /// @dev             Mints an amount of the token and assigns it to an account.\\n  ///                  Uses the internal _mint function.\\n  /// @param _header   header\\n  /// @param _proof    proof\\n  /// @param _version  version\\n  /// @param _locktime locktime\\n  /// @param _index    tx index in block\\n  /// @param _crossingOutputIndex    output index that\\n  /// @param _vin      vin\\n  /// @param _vout     vout\\n  function proofOpReturnAndMint(\\n    bytes calldata _header,\\n    bytes calldata _proof,\\n    bytes4 _version,\\n    bytes4 _locktime,\\n    uint256 _index,\\n    uint32 _crossingOutputIndex,\\n    bytes calldata _vin,\\n    bytes calldata _vout\\n  ) external returns (bool) {\\n    return\\n      _provideProof(\\n        _header,\\n        _proof,\\n        _version,\\n        _locktime,\\n        _index,\\n        _crossingOutputIndex,\\n        _vin,\\n        _vout\\n      );\\n  }\\n\\n  function _provideProof(\\n    bytes memory _header,\\n    bytes memory _proof,\\n    bytes4 _version,\\n    bytes4 _locktime,\\n    uint256 _index,\\n    uint32 _crossingOutputIndex,\\n    bytes memory _vin,\\n    bytes memory _vout\\n  ) internal returns (bool) {\\n    bytes32 txId = abi.encodePacked(_version, _vin, _vout, _locktime).ref(0).hash256();\\n    bytes32 outpoint = makeCompressedOutpoint(txId, _crossingOutputIndex);\\n    require(!knownOutpoints[outpoint], \\\"already processed outputs\\\");\\n\\n    _checkInclusion(\\n      _header.ref(0).tryAsHeader().assertValid(),\\n      _proof.ref(0).tryAsMerkleArray().assertValid(),\\n      _index,\\n      txId\\n    );\\n\\n    // mark processed\\n    knownOutpoints[outpoint] = true;\\n\\n    // do payouts\\n    address account;\\n    uint256 amount;\\n    (account, amount) = doPayouts(_vout.ref(0).tryAsVout(), _crossingOutputIndex);\\n    emit Crossing(txId, account, amount, _crossingOutputIndex);\\n    return true;\\n  }\\n\\n  function doPayouts(bytes29 _vout, uint32 _crossingOutputIndex)\\n    internal\\n    returns (address account, uint256 amount)\\n  {\\n    bytes29 output = _vout.indexVout(_crossingOutputIndex);\\n\\n    // extract receiver and address\\n    amount = output.value() * 10**10; // wei / satosh = 10^18 / 10^8 = 10^10\\n    require(amount > 0, \\\"output has 0 value\\\");\\n\\n    bytes29 opReturnPayload = output.scriptPubkey().opReturnPayload();\\n    require(opReturnPayload.len() == ADDR_LEN + 3, \\\"invalid op-return payload length\\\");\\n    require(bytes3(opReturnPayload.index(0, 3)) == PROTOCOL_ID, \\\"invalid protocol id\\\");\\n    account = address(bytes20(opReturnPayload.index(3, ADDR_LEN)));\\n\\n    uint256 sqrtVbtcBefore = Babylonian.sqrt(totalSupply());\\n    _mint(account, amount);\\n    uint256 sqrtVbtcAfter = Babylonian.sqrt(totalSupply());\\n\\n    // calculate the reward as area h(x) = f(x) - g(x), where f(x) = x^2 and g(x) = |minted|\\n    // pay out only the delta to the previous claim: H(after) - H(before)\\n    // this caps all minting rewards to 2/3 of BTC_CAP\\n    uint256 rewardAmount = BTC_CAP\\n      .mul(3)\\n      .mul(sqrtVbtcAfter)\\n      .add(sqrtVbtcBefore**3)\\n      .sub(BTC_CAP.mul(3).mul(sqrtVbtcBefore))\\n      .sub(sqrtVbtcAfter**3)\\n      .div(3)\\n      .div(BTC_CAP_SQRT);\\n    strudel.mint(account, rewardAmount);\\n    strudel.mint(owner(), rewardAmount.div(devFundDivRate));\\n  }\\n\\n  // TODO: implement\\n  // bytes calldata _header,\\n  // bytes calldata _proof,\\n  // uint256 _index,\\n  // bytes32 _txid,\\n  function proofP2FSHAndMint(\\n    bytes calldata _header,\\n    bytes calldata _proof,\\n    uint256 _index,\\n    bytes32 _txid\\n  ) external virtual returns (bool) {\\n    require(false, \\\"not implemented\\\");\\n  }\\n\\n  function addHeaders(bytes calldata _anchor, bytes calldata _headers) external returns (bool) {\\n    require(relay.addHeaders(_anchor, _headers), \\\"add header failed\\\");\\n    strudel.mint(msg.sender, relayReward.mul(_headers.length / 80));\\n  }\\n\\n  function addHeadersWithRetarget(\\n    bytes calldata _oldPeriodStartHeader,\\n    bytes calldata _oldPeriodEndHeader,\\n    bytes calldata _headers\\n  ) external returns (bool) {\\n    require(\\n      relay.addHeadersWithRetarget(_oldPeriodStartHeader, _oldPeriodEndHeader, _headers),\\n      \\\"add header with retarget failed\\\"\\n    );\\n    strudel.mint(msg.sender, relayReward.mul(_headers.length / 80));\\n  }\\n\\n  function markNewHeaviest(\\n    bytes32 _ancestor,\\n    bytes calldata _currentBest,\\n    bytes calldata _newBest,\\n    uint256 _limit\\n  ) external returns (bool) {\\n    require(\\n      relay.markNewHeaviest(_ancestor, _currentBest, _newBest, _limit),\\n      \\\"mark new heaviest failed\\\"\\n    );\\n    strudel.mint(msg.sender, relayReward);\\n  }\\n\\n  /// @dev             Burns an amount of the token from the given account's balance.\\n  ///                  deducting from the sender's allowance for said account.\\n  ///                  Uses the internal _burn function.\\n  /// @param _account  The account whose tokens will be burnt.\\n  /// @param _amount   The amount of tokens that will be burnt.\\n  function burnFrom(address _account, uint256 _amount) external {\\n    uint256 decreasedAllowance = allowance(_account, _msgSender()).sub(\\n      _amount,\\n      \\\"ERC20: burn amount exceeds allowance\\\"\\n    );\\n\\n    _approve(_account, _msgSender(), decreasedAllowance);\\n    _burn(_account, _amount);\\n  }\\n\\n  /// @dev Destroys `amount` tokens from `msg.sender`, reducing the\\n  /// total supply.\\n  /// @param _amount   The amount of tokens that will be burnt.\\n  function burn(uint256 _amount) external {\\n    _burn(msg.sender, _amount);\\n  }\\n\\n  /// @notice           Set allowance for other address and notify.\\n  ///                   Allows `_spender` to spend no more than `_value`\\n  ///                   tokens on your behalf and then ping the contract about\\n  ///                   it.\\n  /// @dev              The `_spender` should implement the `ITokenRecipient`\\n  ///                   interface to receive approval notifications.\\n  /// @param _spender   Address of contract authorized to spend.\\n  /// @param _value     The max amount they can spend.\\n  /// @param _extraData Extra information to send to the approved contract.\\n  /// @return true if the `_spender` was successfully approved and acted on\\n  ///         the approval, false (or revert) otherwise.\\n  function approveAndCall(\\n    ITokenRecipient _spender,\\n    uint256 _value,\\n    bytes calldata _extraData\\n  ) external returns (bool) {\\n    // not external to allow bytes memory parameters\\n    if (approve(address(_spender), _value)) {\\n      _spender.receiveApproval(msg.sender, _value, address(this), _extraData);\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external {\\n    require(deadline >= block.timestamp, \\\"vBTC: EXPIRED\\\");\\n    bytes32 digest = keccak256(\\n      abi.encodePacked(\\n        \\\"\\\\x19\\\\x01\\\",\\n        DOMAIN_SEPARATOR,\\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n      )\\n    );\\n    address recoveredAddress = ecrecover(digest, v, r, s);\\n    require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"VBTC: INVALID_SIGNATURE\\\");\\n    _approve(owner, spender, value);\\n  }\\n\\n  function setRelayReward(uint256 _newRelayReward) external onlyOwner {\\n    require(_newRelayReward > 0, \\\"!newRelayReward-0\\\");\\n    relayReward = _newRelayReward;\\n  }\\n\\n  function setRelayAddress(address _newRelayAddr) external onlyOwner {\\n    require(_newRelayAddr != address(0), \\\"!newRelayAddr-0\\\");\\n    relay = IRelay(_newRelayAddr);\\n  }\\n\\n  function setNumConfs(uint256 _numConfs) external onlyOwner {\\n    require(_numConfs > 0, \\\"!newNumConfs-0\\\");\\n    require(_numConfs < 100, \\\"!newNumConfs-useless\\\");\\n    numConfs = _numConfs;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Capped.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"../../Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\\n */\\nabstract contract ERC20CappedUpgradeSafe is Initializable, ERC20UpgradeSafe {\\n    uint256 private _cap;\\n\\n    /**\\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\\n     * set once during construction.\\n     */\\n\\n    function __ERC20Capped_init(uint256 cap) internal initializer {\\n        __Context_init_unchained();\\n        __ERC20Capped_init_unchained(cap);\\n    }\\n\\n    function __ERC20Capped_init_unchained(uint256 cap) internal initializer {\\n\\n\\n        require(cap > 0, \\\"ERC20Capped: cap is 0\\\");\\n        _cap = cap;\\n\\n    }\\n\\n\\n    /**\\n     * @dev Returns the cap on the token's total supply.\\n     */\\n    function cap() public view returns (uint256) {\\n        return _cap;\\n    }\\n\\n    /**\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - minted tokens must not cause the total supply to go over the cap.\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (from == address(0)) { // When minting tokens\\n            require(totalSupply().add(amount) <= _cap, \\\"ERC20Capped: cap exceeded\\\");\\n        }\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/StrudelToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"./erc20/MinterRole.sol\\\";\\nimport \\\"./erc20/ITokenRecipient.sol\\\";\\n\\n/// @title  Strudel Token.\\n/// @notice This is the Strudel ERC20 contract.\\ncontract StrudelToken is ERC20UpgradeSafe, MinterRole {\\n  using SafeMath for uint256;\\n\\n  bytes32 public DOMAIN_SEPARATOR;\\n  // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n  bytes32\\n    public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n  mapping(address => uint256) public nonces;\\n\\n  constructor() public {\\n    __ERC20_init(\\\"Strudel Finance\\\", \\\"$TRDL\\\");\\n    __Ownable_init();\\n    uint256 chainId;\\n    assembly {\\n      chainId := chainid()\\n    }\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(\\n        keccak256(\\n          \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        ),\\n        keccak256(bytes(\\\"Strudel Finance\\\")),\\n        keccak256(bytes(\\\"1\\\")),\\n        chainId,\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @dev See {ERC20-_mint}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have the {MinterRole}.\\n   */\\n  function mint(address account, uint256 amount) external onlyMinter returns (bool) {\\n    _mint(account, amount);\\n    return true;\\n  }\\n\\n  /// @dev             Burns an amount of the token from the given account's balance.\\n  ///                  deducting from the sender's allowance for said account.\\n  ///                  Uses the internal _burn function.\\n  /// @param _account  The account whose tokens will be burnt.\\n  /// @param _amount   The amount of tokens that will be burnt.\\n  function burnFrom(address _account, uint256 _amount) external {\\n    uint256 decreasedAllowance = allowance(_account, _msgSender()).sub(\\n      _amount,\\n      \\\"ERC20: burn amount exceeds allowance\\\"\\n    );\\n\\n    _approve(_account, _msgSender(), decreasedAllowance);\\n    _burn(_account, _amount);\\n  }\\n\\n  /// @dev Destroys `amount` tokens from `msg.sender`, reducing the\\n  /// total supply.\\n  /// @param _amount   The amount of tokens that will be burnt.\\n  function burn(uint256 _amount) external {\\n    _burn(msg.sender, _amount);\\n  }\\n\\n  /// @notice           Set allowance for other address and notify.\\n  ///                   Allows `_spender` to spend no more than `_value`\\n  ///                   tokens on your behalf and then ping the contract about\\n  ///                   it.\\n  /// @dev              The `_spender` should implement the `ITokenRecipient`\\n  ///                   interface to receive approval notifications.\\n  /// @param _spender   Address of contract authorized to spend.\\n  /// @param _value     The max amount they can spend.\\n  /// @param _extraData Extra information to send to the approved contract.\\n  /// @return true if the `_spender` was successfully approved and acted on\\n  ///         the approval, false (or revert) otherwise.\\n  function approveAndCall(\\n    ITokenRecipient _spender,\\n    uint256 _value,\\n    bytes memory _extraData\\n  ) public returns (bool) {\\n    // not external to allow bytes memory parameters\\n    if (approve(address(_spender), _value)) {\\n      _spender.receiveApproval(msg.sender, _value, address(this), _extraData);\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external {\\n    require(deadline >= block.timestamp, \\\"Strudel: EXPIRED\\\");\\n    bytes32 digest = keccak256(\\n      abi.encodePacked(\\n        \\\"\\\\x19\\\\x01\\\",\\n        DOMAIN_SEPARATOR,\\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n      )\\n    );\\n    address recoveredAddress = ecrecover(digest, v, r, s);\\n    require(\\n      recoveredAddress != address(0) && recoveredAddress == owner,\\n      \\\"Strudel: INVALID_SIGNATURE\\\"\\n    );\\n    _approve(owner, spender, value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ReservePoolController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity 0.6.6;\\n\\n// Imports\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@uniswap/lib/contracts/libraries/Babylonian.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"./balancer/IBFactory.sol\\\";\\nimport \\\"./balancer/IBPool.sol\\\";\\nimport \\\"./IBtcPriceOracle.sol\\\";\\nimport \\\"./balancer/BMath.sol\\\";\\nimport \\\"./uniswap/IWETH9.sol\\\";\\nimport \\\"./VbtcToken.sol\\\";\\nimport \\\"./IBorrower.sol\\\";\\nimport \\\"./ILender.sol\\\";\\n\\n/**\\n *\\n * Reference:\\n * https://github.com/balancer-labs/configurable-rights-pool/blob/master/contracts/templates/ElasticSupplyPool.sol\\n *\\n * @title Reserve Pool Controller.\\n *\\n * @dev   Extension of Balancer labs' configurable rights pool (smart-pool).\\n *        The reserve pool holds liquidity to affect the peg of vBTC in the spot pool.\\n *        The setWeight function is used to shift liquidity between pools and follow\\n *        the peg within a bounded range. The bounds are imposed by liquidity and MAX_WEIGHT param.\\n *\\n */\\ncontract ReservePoolController is ERC20UpgradeSafe, BMath, IBorrower, OwnableUpgradeSafe {\\n  using SafeMath for uint256;\\n\\n  uint256 internal constant DEFAULT_WEIGHT = 5 * 10**18;\\n  // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n  bytes32\\n    internal constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n  // Event declarations\\n  event Trade(bool indexed direction, uint256 amount);\\n  event LogJoin(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\\n  event LogExit(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\\n\\n  // immutable\\n  VbtcToken private vBtc;\\n  IWETH9 private wEth;\\n  IBFactory private bFactory;\\n  bytes32 public DOMAIN_SEPARATOR;\\n\\n  // goverance params\\n  IUniswapV2Router01 private uniRouter; // IUniswapV2Router01\\n  address private oracle; // 24 hour price feed for BTC\\n  uint256 private maxVbtcWeight; // denormmalized, like in Balancer\\n\\n  // working memory\\n  IBPool public bPool; // IBPool\\n  uint32 private blockTimestampLast;\\n  mapping(address => uint256) private nonces;\\n\\n  function initialize(\\n    address _vBtcAddr,\\n    IWETH9 _wEthAddr,\\n    address _bPoolFactory,\\n    IUniswapV2Router01 _uniRouter,\\n    address _oracle\\n  ) external initializer {\\n    vBtc = VbtcToken(_vBtcAddr);\\n    wEth = _wEthAddr;\\n    bFactory = IBFactory(_bPoolFactory);\\n    uniRouter = _uniRouter;\\n    oracle = _oracle;\\n    maxVbtcWeight = 3 * DEFAULT_WEIGHT;\\n    // chain constructors?\\n    __ERC20_init(\\\"Strudel vBTC++\\\", \\\"vBTC++\\\");\\n    __Ownable_init();\\n    uint256 chainId;\\n    assembly {\\n      chainId := chainid()\\n    }\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(\\n        keccak256(\\n          \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        ),\\n        keccak256(bytes(\\\"Strudel vBTC++\\\")),\\n        keccak256(bytes(\\\"1\\\")),\\n        chainId,\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n  function sortTokens(address tokenA, address tokenB)\\n    internal\\n    pure\\n    returns (address token0, address token1)\\n  {\\n    require(tokenA != tokenB, \\\"UniswapV2Library: IDENTICAL_ADDRESSES\\\");\\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n    require(token0 != address(0), \\\"UniswapV2Library: ZERO_ADDRESS\\\");\\n  }\\n\\n  // calculates the CREATE2 address for a pair without making any external calls\\n  function pairFor(\\n    address factory,\\n    address tokenA,\\n    address tokenB\\n  ) internal pure returns (address pair) {\\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\\n    pair = address(\\n      uint256(\\n        keccak256(\\n          abi.encodePacked(\\n            hex\\\"ff\\\",\\n            factory,\\n            keccak256(abi.encodePacked(token0, token1)),\\n            hex\\\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\\" // init code hash\\n          )\\n        )\\n      )\\n    );\\n  }\\n\\n  // fetches and sorts the reserves for a pair\\n  function getReserves(\\n    address factory,\\n    address tokenA,\\n    address tokenB\\n  ) internal view returns (uint256 reserveA, uint256 reserveB) {\\n    (address token0, ) = sortTokens(tokenA, tokenB);\\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB))\\n      .getReserves();\\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n  }\\n\\n  // computes the direction and magnitude of the profit-maximizing trade\\n  function computeProfitMaximizingTrade(\\n    uint256 truePriceTokenA,\\n    uint256 truePriceTokenB,\\n    uint256 reserveA,\\n    uint256 reserveB\\n  ) internal pure returns (bool aToB, uint256 amountIn) {\\n    aToB = reserveA.mul(truePriceTokenB) / reserveB < truePriceTokenA;\\n\\n    uint256 invariant = reserveA.mul(reserveB);\\n\\n    uint256 leftSide = Babylonian.sqrt(\\n      invariant.mul(aToB ? truePriceTokenA : truePriceTokenB).mul(1000) /\\n        uint256(aToB ? truePriceTokenB : truePriceTokenA).mul(997)\\n    );\\n    uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\\n\\n    // compute the amount that must be sent to move the price to the profit-maximizing price\\n    amountIn = leftSide.sub(rightSide);\\n  }\\n\\n  // Rebind BPool and pull tokens from address\\n  // bPool is a contract interface; function calls on it are external\\n  function _pullUnderlying(\\n    address erc20,\\n    uint256 tokenBalance,\\n    address from,\\n    uint256 amount\\n  ) internal {\\n    // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\\n    uint256 tokenWeight = bPool.getDenormalizedWeight(erc20);\\n\\n    bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\\n    require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    bPool.rebind(erc20, badd(tokenBalance, amount), tokenWeight);\\n  }\\n\\n  // Rebind BPool and push tokens to address\\n  // bPool is a contract interface; function calls on it are external\\n  function _pushUnderlying(\\n    address erc20,\\n    address to,\\n    uint256 amount\\n  ) internal {\\n    // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\\n    uint256 tokenBalance = bPool.getBalance(erc20);\\n    uint256 tokenWeight = bPool.getDenormalizedWeight(erc20);\\n    bPool.rebind(erc20, bsub(tokenBalance, amount), tokenWeight);\\n\\n    bool xfer = IERC20(erc20).transfer(to, amount);\\n    require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n  }\\n\\n  function _joinPool(\\n    uint256 poolAmountOut,\\n    uint256[] memory maxAmountsIn,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    // Library computes actualAmountsIn, and does many validations\\n    // Cannot call the push/pull/min from an external library for\\n    // any of these pool functions. Since msg.sender can be anybody,\\n    // they must be internal\\n    address[] memory tokens = bPool.getCurrentTokens();\\n\\n    require(maxAmountsIn.length == tokens.length, \\\"ERR_AMOUNTS_MISMATCH\\\");\\n\\n    // Subtract  1 to ensure any rounding errors favor the pool\\n    uint256 ratio = bdiv(poolAmountOut, bsub(totalSupply(), 1));\\n\\n    require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n    // This loop contains external calls\\n    // External calls are to math libraries or the underlying pool, so low risk\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address t = tokens[i];\\n      uint256 bal = bPool.getBalance(t);\\n      // Add 1 to ensure any rounding errors favor the pool\\n      uint256 tokenAmountIn = bmul(ratio, badd(bal, 1));\\n\\n      require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n      require(tokenAmountIn <= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n\\n      emit LogJoin(msg.sender, t, tokenAmountIn);\\n\\n      if (deadline > 0 && t == address(wEth) && msg.value > 0) {\\n        // either convert ether\\n        require(msg.value == tokenAmountIn, \\\"wrong eth amount supplied\\\");\\n        wEth.deposit{value: tokenAmountIn}();\\n        bPool.rebind(t, badd(bal, tokenAmountIn), bPool.getDenormalizedWeight(t));\\n      } else {\\n        if (deadline > 0 && t == address(vBtc)) {\\n          vBtc.permit(msg.sender, address(this), MAX_UINT, deadline, v, r, s);\\n        }\\n        _pullUnderlying(t, bal, msg.sender, tokenAmountIn);\\n      }\\n    }\\n    _mint(msg.sender, poolAmountOut);\\n  }\\n\\n  // External functions\\n\\n  function getParams()\\n    external\\n    view\\n    returns (\\n      address,\\n      address,\\n      uint256,\\n      uint32\\n    )\\n  {\\n    return (address(uniRouter), oracle, maxVbtcWeight, blockTimestampLast);\\n  }\\n\\n  function deployPool(uint256 initialSwapFee) external {\\n    require(address(bPool) == address(0), \\\"already initialized\\\");\\n\\n    // get price\\n    uint256 vBtcBal = vBtc.balanceOf(address(this));\\n    require(vBtcBal > 0, \\\"missing initial vBTC bal\\\");\\n    // check denorm amount\\n    uint256 btcInEthPrice = IBtcPriceOracle(oracle).consult(vBtcBal);\\n    require(wEth.balanceOf(address(this)) == btcInEthPrice, \\\"missing initial WETH bal\\\");\\n\\n    // deploy bpool\\n    bPool = bFactory.newBPool();\\n\\n    // approve vBTC and weth to bpool and uni pool\\n    vBtc.approve(address(bPool), MAX_UINT);\\n    vBtc.approve(address(uniRouter), MAX_UINT);\\n    wEth.approve(address(bPool), MAX_UINT);\\n    wEth.approve(address(uniRouter), MAX_UINT);\\n\\n    // bind assets\\n    bPool.bind(address(vBtc), vBtcBal, DEFAULT_WEIGHT);\\n    bPool.bind(address(wEth), btcInEthPrice, DEFAULT_WEIGHT);\\n\\n    // set fee, go public and issue shares\\n    bPool.setSwapFee(initialSwapFee);\\n    bPool.setPublicSwap(true);\\n    _mint(msg.sender, MIN_POOL_SUPPLY);\\n  }\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external {\\n    require(deadline >= block.timestamp, \\\"vBTC: EXPIRED\\\");\\n    bytes32 digest = keccak256(\\n      abi.encodePacked(\\n        \\\"\\\\x19\\\\x01\\\",\\n        DOMAIN_SEPARATOR,\\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n      )\\n    );\\n    address recoveredAddress = ecrecover(digest, v, r, s);\\n    require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"VBTC: INVALID_SIGNATURE\\\");\\n    _approve(owner, spender, value);\\n  }\\n\\n  /**\\n   * @notice Join a pool\\n   * @dev Emits a LogJoin event (for each token)\\n   *      bPool is a contract interface; function calls on it are external\\n   * @param poolAmountOut - number of pool tokens to receive\\n   * @param maxAmountsIn - Max amount of asset tokens to spend\\n   */\\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external {\\n    _joinPool(poolAmountOut, maxAmountsIn, 0, 0, 0x0, 0x0);\\n  }\\n\\n  // TODO: join pool with ether and vBtc permit, so no approval is needed\\n  // signature is only for vBtc\\n  // the function also takes ETH or WETH\\n  function joinPoolDirectly(\\n    uint256 poolAmountOut,\\n    uint256[] calldata maxAmountsIn,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external payable {\\n    _joinPool(poolAmountOut, maxAmountsIn, deadline, v, r, s);\\n  }\\n\\n  /**\\n   * @notice Exit a pool - redeem pool tokens for underlying assets\\n   * @dev Emits a LogExit event for each token\\n   *      bPool is a contract interface; function calls on it are external\\n   * @param poolAmountIn - amount of pool tokens to redeem\\n   * @param minAmountsOut - minimum amount of asset tokens to receive\\n   */\\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external {\\n    address[] memory tokens = bPool.getCurrentTokens();\\n\\n    require(minAmountsOut.length == tokens.length, \\\"ERR_AMOUNTS_MISMATCH\\\");\\n\\n    uint256 ratio = bdiv(poolAmountIn, badd(totalSupply(), 1));\\n\\n    // This loop contains external calls\\n    // External calls are to math libraries or the underlying pool, so low risk\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address t = tokens[i];\\n      uint256 bal = bPool.getBalance(t);\\n      // Subtract 1 to ensure any rounding errors favor the pool\\n      uint256 tokenAmountOut = bmul(ratio, bsub(bal, 1));\\n\\n      require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n      require(tokenAmountOut >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n\\n      emit LogExit(msg.sender, t, tokenAmountOut);\\n\\n      _pushUnderlying(t, msg.sender, tokenAmountOut);\\n    }\\n\\n    _burn(msg.sender, poolAmountIn);\\n  }\\n\\n  /**\\n   * @notice Join by swapping a fixed amount of an external token in (must be present in the pool)\\n   *         System calculates the pool token amount\\n   * @dev emits a LogJoin event\\n   * @param tokenIn - which token we're transferring in\\n   * @param tokenAmountIn - amount of deposit\\n   * @param minPoolAmountOut - minimum of pool tokens to receive\\n   * @return poolAmountOut - amount of pool tokens minted and transferred\\n   */\\n  function joinswapExternAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    uint256 minPoolAmountOut\\n  ) external returns (uint256 poolAmountOut) {\\n    require(bPool.isBound(tokenIn), \\\"ERR_NOT_BOUND\\\");\\n    uint256 balTokenIn = bPool.getBalance(tokenIn);\\n    require(tokenAmountIn <= bmul(balTokenIn, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n    poolAmountOut = calcPoolOutGivenSingleIn(\\n      balTokenIn,\\n      bPool.getDenormalizedWeight(tokenIn),\\n      totalSupply(),\\n      bPool.getTotalDenormalizedWeight(),\\n      tokenAmountIn,\\n      bPool.getSwapFee()\\n    );\\n\\n    require(poolAmountOut >= minPoolAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n    emit LogJoin(msg.sender, tokenIn, tokenAmountIn);\\n\\n    _mint(msg.sender, poolAmountOut);\\n    _pullUnderlying(tokenIn, balTokenIn, msg.sender, tokenAmountIn);\\n\\n    return poolAmountOut;\\n  }\\n\\n  /**\\n   * @notice Join by swapping an external token in (must be present in the pool)\\n   *         To receive an exact amount of pool tokens out. System calculates the deposit amount\\n   * @dev emits a LogJoin event\\n   * @param tokenIn - which token we're transferring in (system calculates amount required)\\n   * @param poolAmountOut - amount of pool tokens to be received\\n   * @param maxAmountIn - Maximum asset tokens that can be pulled to pay for the pool tokens\\n   * @return tokenAmountIn - amount of asset tokens transferred in to purchase the pool tokens\\n   */\\n  function joinswapPoolAmountOut(\\n    address tokenIn,\\n    uint256 poolAmountOut,\\n    uint256 maxAmountIn\\n  ) external returns (uint256 tokenAmountIn) {\\n    require(bPool.isBound(tokenIn), \\\"ERR_NOT_BOUND\\\");\\n\\n    uint256 balTokenIn = bPool.getBalance(tokenIn);\\n    tokenAmountIn = calcSingleInGivenPoolOut(\\n      balTokenIn,\\n      bPool.getDenormalizedWeight(tokenIn),\\n      totalSupply(),\\n      bPool.getTotalDenormalizedWeight(),\\n      poolAmountOut,\\n      bPool.getSwapFee()\\n    );\\n\\n    require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n    require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n    require(tokenAmountIn <= bmul(balTokenIn, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n    emit LogJoin(msg.sender, tokenIn, tokenAmountIn);\\n\\n    _mint(msg.sender, poolAmountOut);\\n    _pullUnderlying(tokenIn, balTokenIn, msg.sender, tokenAmountIn);\\n\\n    return tokenAmountIn;\\n  }\\n\\n  /**\\n   * @notice Exit a pool - redeem pool tokens for a specific amount of underlying assets\\n   *         Asset must be present in the pool\\n   * @dev Emits a LogExit event for the token\\n   * @param tokenOut - which token the caller wants to receive\\n   * @param tokenAmountOut - amount of underlying asset tokens to receive\\n   * @param maxPoolAmountIn - maximum pool tokens to be redeemed\\n   * @return poolAmountIn - amount of pool tokens redeemed\\n   */\\n  function exitswapExternAmountOut(\\n    address tokenOut,\\n    uint256 tokenAmountOut,\\n    uint256 maxPoolAmountIn\\n  ) external returns (uint256 poolAmountIn) {\\n    require(bPool.isBound(tokenOut), \\\"ERR_NOT_BOUND\\\");\\n    uint256 balTokenIn = bPool.getBalance(tokenOut);\\n    require(tokenAmountOut <= bmul(balTokenIn, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n    poolAmountIn = calcPoolInGivenSingleOut(\\n      balTokenIn,\\n      bPool.getDenormalizedWeight(tokenOut),\\n      totalSupply(),\\n      bPool.getTotalDenormalizedWeight(),\\n      tokenAmountOut,\\n      bPool.getSwapFee()\\n    );\\n\\n    require(poolAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n    require(poolAmountIn <= maxPoolAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n    emit LogExit(msg.sender, tokenOut, tokenAmountOut);\\n\\n    _burn(msg.sender, poolAmountIn);\\n    _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n    return poolAmountIn;\\n  }\\n\\n  /**\\n   * @notice Update the weight of a token without changing the price (or transferring tokens)\\n   * @dev Checks if the token's current pool balance has deviated from cached balance,\\n   *      if so it adjusts the token's weights proportional to the deviation.\\n   *      The underlying BPool enforces bounds on MIN_WEIGHTS=1e18, MAX_WEIGHT=50e18 and TOTAL_WEIGHT=50e18.\\n   *      NOTE: The BPool.rebind function CAN REVERT if the updated weights go beyond the enforced bounds.\\n   */\\n  function resyncWeights() external {\\n    // simple check for re-entrancy\\n    require(msg.sender == tx.origin, \\\"caller not EOA\\\");\\n    // read FEED price of BTC ()\\n    uint256 truePriceBtc = 10**18;\\n    uint256 truePriceEth = IBtcPriceOracle(oracle).consult(truePriceBtc);\\n\\n    // true price is expressed as a ratio, so both values must be non-zero\\n    require(truePriceBtc != 0, \\\"ReservePool: ZERO_PRICE\\\");\\n\\n    // deal with spot pool\\n    bool isEthToVbtc;\\n    uint256 tradeAmount;\\n    {\\n      // read SPOT price of vBTC\\n      (uint256 reserveWeth, uint256 reserveVbtc) = getReserves(\\n        uniRouter.factory(),\\n        address(wEth),\\n        address(vBtc)\\n      );\\n      // how much ETH (including UNI fee) is needed to lift SPOT to FEED?\\n      (isEthToVbtc, tradeAmount) = computeProfitMaximizingTrade(\\n        truePriceEth,\\n        truePriceBtc,\\n        reserveWeth,\\n        reserveVbtc\\n      );\\n    }\\n\\n    // deal with reserve pool\\n    uint256 vBtcToBorrow = tradeAmount;\\n    uint256 vBtcWeight = bPool.getDenormalizedWeight(address(vBtc));\\n    if (isEthToVbtc) {\\n      // calculate amount vBTC to get the needed ETH from reserve pool\\n      {\\n        uint256 tokenBalanceIn = bPool.getBalance(address(vBtc));\\n        uint256 tokenBalanceOut = bPool.getBalance(address(wEth));\\n        uint256 tokenWeightOut = bPool.getDenormalizedWeight(address(wEth));\\n        uint256 swapFee = bPool.getSwapFee();\\n        vBtcToBorrow = calcInGivenOut(\\n          tokenBalanceIn,\\n          vBtcWeight,\\n          tokenBalanceOut,\\n          tokenWeightOut,\\n          tradeAmount, // amount of ETH we want to get out\\n          swapFee\\n        );\\n      }\\n    }\\n    // encode direction and old weight together\\n    bytes32 data = bytes32((uint256(isEthToVbtc ? 1 : 0) << 248) | vBtcWeight);\\n    // get the loan\\n    ILender(address(vBtc)).flashMint(vBtcToBorrow, data);\\n\\n    // if any earnings remain (rounding error?), reward msg.sender\\n    uint256 remainder = vBtc.balanceOf(address(this));\\n    if (remainder > 0) {\\n      vBtc.transfer(msg.sender, remainder);\\n    }\\n  }\\n\\n  function executeOnFlashMint(uint256 amount, bytes32 data) external override {\\n    // check sender\\n    require(msg.sender == address(vBtc), \\\"who are you?!\\\");\\n    // check amount\\n    require(vBtc.balanceOf(address(this)) >= amount, \\\"loan error\\\");\\n    // we received a bunch of vBTC here\\n    // read direction, then do the trade, trust that amounts were calculated correctly\\n    bool isEthToVbtc = (uint256(data) >> 248) != 0;\\n    uint256 oldVbtcWeight = (uint256(data) << 8) >> 8;\\n    address tokenIn = isEthToVbtc ? address(wEth) : address(vBtc);\\n    address tokenOut = isEthToVbtc ? address(vBtc) : address(wEth);\\n    uint256 tradeAmount = amount;\\n    emit Trade(isEthToVbtc, tradeAmount);\\n\\n    if (isEthToVbtc) {\\n      // we want to trade eth to vBTC in UNI, so let's get the ETH\\n      // 4. buy ETH in reserve pool with all vBTC\\n      (tradeAmount, ) = bPool.swapExactAmountIn( // returns uint tokenAmountOut, uint spotPriceAfter\\n        address(vBtc),\\n        amount,\\n        address(wEth),\\n        0, // minAmountOut\\n        MAX_UINT\\n      ); // maxPrice\\n    }\\n\\n    // approve should have been done in constructor\\n    // TransferHelper.safeApprove(tokenIn, address(router), tradeAmount);\\n\\n    address[] memory path = new address[](2);\\n    path[0] = tokenIn;\\n    path[1] = tokenOut;\\n    // 5. sell ETH in spot pool\\n    uint256[] memory amounts = IUniswapV2Router01(uniRouter).swapExactTokensForTokens(\\n      tradeAmount,\\n      0, // amountOutMin: we can skip computing this number because the math is tested\\n      path,\\n      address(this),\\n      MAX_UINT // deadline\\n    );\\n\\n    if (!isEthToVbtc) {\\n      // we traded vBTC for ETH in uni, now let's use it in balancer\\n      (tradeAmount, ) = bPool.swapExactAmountIn( // returns uint tokenAmountOut, uint spotPriceAfter\\n        address(wEth), // address tokenIn,\\n        amounts[1], // uint256 tokenAmountIn,\\n        address(vBtc), // address tokenOut,\\n        0, // minAmountOut\\n        MAX_UINT // maxPrice\\n      );\\n    }\\n\\n    // adjusts weight in reserve pool\\n    {\\n      // read uni weights\\n      (uint256 reserveWeth, uint256 reserveVbtc) = getReserves(\\n        uniRouter.factory(),\\n        address(wEth),\\n        address(vBtc)\\n      );\\n      uint256 vBtcBalance = bPool.getBalance(address(vBtc));\\n      uint256 wEthBalance = bPool.getBalance(address(wEth));\\n      // check that new weight does not exceed max weight\\n      uint256 newVbtcWeight = wEthBalance.mul(DEFAULT_WEIGHT).mul(reserveVbtc).div(vBtcBalance).div(\\n        reserveWeth\\n      );\\n      // if trade moves away from equal balance, slow it down\\n      if (newVbtcWeight > oldVbtcWeight && newVbtcWeight > DEFAULT_WEIGHT) {\\n        require(now.sub(blockTimestampLast) > 24 hours, \\\"hold the unicorns\\\");\\n      }\\n      blockTimestampLast = uint32(now);\\n      require(newVbtcWeight < maxVbtcWeight, \\\"max weight error\\\");\\n      // adjust weights so there is no arbitrage\\n      IBPool(bPool).rebind(address(vBtc), vBtcBalance, newVbtcWeight);\\n      IBPool(bPool).rebind(address(wEth), wEthBalance, DEFAULT_WEIGHT);\\n    }\\n\\n    // repay loan\\n    // TODO: what about the flash loan fee?\\n  }\\n\\n  // governance function\\n  function setParams(\\n    address _uniRouter,\\n    address _oracle,\\n    uint256 _maxVbtcWeight,\\n    uint256 _swapFee,\\n    bool _isPublicSwap\\n  ) external onlyOwner {\\n    uniRouter = IUniswapV2Router01(_uniRouter);\\n\\n    require(_oracle != address(0), \\\"!oracle-0\\\");\\n    oracle = _oracle;\\n\\n    require(_maxVbtcWeight >= DEFAULT_WEIGHT / 5, \\\"set max weight too low error\\\");\\n    require(_maxVbtcWeight <= DEFAULT_WEIGHT * 9, \\\"set max weight too high error\\\");\\n    maxVbtcWeight = _maxVbtcWeight;\\n\\n    bPool.setSwapFee(_swapFee);\\n    bPool.setPublicSwap(_isPublicSwap);\\n    //TODO: swipe contract, if needed\\n  }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/IWETH9.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface IWETH9 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function balanceOf(address) external view returns (uint256);\\n\\n  function allowance(address, address) external view returns (uint256);\\n\\n  function deposit() external payable;\\n\\n  function withdraw(uint256 wad) external;\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function approve(address guy, uint256 wad) external returns (bool);\\n\\n  function transfer(address dst, uint256 wad) external returns (bool);\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 wad\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Timelock.sol\": {\r\n      \"content\": \"// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\\n// Copyright 2020 Compound Labs, Inc.\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n//\\n// Ctrl+f for XXX to see all the modifications.\\n\\n// XXX: pragma solidity ^0.5.16;\\npragma solidity 0.6.6;\\n\\n// XXX: import \\\"./SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\ncontract Timelock {\\n  using SafeMath for uint256;\\n\\n  event NewAdmin(address indexed newAdmin);\\n  event NewPendingAdmin(address indexed newPendingAdmin);\\n  event NewDelay(uint256 indexed newDelay);\\n  event CancelTransaction(\\n    bytes32 indexed txHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 eta\\n  );\\n  event ExecuteTransaction(\\n    bytes32 indexed txHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 eta\\n  );\\n  event QueueTransaction(\\n    bytes32 indexed txHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 eta\\n  );\\n\\n  uint256 public constant GRACE_PERIOD = 14 days;\\n  uint256 public constant MINIMUM_DELAY = 1 days;\\n  uint256 public constant MAXIMUM_DELAY = 30 days;\\n\\n  address public admin;\\n  address public pendingAdmin;\\n  uint256 public delay;\\n  bool public admin_initialized;\\n\\n  mapping(bytes32 => bool) public queuedTransactions;\\n\\n  constructor(address admin_, uint256 delay_) public {\\n    require(delay_ >= MINIMUM_DELAY, \\\"Timelock::constructor: Delay must exceed minimum delay.\\\");\\n    require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::constructor: Delay must not exceed maximum delay.\\\");\\n\\n    admin = admin_;\\n    delay = delay_;\\n    admin_initialized = false;\\n  }\\n\\n  // XXX: function() external payable { }\\n  receive() external payable {}\\n\\n  function setDelay(uint256 delay_) public {\\n    require(msg.sender == address(this), \\\"Timelock::setDelay: Call must come from Timelock.\\\");\\n    require(delay_ >= MINIMUM_DELAY, \\\"Timelock::setDelay: Delay must exceed minimum delay.\\\");\\n    require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n    delay = delay_;\\n\\n    emit NewDelay(delay);\\n  }\\n\\n  function acceptAdmin() public {\\n    require(msg.sender == pendingAdmin, \\\"Timelock::acceptAdmin: Call must come from pendingAdmin.\\\");\\n    admin = msg.sender;\\n    pendingAdmin = address(0);\\n\\n    emit NewAdmin(admin);\\n  }\\n\\n  function setPendingAdmin(address pendingAdmin_) public {\\n    // allows one time setting of admin for deployment purposes\\n    if (admin_initialized) {\\n      require(\\n        msg.sender == address(this),\\n        \\\"Timelock::setPendingAdmin: Call must come from Timelock.\\\"\\n      );\\n    } else {\\n      require(msg.sender == admin, \\\"Timelock::setPendingAdmin: First call must come from admin.\\\");\\n      admin_initialized = true;\\n    }\\n    pendingAdmin = pendingAdmin_;\\n\\n    emit NewPendingAdmin(pendingAdmin);\\n  }\\n\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 eta\\n  ) public returns (bytes32) {\\n    require(msg.sender == admin, \\\"Timelock::queueTransaction: Call must come from admin.\\\");\\n    require(\\n      eta >= getBlockTimestamp().add(delay),\\n      \\\"Timelock::queueTransaction: Estimated execution block must satisfy delay.\\\"\\n    );\\n\\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n    queuedTransactions[txHash] = true;\\n\\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\\n    return txHash;\\n  }\\n\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 eta\\n  ) public {\\n    require(msg.sender == admin, \\\"Timelock::cancelTransaction: Call must come from admin.\\\");\\n\\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n    queuedTransactions[txHash] = false;\\n\\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\\n  }\\n\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 eta\\n  ) public payable returns (bytes memory) {\\n    require(msg.sender == admin, \\\"Timelock::executeTransaction: Call must come from admin.\\\");\\n\\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n    require(\\n      queuedTransactions[txHash],\\n      \\\"Timelock::executeTransaction: Transaction hasn't been queued.\\\"\\n    );\\n    require(\\n      getBlockTimestamp() >= eta,\\n      \\\"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\\\"\\n    );\\n    require(\\n      getBlockTimestamp() <= eta.add(GRACE_PERIOD),\\n      \\\"Timelock::executeTransaction: Transaction is stale.\\\"\\n    );\\n\\n    queuedTransactions[txHash] = false;\\n\\n    bytes memory callData;\\n\\n    if (bytes(signature).length == 0) {\\n      callData = data;\\n    } else {\\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n    }\\n\\n    // solium-disable-next-line security/no-call-value\\n    (bool success, bytes memory returnData) = target.call{value: value}(callData);\\n    require(success, \\\"Timelock::executeTransaction: Transaction execution reverted.\\\");\\n\\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\\n\\n    return returnData;\\n  }\\n\\n  function getBlockTimestamp() internal view returns (uint256) {\\n    // solium-disable-next-line security/no-block-members\\n    return block.timestamp;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/TorchShip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\nimport \\\"./StrudelToken.sol\\\";\\n\\n// The torchship has brought them to Ganymede, where they have to pulverize boulders and lava flows, and seed the resulting dust with carefully formulated organic material.\\n//\\n// Note that it's ownable and the owner wields tremendous power. The ownership\\n// will be transferred to a governance smart contract once STRDLS is sufficiently\\n// distributed and the community can show to govern itself.\\n//\\n// Have fun reading it. Hopefully it's bug-free. God bless.\\ncontract TorchShip is Initializable, ContextUpgradeSafe, OwnableUpgradeSafe {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  // Events\\n  event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n  event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n  event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n\\n  // Info of each user.\\n  struct UserInfo {\\n    uint256 amount; // How many LP tokens the user has provided.\\n    uint256 rewardDebt; // Reward debt. See explanation below.\\n    //\\n    // We do some fancy math here. Basically, any point in time, the amount of STRDLs\\n    // entitled to a user but is pending to be distributed is:\\n    //\\n    //   pending reward = (user.amount * pool.accStrudelPerShare) - user.rewardDebt\\n    //\\n    // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\\n    //   1. The pool's `accStrudelPerShare` (and `lastRewardBlock`) gets updated.\\n    //   2. User receives the pending reward sent to his/her address.\\n    //   3. User's `amount` gets updated.\\n    //   4. User's `rewardDebt` gets updated.\\n  }\\n\\n  // Info of each pool.\\n  struct PoolInfo {\\n    IERC20 lpToken; // Address of LP token contract.\\n    uint256 allocPoint; // How many allocation points assigned to this pool. STRDLs to distribute per block.\\n    uint256 lastRewardBlock; // Last block number that STRDLs distribution occurs.\\n    uint256 accStrudelPerShare; // Accumulated STRDLs per share, times 1e12. See below.\\n  }\\n\\n  // immutable\\n  StrudelToken private strudel;\\n\\n  // governance params\\n  // Dev fund\\n  uint256 public devFundDivRate;\\n  // Block number when bonus STRDL period ends.\\n  uint256 public bonusEndBlock;\\n  // STRDL tokens created per block.\\n  uint256 public strudelPerBlock;\\n  // Bonus muliplier for early strudel makers.\\n  uint256 public bonusMultiplier;\\n  // The block number when STRDL mining starts.\\n  uint256 public startBlock;\\n\\n  // working memory\\n  // Info of each pool.\\n  PoolInfo[] public poolInfo;\\n  // Info of each user that stakes LP tokens.\\n  mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n  // Total allocation points. Must be the sum of all allocation points in all pools.\\n  uint256 public totalAllocPoint;\\n\\n  function initialize(\\n    address _strudel,\\n    uint256 _strudelPerBlock,\\n    uint256 _startBlock,\\n    uint256 _bonusEndBlock,\\n    uint256 _bonusMultiplier\\n  ) public initializer {\\n    __Ownable_init();\\n    strudel = StrudelToken(_strudel);\\n    require(_strudelPerBlock >= 10**15, \\\"forgot the decimals for $TRDL?\\\");\\n    strudelPerBlock = _strudelPerBlock;\\n    bonusEndBlock = _bonusEndBlock;\\n    startBlock = _startBlock;\\n    bonusMultiplier = _bonusMultiplier;\\n    totalAllocPoint = 0;\\n    devFundDivRate = 17;\\n  }\\n\\n  // Safe strudel transfer function, just in case if rounding error causes pool to not have enough STRDLs.\\n  function safeStrudelTransfer(address _to, uint256 _amount) internal {\\n    uint256 strudelBal = strudel.balanceOf(address(this));\\n    if (_amount > strudelBal) {\\n      strudel.transfer(_to, strudelBal);\\n    } else {\\n      strudel.transfer(_to, _amount);\\n    }\\n  }\\n\\n  function poolLength() external view returns (uint256) {\\n    return poolInfo.length;\\n  }\\n\\n  // Return reward multiplier over the given _from to _to block.\\n  function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\\n    if (_to <= bonusEndBlock) {\\n      return _to.sub(_from).mul(bonusMultiplier);\\n    } else if (_from >= bonusEndBlock) {\\n      return _to.sub(_from);\\n    } else {\\n      return bonusEndBlock.sub(_from).mul(bonusMultiplier).add(_to.sub(bonusEndBlock));\\n    }\\n  }\\n\\n  // View function to see pending STRDLs on frontend.\\n  function pendingStrudel(uint256 _pid, address _user) external view returns (uint256) {\\n    PoolInfo storage pool = poolInfo[_pid];\\n    UserInfo storage user = userInfo[_pid][_user];\\n    uint256 accStrudelPerShare = pool.accStrudelPerShare;\\n    uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n    if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n      uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n      uint256 strudelReward = multiplier.mul(strudelPerBlock).mul(pool.allocPoint).div(\\n        totalAllocPoint\\n      );\\n      accStrudelPerShare = accStrudelPerShare.add(strudelReward.mul(1e12).div(lpSupply));\\n    }\\n    return user.amount.mul(accStrudelPerShare).div(1e12).sub(user.rewardDebt);\\n  }\\n\\n  // Update reward vairables for all pools. Be careful of gas spending!\\n  function massUpdatePools() public {\\n    uint256 length = poolInfo.length;\\n    for (uint256 pid = 0; pid < length; ++pid) {\\n      updatePool(pid);\\n    }\\n  }\\n\\n  // Update reward variables of the given pool to be up-to-date.\\n  function updatePool(uint256 _pid) public {\\n    PoolInfo storage pool = poolInfo[_pid];\\n    if (block.number <= pool.lastRewardBlock) {\\n      return;\\n    }\\n    uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n    if (lpSupply == 0) {\\n      pool.lastRewardBlock = block.number;\\n      return;\\n    }\\n    uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n    uint256 strudelReward = multiplier.mul(strudelPerBlock).mul(pool.allocPoint).div(\\n      totalAllocPoint\\n    );\\n    strudel.mint(owner(), strudelReward.div(devFundDivRate));\\n    strudel.mint(address(this), strudelReward);\\n    pool.accStrudelPerShare = pool.accStrudelPerShare.add(strudelReward.mul(1e12).div(lpSupply));\\n    pool.lastRewardBlock = block.number;\\n  }\\n\\n  // Deposit LP tokens to TorchShip for STRDL allocation.\\n  function deposit(uint256 _pid, uint256 _amount) external {\\n    PoolInfo storage pool = poolInfo[_pid];\\n    UserInfo storage user = userInfo[_pid][msg.sender];\\n    updatePool(_pid);\\n    if (user.amount > 0) {\\n      uint256 pending = user.amount.mul(pool.accStrudelPerShare).div(1e12).sub(user.rewardDebt);\\n      safeStrudelTransfer(msg.sender, pending);\\n    }\\n    pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\\n    user.amount = user.amount.add(_amount);\\n    user.rewardDebt = user.amount.mul(pool.accStrudelPerShare).div(1e12);\\n    emit Deposit(msg.sender, _pid, _amount);\\n  }\\n\\n  // Withdraw LP tokens from TorchShip.\\n  function withdraw(uint256 _pid, uint256 _amount) external {\\n    PoolInfo storage pool = poolInfo[_pid];\\n    UserInfo storage user = userInfo[_pid][msg.sender];\\n    require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n    updatePool(_pid);\\n    uint256 pending = user.amount.mul(pool.accStrudelPerShare).div(1e12).sub(user.rewardDebt);\\n    safeStrudelTransfer(msg.sender, pending);\\n    user.amount = user.amount.sub(_amount);\\n    user.rewardDebt = user.amount.mul(pool.accStrudelPerShare).div(1e12);\\n    pool.lpToken.safeTransfer(address(msg.sender), _amount);\\n    emit Withdraw(msg.sender, _pid, _amount);\\n  }\\n\\n  // Withdraw without caring about rewards. EMERGENCY ONLY.\\n  function emergencyWithdraw(uint256 _pid) external {\\n    PoolInfo storage pool = poolInfo[_pid];\\n    UserInfo storage user = userInfo[_pid][msg.sender];\\n    pool.lpToken.safeTransfer(address(msg.sender), user.amount);\\n    emit EmergencyWithdraw(msg.sender, _pid, user.amount);\\n    user.amount = 0;\\n    user.rewardDebt = 0;\\n  }\\n\\n  // governance functions:\\n\\n  // Add a new lp to the pool. Can only be called by the owner.\\n  // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n  function add(\\n    uint256 _allocPoint,\\n    IERC20 _lpToken,\\n    bool _withUpdate\\n  ) public onlyOwner {\\n    if (_withUpdate) {\\n      massUpdatePools();\\n    }\\n    uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\\n    totalAllocPoint = totalAllocPoint.add(_allocPoint);\\n    poolInfo.push(\\n      PoolInfo({\\n        lpToken: _lpToken,\\n        allocPoint: _allocPoint,\\n        lastRewardBlock: lastRewardBlock,\\n        accStrudelPerShare: 0\\n      })\\n    );\\n  }\\n\\n  // Update the given pool's STRDL allocation point. Can only be called by the owner.\\n  function set(\\n    uint256 _pid,\\n    uint256 _allocPoint,\\n    bool _withUpdate\\n  ) public onlyOwner {\\n    if (_withUpdate) {\\n      massUpdatePools();\\n    }\\n    totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\n    poolInfo[_pid].allocPoint = _allocPoint;\\n  }\\n\\n  function setDevFundDivRate(uint256 _devFundDivRate) public onlyOwner {\\n    require(_devFundDivRate > 0, \\\"!devFundDivRate-0\\\");\\n    devFundDivRate = _devFundDivRate;\\n  }\\n\\n  function setBonusEndBlock(uint256 _bonusEndBlock) public onlyOwner {\\n    bonusEndBlock = _bonusEndBlock;\\n  }\\n\\n  function setStrudelPerBlock(uint256 _strudelPerBlock) public onlyOwner {\\n    require(_strudelPerBlock > 0, \\\"!strudelPerBlock-0\\\");\\n    strudelPerBlock = _strudelPerBlock;\\n  }\\n\\n  function setBonusMultiplier(uint256 _bonusMultiplier) public onlyOwner {\\n    require(_bonusMultiplier > 0, \\\"!bonusMultiplier-0\\\");\\n    bonusMultiplier = _bonusMultiplier;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface IUniswapV2Factory {\\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n\\n  function feeTo() external view returns (address);\\n\\n  function feeToSetter() external view returns (address);\\n\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n  function allPairs(uint256) external view returns (address pair);\\n\\n  function allPairsLength() external view returns (uint256);\\n\\n  function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n  function setFeeTo(address) external;\\n\\n  function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface IUniswapV2Pair {\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  function name() external pure returns (string memory);\\n\\n  function symbol() external pure returns (string memory);\\n\\n  function decimals() external pure returns (uint8);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address owner) external view returns (uint256);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  function approve(address spender, uint256 value) external returns (bool);\\n\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  function nonces(address owner) external view returns (uint256);\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n  event Swap(\\n    address indexed sender,\\n    uint256 amount0In,\\n    uint256 amount1In,\\n    uint256 amount0Out,\\n    uint256 amount1Out,\\n    address indexed to\\n  );\\n  event Sync(uint112 reserve0, uint112 reserve1);\\n\\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n  function factory() external view returns (address);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n\\n  function price0CumulativeLast() external view returns (uint256);\\n\\n  function price1CumulativeLast() external view returns (uint256);\\n\\n  function kLast() external view returns (uint256);\\n\\n  function mint(address to) external returns (uint256 liquidity);\\n\\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n  function swap(\\n    uint256 amount0Out,\\n    uint256 amount1Out,\\n    address to,\\n    bytes calldata data\\n  ) external;\\n\\n  function skim(address to) external;\\n\\n  function sync() external;\\n\\n  function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256 amountETH);\\n\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint256 amountETH);\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external;\\n\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable;\\n\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITokenRecipient\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StrudelToken","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]