[{"SourceCode":"pragma solidity 0.5.10;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\ninterface IDistribution {\r\n    function supply() external view returns(uint256);\r\n    function poolAddress(uint8) external view returns(address);\r\n}\r\n\r\n\r\n\r\ncontract Sacrifice {\r\n    constructor(address payable _recipient) public payable {\r\n        selfdestruct(_recipient);\r\n    }\r\n}\r\n\r\n\r\ninterface IERC677MultiBridgeToken {\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferDistribution(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function balanceOf(address _account) external view returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the `IERC20` interface.\r\n *\r\n * This implementation was taken from\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.3.0/contracts/token/ERC20/ERC20.sol\r\n * This differs from the original one only in the definition for the `_balances`\r\n * mapping: we made it `internal` instead of `private` since we use the `_balances`\r\n * in the `ERC677BridgeToken` child contract to be able to transfer tokens to address(0)\r\n * (see its `_superTransfer` function). The original OpenZeppelin implementation\r\n * doesn't allow transferring to address(0).\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using `_mint`.\r\n * For a generic mechanism see `ERC20Mintable`.\r\n *\r\n * *For a detailed writeup see our guide [How to implement supply\r\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See `IERC20.approve`.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) internal _balances; // CHANGED: not private to write a custom transfer method\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See `IERC20.totalSupply`.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.balanceOf`.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transferFrom`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to `transfer`, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a `Transfer` event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a `Transfer` event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See `_burn` and `_approve`.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * > Note that this information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * `IERC20.balanceOf` and `IERC20.transfer`.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Permittable\r\n * @dev This is ERC20 contract extended by the `permit` function (see EIP712).\r\n */\r\ncontract ERC20Permittable is ERC20, ERC20Detailed {\r\n\r\n    string public constant version = \"1\";\r\n\r\n    // EIP712 niceties\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\r\n\r\n    mapping(address => uint256) public nonces;\r\n    mapping(address => mapping(address => uint256)) public expirations;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) ERC20Detailed(_name, _symbol, _decimals) public {\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n            keccak256(bytes(_name)),\r\n            keccak256(bytes(version)),\r\n            1, // Chain ID for Ethereum Mainnet\r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    /// @dev transferFrom in this contract works in a slightly different form than the generic\r\n    /// transferFrom function. This contract allows for \"unlimited approval\".\r\n    /// Should the user approve an address for the maximum uint256 value,\r\n    /// then that address will have unlimited approval until told otherwise.\r\n    /// @param _sender The address of the sender.\r\n    /// @param _recipient The address of the recipient.\r\n    /// @param _amount The value to transfer.\r\n    /// @return Success status.\r\n    function transferFrom(address _sender, address _recipient, uint256 _amount) public returns (bool) {\r\n        _transfer(_sender, _recipient, _amount);\r\n\r\n        if (_sender != msg.sender) {\r\n            uint256 allowedAmount = allowance(_sender, msg.sender);\r\n\r\n            if (allowedAmount != uint256(-1)) {\r\n                // If allowance is limited, adjust it.\r\n                // In this case `transferFrom` works like the generic\r\n                _approve(_sender, msg.sender, allowedAmount.sub(_amount));\r\n            } else {\r\n                // If allowance is unlimited by `permit`, `approve`, or `increaseAllowance`\r\n                // function, don't adjust it. But the expiration date must be empty or in the future\r\n                require(\r\n                    expirations[_sender][msg.sender] == 0 || expirations[_sender][msg.sender] >= _now(),\r\n                    \"expiry is in the past\"\r\n                );\r\n            }\r\n        } else {\r\n            // If `_sender` is `msg.sender`,\r\n            // the function works just like `transfer()`\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev An alias for `transfer` function.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _amount The value to transfer.\r\n    function push(address _to, uint256 _amount) public {\r\n        transferFrom(msg.sender, _to, _amount);\r\n    }\r\n\r\n    /// @dev Makes a request to transfer the specified amount\r\n    /// from the specified address to the caller's address.\r\n    /// @param _from The address of the holder.\r\n    /// @param _amount The value to transfer.\r\n    function pull(address _from, uint256 _amount) public {\r\n        transferFrom(_from, msg.sender, _amount);\r\n    }\r\n\r\n    /// @dev An alias for `transferFrom` function.\r\n    /// @param _from The address of the sender.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _amount The value to transfer.\r\n    function move(address _from, address _to, uint256 _amount) public {\r\n        transferFrom(_from, _to, _amount);\r\n    }\r\n\r\n    /// @dev Allows to spend holder's unlimited amount by the specified spender.\r\n    /// The function can be called by anyone, but requires having allowance parameters\r\n    /// signed by the holder according to EIP712.\r\n    /// @param _holder The holder's address.\r\n    /// @param _spender The spender's address.\r\n    /// @param _nonce The nonce taken from `nonces(_holder)` public getter.\r\n    /// @param _expiry The allowance expiration date (unix timestamp in UTC).\r\n    /// Can be zero for no expiration. Forced to zero if `_allowed` is `false`.\r\n    /// @param _allowed True to enable unlimited allowance for the spender by the holder. False to disable.\r\n    /// @param _v A final byte of signature (ECDSA component).\r\n    /// @param _r The first 32 bytes of signature (ECDSA component).\r\n    /// @param _s The second 32 bytes of signature (ECDSA component).\r\n    function permit(\r\n        address _holder,\r\n        address _spender,\r\n        uint256 _nonce,\r\n        uint256 _expiry,\r\n        bool _allowed,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external {\r\n        require(_expiry == 0 || _now() <= _expiry, \"invalid expiry\");\r\n\r\n        bytes32 digest = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            keccak256(abi.encode(\r\n                PERMIT_TYPEHASH,\r\n                _holder,\r\n                _spender,\r\n                _nonce,\r\n                _expiry,\r\n                _allowed\r\n            ))\r\n        ));\r\n\r\n        require(_holder == ecrecover(digest, _v, _r, _s), \"invalid signature or parameters\");\r\n        require(_nonce == nonces[_holder]++, \"invalid nonce\");\r\n\r\n        uint256 amount = _allowed ? uint256(-1) : 0;\r\n        _approve(_holder, _spender, amount);\r\n\r\n        expirations[_holder][_spender] = _allowed ? _expiry : 0;\r\n    }\r\n\r\n    function _now() internal view returns(uint256) {\r\n        return now;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n// This is a base staking token ERC677 contract for Ethereum Mainnet side\r\n// which is derived by the child ERC677MultiBridgeToken contract.\r\ncontract ERC677BridgeToken is Ownable, ERC20Permittable {\r\n    using SafeERC20 for ERC20;\r\n    using Address for address;\r\n\r\n    ///  @dev Distribution contract address.\r\n    address public distributionAddress;\r\n    ///  @dev The PrivateOffering contract address.\r\n    address public privateOfferingDistributionAddress;\r\n    ///  @dev The AdvisorsReward contract address.\r\n    address public advisorsRewardDistributionAddress;\r\n\r\n    /// @dev Mint event.\r\n    /// @param to To address.\r\n    /// @param amount Minted value.\r\n    event Mint(address indexed to, uint256 amount);\r\n\r\n    /// @dev Modified Transfer event with custom data.\r\n    /// @param from From address.\r\n    /// @param to To address.\r\n    /// @param value Transferred value.\r\n    /// @param data Custom data to call after transfer.\r\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\r\n\r\n    /// @dev Emits if custom call after transfer fails.\r\n    /// @param from From address.\r\n    /// @param to To address.\r\n    /// @param value Transferred value.\r\n    event ContractFallbackCallFailed(address from, address to, uint256 value);\r\n\r\n    /// @dev Checks that the recipient address is valid.\r\n    /// @param _recipient Recipient address.\r\n    modifier validRecipient(address _recipient) {\r\n        require(_recipient != address(0) && _recipient != address(this), \"not a valid recipient\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Reverts if called by any account other than the bridge.\r\n    modifier onlyBridge() {\r\n        require(isBridge(msg.sender), \"caller is not the bridge\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Creates a token and mints the whole supply for the Distribution contract.\r\n    /// @param _name Token name.\r\n    /// @param _symbol Token symbol.\r\n    /// @param _distributionAddress The address of the deployed Distribution contract.\r\n    /// @param _privateOfferingDistributionAddress The address of the PrivateOffering contract.\r\n    /// @param _advisorsRewardDistributionAddress The address of the AdvisorsReward contract.\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _distributionAddress,\r\n        address _privateOfferingDistributionAddress,\r\n        address _advisorsRewardDistributionAddress\r\n    ) ERC20Permittable(_name, _symbol, 18) public {\r\n        require(\r\n            _distributionAddress.isContract() &&\r\n            _privateOfferingDistributionAddress.isContract() &&\r\n            _advisorsRewardDistributionAddress.isContract(),\r\n            \"not a contract address\"\r\n        );\r\n        uint256 supply = IDistribution(_distributionAddress).supply();\r\n        require(supply > 0, \"the supply must be more than 0\");\r\n        _mint(_distributionAddress, supply);\r\n        distributionAddress = _distributionAddress;\r\n        privateOfferingDistributionAddress = _privateOfferingDistributionAddress;\r\n        advisorsRewardDistributionAddress = _advisorsRewardDistributionAddress;\r\n        emit Mint(_distributionAddress, supply);\r\n    }\r\n\r\n    /// @dev Checks if given address is included into bridge contracts list.\r\n    /// Implemented by a child contract.\r\n    /// @param _address Bridge contract address.\r\n    /// @return bool true, if given address is a known bridge contract.\r\n    function isBridge(address _address) public view returns (bool);\r\n\r\n    /// @dev Extends transfer method with callback.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The value to transfer.\r\n    /// @param _data Custom data.\r\n    /// @return Success status.\r\n    function transferAndCall(\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external validRecipient(_to) returns (bool) {\r\n        _superTransfer(_to, _value);\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n\r\n        if (_to.isContract()) {\r\n            require(_contractFallback(msg.sender, _to, _value, _data), \"contract call failed\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Extends transfer method with event when the callback failed.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The value to transfer.\r\n    /// @return Success status.\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        _superTransfer(_to, _value);\r\n        _callAfterTransfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev This is a copy of `transfer` function which can only be called by distribution contracts.\r\n    /// Made to get rid of `onTokenTransfer` calling to save gas when distributing tokens.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The value to transfer.\r\n    /// @return Success status.\r\n    function transferDistribution(address _to, uint256 _value) public returns (bool) {\r\n        require(\r\n            msg.sender == distributionAddress ||\r\n            msg.sender == privateOfferingDistributionAddress ||\r\n            msg.sender == advisorsRewardDistributionAddress,\r\n            \"wrong sender\"\r\n        );\r\n        _superTransfer(_to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Extends transferFrom method with event when the callback failed.\r\n    /// @param _from The address of the sender.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The value to transfer.\r\n    /// @return Success status.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        _superTransferFrom(_from, _to, _value);\r\n        _callAfterTransfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev If someone sent eth/tokens to the contract mistakenly then the owner can send them back.\r\n    /// @param _token The token address to transfer.\r\n    /// @param _to The address of the recipient.\r\n    function claimTokens(address _token, address payable _to) public onlyOwner validRecipient(_to) {\r\n        if (_token == address(0)) {\r\n            uint256 value = address(this).balance;\r\n            if (!_to.send(value)) { // solium-disable-line security/no-send\r\n                // We use the `Sacrifice` trick to be sure the coins can be 100% sent to the receiver.\r\n                // Otherwise, if the receiver is a contract which has a revert in its fallback function,\r\n                // the sending will fail.\r\n                (new Sacrifice).value(value)(_to);\r\n            }\r\n        } else {\r\n            ERC20 token = ERC20(_token);\r\n            uint256 balance = token.balanceOf(address(this));\r\n            token.safeTransfer(_to, balance);\r\n        }\r\n    }\r\n\r\n    /// @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n    /// the total supply. Emits a `Transfer` event with `from` set to the zero address.\r\n    /// Can only be called by a bridge contract which address is set with `addBridge`.\r\n    /// @param _account The address to mint tokens for. Cannot be zero address.\r\n    /// @param _amount The amount of tokens to mint.\r\n    function mint(address _account, uint256 _amount) external onlyBridge returns(bool) {\r\n        _mint(_account, _amount);\r\n        emit Mint(_account, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev The removed implementation of the ownership renouncing.\r\n    function renounceOwnership() public onlyOwner {\r\n        revert(\"not implemented\");\r\n    }\r\n\r\n    /// @dev Calls transfer method and reverts if it fails.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The value to transfer.\r\n    function _superTransfer(address _to, uint256 _value) internal {\r\n        bool success;\r\n        if (\r\n            msg.sender == distributionAddress ||\r\n            msg.sender == privateOfferingDistributionAddress ||\r\n            msg.sender == advisorsRewardDistributionAddress\r\n        ) {\r\n            // Allow sending tokens to `address(0)` by\r\n            // Distribution, PrivateOffering, or AdvisorsReward contract\r\n            _balances[msg.sender] = _balances[msg.sender].sub(_value);\r\n            _balances[_to] = _balances[_to].add(_value);\r\n            emit Transfer(msg.sender, _to, _value);\r\n            success = true;\r\n        } else {\r\n            success = super.transfer(_to, _value);\r\n        }\r\n        require(success, \"transfer failed\");\r\n    }\r\n\r\n    /// @dev Calls transferFrom method and reverts if it fails.\r\n    /// @param _from The address of the sender.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The value to transfer.\r\n    function _superTransferFrom(address _from, address _to, uint256 _value) internal {\r\n        bool success = super.transferFrom(_from, _to, _value);\r\n        require(success, \"transfer failed\");\r\n    }\r\n\r\n    /// @dev Emits an event when the callback failed.\r\n    /// @param _from The address of the sender.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The transferred value.\r\n    function _callAfterTransfer(address _from, address _to, uint256 _value) internal {\r\n        if (_to.isContract() && !_contractFallback(_from, _to, _value, new bytes(0))) {\r\n            require(!isBridge(_to), \"you can't transfer to bridge contract\");\r\n            require(_to != distributionAddress, \"you can't transfer to Distribution contract\");\r\n            require(_to != privateOfferingDistributionAddress, \"you can't transfer to PrivateOffering contract\");\r\n            require(_to != advisorsRewardDistributionAddress, \"you can't transfer to AdvisorsReward contract\");\r\n            emit ContractFallbackCallFailed(_from, _to, _value);\r\n        }\r\n    }\r\n\r\n    /// @dev Makes a callback after the transfer of tokens.\r\n    /// @param _from The address of the sender.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The transferred value.\r\n    /// @param _data Custom data.\r\n    /// @return Success status.\r\n    function _contractFallback(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        string memory signature = \"onTokenTransfer(address,uint256,bytes)\";\r\n        // solium-disable-next-line security/no-low-level-calls\r\n        (bool success, ) = _to.call(abi.encodeWithSignature(signature, _from, _value, _data));\r\n        return success;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC677MultiBridgeToken\r\n * @dev This contract extends ERC677BridgeToken to support several bridges simultaneously.\r\n */\r\ncontract ERC677MultiBridgeToken is IERC677MultiBridgeToken, ERC677BridgeToken {\r\n    address public constant F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\r\n    uint256 internal constant MAX_BRIDGES = 50;\r\n    mapping(address => address) public bridgePointers;\r\n    uint256 public bridgeCount;\r\n\r\n    event BridgeAdded(address indexed bridge);\r\n    event BridgeRemoved(address indexed bridge);\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _distributionAddress,\r\n        address _privateOfferingDistributionAddress,\r\n        address _advisorsRewardDistributionAddress\r\n    ) public ERC677BridgeToken(\r\n        _name,\r\n        _symbol,\r\n        _distributionAddress,\r\n        _privateOfferingDistributionAddress,\r\n        _advisorsRewardDistributionAddress\r\n    ) {\r\n        bridgePointers[F_ADDR] = F_ADDR; // empty bridge contracts list\r\n    }\r\n\r\n    /// @dev Adds one more bridge contract into the list.\r\n    /// @param _bridge Bridge contract address.\r\n    function addBridge(address _bridge) external onlyOwner {\r\n        require(bridgeCount < MAX_BRIDGES, \"can't add one more bridge due to a limit\");\r\n        require(_bridge.isContract(), \"not a contract address\");\r\n        require(!isBridge(_bridge), \"bridge already exists\");\r\n\r\n        address firstBridge = bridgePointers[F_ADDR];\r\n        require(firstBridge != address(0), \"first bridge is zero address\");\r\n        bridgePointers[F_ADDR] = _bridge;\r\n        bridgePointers[_bridge] = firstBridge;\r\n        bridgeCount = bridgeCount.add(1);\r\n\r\n        emit BridgeAdded(_bridge);\r\n    }\r\n\r\n    /// @dev Removes one existing bridge contract from the list.\r\n    /// @param _bridge Bridge contract address.\r\n    function removeBridge(address _bridge) external onlyOwner {\r\n        require(isBridge(_bridge), \"bridge isn't existed\");\r\n\r\n        address nextBridge = bridgePointers[_bridge];\r\n        address index = F_ADDR;\r\n        address next = bridgePointers[index];\r\n        require(next != address(0), \"zero address found\");\r\n\r\n        while (next != _bridge) {\r\n            index = next;\r\n            next = bridgePointers[index];\r\n\r\n            require(next != F_ADDR && next != address(0), \"invalid address found\");\r\n        }\r\n\r\n        bridgePointers[index] = nextBridge;\r\n        delete bridgePointers[_bridge];\r\n        bridgeCount = bridgeCount.sub(1);\r\n\r\n        emit BridgeRemoved(_bridge);\r\n    }\r\n\r\n    /// @dev Returns all recorded bridge contract addresses.\r\n    /// @return address[] Bridge contract addresses.\r\n    function bridgeList() external view returns (address[] memory) {\r\n        address[] memory list = new address[](bridgeCount);\r\n        uint256 counter = 0;\r\n        address nextBridge = bridgePointers[F_ADDR];\r\n        require(nextBridge != address(0), \"zero address found\");\r\n\r\n        while (nextBridge != F_ADDR) {\r\n            list[counter] = nextBridge;\r\n            nextBridge = bridgePointers[nextBridge];\r\n            counter++;\r\n\r\n            require(nextBridge != address(0), \"zero address found\");\r\n        }\r\n\r\n        return list;\r\n    }\r\n\r\n    /// @dev Checks if given address is included into bridge contracts list.\r\n    /// @param _address Bridge contract address.\r\n    /// @return bool true, if given address is a known bridge contract.\r\n    function isBridge(address _address) public view returns (bool) {\r\n        return _address != F_ADDR && bridgePointers[_address] != address(0);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"removeBridge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bridgePointers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorsRewardDistributionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isBridge\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privateOfferingDistributionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_expiry\",\"type\":\"uint256\"},{\"name\":\"_allowed\",\"type\":\"bool\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"addBridge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridgeList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"push\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"move\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"F_ADDR\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"pull\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridgeCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"expirations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_distributionAddress\",\"type\":\"address\"},{\"name\":\"_privateOfferingDistributionAddress\",\"type\":\"address\"},{\"name\":\"_advisorsRewardDistributionAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bridge\",\"type\":\"address\"}],\"name\":\"BridgeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bridge\",\"type\":\"address\"}],\"name\":\"BridgeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ContractFallbackCallFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ERC677MultiBridgeToken","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000009a3c886ef554cfd07b2065d69b4b52a3d2379a4a000000000000000000000000eb92ecc81b112d614404dcdec73ad5b87b9286450000000000000000000000007471215451f6b300e4b771d4cb5b9797e69d17ab00000000000000000000000000000000000000000000000000000000000000105354414b45207465737420746f6b656e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000653544b5453540000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0ad8413827775c27ddf491b436341ef313c21b1aad827a04e4e91991f6ee4cd7"}]