[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ROOT=/home/achapman/augur/packages/augur-core/src/contracts//\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"constantOptimizer\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"reporting/ReputationToken.sol\": {\r\n      \"content\": \"pragma solidity 0.5.15;\\n\\ncontract IAugur {\\n    function createChildUniverse(bytes32 _parentPayoutDistributionHash, uint256[] memory _parentPayoutNumerators) public returns (IUniverse);\\n    function isKnownUniverse(IUniverse _universe) public view returns (bool);\\n    function trustedCashTransfer(address _from, address _to, uint256 _amount) public returns (bool);\\n    function isTrustedSender(address _address) public returns (bool);\\n    function onCategoricalMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, bytes32[] memory _outcomes) public returns (bool);\\n    function onYesNoMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash) public returns (bool);\\n    function onScalarMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, int256[] memory _prices, uint256 _numTicks)  public returns (bool);\\n    function logInitialReportSubmitted(IUniverse _universe, address _reporter, address _market, address _initialReporter, uint256 _amountStaked, bool _isDesignatedReporter, uint256[] memory _payoutNumerators, string memory _description, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime) public returns (bool);\\n    function disputeCrowdsourcerCreated(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _size, uint256 _disputeRound) public returns (bool);\\n    function logDisputeCrowdsourcerContribution(IUniverse _universe, address _reporter, address _market, address _disputeCrowdsourcer, uint256 _amountStaked, string memory description, uint256[] memory _payoutNumerators, uint256 _currentStake, uint256 _stakeRemaining, uint256 _disputeRound) public returns (bool);\\n    function logDisputeCrowdsourcerCompleted(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime, bool _pacingOn, uint256 _totalRepStakedInPayout, uint256 _totalRepStakedInMarket, uint256 _disputeRound) public returns (bool);\\n    function logInitialReporterRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool);\\n    function logDisputeCrowdsourcerRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool);\\n    function logMarketFinalized(IUniverse _universe, uint256[] memory _winningPayoutNumerators) public returns (bool);\\n    function logMarketMigrated(IMarket _market, IUniverse _originalUniverse) public returns (bool);\\n    function logReportingParticipantDisavowed(IUniverse _universe, IMarket _market) public returns (bool);\\n    function logMarketParticipantsDisavowed(IUniverse _universe) public returns (bool);\\n    function logCompleteSetsPurchased(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\\n    function logCompleteSetsSold(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets, uint256 _fees) public returns (bool);\\n    function logMarketOIChanged(IUniverse _universe, IMarket _market) public returns (bool);\\n    function logTradingProceedsClaimed(IUniverse _universe, address _sender, address _market, uint256 _outcome, uint256 _numShares, uint256 _numPayoutTokens, uint256 _fees) public returns (bool);\\n    function logUniverseForked(IMarket _forkingMarket) public returns (bool);\\n    function logReputationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\\n    function logReputationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\\n    function logReputationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\\n    function logShareTokensBalanceChanged(address _account, IMarket _market, uint256 _outcome, uint256 _balance) public returns (bool);\\n    function logDisputeCrowdsourcerTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\\n    function logDisputeCrowdsourcerTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\\n    function logDisputeCrowdsourcerTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\\n    function logDisputeWindowCreated(IDisputeWindow _disputeWindow, uint256 _id, bool _initial) public returns (bool);\\n    function logParticipationTokensRedeemed(IUniverse universe, address _sender, uint256 _attoParticipationTokens, uint256 _feePayoutShare) public returns (bool);\\n    function logTimestampSet(uint256 _newTimestamp) public returns (bool);\\n    function logInitialReporterTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\\n    function logMarketTransferred(IUniverse _universe, address _from, address _to) public returns (bool);\\n    function logParticipationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\\n    function logParticipationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\\n    function logParticipationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\\n    function logMarketRepBondTransferred(address _universe, address _from, address _to) public returns (bool);\\n    function logWarpSyncDataUpdated(address _universe, uint256 _warpSyncHash, uint256 _marketEndTime) public returns (bool);\\n    function isKnownFeeSender(address _feeSender) public view returns (bool);\\n    function lookup(bytes32 _key) public view returns (address);\\n    function getTimestamp() public view returns (uint256);\\n    function getMaximumMarketEndDate() public returns (uint256);\\n    function isKnownMarket(IMarket _market) public view returns (bool);\\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators, uint256 _numTicks, uint256 numOutcomes) public view returns (bytes32);\\n    function logValidityBondChanged(uint256 _validityBond) public returns (bool);\\n    function logDesignatedReportStakeChanged(uint256 _designatedReportStake) public returns (bool);\\n    function logNoShowBondChanged(uint256 _noShowBond) public returns (bool);\\n    function logReportingFeeChanged(uint256 _reportingFee) public returns (bool);\\n    function getUniverseForkIndex(IUniverse _universe) public view returns (uint256);\\n}\\n\\ncontract IOwnable {\\n    function getOwner() public view returns (address);\\n    function transferOwnership(address _newOwner) public returns (bool);\\n}\\n\\ncontract ITyped {\\n    function getTypeName() public view returns (bytes32);\\n}\\n\\nlibrary SafeMathUint256 {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        return a - b;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n        return c;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a <= b) {\\n            return a;\\n        } else {\\n            return b;\\n        }\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a >= b) {\\n            return a;\\n        } else {\\n            return b;\\n        }\\n    }\\n\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            uint256 x = (y + 1) / 2;\\n            z = y;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n    function getUint256Min() internal pure returns (uint256) {\\n        return 0;\\n    }\\n\\n    function getUint256Max() internal pure returns (uint256) {\\n        // 2 ** 256 - 1\\n        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n    }\\n\\n    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\\n        return a % b == 0;\\n    }\\n\\n    // Float [fixed point] Operations\\n    function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\\n        return div(mul(a, b), base);\\n    }\\n\\n    function fxpDiv(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\\n        return div(mul(a, base), b);\\n    }\\n}\\n\\ninterface IERC1155 {\\n\\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\\n    ///      including zero value transfers as well as minting or burning.\\n    /// Operator will always be msg.sender.\\n    /// Either event from address `0x0` signifies a minting operation.\\n    /// An event to address `0x0` signifies a burning or melting operation.\\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\\n    /// be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID.\\n    /// To define a token ID with no initial balance, the contract SHOULD emit the TransferSingle event\\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 value\\n    );\\n\\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\\n    ///      including zero value transfers as well as minting or burning.\\n    ///Operator will always be msg.sender.\\n    /// Either event from address `0x0` signifies a minting operation.\\n    /// An event to address `0x0` signifies a burning or melting operation.\\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\\n    /// be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID.\\n    /// To define multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event\\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /// @dev MUST emit when an approval is updated.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /// @dev MUST emit when the URI is updated for a token ID.\\n    /// URIs are defined in RFC 3986.\\n    /// The URI MUST point a JSON file that conforms to the \\\"ERC-1155 Metadata JSON Schema\\\".\\n    event URI(\\n        string value,\\n        uint256 indexed id\\n    );\\n\\n    /// @notice Transfers value amount of an _id from the _from address to the _to address specified.\\n    /// @dev MUST emit TransferSingle event on success.\\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\\n    /// MUST throw if `_to` is the zero address.\\n    /// MUST throw if balance of sender for token `_id` is lower than the `_value` sent.\\n    /// MUST throw on any other error.\\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\\n    /// If so, it MUST call `onERC1155Received` on `_to` and revert if the return value\\n    /// is not `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`.\\n    /// @param from    Source address\\n    /// @param to      Target address\\n    /// @param id      ID of the token type\\n    /// @param value   Transfer amount\\n    /// @param data    Additional data with no specified format, sent in call to `_to`\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external;\\n\\n    /// @notice Send multiple types of Tokens from a 3rd party in one transfer (with safety call).\\n    /// @dev MUST emit TransferBatch event on success.\\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\\n    /// MUST throw if `_to` is the zero address.\\n    /// MUST throw if length of `_ids` is not the same as length of `_values`.\\n    ///  MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_values` sent.\\n    /// MUST throw on any other error.\\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\\n    /// If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return value\\n    /// is not `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`.\\n    /// @param from    Source addresses\\n    /// @param to      Target addresses\\n    /// @param ids     IDs of each token type\\n    /// @param values  Transfer amounts per token type\\n    /// @param data    Additional data with no specified format, sent in call to `_to`\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external;\\n\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of the caller's tokens.\\n    /// @dev MUST emit the ApprovalForAll event on success.\\n    /// @param operator  Address to add to the set of authorized operators\\n    /// @param approved  True if the operator is approved, false to revoke approval\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @notice Queries the approval status of an operator for a given owner.\\n    /// @param owner     The owner of the Tokens\\n    /// @param operator  Address of authorized operator\\n    /// @return           True if the operator is approved, false if not\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /// @notice Get the balance of an account's Tokens.\\n    /// @param owner  The address of the token holder\\n    /// @param id     ID of the Token\\n    /// @return        The _owner's balance of the Token type requested\\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\\n\\n    /// @notice Get the total supply of a Token.\\n    /// @param id     ID of the Token\\n    /// @return        The total supply of the Token type requested\\n    function totalSupply(uint256 id) external view returns (uint256);\\n\\n    /// @notice Get the balance of multiple account/token pairs\\n    /// @param owners The addresses of the token holders\\n    /// @param ids    ID of the Tokens\\n    /// @return        The _owner's balance of the Token types requested\\n    function balanceOfBatch(\\n        address[] calldata owners,\\n        uint256[] calldata ids\\n    )\\n        external\\n        view\\n        returns (uint256[] memory balances_);\\n}\\n\\ncontract IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address owner) public view returns (uint256);\\n    function transfer(address to, uint256 amount) public returns (bool);\\n    function transferFrom(address from, address to, uint256 amount) public returns (bool);\\n    function approve(address spender, uint256 amount) public returns (bool);\\n    function allowance(address owner, address spender) public view returns (uint256);\\n\\n    // solhint-disable-next-line no-simple-event-func-name\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ncontract ICash is IERC20 {\\n}\\n\\ncontract ERC20 is IERC20 {\\n    using SafeMathUint256 for uint256;\\n\\n    uint8 constant public decimals = 18;\\n\\n    uint256 public totalSupply;\\n\\n    mapping (address => uint256) public balances;\\n\\n    mapping (address => mapping (address => uint256)) public allowances;\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address _account) public view returns (uint256) {\\n        return balances[_account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address _recipient, uint256 _amount) public returns (bool) {\\n        _transfer(msg.sender, _recipient, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address _owner, address _spender) public view returns (uint256) {\\n        return allowances[_owner][_spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address _spender, uint256 _amount) public returns (bool) {\\n        _approve(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address _sender, address _recipient, uint256 _amount) public returns (bool) {\\n        _transfer(_sender, _recipient, _amount);\\n        _approve(_sender, msg.sender, allowances[_sender][msg.sender].sub(_amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].sub(_subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\\n        require(_sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(_recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        balances[_sender] = balances[_sender].sub(_amount);\\n        balances[_recipient] = balances[_recipient].add(_amount);\\n        emit Transfer(_sender, _recipient, _amount);\\n        onTokenTransfer(_sender, _recipient, _amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address _account, uint256 _amount) internal {\\n        require(_account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        totalSupply = totalSupply.add(_amount);\\n        balances[_account] = balances[_account].add(_amount);\\n        emit Transfer(address(0), _account, _amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address _account, uint256 _amount) internal {\\n        require(_account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        balances[_account] = balances[_account].sub(_amount);\\n        totalSupply = totalSupply.sub(_amount);\\n        emit Transfer(_account, address(0), _amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\\n        require(_owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(_spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        allowances[_owner][_spender] = _amount;\\n        emit Approval(_owner, _spender, _amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address _account, uint256 _amount) internal {\\n        _burn(_account, _amount);\\n        _approve(_account, msg.sender, allowances[_account][msg.sender].sub(_amount));\\n    }\\n\\n    // Subclasses of this token generally want to send additional logs through the centralized Augur log emitter contract\\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal;\\n}\\n\\ncontract VariableSupplyToken is ERC20 {\\n    using SafeMathUint256 for uint256;\\n\\n    function mint(address _target, uint256 _amount) internal returns (bool) {\\n        _mint(_target, _amount);\\n        onMint(_target, _amount);\\n        return true;\\n    }\\n\\n    function burn(address _target, uint256 _amount) internal returns (bool) {\\n        _burn(_target, _amount);\\n        onBurn(_target, _amount);\\n        return true;\\n    }\\n\\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\\n    function onMint(address, uint256) internal {\\n    }\\n\\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\\n    function onBurn(address, uint256) internal {\\n    }\\n}\\n\\ncontract IAffiliateValidator {\\n    function validateReference(address _account, address _referrer) external view returns (bool);\\n}\\n\\ncontract IDisputeWindow is ITyped, IERC20 {\\n    function invalidMarketsTotal() external view returns (uint256);\\n    function validityBondTotal() external view returns (uint256);\\n\\n    function incorrectDesignatedReportTotal() external view returns (uint256);\\n    function initialReportBondTotal() external view returns (uint256);\\n\\n    function designatedReportNoShowsTotal() external view returns (uint256);\\n    function designatedReporterNoShowBondTotal() external view returns (uint256);\\n\\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _disputeWindowId, bool _participationTokensEnabled, uint256 _duration, uint256 _startTime) public;\\n    function trustedBuy(address _buyer, uint256 _attotokens) public returns (bool);\\n    function getUniverse() public view returns (IUniverse);\\n    function getReputationToken() public view returns (IReputationToken);\\n    function getStartTime() public view returns (uint256);\\n    function getEndTime() public view returns (uint256);\\n    function getWindowId() public view returns (uint256);\\n    function isActive() public view returns (bool);\\n    function isOver() public view returns (bool);\\n    function onMarketFinalized() public;\\n    function redeem(address _account) public returns (bool);\\n}\\n\\ncontract IMarket is IOwnable {\\n    enum MarketType {\\n        YES_NO,\\n        CATEGORICAL,\\n        SCALAR\\n    }\\n\\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public;\\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators) public view returns (bytes32);\\n    function doInitialReport(uint256[] memory _payoutNumerators, string memory _description, uint256 _additionalStake) public returns (bool);\\n    function getUniverse() public view returns (IUniverse);\\n    function getDisputeWindow() public view returns (IDisputeWindow);\\n    function getNumberOfOutcomes() public view returns (uint256);\\n    function getNumTicks() public view returns (uint256);\\n    function getMarketCreatorSettlementFeeDivisor() public view returns (uint256);\\n    function getForkingMarket() public view returns (IMarket _market);\\n    function getEndTime() public view returns (uint256);\\n    function getWinningPayoutDistributionHash() public view returns (bytes32);\\n    function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256);\\n    function getWinningReportingParticipant() public view returns (IReportingParticipant);\\n    function getReputationToken() public view returns (IV2ReputationToken);\\n    function getFinalizationTime() public view returns (uint256);\\n    function getInitialReporter() public view returns (IInitialReporter);\\n    function getDesignatedReportingEndTime() public view returns (uint256);\\n    function getValidityBondAttoCash() public view returns (uint256);\\n    function affiliateFeeDivisor() external view returns (uint256);\\n    function getNumParticipants() public view returns (uint256);\\n    function getDisputePacingOn() public view returns (bool);\\n    function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256);\\n    function recordMarketCreatorFees(uint256 _marketCreatorFees, address _sourceAccount, bytes32 _fingerprint) public returns (bool);\\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\\n    function isFinalizedAsInvalid() public view returns (bool);\\n    function finalize() public returns (bool);\\n    function isFinalized() public view returns (bool);\\n    function getOpenInterest() public view returns (uint256);\\n}\\n\\ncontract IReportingParticipant {\\n    function getStake() public view returns (uint256);\\n    function getPayoutDistributionHash() public view returns (bytes32);\\n    function liquidateLosing() public;\\n    function redeem(address _redeemer) public returns (bool);\\n    function isDisavowed() public view returns (bool);\\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\\n    function getPayoutNumerators() public view returns (uint256[] memory);\\n    function getMarket() public view returns (IMarket);\\n    function getSize() public view returns (uint256);\\n}\\n\\ncontract IDisputeCrowdsourcer is IReportingParticipant, IERC20 {\\n    function initialize(IAugur _augur, IMarket market, uint256 _size, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, uint256 _crowdsourcerGeneration) public;\\n    function contribute(address _participant, uint256 _amount, bool _overload) public returns (uint256);\\n    function setSize(uint256 _size) public;\\n    function getRemainingToFill() public view returns (uint256);\\n    function correctSize() public returns (bool);\\n    function getCrowdsourcerGeneration() public view returns (uint256);\\n}\\n\\ncontract IInitialReporter is IReportingParticipant, IOwnable {\\n    function initialize(IAugur _augur, IMarket _market, address _designatedReporter) public;\\n    function report(address _reporter, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, uint256 _initialReportStake) public;\\n    function designatedReporterShowed() public view returns (bool);\\n    function initialReporterWasCorrect() public view returns (bool);\\n    function getDesignatedReporter() public view returns (address);\\n    function getReportTimestamp() public view returns (uint256);\\n    function migrateToNewUniverse(address _designatedReporter) public;\\n    function returnRepFromDisavow() public;\\n}\\n\\ncontract IReputationToken is IERC20 {\\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool);\\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool);\\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\\n    function getUniverse() public view returns (IUniverse);\\n    function getTotalMigrated() public view returns (uint256);\\n    function getTotalTheoreticalSupply() public view returns (uint256);\\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool);\\n}\\n\\ncontract IShareToken is ITyped, IERC1155 {\\n    function initialize(IAugur _augur) external;\\n    function initializeMarket(IMarket _market, uint256 _numOutcomes, uint256 _numTicks) public;\\n    function unsafeTransferFrom(address _from, address _to, uint256 _id, uint256 _value) public;\\n    function unsafeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;\\n    function claimTradingProceeds(IMarket _market, address _shareHolder, bytes32 _fingerprint) external returns (uint256[] memory _outcomeFees);\\n    function getMarket(uint256 _tokenId) external view returns (IMarket);\\n    function getOutcome(uint256 _tokenId) external view returns (uint256);\\n    function getTokenId(IMarket _market, uint256 _outcome) public pure returns (uint256 _tokenId);\\n    function getTokenIds(IMarket _market, uint256[] memory _outcomes) public pure returns (uint256[] memory _tokenIds);\\n    function buyCompleteSets(IMarket _market, address _account, uint256 _amount) external returns (bool);\\n    function buyCompleteSetsForTrade(IMarket _market, uint256 _amount, uint256 _longOutcome, address _longRecipient, address _shortRecipient) external returns (bool);\\n    function sellCompleteSets(IMarket _market, address _holder, address _recipient, uint256 _amount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee);\\n    function sellCompleteSetsForTrade(IMarket _market, uint256 _outcome, uint256 _amount, address _shortParticipant, address _longParticipant, address _shortRecipient, address _longRecipient, uint256 _price, address _sourceAccount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee);\\n    function totalSupplyForMarketOutcome(IMarket _market, uint256 _outcome) public view returns (uint256);\\n    function balanceOfMarketOutcome(IMarket _market, uint256 _outcome, address _account) public view returns (uint256);\\n    function lowestBalanceOfMarketOutcomes(IMarket _market, uint256[] memory _outcomes, address _account) public view returns (uint256);\\n}\\n\\ncontract IUniverse {\\n    function creationTime() external view returns (uint256);\\n    function marketBalance(address) external view returns (uint256);\\n\\n    function fork() public returns (bool);\\n    function updateForkValues() public returns (bool);\\n    function getParentUniverse() public view returns (IUniverse);\\n    function createChildUniverse(uint256[] memory _parentPayoutNumerators) public returns (IUniverse);\\n    function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse);\\n    function getReputationToken() public view returns (IV2ReputationToken);\\n    function getForkingMarket() public view returns (IMarket);\\n    function getForkEndTime() public view returns (uint256);\\n    function getForkReputationGoal() public view returns (uint256);\\n    function getParentPayoutDistributionHash() public view returns (bytes32);\\n    function getDisputeRoundDurationInSeconds(bool _initial) public view returns (uint256);\\n    function getOrCreateDisputeWindowByTimestamp(uint256 _timestamp, bool _initial) public returns (IDisputeWindow);\\n    function getOrCreateCurrentDisputeWindow(bool _initial) public returns (IDisputeWindow);\\n    function getOrCreateNextDisputeWindow(bool _initial) public returns (IDisputeWindow);\\n    function getOrCreatePreviousDisputeWindow(bool _initial) public returns (IDisputeWindow);\\n    function getOpenInterestInAttoCash() public view returns (uint256);\\n    function getTargetRepMarketCapInAttoCash() public view returns (uint256);\\n    function getOrCacheValidityBond() public returns (uint256);\\n    function getOrCacheDesignatedReportStake() public returns (uint256);\\n    function getOrCacheDesignatedReportNoShowBond() public returns (uint256);\\n    function getOrCacheMarketRepBond() public returns (uint256);\\n    function getOrCacheReportingFeeDivisor() public returns (uint256);\\n    function getDisputeThresholdForFork() public view returns (uint256);\\n    function getDisputeThresholdForDisputePacing() public view returns (uint256);\\n    function getInitialReportMinValue() public view returns (uint256);\\n    function getPayoutNumerators() public view returns (uint256[] memory);\\n    function getReportingFeeDivisor() public view returns (uint256);\\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\\n    function getWinningChildPayoutNumerator(uint256 _outcome) public view returns (uint256);\\n    function isOpenInterestCash(address) public view returns (bool);\\n    function isForkingMarket() public view returns (bool);\\n    function getCurrentDisputeWindow(bool _initial) public view returns (IDisputeWindow);\\n    function getDisputeWindowStartTimeAndDuration(uint256 _timestamp, bool _initial) public view returns (uint256, uint256);\\n    function isParentOf(IUniverse _shadyChild) public view returns (bool);\\n    function updateTentativeWinningChildUniverse(bytes32 _parentPayoutDistributionHash) public returns (bool);\\n    function isContainerForDisputeWindow(IDisputeWindow _shadyTarget) public view returns (bool);\\n    function isContainerForMarket(IMarket _shadyTarget) public view returns (bool);\\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\\n    function migrateMarketOut(IUniverse _destinationUniverse) public returns (bool);\\n    function migrateMarketIn(IMarket _market, uint256 _cashBalance, uint256 _marketOI) public returns (bool);\\n    function decrementOpenInterest(uint256 _amount) public returns (bool);\\n    function decrementOpenInterestFromMarket(IMarket _market) public returns (bool);\\n    function incrementOpenInterest(uint256 _amount) public returns (bool);\\n    function getWinningChildUniverse() public view returns (IUniverse);\\n    function isForking() public view returns (bool);\\n    function deposit(address _sender, uint256 _amount, address _market) public returns (bool);\\n    function withdraw(address _recipient, uint256 _amount, address _market) public returns (bool);\\n    function createScalarMarket(uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, int256[] memory _prices, uint256 _numTicks, string memory _extraInfo) public returns (IMarket _newMarket);\\n}\\n\\ncontract IV2ReputationToken is IReputationToken {\\n    function parentUniverse() external returns (IUniverse);\\n    function burnForMarket(uint256 _amountToBurn) public returns (bool);\\n    function mintForWarpSync(uint256 _amountToMint, address _target) public returns (bool);\\n}\\n\\nlibrary Reporting {\\n    uint256 private constant DESIGNATED_REPORTING_DURATION_SECONDS = 1 days;\\n    uint256 private constant DISPUTE_ROUND_DURATION_SECONDS = 7 days;\\n    uint256 private constant INITIAL_DISPUTE_ROUND_DURATION_SECONDS = 1 days;\\n    uint256 private constant DISPUTE_WINDOW_BUFFER_SECONDS = 1 hours;\\n    uint256 private constant FORK_DURATION_SECONDS = 60 days;\\n\\n    uint256 private constant BASE_MARKET_DURATION_MAXIMUM = 30 days; // A market of 30 day length can always be created\\n    uint256 private constant UPGRADE_CADENCE = 365 days;\\n    uint256 private constant INITIAL_UPGRADE_TIMESTAMP = 1627776000; // Aug 1st 2021\\n\\n    uint256 private constant INITIAL_REP_SUPPLY = 11 * 10 ** 6 * 10 ** 18; // 11 Million REP\\n\\n    uint256 private constant AFFILIATE_SOURCE_CUT_DIVISOR = 5; // The trader gets 20% of the affiliate fee when an affiliate fee is taken\\n\\n    uint256 private constant DEFAULT_VALIDITY_BOND = 10 ether; // 10 Cash (Dai)\\n    uint256 private constant VALIDITY_BOND_FLOOR = 10 ether; // 10 Cash (Dai)\\n    uint256 private constant DEFAULT_REPORTING_FEE_DIVISOR = 10000; // .01% fees\\n    uint256 private constant MAXIMUM_REPORTING_FEE_DIVISOR = 10000; // Minimum .01% fees\\n    uint256 private constant MINIMUM_REPORTING_FEE_DIVISOR = 3; // Maximum 33.3~% fees. Note than anything less than a value of 2 here will likely result in bugs such as divide by 0 cases.\\n\\n    uint256 private constant TARGET_INVALID_MARKETS_DIVISOR = 100; // 1% of markets are expected to be invalid\\n    uint256 private constant TARGET_INCORRECT_DESIGNATED_REPORT_MARKETS_DIVISOR = 100; // 1% of markets are expected to have an incorrect designate report\\n    uint256 private constant TARGET_DESIGNATED_REPORT_NO_SHOWS_DIVISOR = 20; // 5% of markets are expected to have a no show\\n    uint256 private constant TARGET_REP_MARKET_CAP_MULTIPLIER = 5; // We multiply and divide by constants since we may want to multiply by a fractional amount\\n\\n    uint256 private constant FORK_THRESHOLD_DIVISOR = 40; // 2.5% of the total REP supply being filled in a single dispute bond will trigger a fork\\n    uint256 private constant MAXIMUM_DISPUTE_ROUNDS = 20; // We ensure that after 20 rounds of disputes a fork will occur\\n    uint256 private constant MINIMUM_SLOW_ROUNDS = 8; // We ensure that at least 8 dispute rounds take DISPUTE_ROUND_DURATION_SECONDS+ seconds to complete until the next round begins\\n\\n    function getDesignatedReportingDurationSeconds() internal pure returns (uint256) { return DESIGNATED_REPORTING_DURATION_SECONDS; }\\n    function getInitialDisputeRoundDurationSeconds() internal pure returns (uint256) { return INITIAL_DISPUTE_ROUND_DURATION_SECONDS; }\\n    function getDisputeWindowBufferSeconds() internal pure returns (uint256) { return DISPUTE_WINDOW_BUFFER_SECONDS; }\\n    function getDisputeRoundDurationSeconds() internal pure returns (uint256) { return DISPUTE_ROUND_DURATION_SECONDS; }\\n    function getForkDurationSeconds() internal pure returns (uint256) { return FORK_DURATION_SECONDS; }\\n    function getBaseMarketDurationMaximum() internal pure returns (uint256) { return BASE_MARKET_DURATION_MAXIMUM; }\\n    function getUpgradeCadence() internal pure returns (uint256) { return UPGRADE_CADENCE; }\\n    function getInitialUpgradeTimestamp() internal pure returns (uint256) { return INITIAL_UPGRADE_TIMESTAMP; }\\n    function getDefaultValidityBond() internal pure returns (uint256) { return DEFAULT_VALIDITY_BOND; }\\n    function getValidityBondFloor() internal pure returns (uint256) { return VALIDITY_BOND_FLOOR; }\\n    function getTargetInvalidMarketsDivisor() internal pure returns (uint256) { return TARGET_INVALID_MARKETS_DIVISOR; }\\n    function getTargetIncorrectDesignatedReportMarketsDivisor() internal pure returns (uint256) { return TARGET_INCORRECT_DESIGNATED_REPORT_MARKETS_DIVISOR; }\\n    function getTargetDesignatedReportNoShowsDivisor() internal pure returns (uint256) { return TARGET_DESIGNATED_REPORT_NO_SHOWS_DIVISOR; }\\n    function getTargetRepMarketCapMultiplier() internal pure returns (uint256) { return TARGET_REP_MARKET_CAP_MULTIPLIER; }\\n    function getMaximumReportingFeeDivisor() internal pure returns (uint256) { return MAXIMUM_REPORTING_FEE_DIVISOR; }\\n    function getMinimumReportingFeeDivisor() internal pure returns (uint256) { return MINIMUM_REPORTING_FEE_DIVISOR; }\\n    function getDefaultReportingFeeDivisor() internal pure returns (uint256) { return DEFAULT_REPORTING_FEE_DIVISOR; }\\n    function getInitialREPSupply() internal pure returns (uint256) { return INITIAL_REP_SUPPLY; }\\n    function getAffiliateSourceCutDivisor() internal pure returns (uint256) { return AFFILIATE_SOURCE_CUT_DIVISOR; }\\n    function getForkThresholdDivisor() internal pure returns (uint256) { return FORK_THRESHOLD_DIVISOR; }\\n    function getMaximumDisputeRounds() internal pure returns (uint256) { return MAXIMUM_DISPUTE_ROUNDS; }\\n    function getMinimumSlowRounds() internal pure returns (uint256) { return MINIMUM_SLOW_ROUNDS; }\\n}\\n\\ncontract IAugurTrading {\\n    function lookup(bytes32 _key) public view returns (address);\\n    function logProfitLossChanged(IMarket _market, address _account, uint256 _outcome, int256 _netPosition, uint256 _avgPrice, int256 _realizedProfit, int256 _frozenFunds, int256 _realizedCost) public returns (bool);\\n    function logOrderCreated(IUniverse _universe, bytes32 _orderId, bytes32 _tradeGroupId) public returns (bool);\\n    function logOrderCanceled(IUniverse _universe, IMarket _market, address _creator, uint256 _tokenRefund, uint256 _sharesRefund, bytes32 _orderId) public returns (bool);\\n    function logOrderFilled(IUniverse _universe, address _creator, address _filler, uint256 _price, uint256 _fees, uint256 _amountFilled, bytes32 _orderId, bytes32 _tradeGroupId) public returns (bool);\\n    function logMarketVolumeChanged(IUniverse _universe, address _market, uint256 _volume, uint256[] memory _outcomeVolumes, uint256 _totalTrades) public returns (bool);\\n    function logZeroXOrderFilled(IUniverse _universe, IMarket _market, bytes32 _orderHash, bytes32 _tradeGroupId, uint8 _orderType, address[] memory _addressData, uint256[] memory _uint256Data) public returns (bool);\\n    function logZeroXOrderCanceled(address _universe, address _market, address _account, uint256 _outcome, uint256 _price, uint256 _amount, uint8 _type, bytes32 _orderHash) public;\\n}\\n\\ncontract IOrders {\\n    function saveOrder(uint256[] calldata _uints, bytes32[] calldata _bytes32s, Order.Types _type, IMarket _market, address _sender) external returns (bytes32 _orderId);\\n    function removeOrder(bytes32 _orderId) external returns (bool);\\n    function getMarket(bytes32 _orderId) public view returns (IMarket);\\n    function getOrderType(bytes32 _orderId) public view returns (Order.Types);\\n    function getOutcome(bytes32 _orderId) public view returns (uint256);\\n    function getAmount(bytes32 _orderId) public view returns (uint256);\\n    function getPrice(bytes32 _orderId) public view returns (uint256);\\n    function getOrderCreator(bytes32 _orderId) public view returns (address);\\n    function getOrderSharesEscrowed(bytes32 _orderId) public view returns (uint256);\\n    function getOrderMoneyEscrowed(bytes32 _orderId) public view returns (uint256);\\n    function getOrderDataForCancel(bytes32 _orderId) public view returns (uint256, uint256, Order.Types, IMarket, uint256, address);\\n    function getOrderDataForLogs(bytes32 _orderId) public view returns (Order.Types, address[] memory _addressData, uint256[] memory _uint256Data);\\n    function getBetterOrderId(bytes32 _orderId) public view returns (bytes32);\\n    function getWorseOrderId(bytes32 _orderId) public view returns (bytes32);\\n    function getBestOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\\n    function getWorstOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\\n    function getLastOutcomePrice(IMarket _market, uint256 _outcome) public view returns (uint256);\\n    function getOrderId(Order.Types _type, IMarket _market, uint256 _amount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) public pure returns (bytes32);\\n    function getTotalEscrowed(IMarket _market) public view returns (uint256);\\n    function isBetterPrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\\n    function isWorsePrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\\n    function assertIsNotBetterPrice(Order.Types _type, uint256 _price, bytes32 _betterOrderId) public view returns (bool);\\n    function assertIsNotWorsePrice(Order.Types _type, uint256 _price, bytes32 _worseOrderId) public returns (bool);\\n    function recordFillOrder(bytes32 _orderId, uint256 _sharesFilled, uint256 _tokensFilled, uint256 _fill) external returns (bool);\\n    function setPrice(IMarket _market, uint256 _outcome, uint256 _price) external returns (bool);\\n}\\n\\nlibrary Order {\\n    using SafeMathUint256 for uint256;\\n\\n    enum Types {\\n        Bid, Ask\\n    }\\n\\n    enum TradeDirections {\\n        Long, Short\\n    }\\n\\n    struct Data {\\n        // Contracts\\n        IMarket market;\\n        IAugur augur;\\n        IAugurTrading augurTrading;\\n        IShareToken shareToken;\\n        ICash cash;\\n\\n        // Order\\n        bytes32 id;\\n        address creator;\\n        uint256 outcome;\\n        Order.Types orderType;\\n        uint256 amount;\\n        uint256 price;\\n        uint256 sharesEscrowed;\\n        uint256 moneyEscrowed;\\n        bytes32 betterOrderId;\\n        bytes32 worseOrderId;\\n    }\\n\\n    function create(IAugur _augur, IAugurTrading _augurTrading, address _creator, uint256 _outcome, Order.Types _type, uint256 _attoshares, uint256 _price, IMarket _market, bytes32 _betterOrderId, bytes32 _worseOrderId) internal view returns (Data memory) {\\n        require(_outcome < _market.getNumberOfOutcomes(), \\\"Order.create: Outcome is not within market range\\\");\\n        require(_price != 0, \\\"Order.create: Price may not be 0\\\");\\n        require(_price < _market.getNumTicks(), \\\"Order.create: Price is outside of market range\\\");\\n        require(_attoshares > 0, \\\"Order.create: Cannot use amount of 0\\\");\\n        require(_creator != address(0), \\\"Order.create: Creator is 0x0\\\");\\n\\n        IShareToken _shareToken = IShareToken(_augur.lookup(\\\"ShareToken\\\"));\\n\\n        return Data({\\n            market: _market,\\n            augur: _augur,\\n            augurTrading: _augurTrading,\\n            shareToken: _shareToken,\\n            cash: ICash(_augur.lookup(\\\"Cash\\\")),\\n            id: 0,\\n            creator: _creator,\\n            outcome: _outcome,\\n            orderType: _type,\\n            amount: _attoshares,\\n            price: _price,\\n            sharesEscrowed: 0,\\n            moneyEscrowed: 0,\\n            betterOrderId: _betterOrderId,\\n            worseOrderId: _worseOrderId\\n        });\\n    }\\n\\n    //\\n    // \\\"public\\\" functions\\n    //\\n\\n    function getOrderId(Order.Data memory _orderData, IOrders _orders) internal view returns (bytes32) {\\n        if (_orderData.id == bytes32(0)) {\\n            bytes32 _orderId = calculateOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);\\n            require(_orders.getAmount(_orderId) == 0, \\\"Order.getOrderId: New order had amount. This should not be possible\\\");\\n            _orderData.id = _orderId;\\n        }\\n        return _orderData.id;\\n    }\\n\\n    function calculateOrderId(Order.Types _type, IMarket _market, uint256 _amount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) internal pure returns (bytes32) {\\n        return sha256(abi.encodePacked(_type, _market, _amount, _price, _sender, _blockNumber, _outcome, _moneyEscrowed, _sharesEscrowed));\\n    }\\n\\n    function getOrderTradingTypeFromMakerDirection(Order.TradeDirections _creatorDirection) internal pure returns (Order.Types) {\\n        return (_creatorDirection == Order.TradeDirections.Long) ? Order.Types.Bid : Order.Types.Ask;\\n    }\\n\\n    function getOrderTradingTypeFromFillerDirection(Order.TradeDirections _fillerDirection) internal pure returns (Order.Types) {\\n        return (_fillerDirection == Order.TradeDirections.Long) ? Order.Types.Ask : Order.Types.Bid;\\n    }\\n\\n    function saveOrder(Order.Data memory _orderData, bytes32 _tradeGroupId, IOrders _orders) internal returns (bytes32) {\\n        getOrderId(_orderData, _orders);\\n        uint256[] memory _uints = new uint256[](5);\\n        _uints[0] = _orderData.amount;\\n        _uints[1] = _orderData.price;\\n        _uints[2] = _orderData.outcome;\\n        _uints[3] = _orderData.moneyEscrowed;\\n        _uints[4] = _orderData.sharesEscrowed;\\n        bytes32[] memory _bytes32s = new bytes32[](4);\\n        _bytes32s[0] = _orderData.betterOrderId;\\n        _bytes32s[1] = _orderData.worseOrderId;\\n        _bytes32s[2] = _tradeGroupId;\\n        _bytes32s[3] = _orderData.id;\\n        return _orders.saveOrder(_uints, _bytes32s, _orderData.orderType, _orderData.market, _orderData.creator);\\n    }\\n}\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\\ncontract IRepSymbol {\\n    function getRepSymbol(address _augur, address _universe) external view returns (string memory);\\n}\\n\\ncontract ReputationToken is VariableSupplyToken, IV2ReputationToken {\\n    using SafeMathUint256 for uint256;\\n\\n    string constant public name = \\\"Reputation\\\";\\n    IUniverse internal universe;\\n    IUniverse public parentUniverse;\\n    uint256 internal totalMigrated;\\n    IERC20 public legacyRepToken;\\n    IAugur public augur;\\n    address public warpSync;\\n\\n    constructor(IAugur _augur, IUniverse _universe, IUniverse _parentUniverse) public {\\n        augur = _augur;\\n        universe = _universe;\\n        parentUniverse = _parentUniverse;\\n        warpSync = _augur.lookup(\\\"WarpSync\\\");\\n        legacyRepToken = IERC20(_augur.lookup(\\\"LegacyReputationToken\\\"));\\n        require(warpSync != address(0));\\n        require(legacyRepToken != IERC20(0));\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return IRepSymbol(augur.lookup(\\\"RepSymbol\\\")).getRepSymbol(address(augur), address(universe));\\n    }\\n\\n    /**\\n     * @notice Migrate to a Child Universe by indicating the Market payout associated with it\\n     * @param _payoutNumerators The array of payouts for the market associated with the desired universe\\n     * @param _attotokens The amount of tokens to migrate\\n     * @return Bool True\\n     */\\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool) {\\n        require(_attotokens > 0);\\n        IUniverse _destinationUniverse = universe.createChildUniverse(_payoutNumerators);\\n        IReputationToken _destination = _destinationUniverse.getReputationToken();\\n        burn(msg.sender, _attotokens);\\n        _destination.migrateIn(msg.sender, _attotokens);\\n        return true;\\n    }\\n\\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool) {\\n        IUniverse _parentUniverse = parentUniverse;\\n        require(ReputationToken(msg.sender) == _parentUniverse.getReputationToken());\\n        require(augur.getTimestamp() < _parentUniverse.getForkEndTime());\\n        mint(_reporter, _attotokens);\\n        totalMigrated += _attotokens;\\n        // Update the fork tentative winner and finalize if we can\\n        if (!_parentUniverse.getForkingMarket().isFinalized()) {\\n            _parentUniverse.updateTentativeWinningChildUniverse(universe.getParentPayoutDistributionHash());\\n        }\\n        return true;\\n    }\\n\\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool) {\\n        IReportingParticipant _reportingParticipant = IReportingParticipant(msg.sender);\\n        require(parentUniverse.isContainerForReportingParticipant(_reportingParticipant));\\n        // simulate a 40% ROI which would have occured during a normal dispute had this participant's outcome won the dispute\\n        uint256 _bonus = _amountMigrated.mul(2) / 5;\\n        mint(address(_reportingParticipant), _bonus);\\n        return true;\\n    }\\n\\n    function mintForWarpSync(uint256 _amountToMint, address _target) public returns (bool) {\\n        require(warpSync == msg.sender);\\n        mint(_target, _amountToMint);\\n        universe.updateForkValues();\\n        return true;\\n    }\\n\\n    function burnForMarket(uint256 _amountToBurn) public returns (bool) {\\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\\n        burn(msg.sender, _amountToBurn);\\n        return true;\\n    }\\n\\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\\n        require(IUniverse(msg.sender) == universe);\\n        _transfer(_source, _destination, _attotokens);\\n        return true;\\n    }\\n\\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\\n        _transfer(_source, _destination, _attotokens);\\n        return true;\\n    }\\n\\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\\n        require(universe.isContainerForReportingParticipant(IReportingParticipant(msg.sender)));\\n        _transfer(_source, _destination, _attotokens);\\n        return true;\\n    }\\n\\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\\n        require(universe.isContainerForDisputeWindow(IDisputeWindow(msg.sender)));\\n        _transfer(_source, _destination, _attotokens);\\n        return true;\\n    }\\n\\n    function assertReputationTokenIsLegitChild(IReputationToken _shadyReputationToken) private view {\\n        IUniverse _universe = _shadyReputationToken.getUniverse();\\n        require(universe.isParentOf(_universe));\\n        require(_universe.getReputationToken() == _shadyReputationToken);\\n    }\\n\\n    /**\\n     * @return The universe associated with this Reputation Token\\n     */\\n    function getUniverse() public view returns (IUniverse) {\\n        return universe;\\n    }\\n\\n    /**\\n     * @return The total amount of parent REP migrated into this version of REP\\n     */\\n    function getTotalMigrated() public view returns (uint256) {\\n        return totalMigrated;\\n    }\\n\\n    /**\\n     * @return The V1 Rep token\\n     */\\n    function getLegacyRepToken() public view returns (IERC20) {\\n        return legacyRepToken;\\n    }\\n\\n    /**\\n     * @return The maximum possible total supply for this version of REP.\\n     */\\n    function getTotalTheoreticalSupply() public view returns (uint256) {\\n        uint256 _totalSupply = totalSupply;\\n        if (parentUniverse == IUniverse(0)) {\\n            return _totalSupply.add(legacyRepToken.totalSupply()).sub(legacyRepToken.balanceOf(address(1))).sub(legacyRepToken.balanceOf(address(0)));\\n        } else if (augur.getTimestamp() >= parentUniverse.getForkEndTime()) {\\n            return _totalSupply;\\n        } else {\\n            return _totalSupply + parentUniverse.getReputationToken().getTotalTheoreticalSupply();\\n        }\\n    }\\n\\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal {\\n        augur.logReputationTokensTransferred(universe, _from, _to, _value, balances[_from], balances[_to]);\\n    }\\n\\n    function onMint(address _target, uint256 _amount) internal {\\n        augur.logReputationTokensMinted(universe, _target, _amount, totalSupply, balances[_target]);\\n    }\\n\\n    function onBurn(address _target, uint256 _amount) internal {\\n        augur.logReputationTokensBurned(universe, _target, _amount, totalSupply, balances[_target]);\\n    }\\n\\n    /**\\n     * @notice Migrate V1 REP to V2\\n     * @dev This can only be done for the Genesis Universe in V2. If a fork occurs and the window ends V1 REP is stuck in V1 forever\\n     * @return Bool True\\n     */\\n    function migrateFromLegacyReputationToken() public returns (bool) {\\n        require(parentUniverse == IUniverse(0));\\n        uint256 _legacyBalance = legacyRepToken.balanceOf(msg.sender);\\n        require(legacyRepToken.transferFrom(msg.sender, address(1), _legacyBalance));\\n        mint(msg.sender, _legacyBalance);\\n        return true;\\n    }\\n}\\n\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IAugur\",\"name\":\"_augur\",\"type\":\"address\"},{\"internalType\":\"contract IUniverse\",\"name\":\"_universe\",\"type\":\"address\"},{\"internalType\":\"contract IUniverse\",\"name\":\"_parentUniverse\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"augur\",\"outputs\":[{\"internalType\":\"contract IAugur\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burnForMarket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLegacyRepToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalMigrated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalTheoreticalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniverse\",\"outputs\":[{\"internalType\":\"contract IUniverse\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"legacyRepToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrateFromLegacyReputationToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reporter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_attotokens\",\"type\":\"uint256\"}],\"name\":\"migrateIn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_payoutNumerators\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_attotokens\",\"type\":\"uint256\"}],\"name\":\"migrateOutByPayout\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountMigrated\",\"type\":\"uint256\"}],\"name\":\"mintForReportingParticipant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountToMint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"mintForWarpSync\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"parentUniverse\",\"outputs\":[{\"internalType\":\"contract IUniverse\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_source\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_attotokens\",\"type\":\"uint256\"}],\"name\":\"trustedDisputeWindowTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_source\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_attotokens\",\"type\":\"uint256\"}],\"name\":\"trustedMarketTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_source\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_attotokens\",\"type\":\"uint256\"}],\"name\":\"trustedReportingParticipantTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_source\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_attotokens\",\"type\":\"uint256\"}],\"name\":\"trustedUniverseTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"warpSync\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ReputationToken","CompilerVersion":"v0.5.15+commit.6a57276f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000023916a8f5c3846e3100e5f587ff14f3098722f5d00000000000000000000000049244bd018ca9fd1f06ecc07b9e9de773246e5aa0000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://639a17082bb841ef885557bfd4f939fda1d15d9ef9da41800995126dccd4ef0f"}]