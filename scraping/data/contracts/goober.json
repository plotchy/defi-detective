[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/art-gobblers/lib/VRGDAs/src/LogisticToLinearVRGDA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {unsafeWadDiv} from \\\"solmate/utils/SignedWadMath.sol\\\";\\n\\nimport {VRGDA} from \\\"./VRGDA.sol\\\";\\nimport {LogisticVRGDA} from \\\"./LogisticVRGDA.sol\\\";\\n\\n/// @title Logistic To Linear Variable Rate Gradual Dutch Auction\\n/// @author transmissions11 <t11s@paradigm.xyz>\\n/// @author FrankieIsLost <frankie@paradigm.xyz>\\n/// @notice VRGDA with a piecewise logistic and linear issuance curve.\\nabstract contract LogisticToLinearVRGDA is LogisticVRGDA {\\n    /*//////////////////////////////////////////////////////////////\\n                           PRICING PARAMETERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev The number of tokens that must be sold for the switch to occur.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    int256 internal immutable soldBySwitch;\\n\\n    /// @dev The time soldBySwitch tokens were targeted to sell by.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    int256 internal immutable switchTime;\\n\\n    /// @dev The total number of tokens to target selling every full unit of time.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    int256 internal immutable perTimeUnit;\\n\\n    /// @notice Sets pricing parameters for the VRGDA.\\n    /// @param _targetPrice The target price for a token if sold on pace, scaled by 1e18.\\n    /// @param _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\\n    /// @param _logisticAsymptote The asymptote (minus 1) of the pre-switch logistic curve, scaled by 1e18.\\n    /// @param _timeScale The steepness of the pre-switch logistic curve, scaled by 1e18.\\n    /// @param _soldBySwitch The number of tokens that must be sold for the switch to occur.\\n    /// @param _switchTime The time soldBySwitch tokens were targeted to sell by, scaled by 1e18.\\n    /// @param _perTimeUnit The number of tokens to target selling in 1 full unit of time, scaled by 1e18.\\n    constructor(\\n        int256 _targetPrice,\\n        int256 _priceDecayPercent,\\n        int256 _logisticAsymptote,\\n        int256 _timeScale,\\n        int256 _soldBySwitch,\\n        int256 _switchTime,\\n        int256 _perTimeUnit\\n    ) LogisticVRGDA(_targetPrice, _priceDecayPercent, _logisticAsymptote, _timeScale) {\\n        soldBySwitch = _soldBySwitch;\\n\\n        switchTime = _switchTime;\\n\\n        perTimeUnit = _perTimeUnit;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              PRICING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Given a number of tokens sold, return the target time that number of tokens should be sold by.\\n    /// @param sold A number of tokens sold, scaled by 1e18, to get the corresponding target sale time for.\\n    /// @return The target time the tokens should be sold by, scaled by 1e18, where the time is\\n    /// relative, such that 0 means the tokens should be sold immediately when the VRGDA begins.\\n    function getTargetSaleTime(int256 sold) public view virtual override returns (int256) {\\n        // If we've not yet reached the number of sales required for the switch\\n        // to occur, we'll continue using the standard logistic VRGDA schedule.\\n        if (sold < soldBySwitch) return LogisticVRGDA.getTargetSaleTime(sold);\\n\\n        unchecked {\\n            return unsafeWadDiv(sold - soldBySwitch, perTimeUnit) + switchTime;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/art-gobblers/lib/VRGDAs/src/LogisticVRGDA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {wadLn, unsafeDiv, unsafeWadDiv} from \\\"solmate/utils/SignedWadMath.sol\\\";\\n\\nimport {VRGDA} from \\\"./VRGDA.sol\\\";\\n\\n/// @title Logistic Variable Rate Gradual Dutch Auction\\n/// @author transmissions11 <t11s@paradigm.xyz>\\n/// @author FrankieIsLost <frankie@paradigm.xyz>\\n/// @notice VRGDA with a logistic issuance curve.\\nabstract contract LogisticVRGDA is VRGDA {\\n    /*//////////////////////////////////////////////////////////////\\n                           PRICING PARAMETERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev The maximum number of tokens of tokens to sell + 1. We add\\n    /// 1 because the logistic function will never fully reach its limit.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    int256 internal immutable logisticLimit;\\n\\n    /// @dev The maximum number of tokens of tokens to sell + 1 multiplied\\n    /// by 2. We could compute it on the fly each time but this saves gas.\\n    /// @dev Represented as a 36 decimal fixed point number.\\n    int256 internal immutable logisticLimitDoubled;\\n\\n    /// @dev Time scale controls the steepness of the logistic curve,\\n    /// which affects how quickly we will reach the curve's asymptote.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    int256 internal immutable timeScale;\\n\\n    /// @notice Sets pricing parameters for the VRGDA.\\n    /// @param _targetPrice The target price for a token if sold on pace, scaled by 1e18.\\n    /// @param _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\\n    /// @param _maxSellable The maximum number of tokens to sell, scaled by 1e18.\\n    /// @param _timeScale The steepness of the logistic curve, scaled by 1e18.\\n    constructor(\\n        int256 _targetPrice,\\n        int256 _priceDecayPercent,\\n        int256 _maxSellable,\\n        int256 _timeScale\\n    ) VRGDA(_targetPrice, _priceDecayPercent) {\\n        // Add 1 wad to make the limit inclusive of _maxSellable.\\n        logisticLimit = _maxSellable + 1e18;\\n\\n        // Scale by 2e18 to both double it and give it 36 decimals.\\n        logisticLimitDoubled = logisticLimit * 2e18;\\n\\n        timeScale = _timeScale;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              PRICING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Given a number of tokens sold, return the target time that number of tokens should be sold by.\\n    /// @param sold A number of tokens sold, scaled by 1e18, to get the corresponding target sale time for.\\n    /// @return The target time the tokens should be sold by, scaled by 1e18, where the time is\\n    /// relative, such that 0 means the tokens should be sold immediately when the VRGDA begins.\\n    function getTargetSaleTime(int256 sold) public view virtual override returns (int256) {\\n        unchecked {\\n            return -unsafeWadDiv(wadLn(unsafeDiv(logisticLimitDoubled, sold + logisticLimit) - 1e18), timeScale);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/art-gobblers/lib/VRGDAs/src/VRGDA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {wadExp, wadLn, wadMul, unsafeWadMul, toWadUnsafe} from \\\"solmate/utils/SignedWadMath.sol\\\";\\n\\n/// @title Variable Rate Gradual Dutch Auction\\n/// @author transmissions11 <t11s@paradigm.xyz>\\n/// @author FrankieIsLost <frankie@paradigm.xyz>\\n/// @notice Sell tokens roughly according to an issuance schedule.\\nabstract contract VRGDA {\\n    /*//////////////////////////////////////////////////////////////\\n                            VRGDA PARAMETERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Target price for a token, to be scaled according to sales pace.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    int256 public immutable targetPrice;\\n\\n    /// @dev Precomputed constant that allows us to rewrite a pow() as an exp().\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    int256 internal immutable decayConstant;\\n\\n    /// @notice Sets target price and per time unit price decay for the VRGDA.\\n    /// @param _targetPrice The target price for a token if sold on pace, scaled by 1e18.\\n    /// @param _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\\n    constructor(int256 _targetPrice, int256 _priceDecayPercent) {\\n        targetPrice = _targetPrice;\\n\\n        decayConstant = wadLn(1e18 - _priceDecayPercent);\\n\\n        // The decay constant must be negative for VRGDAs to work.\\n        require(decayConstant < 0, \\\"NON_NEGATIVE_DECAY_CONSTANT\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              PRICING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Calculate the price of a token according to the VRGDA formula.\\n    /// @param timeSinceStart Time passed since the VRGDA began, scaled by 1e18.\\n    /// @param sold The total number of tokens that have been sold so far.\\n    /// @return The price of a token according to VRGDA, scaled by 1e18.\\n    function getVRGDAPrice(int256 timeSinceStart, uint256 sold) public view virtual returns (uint256) {\\n        unchecked {\\n            // prettier-ignore\\n            return uint256(wadMul(targetPrice, wadExp(unsafeWadMul(decayConstant,\\n                // Theoretically calling toWadUnsafe with sold can silently overflow but under\\n                // any reasonable circumstance it will never be large enough. We use sold + 1 as\\n                // the VRGDA formula's n param represents the nth token and sold is the n-1th token.\\n                timeSinceStart - getTargetSaleTime(toWadUnsafe(sold + 1))\\n            ))));\\n        }\\n    }\\n\\n    /// @dev Given a number of tokens sold, return the target time that number of tokens should be sold by.\\n    /// @param sold A number of tokens sold, scaled by 1e18, to get the corresponding target sale time for.\\n    /// @return The target time the tokens should be sold by, scaled by 1e18, where the time is\\n    /// relative, such that 0 means the tokens should be sold immediately when the VRGDA begins.\\n    function getTargetSaleTime(int256 sold) public view virtual returns (int256);\\n}\\n\"\r\n    },\r\n    \"lib/art-gobblers/lib/goo-issuance/src/LibGOO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {FixedPointMathLib} from \\\"solmate/utils/FixedPointMathLib.sol\\\";\\n\\n/// @title GOO (Gradual Ownership Optimization) Issuance\\n/// @author transmissions11 <t11s@paradigm.xyz>\\n/// @author FrankieIsLost <frankie@paradigm.xyz>\\n/// @notice Implementation of the GOO Issuance mechanism.\\nlibrary LibGOO {\\n    using FixedPointMathLib for uint256;\\n\\n    /// @notice Compute goo balance based on emission multiple, last balance, and time elapsed.\\n    /// @param emissionMultiple The multiple on emissions to consider when computing the balance.\\n    /// @param lastBalanceWad The last checkpointed balance to apply the emission multiple over time to, scaled by 1e18.\\n    /// @param timeElapsedWad The time elapsed since the last checkpoint, scaled by 1e18.\\n    function computeGOOBalance(\\n        uint256 emissionMultiple,\\n        uint256 lastBalanceWad,\\n        uint256 timeElapsedWad\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            // We use wad math here because timeElapsedWad is, as the name indicates, a wad.\\n            uint256 timeElapsedSquaredWad = timeElapsedWad.mulWadDown(timeElapsedWad);\\n\\n            // prettier-ignore\\n            return lastBalanceWad + // The last recorded balance.\\n\\n            // Don't need to do wad multiplication since we're\\n            // multiplying by a plain integer with no decimals.\\n            // Shift right by 2 is equivalent to division by 4.\\n            ((emissionMultiple * timeElapsedSquaredWad) >> 2) +\\n\\n            timeElapsedWad.mulWadDown( // Terms are wads, so must mulWad.\\n                // No wad multiplication for emissionMultiple * lastBalance\\n                // because emissionMultiple is a plain integer with no decimals.\\n                // We multiply the sqrt's radicand by 1e18 because it expects ints.\\n                (emissionMultiple * lastBalanceWad * 1e18).sqrt()\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/art-gobblers/src/ArtGobblers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/*                                                                              **,/*,\\n                                                                     *%@&%#/*,,..........,/(%&@@#*\\n                                                                 %@%,..............................#@@%\\n                                                              &&,.....,,...............................,/&@*\\n                                                            (@*.....**............,/,.......................(@%\\n                                                           &&......*,............./,.............**............&@\\n                                                          @#......**.............**..............,*........,*,..,@/\\n                                                         /@......,/............../,..............,*........../,..*@.\\n                                                        #@,......................*.............../,..........**...#/\\n                                                      ,@&,.......................................*..........,/....(@\\n                                                  *@&(*...................................................../*....(@\\n                                                 @(..*%@@&%#(#@@@%%%%%&&@@@@@@@@@&&#(///..........................#@\\n                                                 @%/@@@&%&&&@@&%%%%%%%#(/(((/(/(/(/(/(/(/(/(%%&@@@%(/,............#&\\n                                                  @@@#/**./@%%%&%#/*************./(%@@@@&(*********(@&&@@@%(.....,&@\\n                                                 ,@/.//(&@@/.     .#@%/******./&&*,      ./@&********%@/**(@#@@#,..(@\\n                                                 #%****%@.           %@/****./&@      ,.    %&********%@(**&@...(@#.#@\\n                                                 &#**./@/  %@&&      .@#****./@*    &@@@@&  .@/******./@@((((@&....(@\\n                                                 ##**./&@ ,&@@@,     #@/****./@@      @@.  .@&*******./@%****%@@@(,\\n                                                 ,@/**./%@(.      .*@@/********(&@#*,,,,/&@%/*******./@@&&&@@@#\\n                                                   @&/**@&/%&&&&&%/**.//////*********./************./@&******@*\\n                                                     /@@@@&(////#%&@@&(**./#&@@&(//*************./&@(********#@\\n                                                       .@#**.///*****************(#@@@&&&&&@@@@&%(**********./@,\\n                                                       @(*****%@#*********************&@#*********************(@\\n                                                       @****./@#*./@@#//***.///(%@%*****%@*********************#@\\n                                                      #&****./@%************************&@**********************@%\\n                                                     .@/******.//*******************./@@(************************@/\\n                                                     /@**********************************************************(@,\\n                                                     @#*****************************************************%@@@@@@@.\\n                                                    *@/*************************************************************#@(\\n                                                    @%***************************************************************./@(\\n                     /@@&&&@@                     .@/*******************************************************************&@\\n                    @%######%@.                   @#***************************./%&&&%(**************#%******************&#\\n                    @%######&@%&@@.             ,@(***./&#********************#@&#####%@&*************&%****************./@,\\n               &&*,/@%######&@@@*.*@&,         @@****./@&*******************./%@#######%@#***********./@&*****************(@\\n              ((...*%@&##%@@,..........,,,,%@&@%/*****&%****************./&@#*%@#######&@*#@%*********./@&*****************(@,\\n              (@#....(@%#&&,...,/...........@(*******(@(****************(@/...*%@@@@@@%*....&@@@@&@@@@@@%/%@@##(************(@.\\n              ((./(((%@%#&@/,/&@/...........%&*******%@****************./@%,.................#,............/@%***************#@\\n              *@@####@@%###%&@(@(...........%&*******%@****************%@,,#%/..............................#@/***************&/\\n              (#.....,&&####&@..%%..........%%*****(@@#****************#@,...................................@(***************(@\\n              .@@&%%&@@&####&&.............,@(***%@(**********./#%%%%%##&@&#(,...............................#@****************&.\\n               &#.....(@%###&@*............%@**%@(*******(&@&%#/////////@%...................................#@***************&@\\n                 #@@@@&%####&@&&&,........%@./@%*****(@@%////////////////@@@%,...............................#@**************#@\\n                     @@&&&&@@(    /&@@&%%@&@@@%**./&@(///////////////////@%.................................,@(*********./%@&.\\n                      (@//@%                @%***&&(//////////////////////(&@(**,,,,./(%&@@@%/*,,****,,***./@@&&&&&&&&#//%@\\n                      (@//%@               (@(*#@#////////////////////////////%@@%%%&@@#////%@/***************************&&\\n                      (@//%@  .,,,,/#&&&&&&@&*#@#///////////////////////////////@%//&&///////#@(***************************@&(#@@@@@&(*.\\n               ,@@@@@&&@//%@,,.,,,,,.,..,,#@./@%////////////////////////////////%@**&&////////(@(**************************&#,,,,,,,,,,,,/(#&@&\\n          &@%*,,,,,,,,#@//%@,,,,,,,,,,,,,,&%*#@(////////////////////////////////%@**&&/////////&@**************************#@.,,,.,,.,,&#.,,...,%@\\n       (@/,,,,,,,,,,,,(@(/%@,,,,,,,,,,,,,,&%*#@(////////////////////////////////%@./%@/////////#@(*************************&%,,,(%@@@@#*,.     .,/@.\\n      &%..    *&@%/,.,#@(*#@*,,.,,,,,,,,,,%@/#@(////////////////////////////////%@**#@/////////#@(*****************.//#%@@@@%%(/,...        ...,,,%&\\n     ,@*.,.       ../((%&&@@@&%#((///,,,,,/@&(@(////////////////////////////////@&**#@/////////%@%###%&&&&@@@@@@%%#(**,,,,,,.         ..,,,,,,,,,,%#\\n      @(,,,,,..,            ,..   ..,,,**(%%%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%(((,,.,.,,,,,,.,..,,,,.,.,,,,.,..,.,,.,,,,,.,,,,,,,,,.*@%\\n       @%,,,,,,,,,,,,,,,.,.,,,      .,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,.,,,,,,#@@,\\n        ,@@(,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,.,,.,.,./#%&@@@@@#\\n         .@#&@@@@@%*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,/&@@@@@%&@%((((#@@.\\n          .@%((((#@@@/#&@@@@&%#/*,.,..,,,,.,,,,,.,.,,,,,,,,,,,,,,,,..,.,..,,...,,,...,,,,,,.,,,,,,,,,,,../#%&@@@@@@@&%((///*********./(((/&&\\n             %@&%%#/***********./////(((((((####%%&&@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@&&%%%%%%%%#((((((((%@&#(((((#%@%/*******************./*/\\n\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {ERC721} from \\\"solmate/tokens/ERC721.sol\\\";\\nimport {LibString} from \\\"solmate/utils/LibString.sol\\\";\\nimport {MerkleProofLib} from \\\"solmate/utils/MerkleProofLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"solmate/utils/FixedPointMathLib.sol\\\";\\nimport {ERC1155, ERC1155TokenReceiver} from \\\"solmate/tokens/ERC1155.sol\\\";\\nimport {toWadUnsafe, toDaysWadUnsafe} from \\\"solmate/utils/SignedWadMath.sol\\\";\\n\\nimport {LibGOO} from \\\"goo-issuance/LibGOO.sol\\\";\\nimport {LogisticVRGDA} from \\\"VRGDAs/LogisticVRGDA.sol\\\";\\n\\nimport {RandProvider} from \\\"./utils/rand/RandProvider.sol\\\";\\nimport {GobblersERC721} from \\\"./utils/token/GobblersERC721.sol\\\";\\n\\nimport {Goo} from \\\"./Goo.sol\\\";\\nimport {Pages} from \\\"./Pages.sol\\\";\\n\\n/// @title Art Gobblers NFT\\n/// @author FrankieIsLost <frankie@paradigm.xyz>\\n/// @author transmissions11 <t11s@paradigm.xyz>\\n/// @notice An experimental decentralized art factory by Justin Roiland and Paradigm.\\ncontract ArtGobblers is GobblersERC721, LogisticVRGDA, Owned, ERC1155TokenReceiver {\\n    using LibString for uint256;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                ADDRESSES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The address of the Goo ERC20 token contract.\\n    Goo public immutable goo;\\n\\n    /// @notice The address of the Pages ERC721 token contract.\\n    Pages public immutable pages;\\n\\n    /// @notice The address which receives gobblers reserved for the team.\\n    address public immutable team;\\n\\n    /// @notice The address which receives gobblers reserved for the community.\\n    address public immutable community;\\n\\n    /// @notice The address of a randomness provider. This provider will initially be\\n    /// a wrapper around Chainlink VRF v1, but can be changed in case it is fully sunset.\\n    RandProvider public randProvider;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            SUPPLY CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Maximum number of mintable gobblers.\\n    uint256 public constant MAX_SUPPLY = 10000;\\n\\n    /// @notice Maximum amount of gobblers mintable via mintlist.\\n    uint256 public constant MINTLIST_SUPPLY = 2000;\\n\\n    /// @notice Maximum amount of mintable legendary gobblers.\\n    uint256 public constant LEGENDARY_SUPPLY = 10;\\n\\n    /// @notice Maximum amount of gobblers split between the reserves.\\n    /// @dev Set to comprise 20% of the sum of goo mintable gobblers + reserved gobblers.\\n    uint256 public constant RESERVED_SUPPLY = (MAX_SUPPLY - MINTLIST_SUPPLY - LEGENDARY_SUPPLY) / 5;\\n\\n    /// @notice Maximum amount of gobblers that can be minted via VRGDA.\\n    // prettier-ignore\\n    uint256 public constant MAX_MINTABLE = MAX_SUPPLY\\n        - MINTLIST_SUPPLY\\n        - LEGENDARY_SUPPLY\\n        - RESERVED_SUPPLY;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           METADATA CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Provenance hash for gobbler metadata.\\n    bytes32 public immutable PROVENANCE_HASH;\\n\\n    /// @notice URI for gobblers pending reveal.\\n    string public UNREVEALED_URI;\\n\\n    /// @notice Base URI for minted gobblers.\\n    string public BASE_URI;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             MINTLIST STATE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Merkle root of mint mintlist.\\n    bytes32 public immutable merkleRoot;\\n\\n    /// @notice Mapping to keep track of which addresses have claimed from mintlist.\\n    mapping(address => bool) public hasClaimedMintlistGobbler;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            VRGDA INPUT STATE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Timestamp for the start of minting.\\n    uint256 public immutable mintStart;\\n\\n    /// @notice Number of gobblers minted from goo.\\n    uint128 public numMintedFromGoo;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         STANDARD GOBBLER STATE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Id of the most recently minted non legendary gobbler.\\n    /// @dev Will be 0 if no non legendary gobblers have been minted yet.\\n    uint128 public currentNonLegendaryId;\\n\\n    /// @notice The number of gobblers minted to the reserves.\\n    uint256 public numMintedForReserves;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     LEGENDARY GOBBLER AUCTION STATE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Initial legendary gobbler auction price.\\n    uint256 public constant LEGENDARY_GOBBLER_INITIAL_START_PRICE = 69;\\n\\n    /// @notice The last LEGENDARY_SUPPLY ids are reserved for legendary gobblers.\\n    uint256 public constant FIRST_LEGENDARY_GOBBLER_ID = MAX_SUPPLY - LEGENDARY_SUPPLY + 1;\\n\\n    /// @notice Legendary auctions begin each time a multiple of these many gobblers have been minted from goo.\\n    /// @dev We add 1 to LEGENDARY_SUPPLY because legendary auctions begin only after the first interval.\\n    uint256 public constant LEGENDARY_AUCTION_INTERVAL = MAX_MINTABLE / (LEGENDARY_SUPPLY + 1);\\n\\n    /// @notice Struct holding data required for legendary gobbler auctions.\\n    struct LegendaryGobblerAuctionData {\\n        // Start price of current legendary gobbler auction.\\n        uint128 startPrice;\\n        // Number of legendary gobblers sold so far.\\n        uint128 numSold;\\n    }\\n\\n    /// @notice Data about the current legendary gobbler auction.\\n    LegendaryGobblerAuctionData public legendaryGobblerAuctionData;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          GOBBLER REVEAL STATE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Struct holding data required for gobbler reveals.\\n    struct GobblerRevealsData {\\n        // Last randomness obtained from the rand provider.\\n        uint64 randomSeed;\\n        // Next reveal cannot happen before this timestamp.\\n        uint64 nextRevealTimestamp;\\n        // Id of latest gobbler which has been revealed so far.\\n        uint64 lastRevealedId;\\n        // Remaining gobblers to be revealed with the current seed.\\n        uint56 toBeRevealed;\\n        // Whether we are waiting to receive a seed from the provider.\\n        bool waitingForSeed;\\n    }\\n\\n    /// @notice Data about the current state of gobbler reveals.\\n    GobblerRevealsData public gobblerRevealsData;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            GOBBLED ART STATE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Maps gobbler ids to NFT contracts and their ids to the # of those NFT ids gobbled by the gobbler.\\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) public getCopiesOfArtGobbledByGobbler;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event GooBalanceUpdated(address indexed user, uint256 newGooBalance);\\n\\n    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);\\n    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);\\n    event LegendaryGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);\\n    event ReservedGobblersMinted(address indexed user, uint256 lastMintedGobblerId, uint256 numGobblersEach);\\n\\n    event RandomnessFulfilled(uint256 randomness);\\n    event RandomnessRequested(address indexed user, uint256 toBeRevealed);\\n    event RandProviderUpgraded(address indexed user, RandProvider indexed newRandProvider);\\n\\n    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);\\n\\n    event ArtGobbled(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    error InvalidProof();\\n    error AlreadyClaimed();\\n    error MintStartPending();\\n\\n    error SeedPending();\\n    error RevealsPending();\\n    error RequestTooEarly();\\n    error ZeroToBeRevealed();\\n    error NotRandProvider();\\n\\n    error ReserveImbalance();\\n\\n    error Cannibalism();\\n    error OwnerMismatch(address owner);\\n\\n    error NoRemainingLegendaryGobblers();\\n    error CannotBurnLegendary(uint256 gobblerId);\\n    error InsufficientGobblerAmount(uint256 cost);\\n    error LegendaryAuctionNotStarted(uint256 gobblersLeft);\\n\\n    error PriceExceededMax(uint256 currentPrice);\\n\\n    error NotEnoughRemainingToBeRevealed(uint256 totalRemainingToBeRevealed);\\n\\n    error UnauthorizedCaller(address caller);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Sets VRGDA parameters, mint config, relevant addresses, and URIs.\\n    /// @param _merkleRoot Merkle root of mint mintlist.\\n    /// @param _mintStart Timestamp for the start of the VRGDA mint.\\n    /// @param _goo Address of the Goo contract.\\n    /// @param _team Address of the team reserve.\\n    /// @param _community Address of the community reserve.\\n    /// @param _randProvider Address of the randomness provider.\\n    /// @param _baseUri Base URI for revealed gobblers.\\n    /// @param _unrevealedUri URI for unrevealed gobblers.\\n    /// @param _provenanceHash Provenance Hash for gobbler metadata.\\n    constructor(\\n        // Mint config:\\n        bytes32 _merkleRoot,\\n        uint256 _mintStart,\\n        // Addresses:\\n        Goo _goo,\\n        Pages _pages,\\n        address _team,\\n        address _community,\\n        RandProvider _randProvider,\\n        // URIs:\\n        string memory _baseUri,\\n        string memory _unrevealedUri,\\n        // Provenance:\\n        bytes32 _provenanceHash\\n    )\\n        GobblersERC721(\\\"Art Gobblers\\\", \\\"GOBBLER\\\")\\n        Owned(msg.sender)\\n        LogisticVRGDA(\\n            69.42e18, // Target price.\\n            0.31e18, // Price decay percent.\\n            // Max gobblers mintable via VRGDA.\\n            toWadUnsafe(MAX_MINTABLE),\\n            0.0023e18 // Time scale.\\n        )\\n    {\\n        mintStart = _mintStart;\\n        merkleRoot = _merkleRoot;\\n\\n        goo = _goo;\\n        pages = _pages;\\n        team = _team;\\n        community = _community;\\n        randProvider = _randProvider;\\n\\n        BASE_URI = _baseUri;\\n        UNREVEALED_URI = _unrevealedUri;\\n\\n        PROVENANCE_HASH = _provenanceHash;\\n\\n        // Set the starting price for the first legendary gobbler auction.\\n        legendaryGobblerAuctionData.startPrice = uint128(LEGENDARY_GOBBLER_INITIAL_START_PRICE);\\n\\n        // Reveal for initial mint must wait a day from the start of the mint.\\n        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          MINTLIST CLAIM LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Claim from mintlist, using a merkle proof.\\n    /// @dev Function does not directly enforce the MINTLIST_SUPPLY limit for gas efficiency. The\\n    /// limit is enforced during the creation of the merkle proof, which will be shared publicly.\\n    /// @param proof Merkle proof to verify the sender is mintlisted.\\n    /// @return gobblerId The id of the gobbler that was claimed.\\n    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {\\n        // If minting has not yet begun, revert.\\n        if (mintStart > block.timestamp) revert MintStartPending();\\n\\n        // If the user has already claimed, revert.\\n        if (hasClaimedMintlistGobbler[msg.sender]) revert AlreadyClaimed();\\n\\n        // If the user's proof is invalid, revert.\\n        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert InvalidProof();\\n\\n        hasClaimedMintlistGobbler[msg.sender] = true;\\n\\n        unchecked {\\n            // Overflow should be impossible due to supply cap of 10,000.\\n            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLegendaryId);\\n        }\\n\\n        _mint(msg.sender, gobblerId);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              MINTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Mint a gobbler, paying with goo.\\n    /// @param maxPrice Maximum price to pay to mint the gobbler.\\n    /// @param useVirtualBalance Whether the cost is paid from the\\n    /// user's virtual goo balance, or from their ERC20 goo balance.\\n    /// @return gobblerId The id of the gobbler that was minted.\\n    function mintFromGoo(uint256 maxPrice, bool useVirtualBalance) external returns (uint256 gobblerId) {\\n        // No need to check if we're at MAX_MINTABLE,\\n        // gobblerPrice() will revert once we reach it due to its\\n        // logistic nature. It will also revert prior to the mint start.\\n        uint256 currentPrice = gobblerPrice();\\n\\n        // If the current price is above the user's specified max, revert.\\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);\\n\\n        // Decrement the user's goo balance by the current\\n        // price, either from virtual balance or ERC20 balance.\\n        useVirtualBalance\\n            ? updateUserGooBalance(msg.sender, currentPrice, GooBalanceUpdateType.DECREASE)\\n            : goo.burnForGobblers(msg.sender, currentPrice);\\n\\n        unchecked {\\n            ++numMintedFromGoo; // Overflow should be impossible due to the supply cap.\\n\\n            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLegendaryId, currentPrice);\\n        }\\n\\n        _mint(msg.sender, gobblerId);\\n    }\\n\\n    /// @notice Gobbler pricing in terms of goo.\\n    /// @dev Will revert if called before minting starts\\n    /// or after all gobblers have been minted via VRGDA.\\n    /// @return Current price of a gobbler in terms of goo.\\n    function gobblerPrice() public view returns (uint256) {\\n        // We need checked math here to cause underflow\\n        // before minting has begun, preventing mints.\\n        uint256 timeSinceStart = block.timestamp - mintStart;\\n\\n        return getVRGDAPrice(toDaysWadUnsafe(timeSinceStart), numMintedFromGoo);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     LEGENDARY GOBBLER AUCTION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Mint a legendary gobbler by burning multiple standard gobblers.\\n    /// @param gobblerIds The ids of the standard gobblers to burn.\\n    /// @return gobblerId The id of the legendary gobbler that was minted.\\n    function mintLegendaryGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {\\n        // Get the number of legendary gobblers sold up until this point.\\n        uint256 numSold = legendaryGobblerAuctionData.numSold;\\n\\n        gobblerId = FIRST_LEGENDARY_GOBBLER_ID + numSold; // Assign id.\\n\\n        // This will revert if the auction hasn't started yet or legendaries\\n        // have sold out entirely, so there is no need to check here as well.\\n        uint256 cost = legendaryGobblerPrice();\\n\\n        if (gobblerIds.length < cost) revert InsufficientGobblerAmount(cost);\\n\\n        // Overflow should not occur in here, as most math is on emission multiples, which are inherently small.\\n        unchecked {\\n            uint256 burnedMultipleTotal; // The legendary's emissionMultiple will be 2x the sum of the gobblers burned.\\n\\n            /*//////////////////////////////////////////////////////////////\\n                                    BATCH BURN LOGIC\\n            //////////////////////////////////////////////////////////////*/\\n\\n            uint256 id; // Storing outside the loop saves ~7 gas per iteration.\\n\\n            for (uint256 i = 0; i < cost; ++i) {\\n                id = gobblerIds[i];\\n\\n                if (id >= FIRST_LEGENDARY_GOBBLER_ID) revert CannotBurnLegendary(id);\\n\\n                GobblerData storage gobbler = getGobblerData[id];\\n\\n                require(gobbler.owner == msg.sender, \\\"WRONG_FROM\\\");\\n\\n                burnedMultipleTotal += gobbler.emissionMultiple;\\n\\n                delete getApproved[id];\\n\\n                emit Transfer(msg.sender, gobbler.owner = address(0), id);\\n            }\\n\\n            /*//////////////////////////////////////////////////////////////\\n                                 LEGENDARY MINTING LOGIC\\n            //////////////////////////////////////////////////////////////*/\\n\\n            // The legendary's emissionMultiple is 2x the sum of the multiples of the gobblers burned.\\n            getGobblerData[gobblerId].emissionMultiple = uint32(burnedMultipleTotal * 2);\\n\\n            // Update the user's user data struct in one big batch. We add burnedMultipleTotal to their\\n            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that\\n            // were burned and hence should have their multiples subtracted from the user's total multiple.\\n            getUserData[msg.sender].lastBalance = uint128(gooBalance(msg.sender)); // Checkpoint balance.\\n            getUserData[msg.sender].lastTimestamp = uint64(block.timestamp); // Store time alongside it.\\n            getUserData[msg.sender].emissionMultiple += uint32(burnedMultipleTotal); // Update multiple.\\n            // Update the total number of gobblers owned by the user. The call to _mint\\n            // below will increase the count by 1 to account for the new legendary gobbler.\\n            getUserData[msg.sender].gobblersOwned -= uint32(cost);\\n\\n            // New start price is the max of LEGENDARY_GOBBLER_INITIAL_START_PRICE and cost * 2.\\n            legendaryGobblerAuctionData.startPrice = uint128(\\n                cost <= LEGENDARY_GOBBLER_INITIAL_START_PRICE / 2 ? LEGENDARY_GOBBLER_INITIAL_START_PRICE : cost * 2\\n            );\\n            legendaryGobblerAuctionData.numSold = uint128(numSold + 1); // Increment the # of legendaries sold.\\n\\n            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.\\n            emit LegendaryGobblerMinted(msg.sender, gobblerId, gobblerIds[:cost]);\\n\\n            _mint(msg.sender, gobblerId);\\n        }\\n    }\\n\\n    /// @notice Calculate the legendary gobbler price in terms of gobblers, according to a linear decay function.\\n    /// @dev The price of a legendary gobbler decays as gobblers are minted. The first legendary auction begins when\\n    /// 1 LEGENDARY_AUCTION_INTERVAL worth of gobblers are minted, and the price decays linearly while the next interval of\\n    /// gobblers are minted. Every time an additional interval is minted, a new auction begins until all legendaries have been sold.\\n    /// @dev Will revert if the auction hasn't started yet or legendaries have sold out entirely.\\n    /// @return The current price of the legendary gobbler being auctioned, in terms of gobblers.\\n    function legendaryGobblerPrice() public view returns (uint256) {\\n        // Retrieve and cache various auction parameters and variables.\\n        uint256 startPrice = legendaryGobblerAuctionData.startPrice;\\n        uint256 numSold = legendaryGobblerAuctionData.numSold;\\n\\n        // If all legendary gobblers have been sold, there are none left to auction.\\n        if (numSold == LEGENDARY_SUPPLY) revert NoRemainingLegendaryGobblers();\\n\\n        unchecked {\\n            // Get and cache the number of standard gobblers sold via VRGDA up until this point.\\n            uint256 mintedFromGoo = numMintedFromGoo;\\n\\n            // The number of gobblers minted at the start of the auction is computed by multiplying the # of\\n            // intervals that must pass before the next auction begins by the number of gobblers in each interval.\\n            uint256 numMintedAtStart = (numSold + 1) * LEGENDARY_AUCTION_INTERVAL;\\n\\n            // If not enough gobblers have been minted to start the auction yet, return how many need to be minted.\\n            if (numMintedAtStart > mintedFromGoo) revert LegendaryAuctionNotStarted(numMintedAtStart - mintedFromGoo);\\n\\n            // Compute how many gobblers were minted since the auction began.\\n            uint256 numMintedSinceStart = mintedFromGoo - numMintedAtStart;\\n\\n            // prettier-ignore\\n            // If we've minted the full interval or beyond it, the price has decayed to 0.\\n            if (numMintedSinceStart >= LEGENDARY_AUCTION_INTERVAL) return 0;\\n            // Otherwise decay the price linearly based on what fraction of the interval has been minted.\\n            else return FixedPointMathLib.unsafeDivUp(startPrice * (LEGENDARY_AUCTION_INTERVAL - numMintedSinceStart), LEGENDARY_AUCTION_INTERVAL);\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            RANDOMNESS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Request a new random seed for revealing gobblers.\\n    function requestRandomSeed() external returns (bytes32) {\\n        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;\\n\\n        // A new random seed cannot be requested before the next reveal timestamp.\\n        if (block.timestamp < nextRevealTimestamp) revert RequestTooEarly();\\n\\n        // A random seed can only be requested when all gobblers from the previous seed have been revealed.\\n        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.\\n        if (gobblerRevealsData.toBeRevealed != 0) revert RevealsPending();\\n\\n        unchecked {\\n            // Prevent revealing while we wait for the seed.\\n            gobblerRevealsData.waitingForSeed = true;\\n\\n            // Compute the number of gobblers to be revealed with the seed.\\n            uint256 toBeRevealed = currentNonLegendaryId - gobblerRevealsData.lastRevealedId;\\n\\n            // Ensure that there are more than 0 gobblers to be revealed,\\n            // otherwise the contract could waste LINK revealing nothing.\\n            if (toBeRevealed == 0) revert ZeroToBeRevealed();\\n\\n            // Lock in the number of gobblers to be revealed from seed.\\n            gobblerRevealsData.toBeRevealed = uint56(toBeRevealed);\\n\\n            // We enable reveals for a set of gobblers every 24 hours.\\n            // Timestamp overflow is impossible on human timescales.\\n            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);\\n\\n            emit RandomnessRequested(msg.sender, toBeRevealed);\\n        }\\n\\n        // Call out to the randomness provider.\\n        return randProvider.requestRandomBytes();\\n    }\\n\\n    /// @notice Callback from rand provider. Sets randomSeed. Can only be called by the rand provider.\\n    /// @param randomness The 256 bits of verifiable randomness provided by the rand provider.\\n    function acceptRandomSeed(bytes32, uint256 randomness) external {\\n        // The caller must be the randomness provider, revert in the case it's not.\\n        if (msg.sender != address(randProvider)) revert NotRandProvider();\\n\\n        // The unchecked cast to uint64 is equivalent to moduloing the randomness by 2**64.\\n        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.\\n\\n        gobblerRevealsData.waitingForSeed = false; // We have the seed now, open up reveals.\\n\\n        emit RandomnessFulfilled(randomness);\\n    }\\n\\n    /// @notice Upgrade the rand provider contract. Useful if current VRF is sunset.\\n    /// @param newRandProvider The new randomness provider contract address.\\n    function upgradeRandProvider(RandProvider newRandProvider) external onlyOwner {\\n        // Reset reveal state when we upgrade while the seed is pending. This gives us a\\n        // safeguard against malfunctions since we won't be stuck waiting for a seed forever.\\n        if (gobblerRevealsData.waitingForSeed) {\\n            gobblerRevealsData.waitingForSeed = false;\\n            gobblerRevealsData.toBeRevealed = 0;\\n            gobblerRevealsData.nextRevealTimestamp -= 1 days;\\n        }\\n\\n        randProvider = newRandProvider; // Update the randomness provider.\\n\\n        emit RandProviderUpgraded(msg.sender, newRandProvider);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          GOBBLER REVEAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Knuth shuffle to progressively reveal\\n    /// new gobblers using entropy from a random seed.\\n    /// @param numGobblers The number of gobblers to reveal.\\n    function revealGobblers(uint256 numGobblers) external {\\n        uint256 randomSeed = gobblerRevealsData.randomSeed;\\n\\n        uint256 lastRevealedId = gobblerRevealsData.lastRevealedId;\\n\\n        uint256 totalRemainingToBeRevealed = gobblerRevealsData.toBeRevealed;\\n\\n        // Can't reveal if we're still waiting for a new seed.\\n        if (gobblerRevealsData.waitingForSeed) revert SeedPending();\\n\\n        // Can't reveal more gobblers than are currently remaining to be revealed with the seed.\\n        if (numGobblers > totalRemainingToBeRevealed) revert NotEnoughRemainingToBeRevealed(totalRemainingToBeRevealed);\\n\\n        // Implements a Knuth shuffle. If something in\\n        // here can overflow, we've got bigger problems.\\n        unchecked {\\n            for (uint256 i = 0; i < numGobblers; ++i) {\\n                /*//////////////////////////////////////////////////////////////\\n                                      DETERMINE RANDOM SWAP\\n                //////////////////////////////////////////////////////////////*/\\n\\n                // Number of ids that have not been revealed. Subtract 1\\n                // because we don't want to include any legendaries in the swap.\\n                uint256 remainingIds = FIRST_LEGENDARY_GOBBLER_ID - lastRevealedId - 1;\\n\\n                // Randomly pick distance for swap.\\n                uint256 distance = randomSeed % remainingIds;\\n\\n                // Current id is consecutive to last reveal.\\n                uint256 currentId = ++lastRevealedId;\\n\\n                // Select swap id, adding distance to next reveal id.\\n                uint256 swapId = currentId + distance;\\n\\n                /*//////////////////////////////////////////////////////////////\\n                                       GET INDICES FOR IDS\\n                //////////////////////////////////////////////////////////////*/\\n\\n                // Get the index of the swap id.\\n                uint64 swapIndex = getGobblerData[swapId].idx == 0\\n                    ? uint64(swapId) // Hasn't been shuffled before.\\n                    : getGobblerData[swapId].idx; // Shuffled before.\\n\\n                // Get the owner of the current id.\\n                address currentIdOwner = getGobblerData[currentId].owner;\\n\\n                // Get the index of the current id.\\n                uint64 currentIndex = getGobblerData[currentId].idx == 0\\n                    ? uint64(currentId) // Hasn't been shuffled before.\\n                    : getGobblerData[currentId].idx; // Shuffled before.\\n\\n                /*//////////////////////////////////////////////////////////////\\n                                  SWAP INDICES AND SET MULTIPLE\\n                //////////////////////////////////////////////////////////////*/\\n\\n                // Determine the current id's new emission multiple.\\n                uint256 newCurrentIdMultiple = 9; // For beyond 7963.\\n\\n                // The branchless expression below is equivalent to:\\n                //      if (swapIndex <= 3054) newCurrentIdMultiple = 6;\\n                // else if (swapIndex <= 5672) newCurrentIdMultiple = 7;\\n                // else if (swapIndex <= 7963) newCurrentIdMultiple = 8;\\n                assembly {\\n                    // prettier-ignore\\n                    newCurrentIdMultiple := sub(sub(sub(\\n                        newCurrentIdMultiple,\\n                        lt(swapIndex, 7964)),\\n                        lt(swapIndex, 5673)),\\n                        lt(swapIndex, 3055)\\n                    )\\n                }\\n\\n                // Swap the index and multiple of the current id.\\n                getGobblerData[currentId].idx = swapIndex;\\n                getGobblerData[currentId].emissionMultiple = uint32(newCurrentIdMultiple);\\n\\n                // Swap the index of the swap id.\\n                getGobblerData[swapId].idx = currentIndex;\\n\\n                /*//////////////////////////////////////////////////////////////\\n                                   UPDATE CURRENT ID MULTIPLE\\n                //////////////////////////////////////////////////////////////*/\\n\\n                // Update the user data for the owner of the current id.\\n                getUserData[currentIdOwner].lastBalance = uint128(gooBalance(currentIdOwner));\\n                getUserData[currentIdOwner].lastTimestamp = uint64(block.timestamp);\\n                getUserData[currentIdOwner].emissionMultiple += uint32(newCurrentIdMultiple);\\n\\n                // Update the random seed to choose a new distance for the next iteration.\\n                // It is critical that we cast to uint64 here, as otherwise the random seed\\n                // set after calling revealGobblers(1) thrice would differ from the seed set\\n                // after calling revealGobblers(3) a single time. This would enable an attacker\\n                // to choose from a number of different seeds and use whichever is most favorable.\\n                // Equivalent to randomSeed = uint64(uint256(keccak256(abi.encodePacked(randomSeed))))\\n                assembly {\\n                    mstore(0, randomSeed) // Store the random seed in scratch space.\\n\\n                    // Moduloing by 2 ** 64 is equivalent to a uint64 cast.\\n                    randomSeed := mod(keccak256(0, 32), exp(2, 64))\\n                }\\n            }\\n\\n            // Update all relevant reveal state.\\n            gobblerRevealsData.randomSeed = uint64(randomSeed);\\n            gobblerRevealsData.lastRevealedId = uint64(lastRevealedId);\\n            gobblerRevealsData.toBeRevealed = uint56(totalRemainingToBeRevealed - numGobblers);\\n\\n            emit GobblersRevealed(msg.sender, numGobblers, lastRevealedId);\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                URI LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Returns a token's URI if it has been minted.\\n    /// @param gobblerId The id of the token to get the URI for.\\n    function tokenURI(uint256 gobblerId) public view virtual override returns (string memory) {\\n        // Between 0 and lastRevealed are revealed normal gobblers.\\n        if (gobblerId <= gobblerRevealsData.lastRevealedId) {\\n            if (gobblerId == 0) revert(\\\"NOT_MINTED\\\"); // 0 is not a valid id for Art Gobblers.\\n\\n            return string.concat(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString());\\n        }\\n\\n        // Between lastRevealed + 1 and currentNonLegendaryId are minted but not revealed.\\n        if (gobblerId <= currentNonLegendaryId) return UNREVEALED_URI;\\n\\n        // Between currentNonLegendaryId and FIRST_LEGENDARY_GOBBLER_ID are unminted.\\n        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID) revert(\\\"NOT_MINTED\\\");\\n\\n        // Between FIRST_LEGENDARY_GOBBLER_ID and FIRST_LEGENDARY_GOBBLER_ID + numSold are minted legendaries.\\n        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold)\\n            return string.concat(BASE_URI, gobblerId.toString());\\n\\n        revert(\\\"NOT_MINTED\\\"); // Unminted legendaries and invalid token ids.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            GOBBLE ART LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Feed a gobbler a work of art.\\n    /// @param gobblerId The gobbler to feed the work of art.\\n    /// @param nft The ERC721 or ERC1155 contract of the work of art.\\n    /// @param id The id of the work of art.\\n    /// @param isERC1155 Whether the work of art is an ERC1155 token.\\n    function gobble(\\n        uint256 gobblerId,\\n        address nft,\\n        uint256 id,\\n        bool isERC1155\\n    ) external {\\n        // Get the owner of the gobbler to feed.\\n        address owner = getGobblerData[gobblerId].owner;\\n\\n        // The caller must own the gobbler they're feeding.\\n        if (owner != msg.sender) revert OwnerMismatch(owner);\\n\\n        // Gobblers have taken a vow not to eat other gobblers.\\n        if (nft == address(this)) revert Cannibalism();\\n\\n        unchecked {\\n            // Increment the # of copies gobbled by the gobbler. Unchecked is\\n            // safe, as an NFT can't have more than type(uint256).max copies.\\n            ++getCopiesOfArtGobbledByGobbler[gobblerId][nft][id];\\n        }\\n\\n        emit ArtGobbled(msg.sender, gobblerId, nft, id);\\n\\n        isERC1155\\n            ? ERC1155(nft).safeTransferFrom(msg.sender, address(this), id, 1, \\\"\\\")\\n            : ERC721(nft).transferFrom(msg.sender, address(this), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                GOO LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Calculate a user's virtual goo balance.\\n    /// @param user The user to query balance for.\\n    function gooBalance(address user) public view returns (uint256) {\\n        // Compute the user's virtual goo balance using LibGOO.\\n        // prettier-ignore\\n        return LibGOO.computeGOOBalance(\\n            getUserData[user].emissionMultiple,\\n            getUserData[user].lastBalance,\\n            uint256(toDaysWadUnsafe(block.timestamp - getUserData[user].lastTimestamp))\\n        );\\n    }\\n\\n    /// @notice Add goo to your emission balance,\\n    /// burning the corresponding ERC20 balance.\\n    /// @param gooAmount The amount of goo to add.\\n    function addGoo(uint256 gooAmount) external {\\n        // Burn goo being added to gobbler.\\n        goo.burnForGobblers(msg.sender, gooAmount);\\n\\n        // Increase msg.sender's virtual goo balance.\\n        updateUserGooBalance(msg.sender, gooAmount, GooBalanceUpdateType.INCREASE);\\n    }\\n\\n    /// @notice Remove goo from your emission balance, and\\n    /// add the corresponding amount to your ERC20 balance.\\n    /// @param gooAmount The amount of goo to remove.\\n    function removeGoo(uint256 gooAmount) external {\\n        // Decrease msg.sender's virtual goo balance.\\n        updateUserGooBalance(msg.sender, gooAmount, GooBalanceUpdateType.DECREASE);\\n\\n        // Mint the corresponding amount of ERC20 goo.\\n        goo.mintForGobblers(msg.sender, gooAmount);\\n    }\\n\\n    /// @notice Burn an amount of a user's virtual goo balance. Only callable\\n    /// by the Pages contract to enable purchasing pages with virtual balance.\\n    /// @param user The user whose virtual goo balance we should burn from.\\n    /// @param gooAmount The amount of goo to burn from the user's virtual balance.\\n    function burnGooForPages(address user, uint256 gooAmount) external {\\n        // The caller must be the Pages contract, revert otherwise.\\n        if (msg.sender != address(pages)) revert UnauthorizedCaller(msg.sender);\\n\\n        // Burn the requested amount of goo from the user's virtual goo balance.\\n        // Will revert if the user doesn't have enough goo in their virtual balance.\\n        updateUserGooBalance(user, gooAmount, GooBalanceUpdateType.DECREASE);\\n    }\\n\\n    /// @dev An enum for representing whether to\\n    /// increase or decrease a user's goo balance.\\n    enum GooBalanceUpdateType {\\n        INCREASE,\\n        DECREASE\\n    }\\n\\n    /// @notice Update a user's virtual goo balance.\\n    /// @param user The user whose virtual goo balance we should update.\\n    /// @param gooAmount The amount of goo to update the user's virtual balance by.\\n    /// @param updateType Whether to increase or decrease the user's balance by gooAmount.\\n    function updateUserGooBalance(\\n        address user,\\n        uint256 gooAmount,\\n        GooBalanceUpdateType updateType\\n    ) internal {\\n        // Will revert due to underflow if we're decreasing by more than the user's current balance.\\n        // Don't need to do checked addition in the increase case, but we do it anyway for convenience.\\n        uint256 updatedBalance = updateType == GooBalanceUpdateType.INCREASE\\n            ? gooBalance(user) + gooAmount\\n            : gooBalance(user) - gooAmount;\\n\\n        // Snapshot the user's new goo balance with the current timestamp.\\n        getUserData[user].lastBalance = uint128(updatedBalance);\\n        getUserData[user].lastTimestamp = uint64(block.timestamp);\\n\\n        emit GooBalanceUpdated(user, updatedBalance);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     RESERVED GOBBLERS MINTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Mint a number of gobblers to the reserves.\\n    /// @param numGobblersEach The number of gobblers to mint to each reserve.\\n    /// @dev Gobblers minted to reserves cannot comprise more than 20% of the sum of\\n    /// the supply of goo minted gobblers and the supply of gobblers minted to reserves.\\n    function mintReservedGobblers(uint256 numGobblersEach) external returns (uint256 lastMintedGobblerId) {\\n        unchecked {\\n            // Optimistically increment numMintedForReserves, may be reverted below.\\n            // Overflow in this calculation is possible but numGobblersEach would have to\\n            // be so large that it would cause the loop in _batchMint to run out of gas quickly.\\n            uint256 newNumMintedForReserves = numMintedForReserves += (numGobblersEach * 2);\\n\\n            // Ensure that after this mint gobblers minted to reserves won't comprise more than 20% of\\n            // the sum of the supply of goo minted gobblers and the supply of gobblers minted to reserves.\\n            if (newNumMintedForReserves > (numMintedFromGoo + newNumMintedForReserves) / 5) revert ReserveImbalance();\\n        }\\n\\n        // Mint numGobblersEach gobblers to both the team and community reserve.\\n        lastMintedGobblerId = _batchMint(team, numGobblersEach, currentNonLegendaryId);\\n        lastMintedGobblerId = _batchMint(community, numGobblersEach, lastMintedGobblerId);\\n\\n        currentNonLegendaryId = uint128(lastMintedGobblerId); // Set currentNonLegendaryId.\\n\\n        emit ReservedGobblersMinted(msg.sender, lastMintedGobblerId, numGobblersEach);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          CONVENIENCE FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Convenience function to get emissionMultiple for a gobbler.\\n    /// @param gobblerId The gobbler to get emissionMultiple for.\\n    function getGobblerEmissionMultiple(uint256 gobblerId) external view returns (uint256) {\\n        return getGobblerData[gobblerId].emissionMultiple;\\n    }\\n\\n    /// @notice Convenience function to get emissionMultiple for a user.\\n    /// @param user The user to get emissionMultiple for.\\n    function getUserEmissionMultiple(address user) external view returns (uint256) {\\n        return getUserData[user].emissionMultiple;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public override {\\n        require(from == getGobblerData[id].owner, \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        delete getApproved[id];\\n\\n        getGobblerData[id].owner = to;\\n\\n        unchecked {\\n            uint32 emissionMultiple = getGobblerData[id].emissionMultiple; // Caching saves gas.\\n\\n            // We update their last balance before updating their emission multiple to avoid\\n            // penalizing them by retroactively applying their new (lower) emission multiple.\\n            getUserData[from].lastBalance = uint128(gooBalance(from));\\n            getUserData[from].lastTimestamp = uint64(block.timestamp);\\n            getUserData[from].emissionMultiple -= emissionMultiple;\\n            getUserData[from].gobblersOwned -= 1;\\n\\n            // We update their last balance before updating their emission multiple to avoid\\n            // overpaying them by retroactively applying their new (higher) emission multiple.\\n            getUserData[to].lastBalance = uint128(gooBalance(to));\\n            getUserData[to].lastTimestamp = uint64(block.timestamp);\\n            getUserData[to].emissionMultiple += emissionMultiple;\\n            getUserData[to].gobblersOwned += 1;\\n        }\\n\\n        emit Transfer(from, to, id);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/art-gobblers/src/Goo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\n/*                                                                %#/*********(&,\\n                                                              .#*********************#.\\n                                                            #****./*********************%\\n                                                          %*******************************%\\n                                                        &**********************************,((\\n                                                       @(*,***********************************#&\\n                                                    (*********************#***********************(\\n                                                  ,%@/**************#%***%**&***%*******************,\\n                                                  /********************#****#*#******,**************%\\n                                                 ,************,#(*****************(#/&(*,*,*********#\\n                                                 **************(%%(&************#@%(///************(\\n                                                ./**************,*./##****************************#*%\\n                                               #**&**************************************************&@@@@@&@&%#((./.\\n                                              (*******************@&%&@@@.   /    %  &********(@/,****,,,*,,,****,,*,**********,*,\\n                                             &******************#  /    *     /   /    .. %/****(******************,**&***********./\\n                                  /%(*******************&***./#    #.#%%    .,    .,   ##&&@****#***********************************.\\n                         *#(*,**************************(***(///.*     *     #     #   .  %*****(/*************************************&\\n                 *(***********************************.//****&    #     #    (#&((%@*,*&(******(%************./@#*   *%&%(/&*************(\\n               #,**************************************,&******&..*#&(*****,,,,/********************************             (/******,**,**,\\n              %*****************************************.//**************#**************************************               .(***********#\\n             (*************************./************************************************************************              @**************\\n             ,**********&@@@&&%#        &,**********************************************************************@             ./*,%*,********./\\n            ***********                .************@(*************(&#///////////////.//#&%/*****************&*,,                &************%\\n           (**********.                 .%********************(&./////////////////////////////(%******************                *(**&,&##*\\n          #**********(,                &,*./***************%(///////////////////////////////////*&****************\\n        (************%                %,*****************&///////////////////////////////////////*(***************.\\n      .(***************(             #******************&//////////////////////////////////////////****************\\n     .&*************%*./            .*******************%/////////////////////////////////////////****************##\\n      .*************%*%             (********************#(///////////////////////////////////(#*****************&**,***,.\\n           #***./,***%              #**********************,%%*./////////////////////////*(@*******************(/****./********,((\\n           @@,                    &**@*****************************./(%@&%%((((((%&&%(*********************************&,**********.\\n                         .   .#,,*****./&/*****************************************************************************************\\n                          %,******************************************************************************************************#\\n                       %*******@*****************************************************./#%%,...((,           .,********************(\\n                     ,*******************************@&(**./%&%*        .,//(//////////,                           ,************./\\n                      /**************************&*                      ////*(/////////                            ***(*********%\\n                       (*********************(#                         ..///////////(//(                          .***********./\\n                         #******************%                       *..,,,(//////////(//(*.//,                     %***************&\\n                           %*****************                   ////////&&&&&&&&%#(//(&@&#(#@@                    &*********************#\\n                             #****************.                 ,//(//////(@@%%%%%///////****&                   &************************(\\n                           .**&***(************./               .@.,(///(/(.//(***((*(//*****@/&                ,*************************./\\n                            &********************#             .(#(@#//(****(//(*****(/(&(..&(                  ./*********************(#.\\n                        #/***********************./          /,,./*((#%@(%&%(((((((#%&&&/(#(#@(\\n                      #*,***********************,*&                 .%@@@&#,  ///(/*\\n                     (*************************%                             ..(/,./(,.,*\\n                      /#/*./(%&(.*/\\n\\n/// @title Goo Token (GOO)\\n/// @author FrankieIsLost <frankie@paradigm.xyz>\\n/// @author transmissions11 <t11s@paradigm.xyz>\\n/// @notice Goo is the in-game token for ArtGobblers. It's a standard ERC20\\n/// token that can be burned and minted by the gobblers and pages contract.\\ncontract Goo is ERC20(\\\"Goo\\\", \\\"GOO\\\", 18) {\\n    /*//////////////////////////////////////////////////////////////\\n                                ADDRESSES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The address of the Art Gobblers contract.\\n    address public immutable artGobblers;\\n\\n    /// @notice The address of the Pages contract.\\n    address public immutable pages;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    error Unauthorized();\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Sets the addresses of relevant contracts.\\n    /// @param _artGobblers Address of the ArtGobblers contract.\\n    /// @param _pages Address of the Pages contract.\\n    constructor(address _artGobblers, address _pages) {\\n        artGobblers = _artGobblers;\\n        pages = _pages;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Requires caller address to match user address.\\n    modifier only(address user) {\\n        if (msg.sender != user) revert Unauthorized();\\n\\n        _;\\n    }\\n\\n    /// @notice Mint any amount of goo to a user. Can only be called by ArtGobblers.\\n    /// @param to The address of the user to mint goo to.\\n    /// @param amount The amount of goo to mint.\\n    function mintForGobblers(address to, uint256 amount) external only(artGobblers) {\\n        _mint(to, amount);\\n    }\\n\\n    /// @notice Burn any amount of goo from a user. Can only be called by ArtGobblers.\\n    /// @param from The address of the user to burn goo from.\\n    /// @param amount The amount of goo to burn.\\n    function burnForGobblers(address from, uint256 amount) external only(artGobblers) {\\n        _burn(from, amount);\\n    }\\n\\n    /// @notice Burn any amount of goo from a user. Can only be called by Pages.\\n    /// @param from The address of the user to burn goo from.\\n    /// @param amount The amount of goo to burn.\\n    function burnForPages(address from, uint256 amount) external only(pages) {\\n        _burn(from, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/art-gobblers/src/Pages.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {LibString} from \\\"solmate/utils/LibString.sol\\\";\\nimport {toDaysWadUnsafe} from \\\"solmate/utils/SignedWadMath.sol\\\";\\n\\nimport {LogisticToLinearVRGDA} from \\\"VRGDAs/LogisticToLinearVRGDA.sol\\\";\\n\\nimport {PagesERC721} from \\\"./utils/token/PagesERC721.sol\\\";\\n\\nimport {Goo} from \\\"./Goo.sol\\\";\\nimport {ArtGobblers} from \\\"./ArtGobblers.sol\\\";\\n\\n/*                                                                                   &@./(\\n                                                                                    &//*&\\n                                                                                   @/*.&\\n                                                                                 (#/./%\\n                                                             .,(#%%&@@&%#(/,    *#./#,                   .*(%@@@@&%#((//////(#&@%.\\n                                                      #&@&/*./*************.///&@%&@@@@@@@@&%#(///**********./********************#&\\n                                                  &@(/*****************************************************************************#/\\n                                               (&**********************************************************************************@\\n                                              @**********************************************************************************(&\\n                                             &/*******************************************************************************%@.\\n           ,(                                *&/***********************************************************************./#@@%(((#@%\\n            .//                                (@/***./*****************************************************.///#&@@@&##(((#(##((##%&\\n             /*.//                                 *@@&#(/////(#&@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&&%%%%%####(#(((((((##(((##((#(###((((#@&\\n              (****./                               @###(###(((((###(##((#(((((#(#####((((#(((((((#((((((((((((((((((((#(##(####((((#(#@\\n              /******./                            &#((#########(############((#(######(########(####(##(###%&&&%########%&&%###((((####@\\n              ,********./                         /&((((#(#((##(((#(((#((########(###((((((((((((((((#((%&#((#((#((((((((((#((((((((((((#@\\n              .**********(                        @#(#(#####(###(#&&&#(((((((((#(((%@%##########(######&#((#&#(((##((((%&@%#((##(#(((#((#%&\\n               /**********(                      /%(#(((((#((#&%(((#(###(#########(((###(((#####(###((#(%@%###(###((((##(((##&%#(##(((##(#@,\\n               (**********./                     @#(#(((((###((#(#((#(((((###(((#(#%@@###((#####(###((#&%&&/.              .*#&&@#((((((((%@\\n               ./**********(                    ,%((((((((##((((#&@#(##((((((##%%&&&&%%#&##((###(##((%*                          .@#(##((##@.\\n                ./********./                    %#((#(((((#####@##(##%@&(.                %#((#((###%*            *(,.             %#((#(((@,\\n                  /********(                    @#((#((((####@#%@#                         .&((((##(&           &@@@@@@%            &#((#&#&,\\n                    /******(                   ,&(#(#((((###@&                              .&##(###&            /@@@@@@            (%((((#@%\\n                      ./*#@@@@*                (%#(((((#((#&           #@@@@@&.              (%#(#((&.            /#.               ##(#(#(##@&\\n                       @%(/((((&               &####(((((#@            .@@@@@@@               &((##(#@@(.                      .#&%#&(#####((##@.\\n                      /#(((((((##         (#*  @##(#(((((#@             ,@@@/*               @&((####(&&#(##%%&&&%%##%&&&&&%##(((#%%(###((####((&&\\n                       #((((%@@@@@.    @#(((#@*&##(((((((#@                              .%&#@#((####(((#((#(((((((((((((((((((##%((#(###((#####(#@\\n                       #@/,,,@#((#%(  @((&%,,,&&%((((((#(#&,                        .%@%#((#@%(((###((((#(((##%&&&&&&&&&&&%#((((####(###(###(###((#@%\\n                   #@##&(,,,(&(##(#@ &###@**#@@@@(((((((##(@@@#,            ,(@@&##(((((((((#((((#####((#%@@@@@@@@@@@@@@@@@&&%%################%%(##@&\\n                %&##((((#&@@%(((((%# &##(####(#&@&(((((((#(##@#((((((((##((###(#(#(((#%&##(#####(####(##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&%##(((#((%@\\n             *&#((#######((((###(%&@ (#(####(((#&@%(((((####(##%&##(#((((###(###%@@%###(##%%%###(#(####@@@@&%###((##((((((((##((((((((##((((((#((##(#@\\n           (&((((((((((((((((##@&/((@@&####(((((((#&&%#(#((((((((#(((((#((###(#((#&@&&@@@@@@@@%((((((#((((#((((((((((((((((((((((((((((((((((((((((((#\\n         .@#(##((((((((((#((&@#%@@&%%&@&##(((###(#####(#@%##(###((#######(((#(#%@#(((#((#(######(###############(###############(###############(##(##\\n        (%(#((#((((((((((#&@%#(%%,,,,&#(#@######(####(((((%%(#(#(###(#(((#%@@@@@&##(####(((#(#(#(#######(#######(#######(#######(#######(#######(##((#\\n       (%((####((###(#&@########@*,,,@#(#%@(((#((#######(((#&(##(###(%@@@@@%##((#@&%####&@@%(###(###############(###############(###############(###(#\\n       @((##(##(((#@%#(#((##(#(#(#&@&#(##@&&@@@&##(#(###(#((&##%&@@%##(#(#(((####((((&%((###((#&####(###(###(###(###(###(###(###(###(###(###(###(####(\\n       @((#(((##@%(((((((######((###(#&@%#(#(#(#(##########(%%((((#((((#(((((((((((((#&&#(###&&(((##############(###############(###############(#####\\n       .%(#(#%@#((###(#((########&@@((((&#(#####((######(##(%&#((#######(#######(#####(#####((##(#######(#######(#######(#######(#######(#######(#####\\n         &##@#(#((##((#####(#&&#(((#&(((@#######(##########(&%%#(#((##(#########(############((((###############(###############(###############(#####\\n          *%(((#(#(#(#(#(#%@#(((((((((##(((((((#(#(#(#(#(#(#@###(((#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#\\n         ,&(##(#(#####((%@#(###((((((((####((###(########((%@&##(###############(###############(###############(###############(###############(#####\\n         &#((((#(##(####&%(##(((((%@%((#(#######(######(##%@&#((((######(#######(#######(#######(#######(#######(#######(#######(#######(#######(#####\\n         %###((#(##########((###((##((##########(####(#((&&###(((###############(###############(###############(###############(###############(#####\\n          &#(#(#(###(###(##((###(###((##(###(###(###((#&&#######(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(#\\n           %%(#(###(#(#(########(#####(#########(###((#&%#(#####(###############(###############(###############(###############(#############(((#####\\n              (&%%#%#%#((#(#####(#######(#######(######((#&%(###(#######(#######(#######(#######(#######(#######(#######(#######((##(##((#(#(###(((###\\n                       ##(#(####(###############(######(((((####(###############(###############(###############(#############(##(#((##%%&@@@@&&&%%%%%\\n                         &((((((((((((((((((((((((((((((((((((##((((((((((((((((((((((((((((((((((((((((((((((((((((((((##(((##&@@&&%%%%%%%%%%%%%%%%%%\\n                          &#(((#(###############(#############%&((((############(###############(###############(#######%&@&%%%%%%%%%%%%%%%%%%%%%%%%%%\\n                           @####(#######(#######(#######(##(%&(((#(#####(#######(#######(#######(#######(#######((##%@&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n                            @#(((###############(#######((#@#(##(###############(###############(##############(%@&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n                             &(#(###(###(###(###(###(##((#&###(((###(###(###(###(###(###(###(###(###(###(#####@&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n                             /%((###############(#####((#&######(###############(###############(#(########&&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n                              &#(#######(#######(######(%%##((##(#######(#######(#######(#######(####(((#@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n                               @################(######(%%##((##((##############(###############(##(###@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n                                &##((#(#(#(#(#(#(#(#(#(#(@##(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(##@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n                                (%(((###########(#######(#&&##(#(###############(################(#@&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n                                 ##(####(#######(#######(#(#%&#((#######(#######(#######(#######(&@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\n                                  /%(((###(#####(########(###(#&%###############(############((#@&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\\n\\n/// @title Pages NFT\\n/// @author FrankieIsLost <frankie@paradigm.xyz>\\n/// @author transmissions11 <t11s@paradigm.xyz>\\n/// @notice Pages is an ERC721 that can hold custom art.\\ncontract Pages is PagesERC721, LogisticToLinearVRGDA {\\n    using LibString for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                ADDRESSES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The address of the goo ERC20 token contract.\\n    Goo public immutable goo;\\n\\n    /// @notice The address which receives pages reserved for the community.\\n    address public immutable community;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                  URIS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Base URI for minted pages.\\n    string public BASE_URI;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            VRGDA INPUT STATE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Timestamp for the start of the VRGDA mint.\\n    uint256 public immutable mintStart;\\n\\n    /// @notice Id of the most recently minted page.\\n    /// @dev Will be 0 if no pages have been minted yet.\\n    uint128 public currentId;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          COMMUNITY PAGES STATE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The number of pages minted to the community reserve.\\n    uint128 public numMintedForCommunity;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            PRICING CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev The day the switch from a logistic to translated linear VRGDA is targeted to occur.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    int256 internal constant SWITCH_DAY_WAD = 233e18;\\n\\n    /// @notice The minimum amount of pages that must be sold for the VRGDA issuance\\n    /// schedule to switch from logistic to the \\\"post switch\\\" translated linear formula.\\n    /// @dev Computed off-chain by plugging SWITCH_DAY_WAD into the uninverted pacing formula.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    int256 internal constant SOLD_BY_SWITCH_WAD = 8336.760939794622713006e18;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event PagePurchased(address indexed user, uint256 indexed pageId, uint256 price);\\n\\n    event CommunityPagesMinted(address indexed user, uint256 lastMintedPageId, uint256 numPages);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    error ReserveImbalance();\\n\\n    error PriceExceededMax(uint256 currentPrice);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Sets VRGDA parameters, mint start, relevant addresses, and base URI.\\n    /// @param _mintStart Timestamp for the start of the VRGDA mint.\\n    /// @param _goo Address of the Goo contract.\\n    /// @param _community Address of the community reserve.\\n    /// @param _artGobblers Address of the ArtGobblers contract.\\n    /// @param _baseUri Base URI for token metadata.\\n    constructor(\\n        // Mint config:\\n        uint256 _mintStart,\\n        // Addresses:\\n        Goo _goo,\\n        address _community,\\n        ArtGobblers _artGobblers,\\n        // URIs:\\n        string memory _baseUri\\n    )\\n        PagesERC721(_artGobblers, \\\"Pages\\\", \\\"PAGE\\\")\\n        LogisticToLinearVRGDA(\\n            4.2069e18, // Target price.\\n            0.31e18, // Price decay percent.\\n            9000e18, // Logistic asymptote.\\n            0.014e18, // Logistic time scale.\\n            SOLD_BY_SWITCH_WAD, // Sold by switch.\\n            SWITCH_DAY_WAD, // Target switch day.\\n            9e18 // Pages to target per day.\\n        )\\n    {\\n        mintStart = _mintStart;\\n\\n        goo = _goo;\\n\\n        community = _community;\\n\\n        BASE_URI = _baseUri;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              MINTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Mint a page with goo, burning the cost.\\n    /// @param maxPrice Maximum price to pay to mint the page.\\n    /// @param useVirtualBalance Whether the cost is paid from the\\n    /// user's virtual goo balance, or from their ERC20 goo balance.\\n    /// @return pageId The id of the page that was minted.\\n    function mintFromGoo(uint256 maxPrice, bool useVirtualBalance) external returns (uint256 pageId) {\\n        // Will revert if prior to mint start.\\n        uint256 currentPrice = pagePrice();\\n\\n        // If the current price is above the user's specified max, revert.\\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);\\n\\n        // Decrement the user's goo balance by the current\\n        // price, either from virtual balance or ERC20 balance.\\n        useVirtualBalance\\n            ? artGobblers.burnGooForPages(msg.sender, currentPrice)\\n            : goo.burnForPages(msg.sender, currentPrice);\\n\\n        unchecked {\\n            emit PagePurchased(msg.sender, pageId = ++currentId, currentPrice);\\n\\n            _mint(msg.sender, pageId);\\n        }\\n    }\\n\\n    /// @notice Calculate the mint cost of a page.\\n    /// @dev If the number of sales is below a pre-defined threshold, we use the\\n    /// VRGDA pricing algorithm, otherwise we use the post-switch pricing formula.\\n    /// @dev Reverts due to underflow if minting hasn't started yet. Done to save gas.\\n    function pagePrice() public view returns (uint256) {\\n        // We need checked math here to cause overflow\\n        // before minting has begun, preventing mints.\\n        uint256 timeSinceStart = block.timestamp - mintStart;\\n\\n        unchecked {\\n            // The number of pages minted for the community reserve\\n            // should never exceed 10% of the total supply of pages.\\n            return getVRGDAPrice(toDaysWadUnsafe(timeSinceStart), currentId - numMintedForCommunity);\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      COMMUNITY PAGES MINTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Mint a number of pages to the community reserve.\\n    /// @param numPages The number of pages to mint to the reserve.\\n    /// @dev Pages minted to the reserve cannot comprise more than 10% of the sum of the\\n    /// supply of goo minted pages and the supply of pages minted to the community reserve.\\n    function mintCommunityPages(uint256 numPages) external returns (uint256 lastMintedPageId) {\\n        unchecked {\\n            // Optimistically increment numMintedForCommunity, may be reverted below.\\n            // Overflow in this calculation is possible but numPages would have to be so\\n            // large that it would cause the loop in _batchMint to run out of gas quickly.\\n            uint256 newNumMintedForCommunity = numMintedForCommunity += uint128(numPages);\\n\\n            // Ensure that after this mint pages minted to the community reserve won't comprise more than\\n            // 10% of the new total page supply. currentId is equivalent to the current total supply of pages.\\n            if (newNumMintedForCommunity > ((lastMintedPageId = currentId) + numPages) / 10) revert ReserveImbalance();\\n\\n            // Mint the pages to the community reserve and update lastMintedPageId once minting is complete.\\n            lastMintedPageId = _batchMint(community, numPages, lastMintedPageId);\\n\\n            currentId = uint128(lastMintedPageId); // Update currentId with the last minted page id.\\n\\n            emit CommunityPagesMinted(msg.sender, lastMintedPageId, numPages);\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             TOKEN URI LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Returns a page's URI if it has been minted.\\n    /// @param pageId The id of the page to get the URI for.\\n    function tokenURI(uint256 pageId) public view virtual override returns (string memory) {\\n        if (pageId == 0 || pageId > currentId) revert(\\\"NOT_MINTED\\\");\\n\\n        return string.concat(BASE_URI, pageId.toString());\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/art-gobblers/src/utils/rand/RandProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @title Randomness Provider Interface.\\n/// @author FrankieIsLost <frankie@paradigm.xyz>\\n/// @author transmissions11 <t11s@paradigm.xyz>\\n/// @notice Generic asynchronous randomness provider interface.\\ninterface RandProvider {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event RandomBytesRequested(bytes32 requestId);\\n    event RandomBytesReturned(bytes32 requestId, uint256 randomness);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Request random bytes from the randomness provider.\\n    function requestRandomBytes() external returns (bytes32 requestId);\\n}\\n\"\r\n    },\r\n    \"lib/art-gobblers/src/utils/token/GobblersERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC721TokenReceiver} from \\\"solmate/tokens/ERC721.sol\\\";\\n\\n/// @notice ERC721 implementation optimized for ArtGobblers by packing balanceOf/ownerOf with user/attribute data.\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract GobblersERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) external view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         GOBBLERS/ERC721 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Struct holding gobbler data.\\n    struct GobblerData {\\n        // The current owner of the gobbler.\\n        address owner;\\n        // Index of token after shuffle.\\n        uint64 idx;\\n        // Multiple on goo issuance.\\n        uint32 emissionMultiple;\\n    }\\n\\n    /// @notice Maps gobbler ids to their data.\\n    mapping(uint256 => GobblerData) public getGobblerData;\\n\\n    /// @notice Struct holding data relevant to each user's account.\\n    struct UserData {\\n        // The total number of gobblers currently owned by the user.\\n        uint32 gobblersOwned;\\n        // The sum of the multiples of all gobblers the user holds.\\n        uint32 emissionMultiple;\\n        // User's goo balance at time of last checkpointing.\\n        uint128 lastBalance;\\n        // Timestamp of the last goo balance checkpoint.\\n        uint64 lastTimestamp;\\n    }\\n\\n    /// @notice Maps user addresses to their account data.\\n    mapping(address => UserData) public getUserData;\\n\\n    function ownerOf(uint256 id) external view returns (address owner) {\\n        require((owner = getGobblerData[id].owner) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) external view returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return getUserData[owner].gobblersOwned;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) external {\\n        address owner = getGobblerData[id].owner;\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) external {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           INTERNAL MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal {\\n        // Does not check if the token was already minted or the recipient is address(0)\\n        // because ArtGobblers.sol manages its ids in such a way that it ensures it won't\\n        // double mint and will only mint to safe addresses or msg.sender who cannot be zero.\\n\\n        unchecked {\\n            ++getUserData[to].gobblersOwned;\\n        }\\n\\n        getGobblerData[id].owner = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256 amount,\\n        uint256 lastMintedId\\n    ) internal returns (uint256) {\\n        // Doesn't check if the tokens were already minted or the recipient is address(0)\\n        // because ArtGobblers.sol manages its ids in such a way that it ensures it won't\\n        // double mint and will only mint to safe addresses or msg.sender who cannot be zero.\\n\\n        unchecked {\\n            getUserData[to].gobblersOwned += uint32(amount);\\n\\n            for (uint256 i = 0; i < amount; ++i) {\\n                getGobblerData[++lastMintedId].owner = to;\\n\\n                emit Transfer(address(0), to, lastMintedId);\\n            }\\n        }\\n\\n        return lastMintedId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/art-gobblers/src/utils/token/PagesERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC721TokenReceiver} from \\\"solmate/tokens/ERC721.sol\\\";\\nimport {ArtGobblers} from \\\"../../ArtGobblers.sol\\\";\\n\\n/// @notice ERC721 implementation optimized for Pages by pre-approving them to the ArtGobblers contract.\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract PagesERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) external view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ArtGobblers public immutable artGobblers;\\n\\n    constructor(\\n        ArtGobblers _artGobblers,\\n        string memory _name,\\n        string memory _symbol\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        artGobblers = _artGobblers;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) external view returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) external view returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) internal _isApprovedForAll;\\n\\n    function isApprovedForAll(address owner, address operator) public view returns (bool isApproved) {\\n        if (operator == address(artGobblers)) return true; // Skip approvals for the ArtGobblers contract.\\n\\n        return _isApprovedForAll[owner][operator];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) external {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll(from, msg.sender) || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external {\\n        transferFrom(from, to, id);\\n\\n        if (to.code.length != 0)\\n            require(\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                    ERC721TokenReceiver.onERC721Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) external {\\n        transferFrom(from, to, id);\\n\\n        if (to.code.length != 0)\\n            require(\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                    ERC721TokenReceiver.onERC721Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           INTERNAL MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal {\\n        // Does not check the token has not been already minted\\n        // or is being minted to address(0) because ids in Pages.sol\\n        // are set using a monotonically increasing counter and only\\n        // minted to safe addresses or msg.sender who cannot be zero.\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256 amount,\\n        uint256 lastMintedId\\n    ) internal returns (uint256) {\\n        // Doesn't check if the tokens were already minted or the recipient is address(0)\\n        // because Pages.sol manages its ids in a way that it ensures it won't double\\n        // mint and will only mint to safe addresses or msg.sender who cannot be zero.\\n\\n        unchecked {\\n            _balanceOf[to] += amount;\\n\\n            for (uint256 i = 0; i < amount; ++i) {\\n                _ownerOf[++lastMintedId] = to;\\n\\n                emit Transfer(address(0), to, lastMintedId);\\n            }\\n        }\\n\\n        return lastMintedId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i = 0; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Efficient library for creating string representations of integers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)\\nlibrary LibString {\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes\\n            // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the\\n            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.\\n            let newFreeMemoryPointer := add(mload(0x40), 160)\\n\\n            // Update the free memory pointer to avoid overriding our string.\\n            mstore(0x40, newFreeMemoryPointer)\\n\\n            // Assign str to the end of the zone of newly allocated memory.\\n            str := sub(newFreeMemoryPointer, 32)\\n\\n            // Clean the last word of memory it may not be overwritten.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                // Move the pointer 1 byte to the left.\\n                str := sub(str, 1)\\n\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n\\n                // Keep dividing temp until zero.\\n                temp := div(temp, 10)\\n\\n                 // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute and cache the final total length of the string.\\n            let length := sub(end, str)\\n\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 32)\\n\\n            // Store the string's length at the start of memory allocated for our string.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/MerkleProofLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized merkle proof verification library.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\\nlibrary MerkleProofLib {\\n    function verify(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool isValid) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if proof.length {\\n                // Left shifting by 5 is like multiplying by 32.\\n                let end := add(proof.offset, shl(5, proof.length))\\n\\n                // Initialize offset to the offset of the proof in calldata.\\n                let offset := proof.offset\\n\\n                // Iterate over proof elements to compute root hash.\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    // Slot where the leaf should be put in scratch space. If\\n                    // leaf > calldataload(offset): slot 32, otherwise: slot 0.\\n                    let leafSlot := shl(5, gt(leaf, calldataload(offset)))\\n\\n                    // Store elements to hash contiguously in scratch space.\\n                    // The xor puts calldataload(offset) in whichever slot leaf\\n                    // is not occupying, so 0 if leafSlot is 32, and 32 otherwise.\\n                    mstore(leafSlot, leaf)\\n                    mstore(xor(leafSlot, 32), calldataload(offset))\\n\\n                    // Reuse leaf to store the hash to reduce stack operations.\\n                    leaf := keccak256(0, 64) // Hash both slots of scratch space.\\n\\n                    offset := add(offset, 32) // Shift 1 word per cycle.\\n\\n                    // prettier-ignore\\n                    if iszero(lt(offset, end)) { break }\\n                }\\n            }\\n\\n            isValid := eq(leaf, root) // The proof is valid if the roots match.\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SignedWadMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Signed 18 decimal fixed point (wad) arithmetic library.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)\\n/// @author Modified from Remco Bloemen (https://xn--2-umb.com/22/exp-ln/index.html)\\n\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by 1e18.\\n        r := mul(x, 1000000000000000000)\\n    }\\n}\\n\\n/// @dev Takes an integer amount of seconds and converts it to a wad amount of days.\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\n/// @dev Not meant for negative second amounts, it assumes x is positive.\\nfunction toDaysWadUnsafe(uint256 x) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by 1e18 and then divide it by 86400.\\n        r := div(mul(x, 1000000000000000000), 86400)\\n    }\\n}\\n\\n/// @dev Takes a wad amount of days and converts it to an integer amount of seconds.\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\n/// @dev Not meant for negative day amounts, it assumes x is positive.\\nfunction fromDaysWadUnsafe(int256 x) pure returns (uint256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by 86400 and then divide it by 1e18.\\n        r := div(mul(x, 86400), 1000000000000000000)\\n    }\\n}\\n\\n/// @dev Will not revert on overflow, only use where overflow is not possible.\\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by y and divide by 1e18.\\n        r := sdiv(mul(x, y), 1000000000000000000)\\n    }\\n}\\n\\n/// @dev Will return 0 instead of reverting if y is zero and will\\n/// not revert on overflow, only use where overflow is not possible.\\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Multiply x by 1e18 and divide it by y.\\n        r := sdiv(mul(x, 1000000000000000000), y)\\n    }\\n}\\n\\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Store x * y in r for now.\\n        r := mul(x, y)\\n\\n        // Equivalent to require(x == 0 || (x * y) / x == y)\\n        if iszero(or(iszero(x), eq(sdiv(r, x), y))) {\\n            revert(0, 0)\\n        }\\n\\n        // Scale the result down by 1e18.\\n        r := sdiv(r, 1000000000000000000)\\n    }\\n}\\n\\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Store x * 1e18 in r for now.\\n        r := mul(x, 1000000000000000000)\\n\\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\\n            revert(0, 0)\\n        }\\n\\n        // Divide r by y.\\n        r := sdiv(r, y)\\n    }\\n}\\n\\nfunction wadExp(int256 x) pure returns (int256 r) {\\n    unchecked {\\n        // When the result is < 0.5 we return zero. This happens when\\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n        if (x <= -42139678854452767551) return 0;\\n\\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n        if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n        // for more intermediate precision and a binary basis. This base conversion\\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n        x = (x << 78) / 5**18;\\n\\n        // Reduce range of x to (- ln 2,  ln 2) * 2**96 by factoring out powers\\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n        x = x - k * 54916777467707473351141471128;\\n\\n        // k is in the range [-61, 195].\\n\\n        // Evaluate using a (6, 7)-term rational approximation.\\n        // p is made monic, we'll multiply by a scale factor later.\\n        int256 y = x + 1346386616545796478920950773328;\\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n        int256 p = y + x - 94201549194550492254356042504812;\\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n        p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n        int256 q = x - 2855989394907223263936484059900;\\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Div in assembly because solidity adds a zero check despite the unchecked.\\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\\n            // No scaling is necessary because p is already 2**96 too large.\\n            r := sdiv(p, q)\\n        }\\n\\n        // r should be in the range (0.09, 0.25) * 2**96.\\n\\n        // We now need to multiply r by:\\n        // * the scale factor s = ~6.031367120.\\n        // * the 2**k factor from the range reduction.\\n        // * the 1e18 / 2**96 factor for base conversion.\\n        // We do this all at once, with an intermediate result in 2**213\\n        // basis, so the final right shift is always by a positive amount.\\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n    }\\n}\\n\\nfunction wadLn(int256 x) pure returns (int256 r) {\\n    unchecked {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n        // We do this by multiplying by 2**96 / 10**18. But since\\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n        // and add ln(2**96 / 10**18) at the end.\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n\\n        // Reduce range of x to (1, 2) * 2**96\\n        // ln(2^k * x) = k * ln(2) + ln(x)\\n        int256 k = r - 96;\\n        x <<= uint256(159 - k);\\n        x = int256(uint256(x) >> 159);\\n\\n        // Evaluate using a (8, 8)-term rational approximation.\\n        // p is made monic, we will multiply by a scale factor later.\\n        int256 p = x + 3273285459638523848632254066296;\\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n        p = p * x - (795164235651350426258249787498 << 96);\\n\\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n        // q is monic by convention.\\n        int256 q = x + 5573035233440673466300451813936;\\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Div in assembly because solidity adds a zero check despite the unchecked.\\n            // The q polynomial is known not to have zeros in the domain.\\n            // No scaling required because p is already 2**96 too large.\\n            r := sdiv(p, q)\\n        }\\n\\n        // r is in the range (0, 0.125) * 2**96\\n\\n        // Finalization, we need to:\\n        // * multiply by the scale factor s = 5.549\\n        // * add ln(2**96 / 10**18)\\n        // * add k * ln(2)\\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n        r *= 1677202110996718588342820967067443963516166;\\n        // add ln(2) * k * 5e18 * 2**192\\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n        // base conversion: mul 2**18 / 2**192\\n        r >>= 174;\\n    }\\n}\\n\\n/// @dev Will return 0 instead of reverting if y is zero.\\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n        // Divide x by y.\\n        r := sdiv(x, y)\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Goober.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"art-gobblers/Goo.sol\\\";\\nimport \\\"art-gobblers/ArtGobblers.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {ReentrancyGuard} from \\\"solmate/utils/ReentrancyGuard.sol\\\";\\nimport {FixedPointMathLib} from \\\"solmate/utils/FixedPointMathLib.sol\\\";\\nimport \\\"./interfaces/IERC20Metadata.sol\\\";\\nimport \\\"./math/UQ112x112.sol\\\";\\nimport \\\"./interfaces/IGoober.sol\\\";\\nimport \\\"./interfaces/IGooberCallee.sol\\\";\\n\\n/// @title goober_xyz\\n/// @author 0xAlcibiades\\n/// @author mevbandit\\n/// @author neodaoist\\n/// @author eth_call\\n/// @author goerlibot\\n/// @author thal0x\\n/// @notice Goober is an experimental Uniswap V2 and EIP-4626 flavored vault to optimize Art\\n/// @notice production for the decentralized art factory by Justin Roiland and Paradigm.\\ncontract Goober is ReentrancyGuard, ERC20, IGoober {\\n    // We want to ensure all transfers are safe.\\n    using SafeTransferLib for Goo;\\n    using SafeTransferLib for ERC20;\\n    // We use this for fixed point WAD scalar math.\\n    using FixedPointMathLib for uint256;\\n    // This is the Uniswap V2 112 bit Q math, updated for Solidity 8.\\n    using UQ112x112 for uint224;\\n\\n    /*//////////////////////////////////////////////////////////////\\n    // Immutable storage\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The Goo contract.\\n    Goo public immutable goo;\\n    /// @notice The Art Gobblers NFT contract.\\n    ArtGobblers public immutable artGobblers;\\n\\n    /// @notice The liquidity locked forever in the pool.\\n    uint16 private constant MINIMUM_LIQUIDITY = 1e3;\\n    /// @notice A scalar for scaling up and down to basis points.\\n    uint16 private constant BPS_SCALAR = 1e4;\\n    /// @notice The management fee in basis points, charged on deposits.\\n    uint16 public constant MANAGEMENT_FEE_BPS = 200;\\n    /// @notice The performance fee in basis points, taken in the form\\n    /// @notice of dilution on the growth of sqrt(gooBalance * gobblerMult),\\n    /// @notice\\n    uint16 public constant PERFORMANCE_FEE_BPS = 1e3;\\n    /// @notice The average multiplier of a newly minted gobbler.\\n    /// @notice 7.3294 = weighted avg. multiplier from mint probabilities,\\n    /// @notice derived from: ((6*3057) + (7*2621) + (8*2293) + (9*2029)) / 10000.\\n    uint32 private constant AVERAGE_MULT_BPS = 73294;\\n\\n    /*//////////////////////////////////////////////////////////////\\n    // Mutable storage\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // Access control\\n    /// @notice This is the \\\"admin\\\" address and also where management and performance fees accrue.\\n    address public feeTo;\\n    /// @notice This is a privileged actor with the ability to mint gobblers when the pool price is low enough.\\n    address public minter;\\n\\n    /// @notice Price oracle accumulator for goo.\\n    uint256 public priceGooCumulativeLast;\\n    /// @notice Price oracle accumulator for gobbler multipliers.\\n    uint256 public priceGobblerCumulativeLast;\\n\\n    /// @notice K, as of immediately after the most recent liquidity event.\\n    uint112 public kLast;\\n    /// @notice A counter for debt accrued against performance fees during the temporary decreases in K\\n    /// @notice after mints by the minter, before gobblers' multipliers are revealed.\\n    uint112 public kDebt;\\n\\n    /// @notice Last block timestamp\\n    /// @dev Yes, the oracle accumulators will reset in 2036.\\n    uint32 public blockTimestampLast; // uses single storage slot, accessible via getReserves\\n\\n    /// @notice Flagged NFTs cannot be deposited or swapped in.\\n    mapping(uint256 => bool) public flagged;\\n\\n    /*//////////////////////////////////////////////////////////////\\n    // Constructor\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Deploys the goober contract.\\n    /// @param _gobblersAddress - The address of the Art Gobblers contract.\\n    /// @param _gooAddress - The address of the Goo contract/token.\\n    /// @param _feeTo - The admin and address to accrue fees to.\\n    /// @param _minter - The address able to mint gobblers to the pool.\\n    /// @notice The minter is able to mint using pool assets based on conditions defined in the mintGobbler function.\\n    constructor(address _gobblersAddress, address _gooAddress, address _feeTo, address _minter)\\n        ERC20(\\\"Goober\\\", \\\"GBR\\\", 18)\\n    {\\n        feeTo = _feeTo;\\n        minter = _minter;\\n        artGobblers = ArtGobblers(_gobblersAddress);\\n        goo = Goo(_gooAddress);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n    // Modifiers\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice This modifier restricts function access to the feeTo address.\\n    modifier onlyFeeTo() {\\n        if (msg.sender != feeTo) {\\n            revert AccessControlViolation(msg.sender, feeTo);\\n        }\\n        _;\\n    }\\n\\n    /// @notice This modifier restricts function access to the minter address.\\n    modifier onlyMinter() {\\n        if (msg.sender != minter) {\\n            revert AccessControlViolation(msg.sender, minter);\\n        }\\n        _;\\n    }\\n\\n    /// @notice This modifier ensures the transaction is included before a specified deadline.\\n    /// @param deadline - Unix timestamp after which the transaction will revert.\\n    modifier ensure(uint256 deadline) {\\n        if (block.timestamp > deadline) {\\n            revert Expired(block.timestamp, deadline);\\n        }\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n    // Internal: Non-Mutating\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Calculates it is within the interest of our pool to mint more Gobblers\\n    /// @notice based on current pool and auction conditions.\\n    function _shouldMint(uint256 _gooBalance, uint256 _gobblerBalance, uint256 _auctionPrice)\\n        internal\\n        pure\\n        returns (bool mint, uint256 auctionPricePerMult, uint256 poolPricePerMult)\\n    {\\n        if (_gooBalance == 0 || _gobblerBalance == 0) {\\n            revert InsufficientLiquidity(_gooBalance, _gobblerBalance);\\n        } else if (_auctionPrice == 0) {\\n            // Unlikely, but avoids divide by zero below.\\n            mint = true;\\n        } else {\\n            if (_gooBalance > _auctionPrice) {\\n                auctionPricePerMult = (_auctionPrice * BPS_SCALAR) / AVERAGE_MULT_BPS;\\n                poolPricePerMult = (_gooBalance / _gobblerBalance);\\n                mint = poolPricePerMult > auctionPricePerMult;\\n            }\\n        }\\n    }\\n\\n    /// @dev Internal swap calculations from Uniswap V2 modified to return an integer error term.\\n    function _swapCalculations(\\n        uint256 _gooReserve,\\n        uint256 _gobblerReserve,\\n        uint256 _gooBalance,\\n        uint256 _gobblerBalance,\\n        uint256 gooOut,\\n        uint256 multOut,\\n        bool revertInsufficient\\n    ) internal pure returns (int256 erroneousGoo, uint256 amount0In, uint256 amount1In) {\\n        erroneousGoo = 0;\\n        amount0In = _gooBalance > _gooReserve - gooOut ? _gooBalance - (_gooReserve - gooOut) : 0;\\n        amount1In = _gobblerBalance > _gobblerReserve - multOut ? _gobblerBalance - (_gobblerReserve - multOut) : 0;\\n        if (!(amount0In > 0 || amount1In > 0)) {\\n            revert InsufficientInputAmount(amount0In, amount1In);\\n        }\\n        {\\n            uint256 balance0Adjusted = (_gooBalance * 1000) - (amount0In * 3);\\n            uint256 balance1Adjusted = (_gobblerBalance * 1000) - (amount1In * 3);\\n            uint256 adjustedBalanceK = ((balance0Adjusted * balance1Adjusted));\\n            uint256 expectedK = ((_gooReserve * _gobblerReserve) * 1000 ** 2);\\n\\n            if (adjustedBalanceK < expectedK) {\\n                uint256 error = FixedPointMathLib.mulWadUp(\\n                    FixedPointMathLib.divWadUp(\\n                        (\\n                            FixedPointMathLib.mulWadUp(FixedPointMathLib.divWadUp(expectedK, balance1Adjusted), 1)\\n                                - balance0Adjusted\\n                        ),\\n                        997\\n                    ),\\n                    1\\n                );\\n                if (revertInsufficient) {\\n                    revert InsufficientGoo(error, adjustedBalanceK, expectedK);\\n                }\\n                erroneousGoo += int256(error);\\n            } else if (adjustedBalanceK > expectedK) {\\n                erroneousGoo -= int256(\\n                    FixedPointMathLib.mulWadDown(\\n                        FixedPointMathLib.divWadDown(\\n                            (\\n                                balance0Adjusted\\n                                    - FixedPointMathLib.mulWadUp(FixedPointMathLib.divWadUp(expectedK, balance1Adjusted), 1)\\n                            ),\\n                            1000\\n                        ),\\n                        1\\n                    )\\n                );\\n            }\\n            // Otherwise return 0.\\n        }\\n    }\\n\\n    /// @notice Returns various calculations about the value of K.\\n    function _kCalculations(uint256 _gooBalance, uint256 _gobblerBalance, uint256 _kLast, uint256 _kDebt, bool _roundUp)\\n        internal\\n        pure\\n        returns (uint256 _k, uint256 _kChange, bool _kChangeSign, uint256 _kDelta, uint256 _kDebtChange)\\n    {\\n        // Get the present value of K.\\n        _k = FixedPointMathLib.sqrt(_gooBalance * _gobblerBalance);\\n        // We don't want to allow the pool to be decommed, ever.\\n        if (_k == 0) {\\n            revert MustLeaveLiquidity(_gooBalance, _gobblerBalance);\\n        }\\n        // Set delta and debt change to zero.\\n        _kDelta = 0;\\n        _kDebtChange = 0;\\n        // Did K increase or decrease?\\n        _kChangeSign = _k > _kLast;\\n        // Get the gross change in K as a numeric.\\n        _kChange = _kChangeSign ? _k - _kLast : _kLast - _k;\\n        // We can't do change math on a fresh pool.\\n        if (_kLast > 0) {\\n            // If K went up,\\n            if (_kChangeSign) {\\n                // let's offset the debt first if it exists;\\n                if (_kDebt > 0) {\\n                    if (_kChange <= _kDebt) {\\n                        _kDebtChange += _kChange;\\n                        _kChange = 0;\\n                    } else {\\n                        _kDebtChange += _kDebt;\\n                        _kChange -= _kDebt;\\n                    }\\n                }\\n            }\\n            // then we can calculate the delta.\\n            if (_roundUp) {\\n                _kDelta = FixedPointMathLib.divWadUp(_kChange, _kLast);\\n            } else {\\n                _kDelta = FixedPointMathLib.divWadDown(_kChange, _kLast);\\n            }\\n        } else {\\n            // If kLast -> k is 0 -> n, then the delta is 100%.\\n            _kDelta = FixedPointMathLib.divWadUp(1, 1);\\n        }\\n    }\\n\\n    /// @notice Returns the management fee given an amount of new fractions created on deposit.\\n    /// @param fractions New fractions issued for a deposit.\\n    function _previewManagementFee(uint256 fractions) internal pure returns (uint256 fee) {\\n        fee = fractions * MANAGEMENT_FEE_BPS / BPS_SCALAR;\\n    }\\n\\n    /// @notice Returns a preview of the performance fee.\\n    /// @param _gooBalance - The Goo balance to simulate with.\\n    /// @param _gobblerBalance - The Gobbler balance to simulate with.\\n    function _previewPerformanceFee(uint256 _gooBalance, uint256 _gobblerBalance)\\n        internal\\n        view\\n        returns (uint256 fee, uint256 kDebtChange, uint256 kDelta)\\n    {\\n        // No K, no fee.\\n        uint112 _kLast = kLast;\\n        uint112 _kDebt = kDebt;\\n        fee = 0;\\n        kDebtChange = 0;\\n        kDelta = 0;\\n        // If kLast was at 0, then we won't accrue a fee yet, as the pool is uninitialized.\\n        if (_kLast > 0) {\\n            (, uint256 _kChange, bool _kChangeSign, uint256 _kDelta, uint256 _kDebtChange) =\\n                _kCalculations(_gooBalance, _gobblerBalance, _kLast, _kDebt, false);\\n            // Then, determine a fee on any remainder after offsetting outstanding debt.\\n            if (_kChange > 0 && _kChangeSign) {\\n                // Calculate the fee as a portion of the the growth of total supply as determined by kDelta.\\n                fee = FixedPointMathLib.mulWadDown(totalSupply, _kDelta) * PERFORMANCE_FEE_BPS / BPS_SCALAR;\\n                // Update kDelta return value.\\n                kDelta = uint112(_kDelta);\\n                // Update kDebtChange return value.\\n                kDebtChange = uint112(_kDebtChange);\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n    // Internal: Mutating\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Update reserves and, on the first call per block, price accumulators.\\n    /// @param _gooBalance - The new Goo balance.\\n    /// @param _gobblerBalance - The new Gobbler multiplier.\\n    /// @param _gooReserve - The previous Goo reserve.\\n    /// @param _gobblerReserve - The previous Gobbler multiplier.\\n    function _update(\\n        uint256 _gooBalance,\\n        uint256 _gobblerBalance,\\n        uint256 _gooReserve,\\n        uint256 _gobblerReserve,\\n        bool recordDebt,\\n        bool updateK\\n    ) internal {\\n        /// @dev The accumulators will reset in 2036 due to modulo.\\n        //slither-disable-next-line weak-prng\\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\\n\\n        uint32 timeElapsed;\\n        unchecked {\\n            // The time elapsed since the last update.\\n            timeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired.\\n        }\\n\\n        // These are accumulators which can be used for a Goo/Gobbler mult TWAP.\\n        (uint112 castGooReserve, uint112 castGobblerReserve) = (uint112(_gooReserve), uint112(_gobblerReserve));\\n        if (timeElapsed > 0 && _gooReserve != 0 && _gobblerReserve != 0) {\\n            unchecked {\\n                // * Never overflows, and + overflow is desired.\\n                priceGooCumulativeLast +=\\n                    uint256(UQ112x112.encode(uint112(castGooReserve)).uqdiv(castGobblerReserve)) * timeElapsed;\\n                priceGobblerCumulativeLast +=\\n                    uint256(UQ112x112.encode(uint112(castGobblerReserve)).uqdiv(uint112(castGooReserve))) * timeElapsed;\\n            }\\n        }\\n\\n        // Update the last update.\\n        blockTimestampLast = blockTimestamp;\\n\\n        /// @dev We don't store reserves here as they were already stored in other contracts and there was no\\n        // need to duplicate the state changes.\\n\\n        // Do we need to update historic K values?\\n        if (updateK || recordDebt) {\\n            // Get the present K.\\n            uint112 _k = uint112(FixedPointMathLib.sqrt(_gooBalance * _gobblerBalance));\\n\\n            // Read the last K from storage.\\n            uint112 _kLast = kLast;\\n\\n            // If K decreased, record the debt.\\n            if ((_k < _kLast) && recordDebt) {\\n                kDebt += _kLast - _k;\\n            }\\n\\n            if (updateK) {\\n                // Update historic K.\\n                kLast = _k;\\n            }\\n        }\\n\\n        // Emit the reserves which can be used to chart the state of the pool.\\n        emit Sync(_gooBalance, _gobblerBalance);\\n    }\\n\\n    /// @notice Accrues the performance fee on the growth of K if any, offset by kDebt.\\n    /// @param _gooBalance - The balance of Goo to use in calculating the growth of K.\\n    /// @param _gobblerBalanceMult - The balance of Gobbler mult to use in calculating the growth of K.\\n    function _performanceFee(uint256 _gooBalance, uint256 _gobblerBalanceMult) internal returns (uint256) {\\n        (uint256 fee, uint256 kDebtChange, uint256 deltaK) = _previewPerformanceFee(_gooBalance, _gobblerBalanceMult);\\n        if (kDebtChange > 0) {\\n            kDebt -= uint112(kDebtChange);\\n        }\\n        if (fee > 0) {\\n            _mint(feeTo, fee);\\n            // Emit info about the fees, and the growth of K.\\n            emit FeesAccrued(feeTo, fee, true, deltaK);\\n        }\\n        return fee;\\n    }\\n\\n    /// @notice Mints and returns the management fee given an amount of new fractions created on deposit.\\n    /// @param fractions - New fractions created for a deposit.\\n    /// @return fee - The managment fee assesed.\\n    function _managementFee(uint256 fractions) internal returns (uint256 fee) {\\n        fee = _previewManagementFee(fractions);\\n        _mint(feeTo, fee);\\n        // _deltaK is 0 here because there isn't actually growth in K.\\n        emit FeesAccrued(feeTo, fee, false, 0);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n    // External: Non Mutating\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IERC721Receiver\\n    /// @notice Handles deposits of Art Gobblers with an on receive hook, verifying characteristics.\\n    /// @dev We don't accept non Art Gobbler NFTs, flagged Gobblers, or unrevealed Gobblers.\\n    function onERC721Received(address, address, uint256 tokenId, bytes calldata) external view returns (bytes4) {\\n        /// @dev We only want Art Gobblers NFTs.\\n        if (msg.sender != address(artGobblers)) {\\n            revert InvalidNFT();\\n        }\\n        /// @dev Revert on flagged NFTs.\\n        if (flagged[tokenId] == true) {\\n            revert InvalidNFT();\\n        }\\n        /// @dev We want to make sure the Gobblers we are getting are revealed.\\n        uint256 gobMult = artGobblers.getGobblerEmissionMultiple(tokenId);\\n        if (gobMult < 6) {\\n            revert InvalidMultiplier(tokenId);\\n        }\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function totalAssets() public view returns (uint256 gooTokens, uint256 gobblerMult) {\\n        gooTokens = artGobblers.gooBalance(address(this));\\n        gobblerMult = artGobblers.getUserEmissionMultiple(address(this));\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function convertToFractions(uint256 gooTokens, uint256 gobblerMult) external view returns (uint256 fractions) {\\n        uint256 _totalSupply = totalSupply;\\n        uint256 kInput = FixedPointMathLib.sqrt(gooTokens * gobblerMult);\\n        if (_totalSupply > 0) {\\n            (uint256 gooBalance, uint256 gobblerMultBalance) = totalAssets();\\n            uint256 kBalance = FixedPointMathLib.sqrt(gooBalance * gobblerMultBalance);\\n            uint256 kDelta = FixedPointMathLib.divWadDown(kInput, kBalance);\\n            fractions = FixedPointMathLib.mulWadDown(_totalSupply, kDelta);\\n        } else {\\n            fractions = kInput;\\n        }\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function convertToAssets(uint256 fractions)\\n        external\\n        view\\n        virtual\\n        returns (uint256 gooTokens, uint256 gobblerMult)\\n    {\\n        gooTokens = 0;\\n        gobblerMult = 0;\\n        uint256 _totalSupply = totalSupply;\\n        if (_totalSupply > 0) {\\n            (gooTokens, gobblerMult) = totalAssets();\\n            gooTokens = fractions.mulDivDown(gooTokens, _totalSupply);\\n            gobblerMult = fractions.mulDivDown(gobblerMult, _totalSupply);\\n        }\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function getReserves()\\n        public\\n        view\\n        returns (uint256 _gooReserve, uint256 _gobblerReserve, uint32 _blockTimestampLast)\\n    {\\n        _gooReserve = artGobblers.gooBalance(address(this));\\n        _gobblerReserve = artGobblers.getUserEmissionMultiple(address(this));\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function previewDeposit(uint256[] calldata gobblers, uint256 gooTokens) external view returns (uint256 fractions) {\\n        // Collect a virtual performance fee.\\n        (uint256 _gooReserve, uint256 _gobblerReserveMult,) = getReserves();\\n        (uint256 pFee,,) = _previewPerformanceFee(_gooReserve, _gobblerReserveMult);\\n        // Increment virtual total supply by performance fee.\\n        uint256 _totalSupply = pFee + totalSupply;\\n        // Simulate transfers.\\n        uint256 _gooBalance = gooTokens + _gooReserve;\\n        uint256 _gobblerBalanceMult = _gobblerReserveMult;\\n        for (uint256 i = 0; i < gobblers.length; i++) {\\n            _gobblerBalanceMult += artGobblers.getGobblerEmissionMultiple(gobblers[i]);\\n        }\\n        // Calculate the fractions to create based on the changes in K.\\n        (uint256 _k,,, uint256 _kDelta,) = _kCalculations(\\n            _gooBalance, _gobblerBalanceMult, FixedPointMathLib.sqrt(_gooReserve * _gobblerReserveMult), 0, true\\n        );\\n        if (_totalSupply == 0) {\\n            // We want to start the fractions at the right order of magnitude at init, so\\n            // we scale this by 1e9 to simulate 2 ERC20s, because Gobbler mult are integers\\n            // rather than 1e18 ERC20s from the Uni V2 design.\\n            fractions = _k * 1e9 - MINIMUM_LIQUIDITY;\\n        } else {\\n            fractions = FixedPointMathLib.mulWadDown(_totalSupply, _kDelta);\\n        }\\n        if (fractions == 0) {\\n            revert InsufficientLiquidityDeposited();\\n        }\\n        // Simulate management fee and return preview.\\n        fractions -= _previewManagementFee(fractions);\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function previewWithdraw(uint256[] calldata gobblers, uint256 gooTokens)\\n        external\\n        view\\n        returns (uint256 fractions)\\n    {\\n        // Collect a virtual performance fee.\\n        (uint256 _gooReserve, uint256 _gobblerReserveMult,) = getReserves();\\n        uint256 _totalSupply = totalSupply;\\n        (uint256 pFee,,) = _previewPerformanceFee(_gooReserve, _gobblerReserveMult);\\n        // Increment virtual total supply.\\n        _totalSupply += pFee;\\n        // Simulate transfers.\\n        uint256 _gooBalance = _gooReserve - gooTokens;\\n        uint256 _gobblerBalanceMult = _gobblerReserveMult;\\n        uint256 gobblerMult;\\n        for (uint256 i = 0; i < gobblers.length; i++) {\\n            if (artGobblers.ownerOf(gobblers[i]) != address(this)) {\\n                revert InvalidNFT();\\n            }\\n            gobblerMult = artGobblers.getGobblerEmissionMultiple(gobblers[i]);\\n            if (gobblerMult < 6) {\\n                revert InvalidMultiplier(gobblers[i]);\\n            }\\n            _gobblerBalanceMult -= gobblerMult;\\n        }\\n        uint256 _gobblerAmountMult = _gobblerReserveMult - _gobblerBalanceMult;\\n        if (!(_gobblerAmountMult > 0 || gooTokens > 0)) {\\n            revert InsufficientLiquidityWithdrawn();\\n        }\\n        {\\n            // Calculate the fractions which will be destroyed based on the changes in K.\\n            (,,, uint256 _kDelta,) = _kCalculations(\\n                _gooBalance, _gobblerBalanceMult, FixedPointMathLib.sqrt(_gooReserve * _gobblerReserveMult), 0, true\\n            );\\n            // Update fractions for return.\\n            fractions = FixedPointMathLib.mulWadUp(_totalSupply, _kDelta);\\n        }\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function previewSwap(uint256[] calldata gobblersIn, uint256 gooIn, uint256[] calldata gobblersOut, uint256 gooOut)\\n        public\\n        view\\n        returns (int256 erroneousGoo)\\n    {\\n        (uint256 _gooReserve, uint256 _gobblerReserve,) = getReserves();\\n        // Simulate the transfers out.\\n        uint256 _gooBalance = _gooReserve - gooOut;\\n        uint256 _gobblerBalance = _gobblerReserve;\\n        uint256 multOut = 0;\\n        uint256 gobblerMult;\\n        for (uint256 i = 0; i < gobblersOut.length; i++) {\\n            if (artGobblers.ownerOf(gobblersOut[i]) != address(this)) {\\n                revert InvalidNFT();\\n            }\\n            gobblerMult = artGobblers.getGobblerEmissionMultiple(gobblersOut[i]);\\n            if (gobblerMult < 6) {\\n                revert InvalidMultiplier(gobblersOut[i]);\\n            }\\n            _gobblerBalance -= gobblerMult;\\n            multOut += gobblerMult;\\n        }\\n        // Simulate the transfers in.\\n        _gooBalance += gooIn;\\n        for (uint256 i = 0; i < gobblersIn.length; i++) {\\n            gobblerMult = artGobblers.getGobblerEmissionMultiple(gobblersIn[i]);\\n            if (gobblerMult < 6) {\\n                revert InvalidMultiplier(gobblersIn[i]);\\n            }\\n            _gobblerBalance += gobblerMult;\\n        }\\n        // Run swap calculations and return error term.\\n        (erroneousGoo,,) =\\n            _swapCalculations(_gooReserve, _gobblerReserve, _gooBalance, _gobblerBalance, gooOut, multOut, false);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n    // External: Mutating, Restricted Access\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // Access Control\\n\\n    /// @inheritdoc IGoober\\n    function setFeeTo(address newFeeTo) external onlyFeeTo {\\n        if (newFeeTo == address(0)) {\\n            revert InvalidAddress(newFeeTo);\\n        }\\n        feeTo = newFeeTo;\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function setMinter(address newMinter) external onlyFeeTo {\\n        if (newMinter == address(0)) {\\n            revert InvalidAddress(newMinter);\\n        }\\n        minter = newMinter;\\n    }\\n\\n    // Other Privileged Functions\\n\\n    /// @inheritdoc IGoober\\n    function mintGobbler() external nonReentrant onlyMinter {\\n        /// @dev Restricted to onlyMinter to prevent Goo price manipulation.\\n        /// @dev Non-reentrant in case onlyMinter address/keeper is compromised.\\n\\n        // Get the mint price.\\n        uint256 mintPrice = artGobblers.gobblerPrice();\\n\\n        // Get the reserves directly to save gas.\\n        uint256 gooReserve = artGobblers.gooBalance(address(this));\\n        uint256 gobblerReserve = artGobblers.getUserEmissionMultiple(address(this));\\n\\n        // Set an internal balance counter for Goo.\\n        uint256 gooBalance = gooReserve;\\n\\n        // Should we mint?\\n        (bool mint, uint256 auctionPricePerMult, uint256 poolPricePerMult) =\\n            _shouldMint(gooBalance, gobblerReserve, mintPrice);\\n\\n        // We revert to tell the minter if it's calculations are off.\\n        if (mint == false) {\\n            revert AuctionPriceTooHigh(auctionPricePerMult, poolPricePerMult);\\n        }\\n\\n        // Mint Gobblers to the pool when our Goo per mult > (VRGDA) auction Goo per mult.\\n        while (mint) {\\n            // Mint a new Gobbler.\\n            // slither-disable-next-line unused-return\\n            artGobblers.mintFromGoo(mintPrice, true);\\n\\n            // _shouldMint already prevents an overflow here.\\n            gooBalance -= mintPrice;\\n\\n            // Emit info about the mint for off-chain analysis.\\n            emit VaultMint(msg.sender, auctionPricePerMult, poolPricePerMult, mintPrice);\\n\\n            // Get the new mint price.\\n            mintPrice = artGobblers.gobblerPrice();\\n\\n            // Should we mint again?\\n            (mint, auctionPricePerMult, poolPricePerMult) = _shouldMint(gooBalance, gobblerReserve, mintPrice);\\n        }\\n\\n        // Update accumulators, kLast, kDebt.\\n        _update(gooBalance, gobblerReserve, gooReserve, gobblerReserve, true, true);\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function skim(address erc20) external nonReentrant onlyFeeTo {\\n        /// @dev Contract should never hold ERC20 tokens (only virtual GOO).\\n        uint256 contractBalance = ERC20(erc20).balanceOf(address(this));\\n        //slither-disable-next-line dangerous-strict-equalities\\n        if (contractBalance == 0) {\\n            revert NoSkim();\\n        }\\n        // Transfer the excess goo to the admin for handling.\\n        ERC20(erc20).safeTransfer(msg.sender, contractBalance);\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function flagGobbler(uint256 tokenId, bool _flagged) external onlyFeeTo {\\n        flagged[tokenId] = _flagged;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n    // External: Mutating, Unrestricted\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IGoober\\n    function deposit(uint256[] calldata gobblers, uint256 gooTokens, address receiver)\\n        public\\n        nonReentrant\\n        returns (uint256 fractions)\\n    {\\n        // Get reserve balances before they are updated from deposit transfers.\\n        (uint256 _gooReserve, uint256 _gobblerReserveMult,) = getReserves();\\n\\n        // Assess performance fee since last transaction.\\n        _performanceFee(_gooReserve, _gobblerReserveMult);\\n\\n        // Transfer goo if any.\\n        if (gooTokens > 0) {\\n            goo.safeTransferFrom(msg.sender, address(this), gooTokens);\\n            artGobblers.addGoo(gooTokens);\\n        }\\n\\n        // Transfer gobblers if any.\\n        for (uint256 i = 0; i < gobblers.length; i++) {\\n            artGobblers.safeTransferFrom(msg.sender, address(this), gobblers[i]);\\n        }\\n\\n        // Get the new reserves after transfers in.\\n        (uint256 _gooBalance, uint256 _gobblerBalanceMult,) = getReserves();\\n        {\\n            // Check the total token supply.\\n            uint256 _totalSupply = totalSupply;\\n\\n            // Calculate issuance.\\n            uint256 _kLast = FixedPointMathLib.sqrt(_gooReserve * _gobblerReserveMult);\\n            // Calculate the fractions to create based on the changes in K.\\n            (uint256 _k,,, uint256 _kDelta,) = _kCalculations(_gooBalance, _gobblerBalanceMult, _kLast, 0, true);\\n            if (_totalSupply == 0) {\\n                // We want to start the fractions at the right order of magnitude at init, so\\n                // we scale this by 1e9 to simulate 2 ERC20s, because Gobbler mult are integers\\n                // rather than 1e18 ERC20s from the Uni V2 design.\\n                fractions = _k * 1e9 - MINIMUM_LIQUIDITY;\\n            } else {\\n                fractions = FixedPointMathLib.mulWadDown(_totalSupply, _kDelta);\\n            }\\n            if (fractions == 0) {\\n                revert InsufficientLiquidityDeposited();\\n            }\\n        }\\n\\n        // Mint fractions less management fee to depositor.\\n        fractions -= _managementFee(fractions);\\n        _mint(receiver, fractions);\\n\\n        // Update kLast and accumulators.\\n        _update(_gooBalance, _gobblerBalanceMult, _gooReserve, _gobblerReserveMult, false, true);\\n\\n        emit Deposit(msg.sender, receiver, gobblers, gooTokens, fractions);\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function safeDeposit(\\n        uint256[] calldata gobblers,\\n        uint256 gooTokens,\\n        address receiver,\\n        uint256 minFractionsOut,\\n        uint256 deadline\\n    ) external ensure(deadline) returns (uint256 fractions) {\\n        fractions = deposit(gobblers, gooTokens, receiver);\\n\\n        if (fractions < minFractionsOut) {\\n            revert MintBelowLimit();\\n        }\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function withdraw(uint256[] calldata gobblers, uint256 gooTokens, address receiver, address owner)\\n        public\\n        nonReentrant\\n        returns (uint256 fractions)\\n    {\\n        // Get the starting reserves.\\n        (uint256 _gooReserve, uint256 _gobblerReserveMult,) = getReserves();\\n        (uint256 _gooBalance, uint256 _gobblerBalanceMult) = (_gooReserve, _gobblerReserveMult);\\n\\n        // Assess performance fee since the last update of K.\\n        _performanceFee(_gooReserve, _gobblerReserveMult);\\n\\n        // Optimistically transfer Goo, if any.\\n        if (gooTokens > 0) {\\n            artGobblers.removeGoo(gooTokens);\\n            goo.safeTransfer(receiver, gooTokens);\\n            _gooBalance -= gooTokens;\\n        }\\n\\n        // Optimistically transfer Gobblers, if any.\\n        uint256 gobblerMult;\\n        for (uint256 i = 0; i < gobblers.length; i++) {\\n            gobblerMult = artGobblers.getGobblerEmissionMultiple(gobblers[i]);\\n            if (gobblerMult < 6) {\\n                revert InvalidMultiplier(gobblers[i]);\\n            }\\n            artGobblers.transferFrom(address(this), receiver, gobblers[i]);\\n            _gobblerBalanceMult -= gobblerMult;\\n        }\\n\\n        // Measure the change in Gobbler mult.\\n        uint256 _gobblerAmountMult = _gobblerReserveMult - _gobblerBalanceMult;\\n\\n        if (!(_gobblerAmountMult > 0 || gooTokens > 0)) {\\n            revert InsufficientLiquidityWithdrawn();\\n        }\\n\\n        {\\n            // Calculate the fractions to destroy based on the changes in K.\\n            (,,, uint256 _kDelta,) = _kCalculations(\\n                _gooBalance, _gobblerBalanceMult, FixedPointMathLib.sqrt(_gooReserve * _gobblerReserveMult), 0, true\\n            );\\n            uint256 _totalSupply = totalSupply;\\n            fractions = FixedPointMathLib.mulWadUp(_totalSupply, _kDelta);\\n        }\\n        // If we are withdrawing on behalf of someone else, we need to check that they have approved us to do so.\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            // Check that we can withdraw the requested amount of liquidity.\\n            if (allowed < fractions) {\\n                revert InsufficientAllowance();\\n            }\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - fractions;\\n        }\\n\\n        // Destroy the fractions from owner.\\n        _burn(owner, fractions);\\n\\n        // Update the reserves.\\n        _update(_gooBalance, _gobblerBalanceMult, _gooReserve, _gobblerReserveMult, false, true);\\n\\n        emit Withdraw(msg.sender, receiver, owner, gobblers, gooTokens, fractions);\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function safeWithdraw(\\n        uint256[] calldata gobblers,\\n        uint256 gooTokens,\\n        address receiver,\\n        address owner,\\n        uint256 maxFractionsIn,\\n        uint256 deadline\\n    ) external ensure(deadline) returns (uint256 fractions) {\\n        fractions = withdraw(gobblers, gooTokens, receiver, owner);\\n\\n        if (fractions > maxFractionsIn) {\\n            revert BurnAboveLimit();\\n        }\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function swap(\\n        uint256[] calldata gobblersIn,\\n        uint256 gooIn,\\n        uint256[] calldata gobblersOut,\\n        uint256 gooOut,\\n        address receiver,\\n        bytes calldata data\\n    ) public nonReentrant returns (int256) {\\n        if (!(gooOut > 0 || gobblersOut.length > 0)) {\\n            revert InsufficientOutputAmount(gooOut, gobblersOut.length);\\n        }\\n\\n        if (receiver == address(goo) || receiver == address(artGobblers)) {\\n            revert InvalidReceiver(receiver);\\n        }\\n\\n        // Intermediary struct so that the stack doesn't get too deep.\\n        SwapData memory internalData = SwapData({\\n            gooReserve: 0,\\n            gobblerReserve: 0,\\n            gooBalance: 0,\\n            gobblerBalance: 0,\\n            multOut: 0,\\n            amount0In: 0,\\n            amount1In: 0,\\n            erroneousGoo: 0\\n        });\\n\\n        (internalData.gooReserve, internalData.gobblerReserve,) = getReserves();\\n\\n        // Transfer out.\\n\\n        // Optimistically transfer Goo, if any.\\n        if (gooOut > 0) {\\n            // Will underflow and revert if we don't have enough Goo, by design.\\n            artGobblers.removeGoo(gooOut);\\n            goo.safeTransfer(receiver, gooOut);\\n        }\\n\\n        // Optimistically transfer Gobblers, if any.\\n        if (gobblersOut.length > 0) {\\n            for (uint256 i = 0; i < gobblersOut.length; i++) {\\n                uint256 gobblerMult = artGobblers.getGobblerEmissionMultiple(gobblersOut[i]);\\n                if (gobblerMult < 6) {\\n                    revert InvalidMultiplier(gobblersOut[i]);\\n                }\\n                internalData.multOut += gobblerMult;\\n                artGobblers.transferFrom(address(this), receiver, gobblersOut[i]);\\n            }\\n        }\\n\\n        /// @dev Flash loan call out.\\n        /// @dev Unlike Uni V2, we only need to send the data,\\n        /// @dev because token transfers in are pulled below.\\n        if (data.length > 0) IGooberCallee(receiver).gooberCall(data);\\n\\n        // Transfer in.\\n\\n        // Transfer in Goo, if any.\\n        if (gooIn > 0) {\\n            goo.safeTransferFrom(msg.sender, address(this), gooIn);\\n            artGobblers.addGoo(gooIn);\\n        }\\n\\n        // Transfer in Gobblers, if any\\n        for (uint256 i = 0; i < gobblersIn.length; i++) {\\n            artGobblers.safeTransferFrom(msg.sender, address(this), gobblersIn[i]);\\n        }\\n\\n        // Get updated balances.\\n        (internalData.gooBalance, internalData.gobblerBalance,) = getReserves();\\n\\n        // Perform swap computation.\\n        (internalData.erroneousGoo, internalData.amount0In, internalData.amount1In) = _swapCalculations(\\n            internalData.gooReserve,\\n            internalData.gobblerReserve,\\n            internalData.gooBalance,\\n            internalData.gobblerBalance,\\n            gooOut,\\n            internalData.multOut,\\n            true\\n        );\\n\\n        // Update oracle.\\n        _update(\\n            internalData.gooBalance,\\n            internalData.gobblerBalance,\\n            internalData.gooReserve,\\n            internalData.gobblerReserve,\\n            false,\\n            false\\n        );\\n\\n        emit Swap(msg.sender, receiver, internalData.amount0In, internalData.amount1In, gooOut, internalData.multOut);\\n\\n        return internalData.erroneousGoo;\\n    }\\n\\n    /// @inheritdoc IGoober\\n    function safeSwap(\\n        uint256 erroneousGooAbs,\\n        uint256 deadline,\\n        uint256[] calldata gobblersIn,\\n        uint256 gooIn,\\n        uint256[] calldata gobblersOut,\\n        uint256 gooOut,\\n        address receiver,\\n        bytes calldata data\\n    ) external ensure(deadline) returns (int256 erroneousGoo) {\\n        erroneousGoo = previewSwap(gobblersIn, gooIn, gobblersOut, gooOut);\\n        if (erroneousGoo < 0) {\\n            uint256 additionalGooOut = uint256(-erroneousGoo);\\n            if (additionalGooOut > erroneousGooAbs) {\\n                revert ExcessiveErroneousGoo(additionalGooOut, erroneousGooAbs);\\n            }\\n            gooOut += additionalGooOut;\\n        } else if (erroneousGoo > 0) {\\n            uint256 additionalGooIn = uint256(erroneousGoo);\\n            if (additionalGooIn > erroneousGooAbs) {\\n                revert ExcessiveErroneousGoo(additionalGooIn, erroneousGooAbs);\\n            }\\n            gooIn += additionalGooIn;\\n        }\\n\\n        erroneousGoo = swap(gobblersIn, gooIn, gobblersOut, gooOut, receiver, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\\n        external\\n        returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IGoober.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IERC20Metadata.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\n\\ninterface IGoober is IERC721Receiver {\\n    // Errors\\n\\n    // Balance Errors\\n    error InsufficientAllowance();\\n    error InsufficientGoo(uint256 amount, uint256 actualK, uint256 expectedK);\\n\\n    // Deposit Errors\\n    error InsufficientLiquidityDeposited();\\n    error MintBelowLimit();\\n\\n    // K Calculation Errors\\n    error MustLeaveLiquidity(uint256 gooBalance, uint256 gobblerBalance);\\n\\n    // Mint Errors\\n    error AuctionPriceTooHigh(uint256 auctionPrice, uint256 poolPrice);\\n    error InsufficientLiquidity(uint256 gooBalance, uint256 gobblerBalance);\\n    error MintFailed();\\n\\n    // NFT Errors\\n    error InvalidNFT();\\n    error InvalidMultiplier(uint256 gobblerId);\\n\\n    // Skim Errors\\n    error NoSkim();\\n\\n    // Swap Errors\\n    error InsufficientInputAmount(uint256 amount0In, uint256 amount1In);\\n    error InsufficientOutputAmount(uint256 gooOut, uint256 gobblersOut);\\n    error InvalidReceiver(address receiver);\\n    error ExcessiveErroneousGoo(uint256 actualErroneousGoo, uint256 allowedErroneousGoo);\\n\\n    // Time Errors\\n    error Expired(uint256 time, uint256 deadline);\\n\\n    // Withdraw Errors\\n    error InsufficientLiquidityWithdrawn();\\n    error BurnAboveLimit();\\n\\n    /**\\n     * @notice The caller doesn't have permission to access the function.\\n     * @param accessor The requesting address.\\n     * @param permissioned The address which has the requisite permissions.\\n     */\\n    error AccessControlViolation(address accessor, address permissioned);\\n\\n    /**\\n     * @notice Invalid feeTo address.\\n     * @param feeTo the feeTo address.\\n     */\\n    error InvalidAddress(address feeTo);\\n\\n    // Structs\\n\\n    /// @dev Intermediary struct for swap calculation.\\n    struct SwapData {\\n        uint256 gooReserve;\\n        uint256 gobblerReserve;\\n        uint256 gooBalance;\\n        uint256 gobblerBalance;\\n        uint256 multOut;\\n        uint256 amount0In;\\n        uint256 amount1In;\\n        int256 erroneousGoo;\\n    }\\n\\n    // Events\\n\\n    event VaultMint(address indexed minter, uint256 auctionPricePerMult, uint256 poolPricePerMult, uint256 gooConsumed);\\n\\n    event Deposit(\\n        address indexed caller, address indexed receiver, uint256[] gobblers, uint256 gooTokens, uint256 fractions\\n    );\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256[] gobblers,\\n        uint256 gooTokens,\\n        uint256 fractions\\n    );\\n\\n    event FeesAccrued(address indexed feeTo, uint256 fractions, bool performanceFee, uint256 _deltaK);\\n\\n    event Swap(\\n        address indexed caller,\\n        address indexed receiver,\\n        uint256 gooTokensIn,\\n        uint256 gobblersMultIn,\\n        uint256 gooTokensOut,\\n        uint256 gobblerMultOut\\n    );\\n\\n    event Sync(uint256 gooBalance, uint256 multBalance);\\n\\n    /*//////////////////////////////////////////////////////////////\\n    // External: Non Mutating\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @return gooTokens The total amount of Goo owned.\\n    /// @return gobblerMult The total multiple of all Gobblers owned.\\n    function totalAssets() external view returns (uint256 gooTokens, uint256 gobblerMult);\\n\\n    /// @param gooTokens - The amount of Goo to simulate.\\n    /// @param gobblerMult - The amount of Gobbler mult in to simulate.\\n    /// @return fractions - The fractions, without any fees assessed, which would be returned for a deposit.\\n    function convertToFractions(uint256 gooTokens, uint256 gobblerMult) external view returns (uint256 fractions);\\n\\n    /// @param fractions The amount of fractions to simulate converting.\\n    /// @param gooTokens - The amount of Goo out.\\n    /// @param gobblerMult - The amount of Gobbler mult out.\\n    function convertToAssets(uint256 fractions) external view returns (uint256 gooTokens, uint256 gobblerMult);\\n\\n    /// @notice Gets the vault reserves of Goo and Gobbler mult, along with the last update time.\\n    /// @dev This can be used to calculate slippage on a swap of certain sizes\\n    /// @dev using Uni V2 style liquidity math.\\n    /// @return _gooReserve - The amount of Goo in the tank for the pool.\\n    /// @return _gobblerReserve - The total multiplier of all Gobblers in the pool.\\n    /// @return _blockTimestampLast - The last time that the oracles were updated.\\n    function getReserves()\\n        external\\n        view\\n        returns (uint256 _gooReserve, uint256 _gobblerReserve, uint32 _blockTimestampLast);\\n\\n    /// @notice Previews a deposit of the supplied Gobblers and Goo.\\n    /// @param gobblers - Array of Gobbler ids.\\n    /// @param gooTokens - Amount of Goo to deposit.\\n    /// @return fractions - Amount of fractions created.\\n    function previewDeposit(uint256[] calldata gobblers, uint256 gooTokens) external view returns (uint256 fractions);\\n\\n    /// @notice Previews a withdraw of the requested Gobblers and Goo tokens from the vault.\\n    /// @param gobblers - Array of Gobbler ids.\\n    /// @param gooTokens - Amount of Goo to withdraw.\\n    /// @return fractions - Amount of fractions withdrawn.\\n    function previewWithdraw(uint256[] calldata gobblers, uint256 gooTokens)\\n        external\\n        view\\n        returns (uint256 fractions);\\n\\n    /// @notice Simulates a swap.\\n    /// @param gobblersIn - Array of Gobbler ids to swap in.\\n    /// @param gooIn - Amount of Goo to swap in.\\n    /// @param gobblersOut - Array of Gobbler ids to swap out.\\n    /// @param gooOut - Amount of Goo to swap out.\\n    /// @return erroneousGoo - The amount in wei by which to increase or decrease gooIn/Out to balance the swap.\\n    function previewSwap(uint256[] calldata gobblersIn, uint256 gooIn, uint256[] calldata gobblersOut, uint256 gooOut)\\n        external\\n        view\\n        returns (int256 erroneousGoo);\\n\\n    /*//////////////////////////////////////////////////////////////\\n    // External: Mutating, Restricted Access\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // Access Control\\n\\n    /**\\n     * @notice Updates the address that fees are sent to.\\n     * @param newFeeTo The new address to which fees will be sent.\\n     */\\n    function setFeeTo(address newFeeTo) external;\\n\\n    /**\\n     * @notice Updates the address that can call mintGobbler.\\n     * @param newMinter The new address to which will be able to call mintGobbler.\\n     */\\n    function setMinter(address newMinter) external;\\n\\n    // Other Privileged Functions\\n\\n    /// @notice Mints Gobblers using the pool's virtual reserves of Goo\\n    /// @notice when specific conditions are met.\\n    function mintGobbler() external;\\n\\n    /// @notice Restricted function for skimming any ERC20s that may have been erroneously sent to the pool.\\n    function skim(address erc20) external;\\n\\n    /// @notice Restricted function for blocking/unblocking compromised Gobblers from the pool.\\n    function flagGobbler(uint256 tokenId, bool _flagged) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n    // External: Mutating, Unrestricted\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Deposits the supplied Gobblers/Goo from the owner and sends fractions to the receiver.\\n    /// @param gobblers - Array of Gobbler ids.\\n    /// @param gooTokens - Amount of Goo to deposit.\\n    /// @param receiver - Address to receive fractions.\\n    /// @return fractions - Amount of fractions created.\\n    function deposit(uint256[] calldata gobblers, uint256 gooTokens, address receiver)\\n        external\\n        returns (uint256 fractions);\\n\\n    /// @notice Deposits the supplied Gobblers/Goo from the owner and sends fractions to the\\n    /// @notice receiver whilst ensuring a deadline is met, and a minimum amount of fractions are created.\\n    /// @param gobblers - Array of Gobbler ids to deposit.\\n    /// @param gooTokens - Amount of Goo to deposit.\\n    /// @param receiver - Address to receive fractions.\\n    /// @param minFractionsOut - Minimum amount of fractions to be sent.\\n    /// @param deadline - Unix timestamp by which the transaction must execute.\\n    /// @return fractions - Amount of fractions created.\\n    function safeDeposit(\\n        uint256[] calldata gobblers,\\n        uint256 gooTokens,\\n        address receiver,\\n        uint256 minFractionsOut,\\n        uint256 deadline\\n    ) external returns (uint256 fractions);\\n\\n    /// @notice Withdraws the requested Gobblers and Goo from the vault.\\n    /// @param gobblers - Array of Gobbler ids to withdraw\\n    /// @param gooTokens - Amount of Goo to withdraw.\\n    /// @param receiver - Address to receive the Goo and Gobblers.\\n    /// @param owner - Owner of the fractions to be destroyed.\\n    /// @return fractions - Amount of fractions destroyed.\\n    function withdraw(uint256[] calldata gobblers, uint256 gooTokens, address receiver, address owner)\\n        external\\n        returns (uint256 fractions);\\n\\n    /// @notice Withdraws the requested Gobblers/Goo from the vault to the receiver and destroys fractions\\n    /// @notice from the owner whilst ensuring a deadline is met, and a maximimum amount of fractions are destroyed.\\n    /// @param gobblers - Array of Gobbler ids to withdraw.\\n    /// @param gooTokens - Amount of Goo to withdraw.\\n    /// @param receiver - Address to receive the Goo and Gobblers.\\n    /// @param owner - Owner of the fractions to be destroyed.\\n    /// @param maxFractionsIn - Maximum amount of fractions to be destroyed.\\n    /// @param deadline - Unix timestamp by which the transaction must execute.\\n    /// @return fractions - Aamount of fractions destroyed.\\n    function safeWithdraw(\\n        uint256[] calldata gobblers,\\n        uint256 gooTokens,\\n        address receiver,\\n        address owner,\\n        uint256 maxFractionsIn,\\n        uint256 deadline\\n    ) external returns (uint256 fractions);\\n\\n    /// @notice Swaps supplied Gobblers/Goo for Gobblers/Goo in the pool.\\n    function swap(\\n        uint256[] calldata gobblersIn,\\n        uint256 gooIn,\\n        uint256[] calldata gobblersOut,\\n        uint256 gooOut,\\n        address receiver,\\n        bytes calldata data\\n    ) external returns (int256 erroneousGoo);\\n\\n    /// @notice Swaps supplied Gobblers/Goo for Gobblers/Goo in the pool, with slippage and deadline control.\\n    function safeSwap(\\n        uint256 erroneousGooAbs,\\n        uint256 deadline,\\n        uint256[] calldata gobblersIn,\\n        uint256 gooIn,\\n        uint256[] calldata gobblersOut,\\n        uint256 gooOut,\\n        address receiver,\\n        bytes calldata data\\n    ) external returns (int256 erroneousGoo);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IGooberCallee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IGoober.sol\\\";\\n\\ninterface IGooberCallee {\\n    function gooberCall(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"src/math/UQ112x112.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL\\n\\npragma solidity ^0.8.17;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 public constant Q112 = 2 ** 112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"VRGDAs/=lib/art-gobblers/lib/VRGDAs/src/\",\r\n      \"art-gobblers/=lib/art-gobblers/src/\",\r\n      \"chainlink/=lib/art-gobblers/lib/chainlink/contracts/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"goo-issuance/=lib/art-gobblers/lib/goo-issuance/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gobblersAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gooAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accessor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"permissioned\",\"type\":\"address\"}],\"name\":\"AccessControlViolation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolPrice\",\"type\":\"uint256\"}],\"name\":\"AuctionPriceTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnAboveLimit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualErroneousGoo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allowedErroneousGoo\",\"type\":\"uint256\"}],\"name\":\"ExcessiveErroneousGoo\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualK\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedK\",\"type\":\"uint256\"}],\"name\":\"InsufficientGoo\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"}],\"name\":\"InsufficientInputAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gooBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gobblerBalance\",\"type\":\"uint256\"}],\"name\":\"InsufficientLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidityDeposited\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidityWithdrawn\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gooOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gobblersOut\",\"type\":\"uint256\"}],\"name\":\"InsufficientOutputAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeTo\",\"type\":\"address\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gobblerId\",\"type\":\"uint256\"}],\"name\":\"InvalidMultiplier\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNFT\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintBelowLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gooBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gobblerBalance\",\"type\":\"uint256\"}],\"name\":\"MustLeaveLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSkim\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"gobblers\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gooTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fractions\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fractions\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"performanceFee\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_deltaK\",\"type\":\"uint256\"}],\"name\":\"FeesAccrued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gooTokensIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gobblersMultIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gooTokensOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gobblerMultOut\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gooBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"multBalance\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionPricePerMult\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolPricePerMult\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gooConsumed\",\"type\":\"uint256\"}],\"name\":\"VaultMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"gobblers\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gooTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fractions\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGEMENT_FEE_BPS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERFORMANCE_FEE_BPS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artGobblers\",\"outputs\":[{\"internalType\":\"contract ArtGobblers\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTimestampLast\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fractions\",\"type\":\"uint256\"}],\"name\":\"convertToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gooTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gobblerMult\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gooTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gobblerMult\",\"type\":\"uint256\"}],\"name\":\"convertToFractions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fractions\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"gobblers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gooTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fractions\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_flagged\",\"type\":\"bool\"}],\"name\":\"flagGobbler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"flagged\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_gooReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gobblerReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_blockTimestampLast\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"goo\",\"outputs\":[{\"internalType\":\"contract Goo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kDebt\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kLast\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintGobbler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"gobblers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gooTokens\",\"type\":\"uint256\"}],\"name\":\"previewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fractions\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"gobblersIn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gooIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"gobblersOut\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gooOut\",\"type\":\"uint256\"}],\"name\":\"previewSwap\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"erroneousGoo\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"gobblers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gooTokens\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fractions\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceGobblerCumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceGooCumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"gobblers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gooTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minFractionsOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"safeDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fractions\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"erroneousGooAbs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"gobblersIn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gooIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"gobblersOut\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gooOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeSwap\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"erroneousGoo\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"gobblers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gooTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxFractionsIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"safeWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fractions\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"gobblersIn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gooIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"gobblersOut\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gooOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gooTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gobblerMult\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"gobblers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gooTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fractions\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Goober","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":"1","Runs":"2000000","ConstructorArguments":"00000000000000000000000060bb1e2aa1c9acafb4d34f71585d7e959f387769000000000000000000000000600000000a36f3cd48407e35eb7c5c910dc1f7a80000000000000000000000000cc56e024e9fda80f939ab3b434d0dd76765d1750000000000000000000000000cc56e024e9fda80f939ab3b434d0dd76765d175","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]