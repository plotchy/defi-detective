[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/join.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// join.sol -- Basic token adapters\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ninterface GemLike {\\r\\n    function decimals() external view returns (uint);\\r\\n    function transfer(address,uint) external returns (bool);\\r\\n    function transferFrom(address,address,uint) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface DSTokenLike {\\r\\n    function mint(address,uint) external;\\r\\n    function burn(address,uint) external;\\r\\n}\\r\\n\\r\\ninterface VatLike {\\r\\n    function slip(bytes32,address,int) external;\\r\\n    function move(address,address,uint) external;\\r\\n}\\r\\n\\r\\n/*\\r\\n    Here we provide *adapters* to connect the Vat to arbitrary external\\r\\n    token implementations, creating a bounded context for the Vat. The\\r\\n    adapters here are provided as working examples:\\r\\n\\r\\n      - `GemJoin`: For well behaved ERC20 tokens, with simple transfer\\r\\n                   semantics.\\r\\n\\r\\n      - `ETHJoin`: For native Ether.\\r\\n\\r\\n      - `USBJoin`: For connecting internal USB balances to an external\\r\\n                   `DSToken` implementation.\\r\\n\\r\\n    In practice, adapter implementations will be varied and specific to\\r\\n    individual collateral types, accounting for different transfer\\r\\n    semantics and token standards.\\r\\n\\r\\n    Adapters need to implement two basic methods:\\r\\n\\r\\n      - `join`: enter collateral into the system\\r\\n      - `exit`: remove collateral from the system\\r\\n\\r\\n*/\\r\\n\\r\\ncontract GemJoin {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address usr) external auth {\\r\\n        wards[usr] = 1;\\r\\n        emit Rely(usr);\\r\\n    }\\r\\n    function deny(address usr) external auth {\\r\\n        wards[usr] = 0;\\r\\n        emit Deny(usr);\\r\\n    }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"GemJoin/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    VatLike public vat;   // CDP Engine\\r\\n    bytes32 public ilk;   // Collateral Type\\r\\n    GemLike public gem;\\r\\n    uint    public dec;\\r\\n    uint    public live;  // Active Flag\\r\\n\\r\\n    // Events\\r\\n    event Rely(address indexed usr);\\r\\n    event Deny(address indexed usr);\\r\\n    event Join(address indexed usr, uint256 wad);\\r\\n    event Exit(address indexed usr, uint256 wad);\\r\\n    event Cage();\\r\\n\\r\\n    constructor(address vat_, bytes32 ilk_, address gem_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        live = 1;\\r\\n        vat = VatLike(vat_);\\r\\n        ilk = ilk_;\\r\\n        gem = GemLike(gem_);\\r\\n        dec = gem.decimals();\\r\\n        emit Rely(msg.sender);\\r\\n    }\\r\\n    function cage() external auth {\\r\\n        live = 0;\\r\\n        emit Cage();\\r\\n    }\\r\\n    function join(address usr, uint wad) external {\\r\\n        require(live == 1, \\\"GemJoin/not-live\\\");\\r\\n        require(int(wad) >= 0, \\\"GemJoin/overflow\\\");\\r\\n        vat.slip(ilk, usr, int(wad));\\r\\n        require(gem.transferFrom(msg.sender, address(this), wad), \\\"GemJoin/failed-transfer\\\");\\r\\n        emit Join(usr, wad);\\r\\n    }\\r\\n    function exit(address usr, uint wad) external {\\r\\n        require(wad <= 2 ** 255, \\\"GemJoin/overflow\\\");\\r\\n        vat.slip(ilk, msg.sender, -int(wad));\\r\\n        require(gem.transfer(usr, wad), \\\"GemJoin/failed-transfer\\\");\\r\\n        emit Exit(usr, wad);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract USBJoin {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address usr) external auth {\\r\\n        wards[usr] = 1;\\r\\n        emit Rely(usr);\\r\\n    }\\r\\n    function deny(address usr) external auth {\\r\\n        wards[usr] = 0;\\r\\n        emit Deny(usr);\\r\\n    }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"USBJoin/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    VatLike public vat;      // CDP Engine\\r\\n    DSTokenLike public USB;  // Stablecoin Token\\r\\n    uint    public live;     // Active Flag\\r\\n\\r\\n    // Events\\r\\n    event Rely(address indexed usr);\\r\\n    event Deny(address indexed usr);\\r\\n    event Join(address indexed usr, uint256 wad);\\r\\n    event Exit(address indexed usr, uint256 wad);\\r\\n    event Cage();\\r\\n\\r\\n    constructor(address vat_, address USB_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        live = 1;\\r\\n        vat = VatLike(vat_);\\r\\n        USB = DSTokenLike(USB_);\\r\\n    }\\r\\n    function cage() external auth {\\r\\n        live = 0;\\r\\n        emit Cage();\\r\\n    }\\r\\n    uint constant ONE = 10 ** 27;\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n    function join(address usr, uint wad) external {\\r\\n        vat.move(address(this), usr, mul(ONE, wad));\\r\\n        USB.burn(msg.sender, wad);\\r\\n        emit Join(usr, wad);\\r\\n    }\\r\\n    function exit(address usr, uint wad) external {\\r\\n        require(live == 1, \\\"USBJoin/not-live\\\");\\r\\n        vat.move(msg.sender, address(this), mul(ONE, wad));\\r\\n        USB.mint(usr, wad);\\r\\n        emit Exit(usr, wad);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/clip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// clip.sol -- USB auction module 2.0\\r\\n\\r\\n\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published\\r\\n// by the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface VatLike {\\r\\n    function move(address,address,uint256) external;\\r\\n    function flux(bytes32,address,address,uint256) external;\\r\\n    function ilks(bytes32) external returns (uint256, uint256, uint256, uint256, uint256);\\r\\n    function suck(address,address,uint256) external;\\r\\n}\\r\\n\\r\\ninterface PipLike {\\r\\n    function peek() external returns (bytes32, bool);\\r\\n}\\r\\n\\r\\ninterface SpotterLike {\\r\\n    function par() external returns (uint256);\\r\\n    function ilks(bytes32) external returns (PipLike, uint256);\\r\\n}\\r\\n\\r\\ninterface DogLike {\\r\\n    function chop(bytes32) external returns (uint256);\\r\\n    function digs(bytes32, uint256) external;\\r\\n}\\r\\n\\r\\ninterface ClipperCallee {\\r\\n    function clipperCall(address, uint256, uint256, bytes calldata) external;\\r\\n}\\r\\n\\r\\ninterface AbacusLike {\\r\\n    function price(uint256, uint256) external view returns (uint256);\\r\\n}\\r\\n\\r\\ncontract Clipper {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint256) public wards;\\r\\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"Clipper/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    bytes32  immutable public ilk;   // Collateral type of this Clipper\\r\\n    VatLike  immutable public vat;   // Core CDP Engine\\r\\n\\r\\n    DogLike     public dog;      // Liquidation module\\r\\n    address     public vow;      // Recipient of USB raised in auctions\\r\\n    SpotterLike public spotter;  // Collateral price module\\r\\n    AbacusLike  public calc;     // Current price calculator\\r\\n\\r\\n    uint256 public buf;    // Multiplicative factor to increase starting price                  [ray]\\r\\n    uint256 public tail;   // Time elapsed before auction reset                                 [seconds]\\r\\n    uint256 public cusp;   // Percentage drop before auction reset                              [ray]\\r\\n    uint64  public chip;   // Percentage of tab to suck from vow to incentivize keepers         [wad]\\r\\n    uint192 public tip;    // Flat fee to suck from vow to incentivize keepers                  [rad]\\r\\n    uint256 public chost;  // Cache the ilk dust times the ilk chop to prevent excessive SLOADs [rad]\\r\\n\\r\\n    uint256   public kicks;   // Total auctions\\r\\n    uint256[] public active;  // Array of active auction ids\\r\\n\\r\\n    struct Sale {\\r\\n        uint256 pos;  // Index in active array\\r\\n        uint256 tab;  // USB to raise       [rad]\\r\\n        uint256 lot;  // collateral to sell [wad]\\r\\n        address usr;  // Liquidated CDP\\r\\n        uint96  tic;  // Auction start time\\r\\n        uint256 top;  // Starting price     [ray]\\r\\n    }\\r\\n    mapping(uint256 => Sale) public sales;\\r\\n\\r\\n    uint256 internal locked;\\r\\n\\r\\n    // Levels for circuit breaker\\r\\n    // 0: no breaker\\r\\n    // 1: no new kick()\\r\\n    // 2: no new kick() or redo()\\r\\n    // 3: no new kick(), redo(), or take()\\r\\n    uint256 public stopped = 0;\\r\\n\\r\\n    // --- Events ---\\r\\n    event Rely(address indexed usr);\\r\\n    event Deny(address indexed usr);\\r\\n\\r\\n    event File(bytes32 indexed what, uint256 data);\\r\\n    event File(bytes32 indexed what, address data);\\r\\n\\r\\n    event Kick(\\r\\n        uint256 indexed id,\\r\\n        uint256 top,\\r\\n        uint256 tab,\\r\\n        uint256 lot,\\r\\n        address indexed usr,\\r\\n        address indexed kpr,\\r\\n        uint256 coin\\r\\n    );\\r\\n    event Take(\\r\\n        uint256 indexed id,\\r\\n        uint256 max,\\r\\n        uint256 price,\\r\\n        uint256 owe,\\r\\n        uint256 tab,\\r\\n        uint256 lot,\\r\\n        address indexed usr\\r\\n    );\\r\\n    event Redo(\\r\\n        uint256 indexed id,\\r\\n        uint256 top,\\r\\n        uint256 tab,\\r\\n        uint256 lot,\\r\\n        address indexed usr,\\r\\n        address indexed kpr,\\r\\n        uint256 coin\\r\\n    );\\r\\n\\r\\n    event Yank(uint256 id);\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address vat_, address spotter_, address dog_, bytes32 ilk_) public {\\r\\n        vat     = VatLike(vat_);\\r\\n        spotter = SpotterLike(spotter_);\\r\\n        dog     = DogLike(dog_);\\r\\n        ilk     = ilk_;\\r\\n        buf     = RAY;\\r\\n        wards[msg.sender] = 1;\\r\\n        emit Rely(msg.sender);\\r\\n    }\\r\\n\\r\\n    // --- Synchronization ---\\r\\n    modifier lock {\\r\\n        require(locked == 0, \\\"Clipper/system-locked\\\");\\r\\n        locked = 1;\\r\\n        _;\\r\\n        locked = 0;\\r\\n    }\\r\\n\\r\\n    modifier isStopped(uint256 level) {\\r\\n        require(stopped < level, \\\"Clipper/stopped-incorrect\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Administration ---\\r\\n    function file(bytes32 what, uint256 data) external auth lock {\\r\\n        if      (what == \\\"buf\\\")         buf = data;\\r\\n        else if (what == \\\"tail\\\")       tail = data;           // Time elapsed before auction reset\\r\\n        else if (what == \\\"cusp\\\")       cusp = data;           // Percentage drop before auction reset\\r\\n        else if (what == \\\"chip\\\")       chip = uint64(data);   // Percentage of tab to incentivize (max: 2^64 - 1 => 18.xxx WAD = 18xx%)\\r\\n        else if (what == \\\"tip\\\")         tip = uint192(data);  // Flat fee to incentivize keepers (max: 2^192 - 1 => 6.277T RAD)\\r\\n        else if (what == \\\"stopped\\\") stopped = data;           // Set breaker (0, 1, 2, or 3)\\r\\n        else revert(\\\"Clipper/file-unrecognized-param\\\");\\r\\n        emit File(what, data);\\r\\n    }\\r\\n    function file(bytes32 what, address data) external auth lock {\\r\\n        if (what == \\\"spotter\\\") spotter = SpotterLike(data);\\r\\n        else if (what == \\\"dog\\\")    dog = DogLike(data);\\r\\n        else if (what == \\\"vow\\\")    vow = data;\\r\\n        else if (what == \\\"calc\\\")  calc = AbacusLike(data);\\r\\n        else revert(\\\"Clipper/file-unrecognized-param\\\");\\r\\n        emit File(what, data);\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    uint256 constant BLN = 10 **  9;\\r\\n    uint256 constant WAD = 10 ** 18;\\r\\n    uint256 constant RAY = 10 ** 27;\\r\\n\\r\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = x <= y ? x : y;\\r\\n    }\\r\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x - y) <= x);\\r\\n    }\\r\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = mul(x, y) / WAD;\\r\\n    }\\r\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = mul(x, y) / RAY;\\r\\n    }\\r\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = mul(x, RAY) / y;\\r\\n    }\\r\\n\\r\\n    // --- Auction ---\\r\\n\\r\\n    // get the price directly from the OSM\\r\\n    // Could get this from rmul(Vat.ilks(ilk).spot, Spotter.mat()) instead, but\\r\\n    // if mat has changed since the last poke, the resulting value will be\\r\\n    // incorrect.\\r\\n    function getFeedPrice() internal returns (uint256 feedPrice) {\\r\\n        (PipLike pip, ) = spotter.ilks(ilk);\\r\\n        (bytes32 val, bool has) = pip.peek();\\r\\n        require(has, \\\"Clipper/invalid-price\\\");\\r\\n        feedPrice = rdiv(mul(uint256(val), BLN), spotter.par());\\r\\n    }\\r\\n\\r\\n    // start an auction\\r\\n    // note: trusts the caller to transfer collateral to the contract\\r\\n    // The starting price `top` is obtained as follows:\\r\\n    //\\r\\n    //     top = val * buf / par\\r\\n    //\\r\\n    // Where `val` is the collateral's unitary value in USD, `buf` is a\\r\\n    // multiplicative factor to increase the starting price, and `par` is a\\r\\n    // reference per USB.\\r\\n    function kick(\\r\\n        uint256 tab,  // Debt                   [rad]\\r\\n        uint256 lot,  // Collateral             [wad]\\r\\n        address usr,  // Address that will receive any leftover collateral\\r\\n        address kpr   // Address that will receive incentives\\r\\n    ) external auth lock isStopped(1) returns (uint256 id) {\\r\\n        // Input validation\\r\\n        require(tab  >          0, \\\"Clipper/zero-tab\\\");\\r\\n        require(lot  >          0, \\\"Clipper/zero-lot\\\");\\r\\n        require(usr != address(0), \\\"Clipper/zero-usr\\\");\\r\\n        id = ++kicks;\\r\\n        require(id   >          0, \\\"Clipper/overflow\\\");\\r\\n\\r\\n        active.push(id);\\r\\n\\r\\n        sales[id].pos = active.length - 1;\\r\\n\\r\\n        sales[id].tab = tab;\\r\\n        sales[id].lot = lot;\\r\\n        sales[id].usr = usr;\\r\\n        sales[id].tic = uint96(block.timestamp);\\r\\n\\r\\n        uint256 top;\\r\\n        top = rmul(getFeedPrice(), buf);\\r\\n        require(top > 0, \\\"Clipper/zero-top-price\\\");\\r\\n        sales[id].top = top;\\r\\n\\r\\n        // incentive to kick auction\\r\\n        uint256 _tip  = tip;\\r\\n        uint256 _chip = chip;\\r\\n        uint256 coin;\\r\\n        if (_tip > 0 || _chip > 0) {\\r\\n            coin = add(_tip, wmul(tab, _chip));\\r\\n            vat.suck(vow, kpr, coin);\\r\\n        }\\r\\n\\r\\n        emit Kick(id, top, tab, lot, usr, kpr, coin);\\r\\n    }\\r\\n\\r\\n    // Reset an auction\\r\\n    // See `kick` above for an explanation of the computation of `top`.\\r\\n    function redo(\\r\\n        uint256 id,  // id of the auction to reset\\r\\n        address kpr  // Address that will receive incentives\\r\\n    ) external lock isStopped(2) {\\r\\n        // Read auction data\\r\\n        address usr = sales[id].usr;\\r\\n        uint96  tic = sales[id].tic;\\r\\n        uint256 top = sales[id].top;\\r\\n\\r\\n        require(usr != address(0), \\\"Clipper/not-running-auction\\\");\\r\\n\\r\\n        // Check that auction needs reset\\r\\n        // and compute current price [ray]\\r\\n        (bool done,) = status(tic, top);\\r\\n        require(done, \\\"Clipper/cannot-reset\\\");\\r\\n\\r\\n        uint256 tab   = sales[id].tab;\\r\\n        uint256 lot   = sales[id].lot;\\r\\n        sales[id].tic = uint96(block.timestamp);\\r\\n\\r\\n        uint256 feedPrice = getFeedPrice();\\r\\n        top = rmul(feedPrice, buf);\\r\\n        require(top > 0, \\\"Clipper/zero-top-price\\\");\\r\\n        sales[id].top = top;\\r\\n\\r\\n        // incentive to redo auction\\r\\n        uint256 _tip  = tip;\\r\\n        uint256 _chip = chip;\\r\\n        uint256 coin;\\r\\n        if (_tip > 0 || _chip > 0) {\\r\\n            uint256 _chost = chost;\\r\\n            if (tab >= _chost && mul(lot, feedPrice) >= _chost) {\\r\\n                coin = add(_tip, wmul(tab, _chip));\\r\\n                vat.suck(vow, kpr, coin);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Redo(id, top, tab, lot, usr, kpr, coin);\\r\\n    }\\r\\n\\r\\n    // Buy up to `amt` of collateral from the auction indexed by `id`.\\r\\n    //\\r\\n    // Auctions will not collect more USB than their assigned USB target,`tab`;\\r\\n    // thus, if `amt` would cost more USB than `tab` at the current price, the\\r\\n    // amount of collateral purchased will instead be just enough to collect `tab` USB.\\r\\n    //\\r\\n    // To avoid partial purchases resulting in very small leftover auctions that will\\r\\n    // never be cleared, any partial purchase must leave at least `Clipper.chost`\\r\\n    // remaining USB target. `chost` is an asynchronously updated value equal to\\r\\n    // (Vat.dust * Dog.chop(ilk) / WAD) where the values are understood to be determined\\r\\n    // by whatever they were when Clipper.upchost() was last called. Purchase amounts\\r\\n    // will be minimally decreased when necessary to respect this limit; i.e., if the\\r\\n    // specified `amt` would leave `tab < chost` but `tab > 0`, the amount actually\\r\\n    // purchased will be such that `tab == chost`.\\r\\n    //\\r\\n    // If `tab <= chost`, partial purchases are no longer possible; that is, the remaining\\r\\n    // collateral can only be purchased entirely, or not at all.\\r\\n    function take(\\r\\n        uint256 id,           // Auction id\\r\\n        uint256 amt,          // Upper limit on amount of collateral to buy  [wad]\\r\\n        uint256 max,          // Maximum acceptable price (USB / collateral) [ray]\\r\\n        address who,          // Receiver of collateral and external call address\\r\\n        bytes calldata data   // Data to pass in external call; if length 0, no call is done\\r\\n    ) external lock isStopped(3) {\\r\\n\\r\\n        address usr = sales[id].usr;\\r\\n        uint96  tic = sales[id].tic;\\r\\n\\r\\n        require(usr != address(0), \\\"Clipper/not-running-auction\\\");\\r\\n\\r\\n        uint256 price;\\r\\n        {\\r\\n            bool done;\\r\\n            (done, price) = status(tic, sales[id].top);\\r\\n\\r\\n            // Check that auction doesn't need reset\\r\\n            require(!done, \\\"Clipper/needs-reset\\\");\\r\\n        }\\r\\n\\r\\n        // Ensure price is acceptable to buyer\\r\\n        require(max >= price, \\\"Clipper/too-expensive\\\");\\r\\n\\r\\n        uint256 lot = sales[id].lot;\\r\\n        uint256 tab = sales[id].tab;\\r\\n        uint256 owe;\\r\\n\\r\\n        {\\r\\n            // Purchase as much as possible, up to amt\\r\\n            uint256 slice = min(lot, amt);  // slice <= lot\\r\\n\\r\\n            // USB needed to buy a slice of this sale\\r\\n            owe = mul(slice, price);\\r\\n\\r\\n            // Don't collect more than tab of USB\\r\\n            if (owe > tab) {\\r\\n                // Total debt will be paid\\r\\n                owe = tab;                  // owe' <= owe\\r\\n                // Adjust slice\\r\\n                slice = owe / price;        // slice' = owe' / price <= owe / price == slice <= lot\\r\\n            } else if (owe < tab && slice < lot) {\\r\\n                // If slice == lot => auction completed => dust doesn't matter\\r\\n                uint256 _chost = chost;\\r\\n                if (tab - owe < _chost) {    // safe as owe < tab\\r\\n                    // If tab <= chost, buyers have to take the entire lot.\\r\\n                    require(tab > _chost, \\\"Clipper/no-partial-purchase\\\");\\r\\n                    // Adjust amount to pay\\r\\n                    owe = tab - _chost;      // owe' <= owe\\r\\n                    // Adjust slice\\r\\n                    slice = owe / price;     // slice' = owe' / price < owe / price == slice < lot\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // Calculate remaining tab after operation\\r\\n            tab = tab - owe;  // safe since owe <= tab\\r\\n            // Calculate remaining lot after operation\\r\\n            lot = lot - slice;\\r\\n\\r\\n            // Send collateral to who\\r\\n            vat.flux(ilk, address(this), who, slice);\\r\\n\\r\\n            // Do external call (if data is defined) but to be\\r\\n            // extremely careful we don't allow to do it to the two\\r\\n            // contracts which the Clipper needs to be authorized\\r\\n            DogLike dog_ = dog;\\r\\n            if (data.length > 0 && who != address(vat) && who != address(dog_)) {\\r\\n                ClipperCallee(who).clipperCall(msg.sender, owe, slice, data);\\r\\n            }\\r\\n\\r\\n            // Get USB from caller\\r\\n            vat.move(msg.sender, vow, owe);\\r\\n\\r\\n            // Removes USB out for liquidation from accumulator\\r\\n            dog_.digs(ilk, lot == 0 ? tab + owe : owe);\\r\\n        }\\r\\n\\r\\n        if (lot == 0) {\\r\\n            _remove(id);\\r\\n        } else if (tab == 0) {\\r\\n            vat.flux(ilk, address(this), usr, lot);\\r\\n            _remove(id);\\r\\n        } else {\\r\\n            sales[id].tab = tab;\\r\\n            sales[id].lot = lot;\\r\\n        }\\r\\n\\r\\n        emit Take(id, max, price, owe, tab, lot, usr);\\r\\n    }\\r\\n\\r\\n    function _remove(uint256 id) internal {\\r\\n        uint256 _move    = active[active.length - 1];\\r\\n        if (id != _move) {\\r\\n            uint256 _index   = sales[id].pos;\\r\\n            active[_index]   = _move;\\r\\n            sales[_move].pos = _index;\\r\\n        }\\r\\n        active.pop();\\r\\n        delete sales[id];\\r\\n    }\\r\\n\\r\\n    // The number of active auctions\\r\\n    function count() external view returns (uint256) {\\r\\n        return active.length;\\r\\n    }\\r\\n\\r\\n    // Return the entire array of active auctions\\r\\n    function list() external view returns (uint256[] memory) {\\r\\n        return active;\\r\\n    }\\r\\n\\r\\n    // Externally returns boolean for if an auction needs a redo and also the current price\\r\\n    function getStatus(uint256 id) external view returns (bool needsRedo, uint256 price, uint256 lot, uint256 tab) {\\r\\n        // Read auction data\\r\\n        address usr = sales[id].usr;\\r\\n        uint96  tic = sales[id].tic;\\r\\n\\r\\n        bool done;\\r\\n        (done, price) = status(tic, sales[id].top);\\r\\n\\r\\n        needsRedo = usr != address(0) && done;\\r\\n        lot = sales[id].lot;\\r\\n        tab = sales[id].tab;\\r\\n    }\\r\\n\\r\\n    // Internally returns boolean for if an auction needs a redo\\r\\n    function status(uint96 tic, uint256 top) internal view returns (bool done, uint256 price) {\\r\\n        price = calc.price(top, sub(block.timestamp, tic));\\r\\n        done  = (sub(block.timestamp, tic) > tail || rdiv(price, top) < cusp);\\r\\n    }\\r\\n\\r\\n    // Public function to update the cached dust*chop value.\\r\\n    function upchost() external {\\r\\n        (,,,, uint256 _dust) = VatLike(vat).ilks(ilk);\\r\\n        chost = wmul(_dust, dog.chop(ilk));\\r\\n    }\\r\\n\\r\\n    // Cancel an auction during ES or via governance action.\\r\\n    function yank(uint256 id) external auth lock {\\r\\n        require(sales[id].usr != address(0), \\\"Clipper/not-running-auction\\\");\\r\\n        dog.digs(ilk, sales[id].tab);\\r\\n        vat.flux(ilk, address(this), msg.sender, sales[id].lot);\\r\\n        _remove(id);\\r\\n        emit Yank(id);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/VoteProxy.sol\": {\r\n      \"content\": \"/// VoteProxy.sol\\n\\n\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\n// vote w/ a hot or cold wallet using a proxy identity\\npragma solidity >=0.4.24;\\n\\ninterface TokenLike {\\n    function balanceOf(address) external view returns (uint256);\\n    function approve(address, uint256) external;\\n    function pull(address, uint256) external;\\n    function push(address, uint256) external;\\n}\\n\\ninterface ChiefLike {\\n    function GOV() external view returns (TokenLike);\\n    function IOU() external view returns (TokenLike);\\n    function deposits(address) external view returns (uint256);\\n    function lock(uint256) external;\\n    function free(uint256) external;\\n    function vote(address[] calldata) external returns (bytes32);\\n    function vote(bytes32) external;\\n}\\n\\ncontract VoteProxy {\\n    address   public cold;\\n    address   public hot;\\n    TokenLike public gov;\\n    TokenLike public iou;\\n    ChiefLike public chief;\\n\\n    constructor(address _chief, address _cold, address _hot) public {\\n        chief = ChiefLike(_chief);\\n        cold = _cold;\\n        hot = _hot;\\n\\n        gov = chief.GOV();\\n        iou = chief.IOU();\\n        gov.approve(address(chief), type(uint256).max);\\n        iou.approve(address(chief), type(uint256).max);\\n    }\\n\\n    modifier auth() {\\n        require(msg.sender == hot || msg.sender == cold, \\\"Sender must be a Cold or Hot Wallet\\\");\\n        _;\\n    }\\n\\n    function lock(uint256 wad) public auth {\\n        gov.pull(cold, wad);   // mkr from cold\\n        chief.lock(wad);       // mkr out, ious in\\n    }\\n\\n    function free(uint256 wad) public auth {\\n        chief.free(wad);       // ious out, mkr in\\n        gov.push(cold, wad);   // mkr to cold\\n    }\\n\\n    function freeAll() public auth {\\n        chief.free(chief.deposits(address(this)));\\n        gov.push(cold, gov.balanceOf(address(this)));\\n    }\\n\\n    function vote(address[] memory yays) public auth returns (bytes32) {\\n        return chief.vote(yays);\\n    }\\n\\n    function vote(bytes32 slate) public auth {\\n        chief.vote(slate);\\n    }\\n}\"\r\n    },\r\n    \"./contracts/flop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// flop.sol -- Debt auction\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ninterface VatLike {\\r\\n    function move(address,address,uint) external;\\r\\n    function suck(address,address,uint) external;\\r\\n}\\r\\ninterface GemLike {\\r\\n    function mint(address,uint) external;\\r\\n}\\r\\ninterface VowLike {\\r\\n    function Ash() external returns (uint);\\r\\n    function kiss(uint) external;\\r\\n}\\r\\n\\r\\n/*\\r\\n   This thing creates gems on demand in return for USB.\\r\\n\\r\\n - `lot` gems in return for bid\\r\\n - `bid` USB paid\\r\\n - `gal` receives USB income\\r\\n - `ttl` single bid lifetime\\r\\n - `beg` minimum bid increase\\r\\n - `end` max auction duration\\r\\n*/\\r\\n\\r\\ncontract Flopper {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address usr) external auth { wards[usr] = 1; }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"Flopper/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    struct Bid {\\r\\n        uint256 bid;  // USB paid                [rad]\\r\\n        uint256 lot;  // gems in return for bid  [wad]\\r\\n        address guy;  // high bidder\\r\\n        uint48  tic;  // bid expiry time         [unix epoch time]\\r\\n        uint48  end;  // auction expiry time     [unix epoch time]\\r\\n    }\\r\\n\\r\\n    mapping (uint => Bid) public bids;\\r\\n\\r\\n    VatLike  public   vat;  // CDP Engine\\r\\n    GemLike  public   gem;\\r\\n\\r\\n    uint256  constant ONE = 1.00E18;\\r\\n    uint256  public   beg = 1.05E18;  // 5% minimum bid increase\\r\\n    uint256  public   pad = 1.50E18;  // 50% lot increase for tick\\r\\n    uint48   public   ttl = 3 hours;  // 3 hours bid lifetime         [seconds]\\r\\n    uint48   public   tau = 2 days;   // 2 days total auction length  [seconds]\\r\\n    uint256  public kicks = 0;\\r\\n    uint256  public live;             // Active Flag\\r\\n    address  public vow;              // not used until shutdown\\r\\n\\r\\n    // --- Events ---\\r\\n    event Kick(\\r\\n      uint256 id,\\r\\n      uint256 lot,\\r\\n      uint256 bid,\\r\\n      address indexed gal\\r\\n    );\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address vat_, address gem_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        vat = VatLike(vat_);\\r\\n        gem = GemLike(gem_);\\r\\n        live = 1;\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n    function min(uint x, uint y) internal pure returns (uint z) {\\r\\n        if (x > y) { z = y; } else { z = x; }\\r\\n    }\\r\\n\\r\\n    // --- Admin ---\\r\\n    function file(bytes32 what, uint data) external auth {\\r\\n        if (what == \\\"beg\\\") beg = data;\\r\\n        else if (what == \\\"pad\\\") pad = data;\\r\\n        else if (what == \\\"ttl\\\") ttl = uint48(data);\\r\\n        else if (what == \\\"tau\\\") tau = uint48(data);\\r\\n        else revert(\\\"Flopper/file-unrecognized-param\\\");\\r\\n    }\\r\\n\\r\\n    // --- Auction ---\\r\\n    function kick(address gal, uint lot, uint bid) external auth returns (uint id) {\\r\\n        require(live == 1, \\\"Flopper/not-live\\\");\\r\\n        require(kicks < type(uint256).max, \\\"Flopper/overflow\\\");\\r\\n        id = ++kicks;\\r\\n\\r\\n        bids[id].bid = bid;\\r\\n        bids[id].lot = lot;\\r\\n        bids[id].guy = gal;\\r\\n        bids[id].end = add(uint48(block.timestamp), tau);\\r\\n\\r\\n        emit Kick(id, lot, bid, gal);\\r\\n    }\\r\\n    function tick(uint id) external {\\r\\n        require(bids[id].end < block.timestamp, \\\"Flopper/not-finished\\\");\\r\\n        require(bids[id].tic == 0, \\\"Flopper/bid-already-placed\\\");\\r\\n        bids[id].lot = mul(pad, bids[id].lot) / ONE;\\r\\n        bids[id].end = add(uint48(block.timestamp), tau);\\r\\n    }\\r\\n    function dent(uint id, uint lot, uint bid) external {\\r\\n        require(live == 1, \\\"Flopper/not-live\\\");\\r\\n        require(bids[id].guy != address(0), \\\"Flopper/guy-not-set\\\");\\r\\n        require(bids[id].tic > block.timestamp || bids[id].tic == 0, \\\"Flopper/already-finished-tic\\\");\\r\\n        require(bids[id].end > block.timestamp, \\\"Flopper/already-finished-end\\\");\\r\\n\\r\\n        require(bid == bids[id].bid, \\\"Flopper/not-matching-bid\\\");\\r\\n        require(lot <  bids[id].lot, \\\"Flopper/lot-not-lower\\\");\\r\\n        require(mul(beg, lot) <= mul(bids[id].lot, ONE), \\\"Flopper/insufficient-decrease\\\");\\r\\n\\r\\n        if (msg.sender != bids[id].guy) {\\r\\n            vat.move(msg.sender, bids[id].guy, bid);\\r\\n\\r\\n            // on first dent, clear as much Ash as possible\\r\\n            if (bids[id].tic == 0) {\\r\\n                uint Ash = VowLike(bids[id].guy).Ash();\\r\\n                VowLike(bids[id].guy).kiss(min(bid, Ash));\\r\\n            }\\r\\n\\r\\n            bids[id].guy = msg.sender;\\r\\n        }\\r\\n\\r\\n        bids[id].lot = lot;\\r\\n        bids[id].tic = add(uint48(block.timestamp), ttl);\\r\\n    }\\r\\n    function deal(uint id) external {\\r\\n        require(live == 1, \\\"Flopper/not-live\\\");\\r\\n        require(bids[id].tic != 0 && (bids[id].tic < block.timestamp || bids[id].end < block.timestamp), \\\"Flopper/not-finished\\\");\\r\\n        gem.mint(bids[id].guy, bids[id].lot);\\r\\n        delete bids[id];\\r\\n    }\\r\\n\\r\\n    // --- Shutdown ---\\r\\n    function cage() external auth {\\r\\n       live = 0;\\r\\n       vow = msg.sender;\\r\\n    }\\r\\n    function yank(uint id) external {\\r\\n        require(live == 0, \\\"Flopper/still-live\\\");\\r\\n        require(bids[id].guy != address(0), \\\"Flopper/guy-not-set\\\");\\r\\n        vat.suck(vow, bids[id].guy, bids[id].bid);\\r\\n        delete bids[id];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/cat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// cat.sol -- USB liquidation module\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ninterface Kicker {\\r\\n    function kick(address urn, address gal, uint256 tab, uint256 lot, uint256 bid)\\r\\n        external returns (uint256);\\r\\n}\\r\\n\\r\\ninterface VatLike {\\r\\n    function ilks(bytes32) external view returns (\\r\\n        uint256 Art,  // [wad]\\r\\n        uint256 rate, // [ray]\\r\\n        uint256 spot, // [ray]\\r\\n        uint256 line, // [rad]\\r\\n        uint256 dust  // [rad]\\r\\n    );\\r\\n    function urns(bytes32,address) external view returns (\\r\\n        uint256 ink,  // [wad]\\r\\n        uint256 art   // [wad]\\r\\n    );\\r\\n    function grab(bytes32,address,address,address,int256,int256) external;\\r\\n    function hope(address) external;\\r\\n    function nope(address) external;\\r\\n}\\r\\n\\r\\ninterface VowLike {\\r\\n    function fess(uint256) external;\\r\\n}\\r\\n\\r\\ncontract Cat {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint256) public wards;\\r\\n    function rely(address usr) external auth { wards[usr] = 1; }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"Cat/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    struct Ilk {\\r\\n        address flip;  // Liquidator\\r\\n        uint256 chop;  // Liquidation Penalty  [wad]\\r\\n        uint256 dunk;  // Liquidation Quantity [rad]\\r\\n    }\\r\\n\\r\\n    mapping (bytes32 => Ilk) public ilks;\\r\\n\\r\\n    uint256 public live;   // Active Flag\\r\\n    VatLike public vat;    // CDP Engine\\r\\n    VowLike public vow;    // Debt Engine\\r\\n    uint256 public box;    // Max USB out for liquidation        [rad]\\r\\n    uint256 public litter; // Balance of USB out for liquidation [rad]\\r\\n\\r\\n    // --- Events ---\\r\\n    event Bite(\\r\\n      bytes32 indexed ilk,\\r\\n      address indexed urn,\\r\\n      uint256 ink,\\r\\n      uint256 art,\\r\\n      uint256 tab,\\r\\n      address flip,\\r\\n      uint256 id\\r\\n    );\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address vat_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        vat = VatLike(vat_);\\r\\n        live = 1;\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    uint256 constant WAD = 10 ** 18;\\r\\n\\r\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        if (x > y) { z = y; } else { z = x; }\\r\\n    }\\r\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x - y) <= x);\\r\\n    }\\r\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n\\r\\n    // --- Administration ---\\r\\n    function file(bytes32 what, address data) external auth {\\r\\n        if (what == \\\"vow\\\") vow = VowLike(data);\\r\\n        else revert(\\\"Cat/file-unrecognized-param\\\");\\r\\n    }\\r\\n    function file(bytes32 what, uint256 data) external auth {\\r\\n        if (what == \\\"box\\\") box = data;\\r\\n        else revert(\\\"Cat/file-unrecognized-param\\\");\\r\\n    }\\r\\n    function file(bytes32 ilk, bytes32 what, uint256 data) external auth {\\r\\n        if (what == \\\"chop\\\") ilks[ilk].chop = data;\\r\\n        else if (what == \\\"dunk\\\") ilks[ilk].dunk = data;\\r\\n        else revert(\\\"Cat/file-unrecognized-param\\\");\\r\\n    }\\r\\n    function file(bytes32 ilk, bytes32 what, address flip) external auth {\\r\\n        if (what == \\\"flip\\\") {\\r\\n            vat.nope(ilks[ilk].flip);\\r\\n            ilks[ilk].flip = flip;\\r\\n            vat.hope(flip);\\r\\n        }\\r\\n        else revert(\\\"Cat/file-unrecognized-param\\\");\\r\\n    }\\r\\n\\r\\n    // --- CDP Liquidation ---\\r\\n    function bite(bytes32 ilk, address urn) external returns (uint256 id) {\\r\\n        (,uint256 rate,uint256 spot,,uint256 dust) = vat.ilks(ilk);\\r\\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\\r\\n\\r\\n        require(live == 1, \\\"Cat/not-live\\\");\\r\\n        require(spot > 0 && mul(ink, spot) < mul(art, rate), \\\"Cat/not-unsafe\\\");\\r\\n\\r\\n        Ilk memory milk = ilks[ilk];\\r\\n        uint256 dart;\\r\\n        {\\r\\n            uint256 room = sub(box, litter);\\r\\n\\r\\n            // test whether the remaining space in the litterbox is dusty\\r\\n            require(litter < box && room >= dust, \\\"Cat/liquidation-limit-hit\\\");\\r\\n\\r\\n            dart = min(art, mul(min(milk.dunk, room), WAD) / rate / milk.chop);\\r\\n        }\\r\\n\\r\\n        uint256 dink = min(ink, mul(ink, dart) / art);\\r\\n\\r\\n        require(dart >  0      && dink >  0     , \\\"Cat/null-auction\\\");\\r\\n        require(dart <= 2**255 && dink <= 2**255, \\\"Cat/overflow\\\"    );\\r\\n\\r\\n        // This may leave the CDP in a dusty state\\r\\n        vat.grab(\\r\\n            ilk, urn, address(this), address(vow), -int256(dink), -int256(dart)\\r\\n        );\\r\\n        vow.fess(mul(dart, rate));\\r\\n\\r\\n        { // Avoid stack too deep\\r\\n            // This calcuation will overflow if dart*rate exceeds ~10^14,\\r\\n            // i.e. the maximum dunk is roughly 100 trillion USB.\\r\\n            uint256 tab = mul(mul(dart, rate), milk.chop) / WAD;\\r\\n            litter = add(litter, tab);\\r\\n\\r\\n            id = Kicker(milk.flip).kick({\\r\\n                urn: urn,\\r\\n                gal: address(vow),\\r\\n                tab: tab,\\r\\n                lot: dink,\\r\\n                bid: 0\\r\\n            });\\r\\n        }\\r\\n\\r\\n        emit Bite(ilk, urn, dink, dart, mul(dart, rate), milk.flip, id);\\r\\n    }\\r\\n\\r\\n    function claw(uint256 rad) external auth {\\r\\n        litter = sub(litter, rad);\\r\\n    }\\r\\n\\r\\n    function cage() external auth {\\r\\n        live = 0;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/vow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// vow.sol -- USB settlement module\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ninterface FlopLike {\\r\\n    function kick(address gal, uint lot, uint bid) external returns (uint);\\r\\n    function cage() external;\\r\\n    function live() external returns (uint);\\r\\n}\\r\\n\\r\\ninterface FlapLike {\\r\\n    function kick(uint lot, uint bid) external returns (uint);\\r\\n    function cage(uint) external;\\r\\n    function live() external returns (uint);\\r\\n}\\r\\n\\r\\ninterface VatLike {\\r\\n    function USB (address) external view returns (uint);\\r\\n    function sin (address) external view returns (uint);\\r\\n    function heal(uint256) external;\\r\\n    function hope(address) external;\\r\\n    function nope(address) external;\\r\\n}\\r\\n\\r\\ncontract Vow {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address usr) external auth { require(live == 1, \\\"Vow/not-live\\\"); wards[usr] = 1; }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"Vow/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    VatLike public vat;        // CDP Engine\\r\\n    FlapLike public flapper;   // Surplus Auction House\\r\\n    FlopLike public flopper;   // Debt Auction House\\r\\n\\r\\n    mapping (uint256 => uint256) public sin;  // debt queue\\r\\n    uint256 public Sin;   // Queued debt            [rad]\\r\\n    uint256 public Ash;   // On-auction debt        [rad]\\r\\n\\r\\n    uint256 public wait;  // Flop delay             [seconds]\\r\\n    uint256 public dump;  // Flop initial lot size  [wad]\\r\\n    uint256 public sump;  // Flop fixed bid size    [rad]\\r\\n\\r\\n    uint256 public bump;  // Flap fixed lot size    [rad]\\r\\n    uint256 public hump;  // Surplus buffer         [rad]\\r\\n\\r\\n    uint256 public live;  // Active Flag\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address vat_, address flapper_, address flopper_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        vat     = VatLike(vat_);\\r\\n        flapper = FlapLike(flapper_);\\r\\n        flopper = FlopLike(flopper_);\\r\\n        vat.hope(flapper_);\\r\\n        live = 1;\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x);\\r\\n    }\\r\\n    function min(uint x, uint y) internal pure returns (uint z) {\\r\\n        return x <= y ? x : y;\\r\\n    }\\r\\n\\r\\n    // --- Administration ---\\r\\n    function file(bytes32 what, uint data) external auth {\\r\\n        if (what == \\\"wait\\\") wait = data;\\r\\n        else if (what == \\\"bump\\\") bump = data;\\r\\n        else if (what == \\\"sump\\\") sump = data;\\r\\n        else if (what == \\\"dump\\\") dump = data;\\r\\n        else if (what == \\\"hump\\\") hump = data;\\r\\n        else revert(\\\"Vow/file-unrecognized-param\\\");\\r\\n    }\\r\\n\\r\\n    function file(bytes32 what, address data) external auth {\\r\\n        if (what == \\\"flapper\\\") {\\r\\n            vat.nope(address(flapper));\\r\\n            flapper = FlapLike(data);\\r\\n            vat.hope(data);\\r\\n        }\\r\\n        else if (what == \\\"flopper\\\") flopper = FlopLike(data);\\r\\n        else revert(\\\"Vow/file-unrecognized-param\\\");\\r\\n    }\\r\\n\\r\\n    // Push to debt-queue\\r\\n    function fess(uint tab) external auth {\\r\\n        sin[block.timestamp] = add(sin[block.timestamp], tab);\\r\\n        Sin = add(Sin, tab);\\r\\n    }\\r\\n    // Pop from debt-queue\\r\\n    function flog(uint era) external {\\r\\n        require(add(era, wait) <= block.timestamp, \\\"Vow/wait-not-finished\\\");\\r\\n        Sin = sub(Sin, sin[era]);\\r\\n        sin[era] = 0;\\r\\n    }\\r\\n\\r\\n    // Debt settlement\\r\\n    function heal(uint rad) external {\\r\\n        require(rad <= vat.USB(address(this)), \\\"Vow/insufficient-surplus\\\");\\r\\n        require(rad <= sub(sub(vat.sin(address(this)), Sin), Ash), \\\"Vow/insufficient-debt\\\");\\r\\n        vat.heal(rad);\\r\\n    }\\r\\n    function kiss(uint rad) external {\\r\\n        require(rad <= Ash, \\\"Vow/not-enough-ash\\\");\\r\\n        require(rad <= vat.USB(address(this)), \\\"Vow/insufficient-surplus\\\");\\r\\n        Ash = sub(Ash, rad);\\r\\n        vat.heal(rad);\\r\\n    }\\r\\n\\r\\n    // Debt auction\\r\\n    function flop() external returns (uint id) {\\r\\n        require(sump <= sub(sub(vat.sin(address(this)), Sin), Ash), \\\"Vow/insufficient-debt\\\");\\r\\n        require(vat.USB(address(this)) == 0, \\\"Vow/surplus-not-zero\\\");\\r\\n        Ash = add(Ash, sump);\\r\\n        id = flopper.kick(address(this), dump, sump);\\r\\n    }\\r\\n    // Surplus auction\\r\\n    function flap() external returns (uint id) {\\r\\n        require(vat.USB(address(this)) >= add(add(vat.sin(address(this)), bump), hump), \\\"Vow/insufficient-surplus\\\");\\r\\n        require(sub(sub(vat.sin(address(this)), Sin), Ash) == 0, \\\"Vow/debt-not-zero\\\");\\r\\n        id = flapper.kick(bump, 0);\\r\\n    }\\r\\n\\r\\n    function cage() external auth {\\r\\n        require(live == 1, \\\"Vow/not-live\\\");\\r\\n        live = 0;\\r\\n        Sin = 0;\\r\\n        Ash = 0;\\r\\n        flapper.cage(vat.USB(address(flapper)));\\r\\n        flopper.cage();\\r\\n        vat.heal(min(vat.USB(address(this)), vat.sin(address(this))));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/end.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// end.sol -- global settlement engine\\r\\n\\r\\n\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface VatLike {\\r\\n    function dai(address) external view returns (uint256);\\r\\n    function ilks(bytes32 ilk) external returns (\\r\\n        uint256 Art,   // [wad]\\r\\n        uint256 rate,  // [ray]\\r\\n        uint256 spot,  // [ray]\\r\\n        uint256 line,  // [rad]\\r\\n        uint256 dust   // [rad]\\r\\n    );\\r\\n    function urns(bytes32 ilk, address urn) external returns (\\r\\n        uint256 ink,   // [wad]\\r\\n        uint256 art    // [wad]\\r\\n    );\\r\\n    function debt() external returns (uint256);\\r\\n    function move(address src, address dst, uint256 rad) external;\\r\\n    function hope(address) external;\\r\\n    function flux(bytes32 ilk, address src, address dst, uint256 rad) external;\\r\\n    function grab(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external;\\r\\n    function suck(address u, address v, uint256 rad) external;\\r\\n    function cage() external;\\r\\n}\\r\\n\\r\\ninterface CatLike {\\r\\n    function ilks(bytes32) external returns (\\r\\n        address flip,\\r\\n        uint256 chop,  // [ray]\\r\\n        uint256 lump   // [rad]\\r\\n    );\\r\\n    function cage() external;\\r\\n}\\r\\n\\r\\ninterface DogLike {\\r\\n    function ilks(bytes32) external returns (\\r\\n        address clip,\\r\\n        uint256 chop,\\r\\n        uint256 hole,\\r\\n        uint256 dirt\\r\\n    );\\r\\n    function cage() external;\\r\\n}\\r\\n\\r\\ninterface PotLike {\\r\\n    function cage() external;\\r\\n}\\r\\n\\r\\ninterface VowLike {\\r\\n    function cage() external;\\r\\n}\\r\\n\\r\\ninterface FlipLike {\\r\\n    function bids(uint256 id) external view returns (\\r\\n        uint256 bid,   // [rad]\\r\\n        uint256 lot,   // [wad]\\r\\n        address guy,\\r\\n        uint48  tic,   // [unix epoch time]\\r\\n        uint48  end,   // [unix epoch time]\\r\\n        address usr,\\r\\n        address gal,\\r\\n        uint256 tab    // [rad]\\r\\n    );\\r\\n    function yank(uint256 id) external;\\r\\n}\\r\\n\\r\\ninterface ClipLike {\\r\\n    function sales(uint256 id) external view returns (\\r\\n        uint256 pos,\\r\\n        uint256 tab,\\r\\n        uint256 lot,\\r\\n        address usr,\\r\\n        uint96  tic,\\r\\n        uint256 top\\r\\n    );\\r\\n    function yank(uint256 id) external;\\r\\n}\\r\\n\\r\\ninterface PipLike {\\r\\n    function read() external view returns (bytes32);\\r\\n}\\r\\n\\r\\ninterface SpotLike {\\r\\n    function par() external view returns (uint256);\\r\\n    function ilks(bytes32) external view returns (\\r\\n        PipLike pip,\\r\\n        uint256 mat    // [ray]\\r\\n    );\\r\\n    function cage() external;\\r\\n}\\r\\n\\r\\n/*\\r\\n    This is the `End` and it coordinates Global Settlement. This is an\\r\\n    involved, stateful process that takes place over nine steps.\\r\\n\\r\\n    First we freeze the system and lock the prices for each ilk.\\r\\n\\r\\n    1. `cage()`:\\r\\n        - freezes user entrypoints\\r\\n        - cancels flop/flap auctions\\r\\n        - starts cooldown period\\r\\n        - stops pot drips\\r\\n\\r\\n    2. `cage(ilk)`:\\r\\n       - set the cage price for each `ilk`, reading off the price feed\\r\\n\\r\\n    We must process some system state before it is possible to calculate\\r\\n    the final dai / collateral price. In particular, we need to determine\\r\\n\\r\\n      a. `gap`, the collateral shortfall per collateral type by\\r\\n         considering under-collateralised CDPs.\\r\\n\\r\\n      b. `debt`, the outstanding dai supply after including system\\r\\n         surplus / deficit\\r\\n\\r\\n    We determine (a) by processing all under-collateralised CDPs with\\r\\n    `skim`:\\r\\n\\r\\n    3. `skim(ilk, urn)`:\\r\\n       - cancels CDP debt\\r\\n       - any excess collateral remains\\r\\n       - backing collateral taken\\r\\n\\r\\n    We determine (b) by processing ongoing dai generating processes,\\r\\n    i.e. auctions. We need to ensure that auctions will not generate any\\r\\n    further dai income.\\r\\n\\r\\n    In the two-way auction model (Flipper) this occurs when\\r\\n    all auctions are in the reverse (`dent`) phase. There are two ways\\r\\n    of ensuring this:\\r\\n\\r\\n    4a. i) `wait`: set the cooldown period to be at least as long as the\\r\\n           longest auction duration, which needs to be determined by the\\r\\n           cage administrator.\\r\\n\\r\\n           This takes a fairly predictable time to occur but with altered\\r\\n           auction dynamics due to the now varying price of dai.\\r\\n\\r\\n       ii) `skip`: cancel all ongoing auctions and seize the collateral.\\r\\n\\r\\n           This allows for faster processing at the expense of more\\r\\n           processing calls. This option allows dai holders to retrieve\\r\\n           their collateral faster.\\r\\n\\r\\n           `skip(ilk, id)`:\\r\\n            - cancel individual flip auctions in the `tend` (forward) phase\\r\\n            - retrieves collateral and debt (including penalty) to owner's CDP\\r\\n            - returns dai to last bidder\\r\\n            - `dent` (reverse) phase auctions can continue normally\\r\\n\\r\\n    Option (i), `wait`, is sufficient (if all auctions were bidded at least\\r\\n    once) for processing the system settlement but option (ii), `skip`,\\r\\n    will speed it up. Both options are available in this implementation,\\r\\n    with `skip` being enabled on a per-auction basis.\\r\\n\\r\\n    In the case of the Dutch Auctions model (Clipper) they keep recovering\\r\\n    debt during the whole lifetime and there isn't a max duration time\\r\\n    guaranteed for the auction to end.\\r\\n    So the way to ensure the protocol will not receive extra dai income is:\\r\\n\\r\\n    4b. i) `snip`: cancel all ongoing auctions and seize the collateral.\\r\\n\\r\\n           `snip(ilk, id)`:\\r\\n            - cancel individual running clip auctions\\r\\n            - retrieves remaining collateral and debt (including penalty)\\r\\n              to owner's CDP\\r\\n\\r\\n    When a CDP has been processed and has no debt remaining, the\\r\\n    remaining collateral can be removed.\\r\\n\\r\\n    5. `free(ilk)`:\\r\\n        - remove collateral from the caller's CDP\\r\\n        - owner can call as needed\\r\\n\\r\\n    After the processing period has elapsed, we enable calculation of\\r\\n    the final price for each collateral type.\\r\\n\\r\\n    6. `thaw()`:\\r\\n       - only callable after processing time period elapsed\\r\\n       - assumption that all under-collateralised CDPs are processed\\r\\n       - fixes the total outstanding supply of dai\\r\\n       - may also require extra CDP processing to cover vow surplus\\r\\n\\r\\n    7. `flow(ilk)`:\\r\\n        - calculate the `fix`, the cash price for a given ilk\\r\\n        - adjusts the `fix` in the case of deficit / surplus\\r\\n\\r\\n    At this point we have computed the final price for each collateral\\r\\n    type and dai holders can now turn their dai into collateral. Each\\r\\n    unit dai can claim a fixed basket of collateral.\\r\\n\\r\\n    Dai holders must first `pack` some dai into a `bag`. Once packed,\\r\\n    dai cannot be unpacked and is not transferrable. More dai can be\\r\\n    added to a bag later.\\r\\n\\r\\n    8. `pack(wad)`:\\r\\n        - put some dai into a bag in preparation for `cash`\\r\\n\\r\\n    Finally, collateral can be obtained with `cash`. The bigger the bag,\\r\\n    the more collateral can be released.\\r\\n\\r\\n    9. `cash(ilk, wad)`:\\r\\n        - exchange some dai from your bag for gems from a specific ilk\\r\\n        - the number of gems is limited by how big your bag is\\r\\n*/\\r\\n\\r\\ncontract End {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint256) public wards;\\r\\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"End/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    VatLike  public vat;   // CDP Engine\\r\\n    CatLike  public cat;\\r\\n    DogLike  public dog;\\r\\n    VowLike  public vow;   // Debt Engine\\r\\n    PotLike  public pot;\\r\\n    SpotLike public spot;\\r\\n\\r\\n    uint256  public live;  // Active Flag\\r\\n    uint256  public when;  // Time of cage                   [unix epoch time]\\r\\n    uint256  public wait;  // Processing Cooldown Length             [seconds]\\r\\n    uint256  public debt;  // Total outstanding dai following processing [rad]\\r\\n\\r\\n    mapping (bytes32 => uint256) public tag;  // Cage price              [ray]\\r\\n    mapping (bytes32 => uint256) public gap;  // Collateral shortfall    [wad]\\r\\n    mapping (bytes32 => uint256) public Art;  // Total debt per ilk      [wad]\\r\\n    mapping (bytes32 => uint256) public fix;  // Final cash price        [ray]\\r\\n\\r\\n    mapping (address => uint256)                      public bag;  //    [wad]\\r\\n    mapping (bytes32 => mapping (address => uint256)) public out;  //    [wad]\\r\\n\\r\\n    // --- Events ---\\r\\n    event Rely(address indexed usr);\\r\\n    event Deny(address indexed usr);\\r\\n\\r\\n    event File(bytes32 indexed what, uint256 data);\\r\\n    event File(bytes32 indexed what, address data);\\r\\n\\r\\n    event Cage();\\r\\n    event Cage(bytes32 indexed ilk);\\r\\n    event Snip(bytes32 indexed ilk, uint256 indexed id, address indexed usr, uint256 tab, uint256 lot, uint256 art);\\r\\n    event Skip(bytes32 indexed ilk, uint256 indexed id, address indexed usr, uint256 tab, uint256 lot, uint256 art);\\r\\n    event Skim(bytes32 indexed ilk, address indexed urn, uint256 wad, uint256 art);\\r\\n    event Free(bytes32 indexed ilk, address indexed usr, uint256 ink);\\r\\n    event Thaw();\\r\\n    event Flow(bytes32 indexed ilk);\\r\\n    event Pack(address indexed usr, uint256 wad);\\r\\n    event Cash(bytes32 indexed ilk, address indexed usr, uint256 wad);\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor() public {\\r\\n        wards[msg.sender] = 1;\\r\\n        live = 1;\\r\\n        emit Rely(msg.sender);\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    uint256 constant WAD = 10 ** 18;\\r\\n    uint256 constant RAY = 10 ** 27;\\r\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = x + y;\\r\\n        require(z >= x);\\r\\n    }\\r\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x - y) <= x);\\r\\n    }\\r\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        return x <= y ? x : y;\\r\\n    }\\r\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = mul(x, y) / RAY;\\r\\n    }\\r\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = mul(x, WAD) / y;\\r\\n    }\\r\\n\\r\\n    // --- Administration ---\\r\\n    function file(bytes32 what, address data) external auth {\\r\\n        require(live == 1, \\\"End/not-live\\\");\\r\\n        if (what == \\\"vat\\\")  vat = VatLike(data);\\r\\n        else if (what == \\\"cat\\\")   cat = CatLike(data);\\r\\n        else if (what == \\\"dog\\\")   dog = DogLike(data);\\r\\n        else if (what == \\\"vow\\\")   vow = VowLike(data);\\r\\n        else if (what == \\\"pot\\\")   pot = PotLike(data);\\r\\n        else if (what == \\\"spot\\\") spot = SpotLike(data);\\r\\n        else revert(\\\"End/file-unrecognized-param\\\");\\r\\n        emit File(what, data);\\r\\n    }\\r\\n    function file(bytes32 what, uint256 data) external auth {\\r\\n        require(live == 1, \\\"End/not-live\\\");\\r\\n        if (what == \\\"wait\\\") wait = data;\\r\\n        else revert(\\\"End/file-unrecognized-param\\\");\\r\\n        emit File(what, data);\\r\\n    }\\r\\n\\r\\n    // --- Settlement ---\\r\\n    function cage() external auth {\\r\\n        require(live == 1, \\\"End/not-live\\\");\\r\\n        live = 0;\\r\\n        when = block.timestamp;\\r\\n        vat.cage();\\r\\n        cat.cage();\\r\\n        dog.cage();\\r\\n        vow.cage();\\r\\n        spot.cage();\\r\\n        pot.cage();\\r\\n        emit Cage();\\r\\n    }\\r\\n\\r\\n    function cage(bytes32 ilk) external {\\r\\n        require(live == 0, \\\"End/still-live\\\");\\r\\n        require(tag[ilk] == 0, \\\"End/tag-ilk-already-defined\\\");\\r\\n        (Art[ilk],,,,) = vat.ilks(ilk);\\r\\n        (PipLike pip,) = spot.ilks(ilk);\\r\\n        // par is a ray, pip returns a wad\\r\\n        tag[ilk] = wdiv(spot.par(), uint256(pip.read()));\\r\\n        emit Cage(ilk);\\r\\n    }\\r\\n\\r\\n    function snip(bytes32 ilk, uint256 id) external {\\r\\n        require(tag[ilk] != 0, \\\"End/tag-ilk-not-defined\\\");\\r\\n\\r\\n        (address _clip,,,) = dog.ilks(ilk);\\r\\n        ClipLike clip = ClipLike(_clip);\\r\\n        (, uint256 rate,,,) = vat.ilks(ilk);\\r\\n        (, uint256 tab, uint256 lot, address usr,,) = clip.sales(id);\\r\\n\\r\\n        vat.suck(address(vow), address(vow),  tab);\\r\\n        clip.yank(id);\\r\\n\\r\\n        uint256 art = tab / rate;\\r\\n        Art[ilk] = add(Art[ilk], art);\\r\\n        require(int256(lot) >= 0 && int256(art) >= 0, \\\"End/overflow\\\");\\r\\n        vat.grab(ilk, usr, address(this), address(vow), int256(lot), int256(art));\\r\\n        emit Snip(ilk, id, usr, tab, lot, art);\\r\\n    }\\r\\n\\r\\n    function skip(bytes32 ilk, uint256 id) external {\\r\\n        require(tag[ilk] != 0, \\\"End/tag-ilk-not-defined\\\");\\r\\n\\r\\n        (address _flip,,) = cat.ilks(ilk);\\r\\n        FlipLike flip = FlipLike(_flip);\\r\\n        (, uint256 rate,,,) = vat.ilks(ilk);\\r\\n        (uint256 bid, uint256 lot,,,, address usr,, uint256 tab) = flip.bids(id);\\r\\n\\r\\n        vat.suck(address(vow), address(vow),  tab);\\r\\n        vat.suck(address(vow), address(this), bid);\\r\\n        vat.hope(address(flip));\\r\\n        flip.yank(id);\\r\\n\\r\\n        uint256 art = tab / rate;\\r\\n        Art[ilk] = add(Art[ilk], art);\\r\\n        require(int256(lot) >= 0 && int256(art) >= 0, \\\"End/overflow\\\");\\r\\n        vat.grab(ilk, usr, address(this), address(vow), int256(lot), int256(art));\\r\\n        emit Skip(ilk, id, usr, tab, lot, art);\\r\\n    }\\r\\n\\r\\n    function skim(bytes32 ilk, address urn) external {\\r\\n        require(tag[ilk] != 0, \\\"End/tag-ilk-not-defined\\\");\\r\\n        (, uint256 rate,,,) = vat.ilks(ilk);\\r\\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\\r\\n\\r\\n        uint256 owe = rmul(rmul(art, rate), tag[ilk]);\\r\\n        uint256 wad = min(ink, owe);\\r\\n        gap[ilk] = add(gap[ilk], sub(owe, wad));\\r\\n\\r\\n        require(wad <= 2**255 && art <= 2**255, \\\"End/overflow\\\");\\r\\n        vat.grab(ilk, urn, address(this), address(vow), -int256(wad), -int256(art));\\r\\n        emit Skim(ilk, urn, wad, art);\\r\\n    }\\r\\n\\r\\n    function free(bytes32 ilk) external {\\r\\n        require(live == 0, \\\"End/still-live\\\");\\r\\n        (uint256 ink, uint256 art) = vat.urns(ilk, msg.sender);\\r\\n        require(art == 0, \\\"End/art-not-zero\\\");\\r\\n        require(ink <= 2**255, \\\"End/overflow\\\");\\r\\n        vat.grab(ilk, msg.sender, msg.sender, address(vow), -int256(ink), 0);\\r\\n        emit Free(ilk, msg.sender, ink);\\r\\n    }\\r\\n\\r\\n    function thaw() external {\\r\\n        require(live == 0, \\\"End/still-live\\\");\\r\\n        require(debt == 0, \\\"End/debt-not-zero\\\");\\r\\n        require(vat.dai(address(vow)) == 0, \\\"End/surplus-not-zero\\\");\\r\\n        require(block.timestamp >= add(when, wait), \\\"End/wait-not-finished\\\");\\r\\n        debt = vat.debt();\\r\\n        emit Thaw();\\r\\n    }\\r\\n    function flow(bytes32 ilk) external {\\r\\n        require(debt != 0, \\\"End/debt-zero\\\");\\r\\n        require(fix[ilk] == 0, \\\"End/fix-ilk-already-defined\\\");\\r\\n\\r\\n        (, uint256 rate,,,) = vat.ilks(ilk);\\r\\n        uint256 wad = rmul(rmul(Art[ilk], rate), tag[ilk]);\\r\\n        fix[ilk] = mul(sub(wad, gap[ilk]), RAY) / (debt / RAY);\\r\\n        emit Flow(ilk);\\r\\n    }\\r\\n\\r\\n    function pack(uint256 wad) external {\\r\\n        require(debt != 0, \\\"End/debt-zero\\\");\\r\\n        vat.move(msg.sender, address(vow), mul(wad, RAY));\\r\\n        bag[msg.sender] = add(bag[msg.sender], wad);\\r\\n        emit Pack(msg.sender, wad);\\r\\n    }\\r\\n    function cash(bytes32 ilk, uint256 wad) external {\\r\\n        require(fix[ilk] != 0, \\\"End/fix-ilk-not-defined\\\");\\r\\n        vat.flux(ilk, address(this), msg.sender, rmul(wad, fix[ilk]));\\r\\n        out[ilk][msg.sender] = add(out[ilk][msg.sender], wad);\\r\\n        require(out[ilk][msg.sender] <= bag[msg.sender], \\\"End/insufficient-bag-balance\\\");\\r\\n        emit Cash(ilk, msg.sender, wad);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/DsrManager.sol\": {\r\n      \"content\": \"// DsrManager.sol\\r\\n\\r\\n\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface VatLike {\\r\\n    function hope(address) external;\\r\\n}\\r\\n\\r\\ninterface PotLike {\\r\\n    function vat() external view returns (address);\\r\\n    function chi() external view returns (uint256);\\r\\n    function rho() external view returns (uint256);\\r\\n    function drip() external returns (uint256);\\r\\n    function join(uint256) external;\\r\\n    function exit(uint256) external;\\r\\n}\\r\\n\\r\\ninterface JoinLike {\\r\\n    function USB() external view returns (address);\\r\\n    function join(address, uint256) external;\\r\\n    function exit(address, uint256) external;\\r\\n}\\r\\n\\r\\ninterface GemLike {\\r\\n    function transferFrom(address,address,uint256) external returns (bool);\\r\\n    function approve(address,uint256) external returns (bool);\\r\\n}\\r\\n\\r\\ncontract DsrManager {\\r\\n    PotLike  public pot;\\r\\n    GemLike  public USB;\\r\\n    JoinLike public USBJoin;\\r\\n\\r\\n    uint256 public supply;\\r\\n\\r\\n    mapping (address => uint256) public pieOf;\\r\\n\\r\\n    event Join(address indexed dst, uint256 wad);\\r\\n    event Exit(address indexed dst, uint256 wad);\\r\\n\\r\\n    uint256 constant RAY = 10 ** 27;\\r\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x - y) <= x);\\r\\n    }\\r\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        // always rounds down\\r\\n        z = mul(x, y) / RAY;\\r\\n    }\\r\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        // always rounds down\\r\\n        z = mul(x, RAY) / y;\\r\\n    }\\r\\n    function rdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        // always rounds up\\r\\n        z = add(mul(x, RAY), sub(y, 1)) / y;\\r\\n    }\\r\\n\\r\\n    constructor(address pot_, address USBJoin_) public {\\r\\n        pot = PotLike(pot_);\\r\\n        USBJoin = JoinLike(USBJoin_);\\r\\n        USB = GemLike(USBJoin.USB());\\r\\n\\r\\n        VatLike vat = VatLike(pot.vat());\\r\\n        vat.hope(address(USBJoin));\\r\\n        vat.hope(address(pot));\\r\\n        USB.approve(address(USBJoin), type(uint256).max);\\r\\n    }\\r\\n\\r\\n    function USBBalance(address usr) external returns (uint256 wad) {\\r\\n        uint256 chi = (block.timestamp > pot.rho()) ? pot.drip() : pot.chi();\\r\\n        wad = rmul(chi, pieOf[usr]);\\r\\n    }\\r\\n\\r\\n    // wad is denominated in USB\\r\\n    function join(address dst, uint256 wad) external {\\r\\n        uint256 chi = (block.timestamp > pot.rho()) ? pot.drip() : pot.chi();\\r\\n        uint256 pie = rdiv(wad, chi);\\r\\n        pieOf[dst] = add(pieOf[dst], pie);\\r\\n        supply = add(supply, pie);\\r\\n\\r\\n        USB.transferFrom(msg.sender, address(this), wad);\\r\\n        USBJoin.join(address(this), wad);\\r\\n        pot.join(pie);\\r\\n        emit Join(dst, wad);\\r\\n    }\\r\\n\\r\\n    // wad is denominated in USB\\r\\n    function exit(address dst, uint256 wad) external {\\r\\n        uint256 chi = (block.timestamp > pot.rho()) ? pot.drip() : pot.chi();\\r\\n        uint256 pie = rdivup(wad, chi);\\r\\n\\r\\n        require(pieOf[msg.sender] >= pie, \\\"insufficient-balance\\\");\\r\\n\\r\\n        pieOf[msg.sender] = sub(pieOf[msg.sender], pie);\\r\\n        supply = sub(supply, pie);\\r\\n\\r\\n        pot.exit(pie);\\r\\n        uint256 amt = rmul(chi, pie);\\r\\n        USBJoin.exit(dst, amt);\\r\\n        emit Exit(dst, amt);\\r\\n    }\\r\\n\\r\\n    function exitAll(address dst) external {\\r\\n        uint256 chi = (block.timestamp > pot.rho()) ? pot.drip() : pot.chi();\\r\\n        uint256 pie = pieOf[msg.sender];\\r\\n\\r\\n        pieOf[msg.sender] = 0;\\r\\n        supply = sub(supply, pie);\\r\\n\\r\\n        pot.exit(pie);\\r\\n        uint256 amt = rmul(chi, pie);\\r\\n        USBJoin.exit(dst, amt);\\r\\n        emit Exit(dst, amt);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/flip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// flip.sol -- Collateral auction\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ninterface VatLike {\\r\\n    function move(address,address,uint256) external;\\r\\n    function flux(bytes32,address,address,uint256) external;\\r\\n}\\r\\n\\r\\ninterface CatLike {\\r\\n    function claw(uint256) external;\\r\\n}\\r\\n\\r\\n/*\\r\\n   This thing lets you flip some gems for a given amount of USB.\\r\\n   Once the given amount of USB is raised, gems are forgone instead.\\r\\n\\r\\n - `lot` gems in return for bid\\r\\n - `tab` total USB wanted\\r\\n - `bid` USB paid\\r\\n - `gal` receives USB income\\r\\n - `usr` receives gem forgone\\r\\n - `ttl` single bid lifetime\\r\\n - `beg` minimum bid increase\\r\\n - `end` max auction duration\\r\\n*/\\r\\n\\r\\ncontract Flipper {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint256) public wards;\\r\\n    function rely(address usr) external auth { wards[usr] = 1; }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"Flipper/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    struct Bid {\\r\\n        uint256 bid;  // USB paid                 [rad]\\r\\n        uint256 lot;  // gems in return for bid   [wad]\\r\\n        address guy;  // high bidder\\r\\n        uint48  tic;  // bid expiry time          [unix epoch time]\\r\\n        uint48  end;  // auction expiry time      [unix epoch time]\\r\\n        address usr;\\r\\n        address gal;\\r\\n        uint256 tab;  // total USB wanted         [rad]\\r\\n    }\\r\\n\\r\\n    mapping (uint256 => Bid) public bids;\\r\\n\\r\\n    VatLike public   vat;            // CDP Engine\\r\\n    bytes32 public   ilk;            // collateral type\\r\\n\\r\\n    uint256 constant ONE = 1.00E18;\\r\\n    uint256 public   beg = 1.05E18;  // 5% minimum bid increase\\r\\n    uint48  public   ttl = 3 hours;  // 3 hours bid duration         [seconds]\\r\\n    uint48  public   tau = 2 days;   // 2 days total auction length  [seconds]\\r\\n    uint256 public kicks = 0;\\r\\n    CatLike public   cat;            // cat liquidation module\\r\\n\\r\\n    // --- Events ---\\r\\n    event Kick(\\r\\n      uint256 id,\\r\\n      uint256 lot,\\r\\n      uint256 bid,\\r\\n      uint256 tab,\\r\\n      address indexed usr,\\r\\n      address indexed gal\\r\\n    );\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address vat_, address cat_, bytes32 ilk_) public {\\r\\n        vat = VatLike(vat_);\\r\\n        cat = CatLike(cat_);\\r\\n        ilk = ilk_;\\r\\n        wards[msg.sender] = 1;\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n\\r\\n    // --- Admin ---\\r\\n    function file(bytes32 what, uint256 data) external auth {\\r\\n        if (what == \\\"beg\\\") beg = data;\\r\\n        else if (what == \\\"ttl\\\") ttl = uint48(data);\\r\\n        else if (what == \\\"tau\\\") tau = uint48(data);\\r\\n        else revert(\\\"Flipper/file-unrecognized-param\\\");\\r\\n    }\\r\\n    function file(bytes32 what, address data) external auth {\\r\\n        if (what == \\\"cat\\\") cat = CatLike(data);\\r\\n        else revert(\\\"Flipper/file-unrecognized-param\\\");\\r\\n    }\\r\\n\\r\\n    // --- Auction ---\\r\\n    function kick(address usr, address gal, uint256 tab, uint256 lot, uint256 bid)\\r\\n        public auth returns (uint256 id)\\r\\n    {\\r\\n        require(kicks < type(uint256).max, \\\"Flipper/overflow\\\");\\r\\n        id = ++kicks;\\r\\n\\r\\n        bids[id].bid = bid;\\r\\n        bids[id].lot = lot;\\r\\n        bids[id].guy = msg.sender;  // configurable??\\r\\n        bids[id].end = add(uint48(block.timestamp), tau);\\r\\n        bids[id].usr = usr;\\r\\n        bids[id].gal = gal;\\r\\n        bids[id].tab = tab;\\r\\n\\r\\n        vat.flux(ilk, msg.sender, address(this), lot);\\r\\n\\r\\n        emit Kick(id, lot, bid, tab, usr, gal);\\r\\n    }\\r\\n    function tick(uint256 id) external {\\r\\n        require(bids[id].end < block.timestamp, \\\"Flipper/not-finished\\\");\\r\\n        require(bids[id].tic == 0, \\\"Flipper/bid-already-placed\\\");\\r\\n        bids[id].end = add(uint48(block.timestamp), tau);\\r\\n    }\\r\\n    function tend(uint256 id, uint256 lot, uint256 bid) external {\\r\\n        require(bids[id].guy != address(0), \\\"Flipper/guy-not-set\\\");\\r\\n        require(bids[id].tic > block.timestamp || bids[id].tic == 0, \\\"Flipper/already-finished-tic\\\");\\r\\n        require(bids[id].end > block.timestamp, \\\"Flipper/already-finished-end\\\");\\r\\n\\r\\n        require(lot == bids[id].lot, \\\"Flipper/lot-not-matching\\\");\\r\\n        require(bid <= bids[id].tab, \\\"Flipper/higher-than-tab\\\");\\r\\n        require(bid >  bids[id].bid, \\\"Flipper/bid-not-higher\\\");\\r\\n        require(mul(bid, ONE) >= mul(beg, bids[id].bid) || bid == bids[id].tab, \\\"Flipper/insufficient-increase\\\");\\r\\n\\r\\n        if (msg.sender != bids[id].guy) {\\r\\n            vat.move(msg.sender, bids[id].guy, bids[id].bid);\\r\\n            bids[id].guy = msg.sender;\\r\\n        }\\r\\n        vat.move(msg.sender, bids[id].gal, bid - bids[id].bid);\\r\\n\\r\\n        bids[id].bid = bid;\\r\\n        bids[id].tic = add(uint48(block.timestamp), ttl);\\r\\n    }\\r\\n    function dent(uint256 id, uint256 lot, uint256 bid) external {\\r\\n        require(bids[id].guy != address(0), \\\"Flipper/guy-not-set\\\");\\r\\n        require(bids[id].tic > block.timestamp || bids[id].tic == 0, \\\"Flipper/already-finished-tic\\\");\\r\\n        require(bids[id].end > block.timestamp, \\\"Flipper/already-finished-end\\\");\\r\\n\\r\\n        require(bid == bids[id].bid, \\\"Flipper/not-matching-bid\\\");\\r\\n        require(bid == bids[id].tab, \\\"Flipper/tend-not-finished\\\");\\r\\n        require(lot < bids[id].lot, \\\"Flipper/lot-not-lower\\\");\\r\\n        require(mul(beg, lot) <= mul(bids[id].lot, ONE), \\\"Flipper/insufficient-decrease\\\");\\r\\n\\r\\n        if (msg.sender != bids[id].guy) {\\r\\n            vat.move(msg.sender, bids[id].guy, bid);\\r\\n            bids[id].guy = msg.sender;\\r\\n        }\\r\\n        vat.flux(ilk, address(this), bids[id].usr, bids[id].lot - lot);\\r\\n\\r\\n        bids[id].lot = lot;\\r\\n        bids[id].tic = add(uint48(block.timestamp), ttl);\\r\\n    }\\r\\n    function deal(uint256 id) external {\\r\\n        require(bids[id].tic != 0 && (bids[id].tic < block.timestamp || bids[id].end < block.timestamp), \\\"Flipper/not-finished\\\");\\r\\n        cat.claw(bids[id].tab);\\r\\n        vat.flux(ilk, address(this), bids[id].guy, bids[id].lot);\\r\\n        delete bids[id];\\r\\n    }\\r\\n\\r\\n    function yank(uint256 id) external auth {\\r\\n        require(bids[id].guy != address(0), \\\"Flipper/guy-not-set\\\");\\r\\n        require(bids[id].bid < bids[id].tab, \\\"Flipper/already-dent-phase\\\");\\r\\n        cat.claw(bids[id].tab);\\r\\n        vat.flux(ilk, address(this), msg.sender, bids[id].lot);\\r\\n        vat.move(msg.sender, bids[id].guy, bids[id].bid);\\r\\n        delete bids[id];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/flap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// flap.sol -- Surplus auction\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ninterface VatLike {\\r\\n    function move(address,address,uint) external;\\r\\n}\\r\\ninterface GemLike {\\r\\n    function move(address,address,uint) external;\\r\\n    function burn(address,uint) external;\\r\\n}\\r\\n\\r\\n/*\\r\\n   This thing lets you sell some USB in return for gems.\\r\\n\\r\\n - `lot` USB in return for bid\\r\\n - `bid` gems paid\\r\\n - `ttl` single bid lifetime\\r\\n - `beg` minimum bid increase\\r\\n - `end` max auction duration\\r\\n*/\\r\\n\\r\\ncontract Flapper {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address usr) external auth { wards[usr] = 1; }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"Flapper/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    struct Bid {\\r\\n        uint256 bid;  // gems paid               [wad]\\r\\n        uint256 lot;  // USB in return for bid   [rad]\\r\\n        address guy;  // high bidder\\r\\n        uint48  tic;  // bid expiry time         [unix epoch time]\\r\\n        uint48  end;  // auction expiry time     [unix epoch time]\\r\\n    }\\r\\n\\r\\n    mapping (uint => Bid) public bids;\\r\\n\\r\\n    VatLike  public   vat;  // CDP Engine\\r\\n    GemLike  public   gem;\\r\\n\\r\\n    uint256  constant ONE = 1.00E18;\\r\\n    uint256  public   beg = 1.05E18;  // 5% minimum bid increase\\r\\n    uint48   public   ttl = 3 hours;  // 3 hours bid duration         [seconds]\\r\\n    uint48   public   tau = 2 days;   // 2 days total auction length  [seconds]\\r\\n    uint256  public kicks = 0;\\r\\n    uint256  public live;  // Active Flag\\r\\n\\r\\n    // --- Events ---\\r\\n    event Kick(\\r\\n      uint256 id,\\r\\n      uint256 lot,\\r\\n      uint256 bid\\r\\n    );\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address vat_, address gem_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        vat = VatLike(vat_);\\r\\n        gem = GemLike(gem_);\\r\\n        live = 1;\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n\\r\\n    // --- Admin ---\\r\\n    function file(bytes32 what, uint data) external auth {\\r\\n        if (what == \\\"beg\\\") beg = data;\\r\\n        else if (what == \\\"ttl\\\") ttl = uint48(data);\\r\\n        else if (what == \\\"tau\\\") tau = uint48(data);\\r\\n        else revert(\\\"Flapper/file-unrecognized-param\\\");\\r\\n    }\\r\\n\\r\\n    // --- Auction ---\\r\\n    function kick(uint lot, uint bid) external auth returns (uint id) {\\r\\n        require(live == 1, \\\"Flapper/not-live\\\");\\r\\n        require(kicks < type(uint256).max, \\\"Flapper/overflow\\\");\\r\\n        id = ++kicks;\\r\\n\\r\\n        bids[id].bid = bid;\\r\\n        bids[id].lot = lot;\\r\\n        bids[id].guy = msg.sender;  // configurable??\\r\\n        bids[id].end = add(uint48(block.timestamp), tau);\\r\\n\\r\\n        vat.move(msg.sender, address(this), lot);\\r\\n\\r\\n        emit Kick(id, lot, bid);\\r\\n    }\\r\\n    function tick(uint id) external {\\r\\n        require(bids[id].end < block.timestamp, \\\"Flapper/not-finished\\\");\\r\\n        require(bids[id].tic == 0, \\\"Flapper/bid-already-placed\\\");\\r\\n        bids[id].end = add(uint48(block.timestamp), tau);\\r\\n    }\\r\\n    function tend(uint id, uint lot, uint bid) external {\\r\\n        require(live == 1, \\\"Flapper/not-live\\\");\\r\\n        require(bids[id].guy != address(0), \\\"Flapper/guy-not-set\\\");\\r\\n        require(bids[id].tic > block.timestamp || bids[id].tic == 0, \\\"Flapper/already-finished-tic\\\");\\r\\n        require(bids[id].end > block.timestamp, \\\"Flapper/already-finished-end\\\");\\r\\n\\r\\n        require(lot == bids[id].lot, \\\"Flapper/lot-not-matching\\\");\\r\\n        require(bid >  bids[id].bid, \\\"Flapper/bid-not-higher\\\");\\r\\n        require(mul(bid, ONE) >= mul(beg, bids[id].bid), \\\"Flapper/insufficient-increase\\\");\\r\\n\\r\\n        if (msg.sender != bids[id].guy) {\\r\\n            gem.move(msg.sender, bids[id].guy, bids[id].bid);\\r\\n            bids[id].guy = msg.sender;\\r\\n        }\\r\\n        gem.move(msg.sender, address(this), bid - bids[id].bid);\\r\\n\\r\\n        bids[id].bid = bid;\\r\\n        bids[id].tic = add(uint48(block.timestamp), ttl);\\r\\n    }\\r\\n    function deal(uint id) external {\\r\\n        require(live == 1, \\\"Flapper/not-live\\\");\\r\\n        require(bids[id].tic != 0 && (bids[id].tic < block.timestamp || bids[id].end < block.timestamp), \\\"Flapper/not-finished\\\");\\r\\n        vat.move(address(this), bids[id].guy, bids[id].lot);\\r\\n        gem.burn(address(this), bids[id].bid);\\r\\n        delete bids[id];\\r\\n    }\\r\\n\\r\\n    function cage(uint rad) external auth {\\r\\n       live = 0;\\r\\n       vat.move(address(this), msg.sender, rad);\\r\\n    }\\r\\n    function yank(uint id) external {\\r\\n        require(live == 0, \\\"Flapper/still-live\\\");\\r\\n        require(bids[id].guy != address(0), \\\"Flapper/guy-not-set\\\");\\r\\n        gem.move(address(this), bids[id].guy, bids[id].bid);\\r\\n        delete bids[id];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/spot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// spot.sol -- Spotter\\r\\n\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ninterface VatLike {\\r\\n    function file(bytes32, bytes32, uint) external;\\r\\n}\\r\\n\\r\\ninterface PipLike {\\r\\n    function peek() external returns (bytes32, bool);\\r\\n}\\r\\n\\r\\ncontract Spotter {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address guy) external auth { wards[guy] = 1;  }\\r\\n    function deny(address guy) external auth { wards[guy] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"Spotter/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    struct Ilk {\\r\\n        PipLike pip;  // Price Feed\\r\\n        uint256 mat;  // Liquidation ratio [ray]\\r\\n    }\\r\\n\\r\\n    mapping (bytes32 => Ilk) public ilks;\\r\\n\\r\\n    VatLike public vat;  // CDP Engine\\r\\n    uint256 public par;  // ref per USB [ray]\\r\\n\\r\\n    uint256 public live;\\r\\n\\r\\n    // --- Events ---\\r\\n    event Poke(\\r\\n      bytes32 ilk,\\r\\n      bytes32 val,  // [wad]\\r\\n      uint256 spot  // [ray]\\r\\n    );\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address vat_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        vat = VatLike(vat_);\\r\\n        par = ONE;\\r\\n        live = 1;\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    uint constant ONE = 10 ** 27;\\r\\n\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = mul(x, ONE) / y;\\r\\n    }\\r\\n\\r\\n    // --- Administration ---\\r\\n    function file(bytes32 ilk, bytes32 what, address pip_) external auth {\\r\\n        require(live == 1, \\\"Spotter/not-live\\\");\\r\\n        if (what == \\\"pip\\\") ilks[ilk].pip = PipLike(pip_);\\r\\n        else revert(\\\"Spotter/file-unrecognized-param\\\");\\r\\n    }\\r\\n    function file(bytes32 what, uint data) external auth {\\r\\n        require(live == 1, \\\"Spotter/not-live\\\");\\r\\n        if (what == \\\"par\\\") par = data;\\r\\n        else revert(\\\"Spotter/file-unrecognized-param\\\");\\r\\n    }\\r\\n    function file(bytes32 ilk, bytes32 what, uint data) external auth {\\r\\n        require(live == 1, \\\"Spotter/not-live\\\");\\r\\n        if (what == \\\"mat\\\") ilks[ilk].mat = data;\\r\\n        else revert(\\\"Spotter/file-unrecognized-param\\\");\\r\\n    }\\r\\n\\r\\n    // --- Update value ---\\r\\n    function poke(bytes32 ilk) external {\\r\\n        (bytes32 val, bool has) = ilks[ilk].pip.peek();\\r\\n        uint256 spot = has ? rdiv(rdiv(mul(uint(val), 10 ** 9), par), ilks[ilk].mat) : 0;\\r\\n        vat.file(ilk, \\\"spot\\\", spot);\\r\\n        emit Poke(ilk, val, spot);\\r\\n    }\\r\\n\\r\\n    function cage() external auth {\\r\\n        live = 0;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/jug.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// jug.sol -- USB Lending Rate\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ninterface VatLike {\\r\\n    function ilks(bytes32) external returns (\\r\\n        uint256 Art,   // [wad]\\r\\n        uint256 rate   // [ray]\\r\\n    );\\r\\n    function fold(bytes32,address,int) external;\\r\\n}\\r\\n\\r\\ncontract Jug {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address usr) external auth { wards[usr] = 1; }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"Jug/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    struct Ilk {\\r\\n        uint256 duty;  // Collateral-specific, per-second stability fee contribution [ray]\\r\\n        uint256  rho;  // Time of last drip [unix epoch time]\\r\\n    }\\r\\n\\r\\n    mapping (bytes32 => Ilk) public ilks;\\r\\n    VatLike                  public vat;   // CDP Engine\\r\\n    address                  public vow;   // Debt Engine\\r\\n    uint256                  public base;  // Global, per-second stability fee contribution [ray]\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address vat_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        vat = VatLike(vat_);\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\\r\\n      assembly {\\r\\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\\r\\n        default {\\r\\n          switch mod(n, 2) case 0 { z := b } default { z := x }\\r\\n          let half := div(b, 2)  // for rounding.\\r\\n          for { n := div(n, 2) } n { n := div(n,2) } {\\r\\n            let xx := mul(x, x)\\r\\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\\r\\n            let xxRound := add(xx, half)\\r\\n            if lt(xxRound, xx) { revert(0,0) }\\r\\n            x := div(xxRound, b)\\r\\n            if mod(n,2) {\\r\\n              let zx := mul(z, x)\\r\\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\\r\\n              let zxRound := add(zx, half)\\r\\n              if lt(zxRound, zx) { revert(0,0) }\\r\\n              z := div(zxRound, b)\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    uint256 constant ONE = 10 ** 27;\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = x + y;\\r\\n        require(z >= x);\\r\\n    }\\r\\n    function diff(uint x, uint y) internal pure returns (int z) {\\r\\n        z = int(x) - int(y);\\r\\n        require(int(x) >= 0 && int(y) >= 0);\\r\\n    }\\r\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = x * y;\\r\\n        require(y == 0 || z / y == x);\\r\\n        z = z / ONE;\\r\\n    }\\r\\n\\r\\n    // --- Administration ---\\r\\n    function init(bytes32 ilk) external auth {\\r\\n        Ilk storage i = ilks[ilk];\\r\\n        require(i.duty == 0, \\\"Jug/ilk-already-init\\\");\\r\\n        i.duty = ONE;\\r\\n        i.rho  = block.timestamp;\\r\\n    }\\r\\n    function file(bytes32 ilk, bytes32 what, uint data) external auth {\\r\\n        require(block.timestamp == ilks[ilk].rho, \\\"Jug/rho-not-updated\\\");\\r\\n        if (what == \\\"duty\\\") ilks[ilk].duty = data;\\r\\n        else revert(\\\"Jug/file-unrecognized-param\\\");\\r\\n    }\\r\\n    function file(bytes32 what, uint data) external auth {\\r\\n        if (what == \\\"base\\\") base = data;\\r\\n        else revert(\\\"Jug/file-unrecognized-param\\\");\\r\\n    }\\r\\n    function file(bytes32 what, address data) external auth {\\r\\n        if (what == \\\"vow\\\") vow = data;\\r\\n        else revert(\\\"Jug/file-unrecognized-param\\\");\\r\\n    }\\r\\n\\r\\n    // --- Stability Fee Collection ---\\r\\n    function drip(bytes32 ilk) external returns (uint rate) {\\r\\n        require(block.timestamp >= ilks[ilk].rho, \\\"Jug/invalid-now\\\");\\r\\n        (, uint prev) = vat.ilks(ilk);\\r\\n        rate = rmul(rpow(add(base, ilks[ilk].duty), block.timestamp - ilks[ilk].rho, ONE), prev);\\r\\n        vat.fold(ilk, vow, diff(rate, prev));\\r\\n        ilks[ilk].rho = block.timestamp;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/vat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// vat.sol -- USB CDP database\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ncontract Vat {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address usr) external auth { require(live == 1, \\\"Vat/not-live\\\"); wards[usr] = 1; }\\r\\n    function deny(address usr) external auth { require(live == 1, \\\"Vat/not-live\\\"); wards[usr] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"Vat/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    mapping(address => mapping (address => uint)) public can;\\r\\n    function hope(address usr) external { can[msg.sender][usr] = 1; }\\r\\n    function nope(address usr) external { can[msg.sender][usr] = 0; }\\r\\n    function wish(address bit, address usr) internal view returns (bool) {\\r\\n        return either(bit == usr, can[bit][usr] == 1);\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    struct Ilk {\\r\\n        uint256 Art;   // Total Normalised Debt     [wad]\\r\\n        uint256 rate;  // Accumulated Rates         [ray]\\r\\n        uint256 spot;  // Price with Safety Margin  [ray]\\r\\n        uint256 line;  // Debt Ceiling              [rad]\\r\\n        uint256 dust;  // Urn Debt Floor            [rad]\\r\\n    }\\r\\n    struct Urn {\\r\\n        uint256 ink;   // Locked Collateral  [wad]\\r\\n        uint256 art;   // Normalised Debt    [wad]\\r\\n    }\\r\\n\\r\\n    mapping (bytes32 => Ilk)                       public ilks;\\r\\n    mapping (bytes32 => mapping (address => Urn )) public urns;\\r\\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\\r\\n    mapping (address => uint256)                   public USB;  // [rad]\\r\\n    mapping (address => uint256)                   public sin;  // [rad]\\r\\n\\r\\n    uint256 public debt;  // Total USB Issued    [rad]\\r\\n    uint256 public vice;  // Total Unbacked USB  [rad]\\r\\n    uint256 public Line;  // Total Debt Ceiling  [rad]\\r\\n    uint256 public live;  // Active Flag\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor() public {\\r\\n        wards[msg.sender] = 1;\\r\\n        live = 1;\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    function add(uint x, int y) internal pure returns (uint z) {\\r\\n        z = x + uint(y);\\r\\n        require(y >= 0 || z <= x);\\r\\n        require(y <= 0 || z >= x);\\r\\n    }\\r\\n    function sub(uint x, int y) internal pure returns (uint z) {\\r\\n        z = x - uint(y);\\r\\n        require(y <= 0 || z <= x);\\r\\n        require(y >= 0 || z >= x);\\r\\n    }\\r\\n    function mul(uint x, int y) internal pure returns (int z) {\\r\\n        z = int(x) * y;\\r\\n        require(int(x) >= 0);\\r\\n        require(y == 0 || z / y == int(x));\\r\\n    }\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x);\\r\\n    }\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n\\r\\n    // --- Administration ---\\r\\n    function init(bytes32 ilk) external auth {\\r\\n        require(ilks[ilk].rate == 0, \\\"Vat/ilk-already-init\\\");\\r\\n        ilks[ilk].rate = 10 ** 27;\\r\\n    }\\r\\n    function file(bytes32 what, uint data) external auth {\\r\\n        require(live == 1, \\\"Vat/not-live\\\");\\r\\n        if (what == \\\"Line\\\") Line = data;\\r\\n        else revert(\\\"Vat/file-unrecognized-param\\\");\\r\\n    }\\r\\n    function file(bytes32 ilk, bytes32 what, uint data) external auth {\\r\\n        require(live == 1, \\\"Vat/not-live\\\");\\r\\n        if (what == \\\"spot\\\") ilks[ilk].spot = data;\\r\\n        else if (what == \\\"line\\\") ilks[ilk].line = data;\\r\\n        else if (what == \\\"dust\\\") ilks[ilk].dust = data;\\r\\n        else revert(\\\"Vat/file-unrecognized-param\\\");\\r\\n    }\\r\\n    function cage() external auth {\\r\\n        live = 0;\\r\\n    }\\r\\n\\r\\n    // --- Fungibility ---\\r\\n    function slip(bytes32 ilk, address usr, int256 wad) external auth {\\r\\n        gem[ilk][usr] = add(gem[ilk][usr], wad);\\r\\n    }\\r\\n    function flux(bytes32 ilk, address src, address dst, uint256 wad) external {\\r\\n        require(wish(src, msg.sender), \\\"Vat/not-allowed\\\");\\r\\n        gem[ilk][src] = sub(gem[ilk][src], wad);\\r\\n        gem[ilk][dst] = add(gem[ilk][dst], wad);\\r\\n    }\\r\\n    function move(address src, address dst, uint256 rad) external {\\r\\n        require(wish(src, msg.sender), \\\"Vat/not-allowed\\\");\\r\\n        USB[src] = sub(USB[src], rad);\\r\\n        USB[dst] = add(USB[dst], rad);\\r\\n    }\\r\\n\\r\\n    function either(bool x, bool y) internal pure returns (bool z) {\\r\\n        assembly{ z := or(x, y)}\\r\\n    }\\r\\n    function both(bool x, bool y) internal pure returns (bool z) {\\r\\n        assembly{ z := and(x, y)}\\r\\n    }\\r\\n\\r\\n    // --- CDP Manipulation ---\\r\\n    function frob(bytes32 i, address u, address v, address w, int dink, int dart) external {\\r\\n        // system is live\\r\\n        require(live == 1, \\\"Vat/not-live\\\");\\r\\n\\r\\n        Urn memory urn = urns[i][u];\\r\\n        Ilk memory ilk = ilks[i];\\r\\n        // ilk has been initialised\\r\\n        require(ilk.rate != 0, \\\"Vat/ilk-not-init\\\");\\r\\n\\r\\n        urn.ink = add(urn.ink, dink);\\r\\n        urn.art = add(urn.art, dart);\\r\\n        ilk.Art = add(ilk.Art, dart);\\r\\n\\r\\n        int dtab = mul(ilk.rate, dart);\\r\\n        uint tab = mul(ilk.rate, urn.art);\\r\\n        debt     = add(debt, dtab);\\r\\n\\r\\n        // either debt has decreased, or debt ceilings are not exceeded\\r\\n        require(either(dart <= 0, both(mul(ilk.Art, ilk.rate) <= ilk.line, debt <= Line)), \\\"Vat/ceiling-exceeded\\\");\\r\\n        // urn is either less risky than before, or it is safe\\r\\n        require(either(both(dart <= 0, dink >= 0), tab <= mul(urn.ink, ilk.spot)), \\\"Vat/not-safe\\\");\\r\\n\\r\\n        // urn is either more safe, or the owner consents\\r\\n        require(either(both(dart <= 0, dink >= 0), wish(u, msg.sender)), \\\"Vat/not-allowed-u\\\");\\r\\n        // collateral src consents\\r\\n        require(either(dink <= 0, wish(v, msg.sender)), \\\"Vat/not-allowed-v\\\");\\r\\n        // debt dst consents\\r\\n        require(either(dart >= 0, wish(w, msg.sender)), \\\"Vat/not-allowed-w\\\");\\r\\n\\r\\n        // urn has no debt, or a non-dusty amount\\r\\n        require(either(urn.art == 0, tab >= ilk.dust), \\\"Vat/dust\\\");\\r\\n\\r\\n        gem[i][v] = sub(gem[i][v], dink);\\r\\n        USB[w]    = add(USB[w],    dtab);\\r\\n\\r\\n        urns[i][u] = urn;\\r\\n        ilks[i]    = ilk;\\r\\n    }\\r\\n    // --- CDP Fungibility ---\\r\\n    function fork(bytes32 ilk, address src, address dst, int dink, int dart) external {\\r\\n        Urn storage u = urns[ilk][src];\\r\\n        Urn storage v = urns[ilk][dst];\\r\\n        Ilk storage i = ilks[ilk];\\r\\n\\r\\n        u.ink = sub(u.ink, dink);\\r\\n        u.art = sub(u.art, dart);\\r\\n        v.ink = add(v.ink, dink);\\r\\n        v.art = add(v.art, dart);\\r\\n\\r\\n        uint utab = mul(u.art, i.rate);\\r\\n        uint vtab = mul(v.art, i.rate);\\r\\n\\r\\n        // both sides consent\\r\\n        require(both(wish(src, msg.sender), wish(dst, msg.sender)), \\\"Vat/not-allowed\\\");\\r\\n\\r\\n        // both sides safe\\r\\n        require(utab <= mul(u.ink, i.spot), \\\"Vat/not-safe-src\\\");\\r\\n        require(vtab <= mul(v.ink, i.spot), \\\"Vat/not-safe-dst\\\");\\r\\n\\r\\n        // both sides non-dusty\\r\\n        require(either(utab >= i.dust, u.art == 0), \\\"Vat/dust-src\\\");\\r\\n        require(either(vtab >= i.dust, v.art == 0), \\\"Vat/dust-dst\\\");\\r\\n    }\\r\\n    // --- CDP Confiscation ---\\r\\n    function grab(bytes32 i, address u, address v, address w, int dink, int dart) external auth {\\r\\n        Urn storage urn = urns[i][u];\\r\\n        Ilk storage ilk = ilks[i];\\r\\n\\r\\n        urn.ink = add(urn.ink, dink);\\r\\n        urn.art = add(urn.art, dart);\\r\\n        ilk.Art = add(ilk.Art, dart);\\r\\n\\r\\n        int dtab = mul(ilk.rate, dart);\\r\\n\\r\\n        gem[i][v] = sub(gem[i][v], dink);\\r\\n        sin[w]    = sub(sin[w],    dtab);\\r\\n        vice      = sub(vice,      dtab);\\r\\n    }\\r\\n\\r\\n    // --- Settlement ---\\r\\n    function heal(uint rad) external {\\r\\n        address u = msg.sender;\\r\\n        sin[u] = sub(sin[u], rad);\\r\\n        USB[u] = sub(USB[u], rad);\\r\\n        vice   = sub(vice,   rad);\\r\\n        debt   = sub(debt,   rad);\\r\\n    }\\r\\n    function suck(address u, address v, uint rad) external auth {\\r\\n        sin[u] = add(sin[u], rad);\\r\\n        USB[v] = add(USB[v], rad);\\r\\n        vice   = add(vice,   rad);\\r\\n        debt   = add(debt,   rad);\\r\\n    }\\r\\n\\r\\n    // --- Rates ---\\r\\n    function fold(bytes32 i, address u, int rate) external auth {\\r\\n        require(live == 1, \\\"Vat/not-live\\\");\\r\\n        Ilk storage ilk = ilks[i];\\r\\n        ilk.rate = add(ilk.rate, rate);\\r\\n        int rad  = mul(ilk.Art, rate);\\r\\n        USB[u]   = add(USB[u], rad);\\r\\n        debt     = add(debt,   rad);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/dai.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\\r\\n\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ncontract USB {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address guy) external auth { wards[guy] = 1; }\\r\\n    function deny(address guy) external auth { wards[guy] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"USB/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- ERC20 Data ---\\r\\n    string  public constant name     = \\\"USB Stablecoin\\\";\\r\\n    string  public constant symbol   = \\\"USB\\\";\\r\\n    string  public constant version  = \\\"1\\\";\\r\\n    uint8   public constant decimals = 18;\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    mapping (address => uint)                      public balanceOf;\\r\\n    mapping (address => mapping (address => uint)) public allowance;\\r\\n    mapping (address => uint)                      public nonces;\\r\\n\\r\\n    event Approval(address indexed src, address indexed guy, uint wad);\\r\\n    event Transfer(address indexed src, address indexed dst, uint wad);\\r\\n\\r\\n    // --- Math ---\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x);\\r\\n    }\\r\\n\\r\\n    // --- EIP712 niceties ---\\r\\n    bytes32 public DOMAIN_SEPARATOR;\\r\\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\\\");\\r\\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\\r\\n\\r\\n    constructor(uint256 chainId_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\\r\\n            keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\r\\n            keccak256(bytes(name)),\\r\\n            keccak256(bytes(version)),\\r\\n            chainId_,\\r\\n            address(this)\\r\\n        ));\\r\\n    }\\r\\n\\r\\n    // --- Token ---\\r\\n    function transfer(address dst, uint wad) external returns (bool) {\\r\\n        return transferFrom(msg.sender, dst, wad);\\r\\n    }\\r\\n    function transferFrom(address src, address dst, uint wad)\\r\\n        public returns (bool)\\r\\n    {\\r\\n        require(balanceOf[src] >= wad, \\\"USB/insufficient-balance\\\");\\r\\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\\r\\n            require(allowance[src][msg.sender] >= wad, \\\"USB/insufficient-allowance\\\");\\r\\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\\r\\n        }\\r\\n        balanceOf[src] = sub(balanceOf[src], wad);\\r\\n        balanceOf[dst] = add(balanceOf[dst], wad);\\r\\n        emit Transfer(src, dst, wad);\\r\\n        return true;\\r\\n    }\\r\\n    function mint(address usr, uint wad) external auth {\\r\\n        balanceOf[usr] = add(balanceOf[usr], wad);\\r\\n        totalSupply    = add(totalSupply, wad);\\r\\n        emit Transfer(address(0), usr, wad);\\r\\n    }\\r\\n    function burn(address usr, uint wad) external {\\r\\n        require(balanceOf[usr] >= wad, \\\"USB/insufficient-balance\\\");\\r\\n        if (usr != msg.sender && allowance[usr][msg.sender] != type(uint256).max) {\\r\\n            require(allowance[usr][msg.sender] >= wad, \\\"USB/insufficient-allowance\\\");\\r\\n            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\\r\\n        }\\r\\n        balanceOf[usr] = sub(balanceOf[usr], wad);\\r\\n        totalSupply    = sub(totalSupply, wad);\\r\\n        emit Transfer(usr, address(0), wad);\\r\\n    }\\r\\n    function approve(address usr, uint wad) external returns (bool) {\\r\\n        allowance[msg.sender][usr] = wad;\\r\\n        emit Approval(msg.sender, usr, wad);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // --- Alias ---\\r\\n    function push(address usr, uint wad) external {\\r\\n        transferFrom(msg.sender, usr, wad);\\r\\n    }\\r\\n    function pull(address usr, uint wad) external {\\r\\n        transferFrom(usr, msg.sender, wad);\\r\\n    }\\r\\n    function move(address src, address dst, uint wad) external {\\r\\n        transferFrom(src, dst, wad);\\r\\n    }\\r\\n\\r\\n    // --- Approve by signature ---\\r\\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\\r\\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\\r\\n    {\\r\\n        bytes32 digest =\\r\\n            keccak256(abi.encodePacked(\\r\\n                \\\"\\\\x19\\\\x01\\\",\\r\\n                DOMAIN_SEPARATOR,\\r\\n                keccak256(abi.encode(PERMIT_TYPEHASH,\\r\\n                                     holder,\\r\\n                                     spender,\\r\\n                                     nonce,\\r\\n                                     expiry,\\r\\n                                     allowed))\\r\\n        ));\\r\\n\\r\\n        require(holder != address(0), \\\"USB/invalid-address-0\\\");\\r\\n        require(holder == ecrecover(digest, v, r, s), \\\"USB/invalid-permit\\\");\\r\\n        require(expiry == 0 || block.timestamp <= expiry, \\\"USB/permit-expired\\\");\\r\\n        require(nonce == nonces[holder]++, \\\"USB/invalid-nonce\\\");\\r\\n        uint wad = allowed ? type(uint256).max : 0;\\r\\n        allowance[holder][spender] = wad;\\r\\n        emit Approval(holder, spender, wad);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/DssProxyActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\n/// DssProxyActions.sol\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.5.12;\\n\\ninterface GemLike {\\n    function approve(address, uint) external;\\n    function transfer(address, uint) external;\\n    function transferFrom(address, address, uint) external;\\n    function deposit() external payable;\\n    function withdraw(uint) external;\\n}\\n\\ninterface ManagerLike {\\n    function cdpCan(address, uint, address) external view returns (uint);\\n    function ilks(uint) external view returns (bytes32);\\n    function owns(uint) external view returns (address);\\n    function urns(uint) external view returns (address);\\n    function vat() external view returns (address);\\n    function open(bytes32, address) external returns (uint);\\n    function give(uint, address) external;\\n    function cdpAllow(uint, address, uint) external;\\n    function urnAllow(address, uint) external;\\n    function frob(uint, int, int) external;\\n    function flux(uint, address, uint) external;\\n    function move(uint, address, uint) external;\\n    function exit(address, uint, address, uint) external;\\n    function quit(uint, address) external;\\n    function enter(address, uint) external;\\n    function shift(uint, uint) external;\\n}\\n\\ninterface VatLike {\\n    function can(address, address) external view returns (uint);\\n    function ilks(bytes32) external view returns (uint, uint, uint, uint, uint);\\n    function USB(address) external view returns (uint);\\n    function urns(bytes32, address) external view returns (uint, uint);\\n    function frob(bytes32, address, address, address, int, int) external;\\n    function hope(address) external;\\n    function move(address, address, uint) external;\\n}\\n\\ninterface GemJoinLike {\\n    function dec() external returns (uint);\\n    function gem() external returns (GemLike);\\n    function join(address, uint) external payable;\\n    function exit(address, uint) external;\\n}\\n\\ninterface GNTJoinLike {\\n    function bags(address) external view returns (address);\\n    function make(address) external returns (address);\\n}\\n\\ninterface USBJoinLike {\\n    function vat() external returns (VatLike);\\n    function USB() external returns (GemLike);\\n    function join(address, uint) external payable;\\n    function exit(address, uint) external;\\n}\\n\\ninterface HopeLike {\\n    function hope(address) external;\\n    function nope(address) external;\\n}\\n\\ninterface EndLike {\\n    function fix(bytes32) external view returns (uint);\\n    function cash(bytes32, uint) external;\\n    function free(bytes32) external;\\n    function pack(uint) external;\\n    function skim(bytes32, address) external;\\n}\\n\\ninterface JugLike {\\n    function drip(bytes32) external returns (uint);\\n}\\n\\ninterface PotLike {\\n    function pie(address) external view returns (uint);\\n    function drip() external returns (uint);\\n    function join(uint) external;\\n    function exit(uint) external;\\n}\\n\\ninterface ProxyRegistryLike {\\n    function proxies(address) external view returns (address);\\n    function build(address) external returns (address);\\n}\\n\\ninterface ProxyLike {\\n    function owner() external view returns (address);\\n}\\n\\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\ncontract Common {\\n    uint256 constant RAY = 10 ** 27;\\n\\n    // Internal functions\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"mul-overflow\\\");\\n    }\\n\\n    // Public functions\\n\\n    function USBJoin_join(address apt, address urn, uint wad) public {\\n        // Gets USB from the user's wallet\\n        USBJoinLike(apt).USB().transferFrom(msg.sender, address(this), wad);\\n        // Approves adapter to take the USB amount\\n        USBJoinLike(apt).USB().approve(apt, wad);\\n        // Joins USB into the vat\\n        USBJoinLike(apt).join(urn, wad);\\n    }\\n}\\n\\ncontract DssProxyActions is Common {\\n    // Internal functions\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, \\\"sub-overflow\\\");\\n    }\\n\\n    function toInt(uint x) internal pure returns (int y) {\\n        y = int(x);\\n        require(y >= 0, \\\"int-overflow\\\");\\n    }\\n\\n    function toRad(uint wad) internal pure returns (uint rad) {\\n        rad = mul(wad, 10 ** 27);\\n    }\\n\\n    function convertTo18(address gemJoin, uint256 amt) internal returns (uint256 wad) {\\n        // For those collaterals that have less than 18 decimals precision we need to do the conversion before passing to frob function\\n        // Adapters will automatically handle the difference of precision\\n        wad = mul(\\n            amt,\\n            10 ** (18 - GemJoinLike(gemJoin).dec())\\n        );\\n    }\\n\\n    function _getDrawDart(\\n        address vat,\\n        address jug,\\n        address urn,\\n        bytes32 ilk,\\n        uint wad\\n    ) internal returns (int dart) {\\n        // Updates stability fee rate\\n        uint rate = JugLike(jug).drip(ilk);\\n\\n        // Gets USB balance of the urn in the vat\\n        uint USB = VatLike(vat).USB(urn);\\n\\n        // If there was already enough USB in the vat balance, just exits it without adding more debt\\n        if (USB < mul(wad, RAY)) {\\n            // Calculates the needed dart so together with the existing USB in the vat is enough to exit wad amount of USB tokens\\n            dart = toInt(sub(mul(wad, RAY), USB) / rate);\\n            // This is neeeded due lack of precision. It might need to sum an extra dart wei (for the given USB wad amount)\\n            dart = mul(uint(dart), rate) < mul(wad, RAY) ? dart + 1 : dart;\\n        }\\n    }\\n\\n    function _getWipeDart(\\n        address vat,\\n        uint USB,\\n        address urn,\\n        bytes32 ilk\\n    ) internal view returns (int dart) {\\n        // Gets actual rate from the vat\\n        (, uint rate,,,) = VatLike(vat).ilks(ilk);\\n        // Gets actual art value of the urn\\n        (, uint art) = VatLike(vat).urns(ilk, urn);\\n\\n        // Uses the whole USB balance in the vat to reduce the debt\\n        dart = toInt(USB / rate);\\n        // Checks the calculated dart is not higher than urn.art (total debt), otherwise uses its value\\n        dart = uint(dart) <= art ? - dart : - toInt(art);\\n    }\\n\\n    function _getWipeAllWad(\\n        address vat,\\n        address usr,\\n        address urn,\\n        bytes32 ilk\\n    ) internal view returns (uint wad) {\\n        // Gets actual rate from the vat\\n        (, uint rate,,,) = VatLike(vat).ilks(ilk);\\n        // Gets actual art value of the urn\\n        (, uint art) = VatLike(vat).urns(ilk, urn);\\n        // Gets actual USB amount in the urn\\n        uint USB = VatLike(vat).USB(usr);\\n\\n        uint rad = sub(mul(art, rate), USB);\\n        wad = rad / RAY;\\n\\n        // If the rad precision has some dust, it will need to request for 1 extra wad wei\\n        wad = mul(wad, RAY) < rad ? wad + 1 : wad;\\n    }\\n\\n    // Public functions\\n\\n    function transfer(address gem, address dst, uint amt) public {\\n        GemLike(gem).transfer(dst, amt);\\n    }\\n\\n    function ethJoin_join(address apt, address urn) public payable {\\n        // Wraps ETH in WETH\\n        GemJoinLike(apt).gem().deposit{value:(msg.value)}();\\n        // Approves adapter to take the WETH amount\\n        GemJoinLike(apt).gem().approve(address(apt), msg.value);\\n        // Joins WETH collateral into the vat\\n        GemJoinLike(apt).join(urn, msg.value);\\n    }\\n\\n    function gemJoin_join(address apt, address urn, uint amt, bool transferFrom) public {\\n        // Only executes for tokens that have approval/transferFrom implementation\\n        if (transferFrom) {\\n            // Gets token from the user's wallet\\n            GemJoinLike(apt).gem().transferFrom(msg.sender, address(this), amt);\\n            // Approves adapter to take the token amount\\n            GemJoinLike(apt).gem().approve(apt, amt);\\n        }\\n        // Joins token collateral into the vat\\n        GemJoinLike(apt).join(urn, amt);\\n    }\\n\\n    function hope(\\n        address obj,\\n        address usr\\n    ) public {\\n        HopeLike(obj).hope(usr);\\n    }\\n\\n    function nope(\\n        address obj,\\n        address usr\\n    ) public {\\n        HopeLike(obj).nope(usr);\\n    }\\n\\n    function open(\\n        address manager,\\n        bytes32 ilk,\\n        address usr\\n    ) public returns (uint cdp) {\\n        cdp = ManagerLike(manager).open(ilk, usr);\\n    }\\n\\n    function give(\\n        address manager,\\n        uint cdp,\\n        address usr\\n    ) public {\\n        ManagerLike(manager).give(cdp, usr);\\n    }\\n\\n    function giveToProxy(\\n        address proxyRegistry,\\n        address manager,\\n        uint cdp,\\n        address dst\\n    ) public {\\n        // Gets actual proxy address\\n        address proxy = ProxyRegistryLike(proxyRegistry).proxies(dst);\\n        // Checks if the proxy address already existed and dst address is still the owner\\n        if (proxy == address(0) || ProxyLike(proxy).owner() != dst) {\\n            uint csize;\\n            assembly {\\n                csize := extcodesize(dst)\\n            }\\n            // We want to avoid creating a proxy for a contract address that might not be able to handle proxies, then losing the CDP\\n            require(csize == 0, \\\"Dst-is-a-contract\\\");\\n            // Creates the proxy for the dst address\\n            proxy = ProxyRegistryLike(proxyRegistry).build(dst);\\n        }\\n        // Transfers CDP to the dst proxy\\n        give(manager, cdp, proxy);\\n    }\\n\\n    function cdpAllow(\\n        address manager,\\n        uint cdp,\\n        address usr,\\n        uint ok\\n    ) public {\\n        ManagerLike(manager).cdpAllow(cdp, usr, ok);\\n    }\\n\\n    function urnAllow(\\n        address manager,\\n        address usr,\\n        uint ok\\n    ) public {\\n        ManagerLike(manager).urnAllow(usr, ok);\\n    }\\n\\n    function flux(\\n        address manager,\\n        uint cdp,\\n        address dst,\\n        uint wad\\n    ) public {\\n        ManagerLike(manager).flux(cdp, dst, wad);\\n    }\\n\\n    function move(\\n        address manager,\\n        uint cdp,\\n        address dst,\\n        uint rad\\n    ) public {\\n        ManagerLike(manager).move(cdp, dst, rad);\\n    }\\n\\n    function frob(\\n        address manager,\\n        uint cdp,\\n        int dink,\\n        int dart\\n    ) public {\\n        ManagerLike(manager).frob(cdp, dink, dart);\\n    }\\n\\n    function quit(\\n        address manager,\\n        uint cdp,\\n        address dst\\n    ) public {\\n        ManagerLike(manager).quit(cdp, dst);\\n    }\\n\\n    function enter(\\n        address manager,\\n        address src,\\n        uint cdp\\n    ) public {\\n        ManagerLike(manager).enter(src, cdp);\\n    }\\n\\n    function shift(\\n        address manager,\\n        uint cdpSrc,\\n        uint cdpOrg\\n    ) public {\\n        ManagerLike(manager).shift(cdpSrc, cdpOrg);\\n    }\\n\\n    function makeGemBag(\\n        address gemJoin\\n    ) public returns (address bag) {\\n        bag = GNTJoinLike(gemJoin).make(address(this));\\n    }\\n\\n    function lockETH(\\n        address manager,\\n        address ethJoin,\\n        uint cdp\\n    ) public payable {\\n        // Receives ETH amount, converts it to WETH and joins it into the vat\\n        ethJoin_join(ethJoin, address(this));\\n        // Locks WETH amount into the CDP\\n        VatLike(ManagerLike(manager).vat()).frob(\\n            ManagerLike(manager).ilks(cdp),\\n            ManagerLike(manager).urns(cdp),\\n            address(this),\\n            address(this),\\n            toInt(msg.value),\\n            0\\n        );\\n    }\\n\\n    function safeLockETH(\\n        address manager,\\n        address ethJoin,\\n        uint cdp,\\n        address owner\\n    ) public payable {\\n        require(ManagerLike(manager).owns(cdp) == owner, \\\"owner-missmatch\\\");\\n        lockETH(manager, ethJoin, cdp);\\n    }\\n\\n    function lockGem(\\n        address manager,\\n        address gemJoin,\\n        uint cdp,\\n        uint amt,\\n        bool transferFrom\\n    ) public {\\n        // Takes token amount from user's wallet and joins into the vat\\n        gemJoin_join(gemJoin, address(this), amt, transferFrom);\\n        // Locks token amount into the CDP\\n        VatLike(ManagerLike(manager).vat()).frob(\\n            ManagerLike(manager).ilks(cdp),\\n            ManagerLike(manager).urns(cdp),\\n            address(this),\\n            address(this),\\n            toInt(convertTo18(gemJoin, amt)),\\n            0\\n        );\\n    }\\n\\n    function safeLockGem(\\n        address manager,\\n        address gemJoin,\\n        uint cdp,\\n        uint amt,\\n        bool transferFrom,\\n        address owner\\n    ) public {\\n        require(ManagerLike(manager).owns(cdp) == owner, \\\"owner-missmatch\\\");\\n        lockGem(manager, gemJoin, cdp, amt, transferFrom);\\n    }\\n\\n    function freeETH(\\n        address manager,\\n        address ethJoin,\\n        uint cdp,\\n        uint wad\\n    ) public {\\n        // Unlocks WETH amount from the CDP\\n        frob(manager, cdp, -toInt(wad), 0);\\n        // Moves the amount from the CDP urn to proxy's address\\n        flux(manager, cdp, address(this), wad);\\n        // Exits WETH amount to proxy address as a token\\n        GemJoinLike(ethJoin).exit(address(this), wad);\\n        // Converts WETH to ETH\\n        GemJoinLike(ethJoin).gem().withdraw(wad);\\n        // Sends ETH back to the user's wallet\\n        payable(msg.sender).transfer(wad);\\n    }\\n\\n    function freeGem(\\n        address manager,\\n        address gemJoin,\\n        uint cdp,\\n        uint amt\\n    ) public {\\n        uint wad = convertTo18(gemJoin, amt);\\n        // Unlocks token amount from the CDP\\n        frob(manager, cdp, -toInt(wad), 0);\\n        // Moves the amount from the CDP urn to proxy's address\\n        flux(manager, cdp, address(this), wad);\\n        // Exits token amount to the user's wallet as a token\\n        GemJoinLike(gemJoin).exit(msg.sender, amt);\\n    }\\n\\n    function exitETH(\\n        address manager,\\n        address ethJoin,\\n        uint cdp,\\n        uint wad\\n    ) public {\\n        // Moves the amount from the CDP urn to proxy's address\\n        flux(manager, cdp, address(this), wad);\\n\\n        // Exits WETH amount to proxy address as a token\\n        GemJoinLike(ethJoin).exit(address(this), wad);\\n        // Converts WETH to ETH\\n        GemJoinLike(ethJoin).gem().withdraw(wad);\\n        // Sends ETH back to the user's wallet\\n        payable(msg.sender).transfer(wad);\\n    }\\n\\n    function exitGem(\\n        address manager,\\n        address gemJoin,\\n        uint cdp,\\n        uint amt\\n    ) public {\\n        // Moves the amount from the CDP urn to proxy's address\\n        flux(manager, cdp, address(this), convertTo18(gemJoin, amt));\\n\\n        // Exits token amount to the user's wallet as a token\\n        GemJoinLike(gemJoin).exit(msg.sender, amt);\\n    }\\n\\n    function draw(\\n        address manager,\\n        address jug,\\n        address USBJoin,\\n        uint cdp,\\n        uint wad\\n    ) public {\\n        address urn = ManagerLike(manager).urns(cdp);\\n        address vat = ManagerLike(manager).vat();\\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\\n        // Generates debt in the CDP\\n        frob(manager, cdp, 0, _getDrawDart(vat, jug, urn, ilk, wad));\\n        // Moves the USB amount (balance in the vat in rad) to proxy's address\\n        move(manager, cdp, address(this), toRad(wad));\\n        // Allows adapter to access to proxy's USB balance in the vat\\n        if (VatLike(vat).can(address(this), address(USBJoin)) == 0) {\\n            VatLike(vat).hope(USBJoin);\\n        }\\n        // Exits USB to the user's wallet as a token\\n        USBJoinLike(USBJoin).exit(msg.sender, wad);\\n    }\\n\\n    function wipe(\\n        address manager,\\n        address USBJoin,\\n        uint cdp,\\n        uint wad\\n    ) public {\\n        address vat = ManagerLike(manager).vat();\\n        address urn = ManagerLike(manager).urns(cdp);\\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\\n\\n        address own = ManagerLike(manager).owns(cdp);\\n        if (own == address(this) || ManagerLike(manager).cdpCan(own, cdp, address(this)) == 1) {\\n            // Joins USB amount into the vat\\n            USBJoin_join(USBJoin, urn, wad);\\n            // Paybacks debt to the CDP\\n            frob(manager, cdp, 0, _getWipeDart(vat, VatLike(vat).USB(urn), urn, ilk));\\n        } else {\\n             // Joins USB amount into the vat\\n            USBJoin_join(USBJoin, address(this), wad);\\n            // Paybacks debt to the CDP\\n            VatLike(vat).frob(\\n                ilk,\\n                urn,\\n                address(this),\\n                address(this),\\n                0,\\n                _getWipeDart(vat, wad * RAY, urn, ilk)\\n            );\\n        }\\n    }\\n\\n    function safeWipe(\\n        address manager,\\n        address USBJoin,\\n        uint cdp,\\n        uint wad,\\n        address owner\\n    ) public {\\n        require(ManagerLike(manager).owns(cdp) == owner, \\\"owner-missmatch\\\");\\n        wipe(manager, USBJoin, cdp, wad);\\n    }\\n\\n    function wipeAll(\\n        address manager,\\n        address USBJoin,\\n        uint cdp\\n    ) public {\\n        address vat = ManagerLike(manager).vat();\\n        address urn = ManagerLike(manager).urns(cdp);\\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\\n        (, uint art) = VatLike(vat).urns(ilk, urn);\\n\\n        address own = ManagerLike(manager).owns(cdp);\\n        if (own == address(this) || ManagerLike(manager).cdpCan(own, cdp, address(this)) == 1) {\\n            // Joins USB amount into the vat\\n            USBJoin_join(USBJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\\n            // Paybacks debt to the CDP\\n            frob(manager, cdp, 0, -int(art));\\n        } else {\\n            // Joins USB amount into the vat\\n            USBJoin_join(USBJoin, address(this), _getWipeAllWad(vat, address(this), urn, ilk));\\n            // Paybacks debt to the CDP\\n            VatLike(vat).frob(\\n                ilk,\\n                urn,\\n                address(this),\\n                address(this),\\n                0,\\n                -int(art)\\n            );\\n        }\\n    }\\n\\n    function safeWipeAll(\\n        address manager,\\n        address USBJoin,\\n        uint cdp,\\n        address owner\\n    ) public {\\n        require(ManagerLike(manager).owns(cdp) == owner, \\\"owner-missmatch\\\");\\n        wipeAll(manager, USBJoin, cdp);\\n    }\\n\\n    function lockETHAndDraw(\\n        address manager,\\n        address jug,\\n        address ethJoin,\\n        address USBJoin,\\n        uint cdp,\\n        uint wadD\\n    ) public payable {\\n        address urn = ManagerLike(manager).urns(cdp);\\n        address vat = ManagerLike(manager).vat();\\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\\n        // Receives ETH amount, converts it to WETH and joins it into the vat\\n        ethJoin_join(ethJoin, urn);\\n        // Locks WETH amount into the CDP and generates debt\\n        frob(manager, cdp, toInt(msg.value), _getDrawDart(vat, jug, urn, ilk, wadD));\\n        // Moves the USB amount (balance in the vat in rad) to proxy's address\\n        move(manager, cdp, address(this), toRad(wadD));\\n        // Allows adapter to access to proxy's USB balance in the vat\\n        if (VatLike(vat).can(address(this), address(USBJoin)) == 0) {\\n            VatLike(vat).hope(USBJoin);\\n        }\\n        // Exits USB to the user's wallet as a token\\n        USBJoinLike(USBJoin).exit(msg.sender, wadD);\\n    }\\n\\n    function openLockETHAndDraw(\\n        address manager,\\n        address jug,\\n        address ethJoin,\\n        address USBJoin,\\n        bytes32 ilk,\\n        uint wadD\\n    ) public payable returns (uint cdp) {\\n        cdp = open(manager, ilk, address(this));\\n        lockETHAndDraw(manager, jug, ethJoin, USBJoin, cdp, wadD);\\n    }\\n\\n    function lockGemAndDraw(\\n        address manager,\\n        address jug,\\n        address gemJoin,\\n        address USBJoin,\\n        uint cdp,\\n        uint amtC,\\n        uint wadD,\\n        bool transferFrom\\n    ) public {\\n        address urn = ManagerLike(manager).urns(cdp);\\n        address vat = ManagerLike(manager).vat();\\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\\n        // Takes token amount from user's wallet and joins into the vat\\n        gemJoin_join(gemJoin, urn, amtC, transferFrom);\\n        // Locks token amount into the CDP and generates debt\\n        frob(manager, cdp, toInt(convertTo18(gemJoin, amtC)), _getDrawDart(vat, jug, urn, ilk, wadD));\\n        // Moves the USB amount (balance in the vat in rad) to proxy's address\\n        move(manager, cdp, address(this), toRad(wadD));\\n        // Allows adapter to access to proxy's USB balance in the vat\\n        if (VatLike(vat).can(address(this), address(USBJoin)) == 0) {\\n            VatLike(vat).hope(USBJoin);\\n        }\\n        // Exits USB to the user's wallet as a token\\n        USBJoinLike(USBJoin).exit(msg.sender, wadD);\\n    }\\n\\n    function openLockGemAndDraw(\\n        address manager,\\n        address jug,\\n        address gemJoin,\\n        address USBJoin,\\n        bytes32 ilk,\\n        uint amtC,\\n        uint wadD,\\n        bool transferFrom\\n    ) public returns (uint cdp) {\\n        cdp = open(manager, ilk, address(this));\\n        lockGemAndDraw(manager, jug, gemJoin, USBJoin, cdp, amtC, wadD, transferFrom);\\n    }\\n\\n    function openLockGNTAndDraw(\\n        address manager,\\n        address jug,\\n        address gntJoin,\\n        address USBJoin,\\n        bytes32 ilk,\\n        uint amtC,\\n        uint wadD\\n    ) public returns (address bag, uint cdp) {\\n        // Creates bag (if doesn't exist) to hold GNT\\n        bag = GNTJoinLike(gntJoin).bags(address(this));\\n        if (bag == address(0)) {\\n            bag = makeGemBag(gntJoin);\\n        }\\n        // Transfer funds to the funds which previously were sent to the proxy\\n        GemLike(GemJoinLike(gntJoin).gem()).transfer(bag, amtC);\\n        cdp = openLockGemAndDraw(manager, jug, gntJoin, USBJoin, ilk, amtC, wadD, false);\\n    }\\n\\n    function wipeAndFreeETH(\\n        address manager,\\n        address ethJoin,\\n        address USBJoin,\\n        uint cdp,\\n        uint wadC,\\n        uint wadD\\n    ) public {\\n        address urn = ManagerLike(manager).urns(cdp);\\n        // Joins USB amount into the vat\\n        USBJoin_join(USBJoin, urn, wadD);\\n        // Paybacks debt to the CDP and unlocks WETH amount from it\\n        frob(\\n            manager,\\n            cdp,\\n            -toInt(wadC),\\n            _getWipeDart(ManagerLike(manager).vat(), VatLike(ManagerLike(manager).vat()).USB(urn), urn, ManagerLike(manager).ilks(cdp))\\n        );\\n        // Moves the amount from the CDP urn to proxy's address\\n        flux(manager, cdp, address(this), wadC);\\n        // Exits WETH amount to proxy address as a token\\n        GemJoinLike(ethJoin).exit(address(this), wadC);\\n        // Converts WETH to ETH\\n        GemJoinLike(ethJoin).gem().withdraw(wadC);\\n        // Sends ETH back to the user's wallet\\n        payable(msg.sender).transfer(wadC);\\n    }\\n\\n    function wipeAllAndFreeETH(\\n        address manager,\\n        address ethJoin,\\n        address USBJoin,\\n        uint cdp,\\n        uint wadC\\n    ) public {\\n        address vat = ManagerLike(manager).vat();\\n        address urn = ManagerLike(manager).urns(cdp);\\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\\n        (, uint art) = VatLike(vat).urns(ilk, urn);\\n\\n        // Joins USB amount into the vat\\n        USBJoin_join(USBJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\\n        // Paybacks debt to the CDP and unlocks WETH amount from it\\n        frob(\\n            manager,\\n            cdp,\\n            -toInt(wadC),\\n            -int(art)\\n        );\\n        // Moves the amount from the CDP urn to proxy's address\\n        flux(manager, cdp, address(this), wadC);\\n        // Exits WETH amount to proxy address as a token\\n        GemJoinLike(ethJoin).exit(address(this), wadC);\\n        // Converts WETH to ETH\\n        GemJoinLike(ethJoin).gem().withdraw(wadC);\\n        // Sends ETH back to the user's wallet\\n        payable(msg.sender).transfer(wadC);\\n    }\\n\\n    function wipeAndFreeGem(\\n        address manager,\\n        address gemJoin,\\n        address USBJoin,\\n        uint cdp,\\n        uint amtC,\\n        uint wadD\\n    ) public {\\n        address urn = ManagerLike(manager).urns(cdp);\\n        // Joins USB amount into the vat\\n        USBJoin_join(USBJoin, urn, wadD);\\n        uint wadC = convertTo18(gemJoin, amtC);\\n        // Paybacks debt to the CDP and unlocks token amount from it\\n        frob(\\n            manager,\\n            cdp,\\n            -toInt(wadC),\\n            _getWipeDart(ManagerLike(manager).vat(), VatLike(ManagerLike(manager).vat()).USB(urn), urn, ManagerLike(manager).ilks(cdp))\\n        );\\n        // Moves the amount from the CDP urn to proxy's address\\n        flux(manager, cdp, address(this), wadC);\\n        // Exits token amount to the user's wallet as a token\\n        GemJoinLike(gemJoin).exit(msg.sender, amtC);\\n    }\\n\\n    function wipeAllAndFreeGem(\\n        address manager,\\n        address gemJoin,\\n        address USBJoin,\\n        uint cdp,\\n        uint amtC\\n    ) public {\\n        address vat = ManagerLike(manager).vat();\\n        address urn = ManagerLike(manager).urns(cdp);\\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\\n        (, uint art) = VatLike(vat).urns(ilk, urn);\\n\\n        // Joins USB amount into the vat\\n        USBJoin_join(USBJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\\n        uint wadC = convertTo18(gemJoin, amtC);\\n        // Paybacks debt to the CDP and unlocks token amount from it\\n        frob(\\n            manager,\\n            cdp,\\n            -toInt(wadC),\\n            -int(art)\\n        );\\n        // Moves the amount from the CDP urn to proxy's address\\n        flux(manager, cdp, address(this), wadC);\\n        // Exits token amount to the user's wallet as a token\\n        GemJoinLike(gemJoin).exit(msg.sender, amtC);\\n    }\\n}\\n\\ncontract DssProxyActionsEnd is Common {\\n    // Internal functions\\n\\n    function _free(\\n        address manager,\\n        address end,\\n        uint cdp\\n    ) internal returns (uint ink) {\\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\\n        address urn = ManagerLike(manager).urns(cdp);\\n        VatLike vat = VatLike(ManagerLike(manager).vat());\\n        uint art;\\n        (ink, art) = vat.urns(ilk, urn);\\n\\n        // If CDP still has debt, it needs to be paid\\n        if (art > 0) {\\n            EndLike(end).skim(ilk, urn);\\n            (ink,) = vat.urns(ilk, urn);\\n        }\\n        // Approves the manager to transfer the position to proxy's address in the vat\\n        if (vat.can(address(this), address(manager)) == 0) {\\n            vat.hope(manager);\\n        }\\n        // Transfers position from CDP to the proxy address\\n        ManagerLike(manager).quit(cdp, address(this));\\n        // Frees the position and recovers the collateral in the vat registry\\n        EndLike(end).free(ilk);\\n    }\\n\\n    // Public functions\\n    function freeETH(\\n        address manager,\\n        address ethJoin,\\n        address end,\\n        uint cdp\\n    ) public {\\n        uint wad = _free(manager, end, cdp);\\n        // Exits WETH amount to proxy address as a token\\n        GemJoinLike(ethJoin).exit(address(this), wad);\\n        // Converts WETH to ETH\\n        GemJoinLike(ethJoin).gem().withdraw(wad);\\n        // Sends ETH back to the user's wallet\\n        payable(msg.sender).transfer(wad);\\n    }\\n\\n    function freeGem(\\n        address manager,\\n        address gemJoin,\\n        address end,\\n        uint cdp\\n    ) public {\\n        uint amt = _free(manager, end, cdp) / 10 ** (18 - GemJoinLike(gemJoin).dec());\\n        // Exits token amount to the user's wallet as a token\\n        GemJoinLike(gemJoin).exit(msg.sender, amt);\\n    }\\n\\n    function pack(\\n        address USBJoin,\\n        address end,\\n        uint wad\\n    ) public {\\n        USBJoin_join(USBJoin, address(this), wad);\\n        VatLike vat = USBJoinLike(USBJoin).vat();\\n        // Approves the end to take out USB from the proxy's balance in the vat\\n        if (vat.can(address(this), address(end)) == 0) {\\n            vat.hope(end);\\n        }\\n        EndLike(end).pack(wad);\\n    }\\n\\n    function cashETH(\\n        address ethJoin,\\n        address end,\\n        bytes32 ilk,\\n        uint wad\\n    ) public {\\n        EndLike(end).cash(ilk, wad);\\n        uint wadC = mul(wad, EndLike(end).fix(ilk)) / RAY;\\n        // Exits WETH amount to proxy address as a token\\n        GemJoinLike(ethJoin).exit(address(this), wadC);\\n        // Converts WETH to ETH\\n        GemJoinLike(ethJoin).gem().withdraw(wadC);\\n        // Sends ETH back to the user's wallet\\n        payable(msg.sender).transfer(wadC);\\n    }\\n\\n    function cashGem(\\n        address gemJoin,\\n        address end,\\n        bytes32 ilk,\\n        uint wad\\n    ) public {\\n        EndLike(end).cash(ilk, wad);\\n        // Exits token amount to the user's wallet as a token\\n        uint amt = mul(wad, EndLike(end).fix(ilk)) / RAY / 10 ** (18 - GemJoinLike(gemJoin).dec());\\n        GemJoinLike(gemJoin).exit(msg.sender, amt);\\n    }\\n}\\n\\ncontract DssProxyActionsDsr is Common {\\n    function join(\\n        address USBJoin,\\n        address pot,\\n        uint wad\\n    ) public {\\n        VatLike vat = USBJoinLike(USBJoin).vat();\\n        // Executes drip to get the chi rate updated to rho == now, otherwise join will fail\\n        uint chi = PotLike(pot).drip();\\n        // Joins wad amount to the vat balance\\n        USBJoin_join(USBJoin, address(this), wad);\\n        // Approves the pot to take out USB from the proxy's balance in the vat\\n        if (vat.can(address(this), address(pot)) == 0) {\\n            vat.hope(pot);\\n        }\\n        // Joins the pie value (equivalent to the USB wad amount) in the pot\\n        PotLike(pot).join(mul(wad, RAY) / chi);\\n    }\\n\\n    function exit(\\n        address USBJoin,\\n        address pot,\\n        uint wad\\n    ) public {\\n        VatLike vat = USBJoinLike(USBJoin).vat();\\n        // Executes drip to count the savings accumulated until this moment\\n        uint chi = PotLike(pot).drip();\\n        // Calculates the pie value in the pot equivalent to the USB wad amount\\n        uint pie = mul(wad, RAY) / chi;\\n        // Exits USB from the pot\\n        PotLike(pot).exit(pie);\\n        // Checks the actual balance of USB in the vat after the pot exit\\n        uint bal = USBJoinLike(USBJoin).vat().USB(address(this));\\n        // Allows adapter to access to proxy's USB balance in the vat\\n        if (vat.can(address(this), address(USBJoin)) == 0) {\\n            vat.hope(USBJoin);\\n        }\\n        // It is necessary to check if due rounding the exact wad amount can be exited by the adapter.\\n        // Otherwise it will do the maximum USB balance in the vat\\n        USBJoinLike(USBJoin).exit(\\n            msg.sender,\\n            bal >= mul(wad, RAY) ? wad : bal / RAY\\n        );\\n    }\\n\\n    function exitAll(\\n        address USBJoin,\\n        address pot\\n    ) public {\\n        VatLike vat = USBJoinLike(USBJoin).vat();\\n        // Executes drip to count the savings accumulated until this moment\\n        uint chi = PotLike(pot).drip();\\n        // Gets the total pie belonging to the proxy address\\n        uint pie = PotLike(pot).pie(address(this));\\n        // Exits USB from the pot\\n        PotLike(pot).exit(pie);\\n        // Allows adapter to access to proxy's USB balance in the vat\\n        if (vat.can(address(this), address(USBJoin)) == 0) {\\n            vat.hope(USBJoin);\\n        }\\n        // Exits the USB amount corresponding to the value of pie\\n        USBJoinLike(USBJoin).exit(msg.sender, mul(chi, pie) / RAY);\\n    }\\n}\"\r\n    },\r\n    \"./contracts/pot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// pot.sol -- USB Savings Rate\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\n/*\\r\\n   \\\"Savings USB\\\" is obtained when USB is deposited into\\r\\n   this contract. Each \\\"Savings USB\\\" accrues USB interest\\r\\n   at the \\\"USB Savings Rate\\\".\\r\\n\\r\\n   This contract does not implement a user tradeable token\\r\\n   and is intended to be used with adapters.\\r\\n\\r\\n         --- `save` your `USB` in the `pot` ---\\r\\n\\r\\n   - `dsr`: the USB Savings Rate\\r\\n   - `pie`: user balance of Savings USB\\r\\n\\r\\n   - `join`: start saving some USB\\r\\n   - `exit`: remove some USB\\r\\n   - `drip`: perform rate collection\\r\\n\\r\\n*/\\r\\n\\r\\ninterface VatLike {\\r\\n    function move(address,address,uint256) external;\\r\\n    function suck(address,address,uint256) external;\\r\\n}\\r\\n\\r\\ncontract Pot {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address guy) external auth { wards[guy] = 1; }\\r\\n    function deny(address guy) external auth { wards[guy] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"Pot/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    mapping (address => uint256) public pie;  // Normalised Savings USB [wad]\\r\\n\\r\\n    uint256 public Pie;   // Total Normalised Savings USB  [wad]\\r\\n    uint256 public dsr;   // The USB Savings Rate          [ray]\\r\\n    uint256 public chi;   // The Rate Accumulator          [ray]\\r\\n\\r\\n    VatLike public vat;   // CDP Engine\\r\\n    address public vow;   // Debt Engine\\r\\n    uint256 public rho;   // Time of last drip     [unix epoch time]\\r\\n\\r\\n    uint256 public live;  // Active Flag\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address vat_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        vat = VatLike(vat_);\\r\\n        dsr = ONE;\\r\\n        chi = ONE;\\r\\n        rho = block.timestamp;\\r\\n        live = 1;\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    uint256 constant ONE = 10 ** 27;\\r\\n    function rpow(uint x, uint n, uint base) internal pure returns (uint z) {\\r\\n        assembly {\\r\\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\\r\\n            default {\\r\\n                switch mod(n, 2) case 0 { z := base } default { z := x }\\r\\n                let half := div(base, 2)  // for rounding.\\r\\n                for { n := div(n, 2) } n { n := div(n,2) } {\\r\\n                    let xx := mul(x, x)\\r\\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\\r\\n                    let xxRound := add(xx, half)\\r\\n                    if lt(xxRound, xx) { revert(0,0) }\\r\\n                    x := div(xxRound, base)\\r\\n                    if mod(n,2) {\\r\\n                        let zx := mul(z, x)\\r\\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\\r\\n                        let zxRound := add(zx, half)\\r\\n                        if lt(zxRound, zx) { revert(0,0) }\\r\\n                        z := div(zxRound, base)\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = mul(x, y) / ONE;\\r\\n    }\\r\\n\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x);\\r\\n    }\\r\\n\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n\\r\\n    // --- Administration ---\\r\\n    function file(bytes32 what, uint256 data) external auth {\\r\\n        require(live == 1, \\\"Pot/not-live\\\");\\r\\n        require(block.timestamp == rho, \\\"Pot/rho-not-updated\\\");\\r\\n        if (what == \\\"dsr\\\") dsr = data;\\r\\n        else revert(\\\"Pot/file-unrecognized-param\\\");\\r\\n    }\\r\\n\\r\\n    function file(bytes32 what, address addr) external auth {\\r\\n        if (what == \\\"vow\\\") vow = addr;\\r\\n        else revert(\\\"Pot/file-unrecognized-param\\\");\\r\\n    }\\r\\n\\r\\n    function cage() external auth {\\r\\n        live = 0;\\r\\n        dsr = ONE;\\r\\n    }\\r\\n\\r\\n    // --- Savings Rate Accumulation ---\\r\\n    function drip() external returns (uint tmp) {\\r\\n        require(block.timestamp >= rho, \\\"Pot/invalid-now\\\");\\r\\n        tmp = rmul(rpow(dsr, block.timestamp - rho, ONE), chi);\\r\\n        uint chi_ = sub(tmp, chi);\\r\\n        chi = tmp;\\r\\n        rho = block.timestamp;\\r\\n        vat.suck(address(vow), address(this), mul(Pie, chi_));\\r\\n    }\\r\\n\\r\\n    // --- Savings USB Management ---\\r\\n    function join(uint wad) external {\\r\\n        require(block.timestamp == rho, \\\"Pot/rho-not-updated\\\");\\r\\n        pie[msg.sender] = add(pie[msg.sender], wad);\\r\\n        Pie             = add(Pie,             wad);\\r\\n        vat.move(msg.sender, address(this), mul(chi, wad));\\r\\n    }\\r\\n\\r\\n    function exit(uint wad) external {\\r\\n        pie[msg.sender] = sub(pie[msg.sender], wad);\\r\\n        Pie             = sub(Pie,             wad);\\r\\n        vat.move(address(this), msg.sender, mul(chi, wad));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/dog.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// dog.sol -- Dai liquidation module 2.0\\r\\n\\r\\n\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ClipperLike {\\r\\n    function ilk() external view returns (bytes32);\\r\\n    function kick(\\r\\n        uint256 tab,\\r\\n        uint256 lot,\\r\\n        address usr,\\r\\n        address kpr\\r\\n    ) external returns (uint256);\\r\\n}\\r\\n\\r\\ninterface VatLike {\\r\\n    function ilks(bytes32) external view returns (\\r\\n        uint256 Art,  // [wad]\\r\\n        uint256 rate, // [ray]\\r\\n        uint256 spot, // [ray]\\r\\n        uint256 line, // [rad]\\r\\n        uint256 dust  // [rad]\\r\\n    );\\r\\n    function urns(bytes32,address) external view returns (\\r\\n        uint256 ink,  // [wad]\\r\\n        uint256 art   // [wad]\\r\\n    );\\r\\n    function grab(bytes32,address,address,address,int256,int256) external;\\r\\n    function hope(address) external;\\r\\n    function nope(address) external;\\r\\n}\\r\\n\\r\\ninterface VowLike {\\r\\n    function fess(uint256) external;\\r\\n}\\r\\n\\r\\ncontract Dog {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint256) public wards;\\r\\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"Dog/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    struct Ilk {\\r\\n        address clip;  // Liquidator\\r\\n        uint256 chop;  // Liquidation Penalty                                          [wad]\\r\\n        uint256 hole;  // Max DAI needed to cover debt+fees of active auctions per ilk [rad]\\r\\n        uint256 dirt;  // Amt DAI needed to cover debt+fees of active auctions per ilk [rad]\\r\\n    }\\r\\n\\r\\n    VatLike immutable public vat;  // CDP Engine\\r\\n\\r\\n    mapping (bytes32 => Ilk) public ilks;\\r\\n\\r\\n    VowLike public vow;   // Debt Engine\\r\\n    uint256 public live;  // Active Flag\\r\\n    uint256 public Hole;  // Max DAI needed to cover debt+fees of active auctions [rad]\\r\\n    uint256 public Dirt;  // Amt DAI needed to cover debt+fees of active auctions [rad]\\r\\n\\r\\n    // --- Events ---\\r\\n    event Rely(address indexed usr);\\r\\n    event Deny(address indexed usr);\\r\\n\\r\\n    event File(bytes32 indexed what, uint256 data);\\r\\n    event File(bytes32 indexed what, address data);\\r\\n    event File(bytes32 indexed ilk, bytes32 indexed what, uint256 data);\\r\\n    event File(bytes32 indexed ilk, bytes32 indexed what, address clip);\\r\\n\\r\\n    event Bark(\\r\\n      bytes32 indexed ilk,\\r\\n      address indexed urn,\\r\\n      uint256 ink,\\r\\n      uint256 art,\\r\\n      uint256 due,\\r\\n      address clip,\\r\\n      uint256 indexed id\\r\\n    );\\r\\n    event Digs(bytes32 indexed ilk, uint256 rad);\\r\\n    event Cage();\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address vat_) public {\\r\\n        vat = VatLike(vat_);\\r\\n        live = 1;\\r\\n        wards[msg.sender] = 1;\\r\\n        emit Rely(msg.sender);\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    uint256 constant WAD = 10 ** 18;\\r\\n\\r\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = x <= y ? x : y;\\r\\n    }\\r\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x - y) <= x);\\r\\n    }\\r\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n\\r\\n    // --- Administration ---\\r\\n    function file(bytes32 what, address data) external auth {\\r\\n        if (what == \\\"vow\\\") vow = VowLike(data);\\r\\n        else revert(\\\"Dog/file-unrecognized-param\\\");\\r\\n        emit File(what, data);\\r\\n    }\\r\\n    function file(bytes32 what, uint256 data) external auth {\\r\\n        if (what == \\\"Hole\\\") Hole = data;\\r\\n        else revert(\\\"Dog/file-unrecognized-param\\\");\\r\\n        emit File(what, data);\\r\\n    }\\r\\n    function file(bytes32 ilk, bytes32 what, uint256 data) external auth {\\r\\n        if (what == \\\"chop\\\") {\\r\\n            require(data >= WAD, \\\"Dog/file-chop-lt-WAD\\\");\\r\\n            ilks[ilk].chop = data;\\r\\n        } else if (what == \\\"hole\\\") ilks[ilk].hole = data;\\r\\n        else revert(\\\"Dog/file-unrecognized-param\\\");\\r\\n        emit File(ilk, what, data);\\r\\n    }\\r\\n    function file(bytes32 ilk, bytes32 what, address clip) external auth {\\r\\n        if (what == \\\"clip\\\") {\\r\\n            require(ilk == ClipperLike(clip).ilk(), \\\"Dog/file-ilk-neq-clip.ilk\\\");\\r\\n            ilks[ilk].clip = clip;\\r\\n        } else revert(\\\"Dog/file-unrecognized-param\\\");\\r\\n        emit File(ilk, what, clip);\\r\\n    }\\r\\n\\r\\n    function chop(bytes32 ilk) external view returns (uint256) {\\r\\n        return ilks[ilk].chop;\\r\\n    }\\r\\n\\r\\n    // --- CDP Liquidation: all bark and no bite ---\\r\\n    //\\r\\n    // Liquidate a Vault and start a Dutch auction to sell its collateral for DAI.\\r\\n    //\\r\\n    // The third argument is the address that will receive the liquidation reward, if any.\\r\\n    //\\r\\n    // The entire Vault will be liquidated except when the target amount of DAI to be raised in\\r\\n    // the resulting auction (debt of Vault + liquidation penalty) causes either Dirt to exceed\\r\\n    // Hole or ilk.dirt to exceed ilk.hole by an economically significant amount. In that\\r\\n    // case, a partial liquidation is performed to respect the global and per-ilk limits on\\r\\n    // outstanding DAI target. The one exception is if the resulting auction would likely\\r\\n    // have too little collateral to be interesting to Keepers (debt taken from Vault < ilk.dust),\\r\\n    // in which case the function reverts. Please refer to the code and comments within if\\r\\n    // more detail is desired.\\r\\n    function bark(bytes32 ilk, address urn, address kpr) external returns (uint256 id) {\\r\\n        require(live == 1, \\\"Dog/not-live\\\");\\r\\n\\r\\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\\r\\n        Ilk memory milk = ilks[ilk];\\r\\n        uint256 dart;\\r\\n        uint256 rate;\\r\\n        uint256 dust;\\r\\n        {\\r\\n            uint256 spot;\\r\\n            (,rate, spot,, dust) = vat.ilks(ilk);\\r\\n            require(spot > 0 && mul(ink, spot) < mul(art, rate), \\\"Dog/not-unsafe\\\");\\r\\n\\r\\n            // Get the minimum value between:\\r\\n            // 1) Remaining space in the general Hole\\r\\n            // 2) Remaining space in the collateral hole\\r\\n            require(Hole > Dirt && milk.hole > milk.dirt, \\\"Dog/liquidation-limit-hit\\\");\\r\\n            uint256 room = min(Hole - Dirt, milk.hole - milk.dirt);\\r\\n\\r\\n            // uint256.max()/(RAD*WAD) = 115,792,089,237,316\\r\\n            dart = min(art, mul(room, WAD) / rate / milk.chop);\\r\\n\\r\\n            // Partial liquidation edge case logic\\r\\n            if (art > dart) {\\r\\n                if (mul(art - dart, rate) < dust) {\\r\\n\\r\\n                    // If the leftover Vault would be dusty, just liquidate it entirely.\\r\\n                    // This will result in at least one of dirt_i > hole_i or Dirt > Hole becoming true.\\r\\n                    // The amount of excess will be bounded above by ceiling(dust_i * chop_i / WAD).\\r\\n                    // This deviation is assumed to be small compared to both hole_i and Hole, so that\\r\\n                    // the extra amount of target DAI over the limits intended is not of economic concern.\\r\\n                    dart = art;\\r\\n                } else {\\r\\n\\r\\n                    // In a partial liquidation, the resulting auction should also be non-dusty.\\r\\n                    require(mul(dart, rate) >= dust, \\\"Dog/dusty-auction-from-partial-liquidation\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 dink = mul(ink, dart) / art;\\r\\n\\r\\n        require(dink > 0, \\\"Dog/null-auction\\\");\\r\\n        require(dart <= 2**255 && dink <= 2**255, \\\"Dog/overflow\\\");\\r\\n\\r\\n        vat.grab(\\r\\n            ilk, urn, milk.clip, address(vow), -int256(dink), -int256(dart)\\r\\n        );\\r\\n\\r\\n        uint256 due = mul(dart, rate);\\r\\n        vow.fess(due);\\r\\n\\r\\n        {   // Avoid stack too deep\\r\\n            // This calcuation will overflow if dart*rate exceeds ~10^14\\r\\n            uint256 tab = mul(due, milk.chop) / WAD;\\r\\n            Dirt = add(Dirt, tab);\\r\\n            ilks[ilk].dirt = add(milk.dirt, tab);\\r\\n\\r\\n            id = ClipperLike(milk.clip).kick({\\r\\n                tab: tab,\\r\\n                lot: dink,\\r\\n                usr: urn,\\r\\n                kpr: kpr\\r\\n            });\\r\\n        }\\r\\n\\r\\n        emit Bark(ilk, urn, dink, dart, due, milk.clip, id);\\r\\n    }\\r\\n\\r\\n    function digs(bytes32 ilk, uint256 rad) external auth {\\r\\n        Dirt = sub(Dirt, rad);\\r\\n        ilks[ilk].dirt = sub(ilks[ilk].dirt, rad);\\r\\n        emit Digs(ilk, rad);\\r\\n    }\\r\\n\\r\\n    function cage() external auth {\\r\\n        live = 0;\\r\\n        emit Cage();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/DssCdpManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// DssCdpManager.sol\\r\\n\\r\\n\\r\\n\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface VatLike {\\r\\n    function urns(bytes32, address) external view returns (uint, uint);\\r\\n    function hope(address) external;\\r\\n    function flux(bytes32, address, address, uint) external;\\r\\n    function move(address, address, uint) external;\\r\\n    function frob(bytes32, address, address, address, int, int) external;\\r\\n    function fork(bytes32, address, address, int, int) external;\\r\\n}\\r\\n\\r\\ncontract UrnHandler {\\r\\n    constructor(address vat) public {\\r\\n        VatLike(vat).hope(msg.sender);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract DssCdpManager {\\r\\n    address                   public vat;\\r\\n    uint                      public cdpi;      // Auto incremental\\r\\n    mapping (uint => address) public urns;      // CDPId => UrnHandler\\r\\n    mapping (uint => List)    public list;      // CDPId => Prev & Next CDPIds (double linked list)\\r\\n    mapping (uint => address) public owns;      // CDPId => Owner\\r\\n    mapping (uint => bytes32) public ilks;      // CDPId => Ilk\\r\\n\\r\\n    mapping (address => uint) public first;     // Owner => First CDPId\\r\\n    mapping (address => uint) public last;      // Owner => Last CDPId\\r\\n    mapping (address => uint) public count;     // Owner => Amount of CDPs\\r\\n\\r\\n    mapping (\\r\\n        address => mapping (\\r\\n            uint => mapping (\\r\\n                address => uint\\r\\n            )\\r\\n        )\\r\\n    ) public cdpCan;                            // Owner => CDPId => Allowed Addr => True/False\\r\\n\\r\\n    mapping (\\r\\n        address => mapping (\\r\\n            address => uint\\r\\n        )\\r\\n    ) public urnCan;                            // Urn => Allowed Addr => True/False\\r\\n\\r\\n    struct List {\\r\\n        uint prev;\\r\\n        uint next;\\r\\n    }\\r\\n\\r\\n    event NewCdp(address indexed usr, address indexed own, uint indexed cdp);\\r\\n\\r\\n    modifier cdpAllowed(\\r\\n        uint cdp\\r\\n    ) {\\r\\n        require(msg.sender == owns[cdp] || cdpCan[owns[cdp]][cdp][msg.sender] == 1, \\\"cdp-not-allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier urnAllowed(\\r\\n        address urn\\r\\n    ) {\\r\\n        require(msg.sender == urn || urnCan[urn][msg.sender] == 1, \\\"urn-not-allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address vat_) public {\\r\\n        vat = vat_;\\r\\n    }\\r\\n\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x);\\r\\n    }\\r\\n\\r\\n    function toInt(uint x) internal pure returns (int y) {\\r\\n        y = int(x);\\r\\n        require(y >= 0);\\r\\n    }\\r\\n\\r\\n    // Allow/disallow a usr address to manage the cdp.\\r\\n    function cdpAllow(\\r\\n        uint cdp,\\r\\n        address usr,\\r\\n        uint ok\\r\\n    ) public cdpAllowed(cdp) {\\r\\n        cdpCan[owns[cdp]][cdp][usr] = ok;\\r\\n    }\\r\\n\\r\\n    // Allow/disallow a usr address to quit to the the sender urn.\\r\\n    function urnAllow(\\r\\n        address usr,\\r\\n        uint ok\\r\\n    ) public {\\r\\n        urnCan[msg.sender][usr] = ok;\\r\\n    }\\r\\n\\r\\n    // Open a new cdp for a given usr address.\\r\\n    function open(\\r\\n        bytes32 ilk,\\r\\n        address usr\\r\\n    ) public returns (uint) {\\r\\n        require(usr != address(0), \\\"usr-address-0\\\");\\r\\n\\r\\n        cdpi = add(cdpi, 1);\\r\\n        urns[cdpi] = address(new UrnHandler(vat));\\r\\n        owns[cdpi] = usr;\\r\\n        ilks[cdpi] = ilk;\\r\\n\\r\\n        // Add new CDP to double linked list and pointers\\r\\n        if (first[usr] == 0) {\\r\\n            first[usr] = cdpi;\\r\\n        }\\r\\n        if (last[usr] != 0) {\\r\\n            list[cdpi].prev = last[usr];\\r\\n            list[last[usr]].next = cdpi;\\r\\n        }\\r\\n        last[usr] = cdpi;\\r\\n        count[usr] = add(count[usr], 1);\\r\\n\\r\\n        emit NewCdp(msg.sender, usr, cdpi);\\r\\n        return cdpi;\\r\\n    }\\r\\n\\r\\n    // Give the cdp ownership to a dst address.\\r\\n    function give(\\r\\n        uint cdp,\\r\\n        address dst\\r\\n    ) public cdpAllowed(cdp) {\\r\\n        require(dst != address(0), \\\"dst-address-0\\\");\\r\\n        require(dst != owns[cdp], \\\"dst-already-owner\\\");\\r\\n\\r\\n        // Remove transferred CDP from double linked list of origin user and pointers\\r\\n        if (list[cdp].prev != 0) {\\r\\n            list[list[cdp].prev].next = list[cdp].next;         // Set the next pointer of the prev cdp (if exists) to the next of the transferred one\\r\\n        }\\r\\n        if (list[cdp].next != 0) {                              // If wasn't the last one\\r\\n            list[list[cdp].next].prev = list[cdp].prev;         // Set the prev pointer of the next cdp to the prev of the transferred one\\r\\n        } else {                                                // If was the last one\\r\\n            last[owns[cdp]] = list[cdp].prev;                   // Update last pointer of the owner\\r\\n        }\\r\\n        if (first[owns[cdp]] == cdp) {                          // If was the first one\\r\\n            first[owns[cdp]] = list[cdp].next;                  // Update first pointer of the owner\\r\\n        }\\r\\n        count[owns[cdp]] = sub(count[owns[cdp]], 1);\\r\\n\\r\\n        // Transfer ownership\\r\\n        owns[cdp] = dst;\\r\\n\\r\\n        // Add transferred CDP to double linked list of destiny user and pointers\\r\\n        list[cdp].prev = last[dst];\\r\\n        list[cdp].next = 0;\\r\\n        if (last[dst] != 0) {\\r\\n            list[last[dst]].next = cdp;\\r\\n        }\\r\\n        if (first[dst] == 0) {\\r\\n            first[dst] = cdp;\\r\\n        }\\r\\n        last[dst] = cdp;\\r\\n        count[dst] = add(count[dst], 1);\\r\\n    }\\r\\n\\r\\n    // Frob the cdp keeping the generated USB or collateral freed in the cdp urn address.\\r\\n    function frob(\\r\\n        uint cdp,\\r\\n        int dink,\\r\\n        int dart\\r\\n    ) public cdpAllowed(cdp) {\\r\\n        address urn = urns[cdp];\\r\\n        VatLike(vat).frob(\\r\\n            ilks[cdp],\\r\\n            urn,\\r\\n            urn,\\r\\n            urn,\\r\\n            dink,\\r\\n            dart\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // Transfer wad amount of cdp collateral from the cdp address to a dst address.\\r\\n    function flux(\\r\\n        uint cdp,\\r\\n        address dst,\\r\\n        uint wad\\r\\n    ) public cdpAllowed(cdp) {\\r\\n        VatLike(vat).flux(ilks[cdp], urns[cdp], dst, wad);\\r\\n    }\\r\\n\\r\\n    // Transfer wad amount of any type of collateral (ilk) from the cdp address to a dst address.\\r\\n    // This function has the purpose to take away collateral from the system that doesn't correspond to the cdp but was sent there wrongly.\\r\\n    function flux(\\r\\n        bytes32 ilk,\\r\\n        uint cdp,\\r\\n        address dst,\\r\\n        uint wad\\r\\n    ) public cdpAllowed(cdp) {\\r\\n        VatLike(vat).flux(ilk, urns[cdp], dst, wad);\\r\\n    }\\r\\n\\r\\n    // Transfer wad amount of USB from the cdp address to a dst address.\\r\\n    function move(\\r\\n        uint cdp,\\r\\n        address dst,\\r\\n        uint rad\\r\\n    ) public cdpAllowed(cdp) {\\r\\n        VatLike(vat).move(urns[cdp], dst, rad);\\r\\n    }\\r\\n\\r\\n    // Quit the system, migrating the cdp (ink, art) to a different dst urn\\r\\n    function quit(\\r\\n        uint cdp,\\r\\n        address dst\\r\\n    ) public cdpAllowed(cdp) urnAllowed(dst) {\\r\\n        (uint ink, uint art) = VatLike(vat).urns(ilks[cdp], urns[cdp]);\\r\\n        VatLike(vat).fork(\\r\\n            ilks[cdp],\\r\\n            urns[cdp],\\r\\n            dst,\\r\\n            toInt(ink),\\r\\n            toInt(art)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // Import a position from src urn to the urn owned by cdp\\r\\n    function enter(\\r\\n        address src,\\r\\n        uint cdp\\r\\n    ) public urnAllowed(src) cdpAllowed(cdp) {\\r\\n        (uint ink, uint art) = VatLike(vat).urns(ilks[cdp], src);\\r\\n        VatLike(vat).fork(\\r\\n            ilks[cdp],\\r\\n            src,\\r\\n            urns[cdp],\\r\\n            toInt(ink),\\r\\n            toInt(art)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // Move a position from cdpSrc urn to the cdpDst urn\\r\\n    function shift(\\r\\n        uint cdpSrc,\\r\\n        uint cdpDst\\r\\n    ) public cdpAllowed(cdpSrc) cdpAllowed(cdpDst) {\\r\\n        require(ilks[cdpSrc] == ilks[cdpDst], \\\"non-matching-cdps\\\");\\r\\n        (uint ink, uint art) = VatLike(vat).urns(ilks[cdpSrc], urns[cdpSrc]);\\r\\n        VatLike(vat).fork(\\r\\n            ilks[cdpSrc],\\r\\n            urns[cdpSrc],\\r\\n            urns[cdpDst],\\r\\n            toInt(ink),\\r\\n            toInt(art)\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/abaci.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published\\r\\n// by the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface Abacus {\\r\\n    // 1st arg: initial price               [ray]\\r\\n    // 2nd arg: seconds since auction start [seconds]\\r\\n    // returns: current auction price       [ray]\\r\\n    function price(uint256, uint256) external view returns (uint256);\\r\\n}\\r\\n\\r\\ncontract LinearDecrease is Abacus {\\r\\n\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint256) public wards;\\r\\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"LinearDecrease/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    uint256 public tau;  // Seconds after auction start when the price reaches zero [seconds]\\r\\n\\r\\n    // --- Events ---\\r\\n    event Rely(address indexed usr);\\r\\n    event Deny(address indexed usr);\\r\\n\\r\\n    event File(bytes32 indexed what, uint256 data);\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor() public {\\r\\n        wards[msg.sender] = 1;\\r\\n        emit Rely(msg.sender);\\r\\n    }\\r\\n\\r\\n    // --- Administration ---\\r\\n    function file(bytes32 what, uint256 data) external auth {\\r\\n        if (what ==  \\\"tau\\\") tau = data;\\r\\n        else revert(\\\"LinearDecrease/file-unrecognized-param\\\");\\r\\n        emit File(what, data);\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    uint256 constant RAY = 10 ** 27;\\r\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = x * y;\\r\\n        require(y == 0 || z / y == x);\\r\\n        z = z / RAY;\\r\\n    }\\r\\n\\r\\n    // Price calculation when price is decreased linearly in proportion to time:\\r\\n    // tau: The number of seconds after the start of the auction where the price will hit 0\\r\\n    // top: Initial price\\r\\n    // dur: current seconds since the start of the auction\\r\\n    //\\r\\n    // Returns y = top * ((tau - dur) / tau)\\r\\n    //\\r\\n    // Note the internal call to mul multiples by RAY, thereby ensuring that the rmul calculation\\r\\n    // which utilizes top and tau (RAY values) is also a RAY value.\\r\\n    function price(uint256 top, uint256 dur) override external view returns (uint256) {\\r\\n        if (dur >= tau) return 0;\\r\\n        return rmul(top, mul(tau - dur, RAY) / tau);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract StairstepExponentialDecrease is Abacus {\\r\\n\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint256) public wards;\\r\\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"StairstepExponentialDecrease/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    uint256 public step; // Length of time between price drops [seconds]\\r\\n    uint256 public cut;  // Per-step multiplicative factor     [ray]\\r\\n\\r\\n    // --- Events ---\\r\\n    event Rely(address indexed usr);\\r\\n    event Deny(address indexed usr);\\r\\n\\r\\n    event File(bytes32 indexed what, uint256 data);\\r\\n\\r\\n    // --- Init ---\\r\\n    // @notice: `cut` and `step` values must be correctly set for\\r\\n    //     this contract to return a valid price\\r\\n    constructor() public {\\r\\n        wards[msg.sender] = 1;\\r\\n        emit Rely(msg.sender);\\r\\n    }\\r\\n\\r\\n    // --- Administration ---\\r\\n    function file(bytes32 what, uint256 data) external auth {\\r\\n        if      (what ==  \\\"cut\\\") require((cut = data) <= RAY, \\\"StairstepExponentialDecrease/cut-gt-RAY\\\");\\r\\n        else if (what == \\\"step\\\") step = data;\\r\\n        else revert(\\\"StairstepExponentialDecrease/file-unrecognized-param\\\");\\r\\n        emit File(what, data);\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    uint256 constant RAY = 10 ** 27;\\r\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = x * y;\\r\\n        require(y == 0 || z / y == x);\\r\\n        z = z / RAY;\\r\\n    }\\r\\n    // optimized version from dss PR #78\\r\\n    function rpow(uint256 x, uint256 n, uint256 b) internal pure returns (uint256 z) {\\r\\n        assembly {\\r\\n            switch n case 0 { z := b }\\r\\n            default {\\r\\n                switch x case 0 { z := 0 }\\r\\n                default {\\r\\n                    switch mod(n, 2) case 0 { z := b } default { z := x }\\r\\n                    let half := div(b, 2)  // for rounding.\\r\\n                    for { n := div(n, 2) } n { n := div(n,2) } {\\r\\n                        let xx := mul(x, x)\\r\\n                        if shr(128, x) { revert(0,0) }\\r\\n                        let xxRound := add(xx, half)\\r\\n                        if lt(xxRound, xx) { revert(0,0) }\\r\\n                        x := div(xxRound, b)\\r\\n                        if mod(n,2) {\\r\\n                            let zx := mul(z, x)\\r\\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\\r\\n                            let zxRound := add(zx, half)\\r\\n                            if lt(zxRound, zx) { revert(0,0) }\\r\\n                            z := div(zxRound, b)\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // top: initial price\\r\\n    // dur: seconds since the auction has started\\r\\n    // step: seconds between a price drop\\r\\n    // cut: cut encodes the percentage to decrease per step.\\r\\n    //   For efficiency, the values is set as (1 - (% value / 100)) * RAY\\r\\n    //   So, for a 1% decrease per step, cut would be (1 - 0.01) * RAY\\r\\n    //\\r\\n    // returns: top * (cut ^ dur)\\r\\n    //\\r\\n    //\\r\\n    function price(uint256 top, uint256 dur) override external view returns (uint256) {\\r\\n        return rmul(top, rpow(cut, dur / step, RAY));\\r\\n    }\\r\\n}\\r\\n\\r\\n// While an equivalent function can be obtained by setting step = 1 in StairstepExponentialDecrease,\\r\\n// this continous (i.e. per-second) exponential decrease has be implemented as it is more gas-efficient\\r\\n// than using the stairstep version with step = 1 (primarily due to 1 fewer SLOAD per price calculation).\\r\\ncontract ExponentialDecrease is Abacus {\\r\\n\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint256) public wards;\\r\\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"ExponentialDecrease/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    uint256 public cut;  // Per-second multiplicative factor [ray]\\r\\n\\r\\n    // --- Events ---\\r\\n    event Rely(address indexed usr);\\r\\n    event Deny(address indexed usr);\\r\\n\\r\\n    event File(bytes32 indexed what, uint256 data);\\r\\n\\r\\n    // --- Init ---\\r\\n    // @notice: `cut` value must be correctly set for\\r\\n    //     this contract to return a valid price\\r\\n    constructor() public {\\r\\n        wards[msg.sender] = 1;\\r\\n        emit Rely(msg.sender);\\r\\n    }\\r\\n\\r\\n    // --- Administration ---\\r\\n    function file(bytes32 what, uint256 data) external auth {\\r\\n        if      (what ==  \\\"cut\\\") require((cut = data) <= RAY, \\\"ExponentialDecrease/cut-gt-RAY\\\");\\r\\n        else revert(\\\"ExponentialDecrease/file-unrecognized-param\\\");\\r\\n        emit File(what, data);\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    uint256 constant RAY = 10 ** 27;\\r\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = x * y;\\r\\n        require(y == 0 || z / y == x);\\r\\n        z = z / RAY;\\r\\n    }\\r\\n    // optimized version from dss PR #78\\r\\n    function rpow(uint256 x, uint256 n, uint256 b) internal pure returns (uint256 z) {\\r\\n        assembly {\\r\\n            switch n case 0 { z := b }\\r\\n            default {\\r\\n                switch x case 0 { z := 0 }\\r\\n                default {\\r\\n                    switch mod(n, 2) case 0 { z := b } default { z := x }\\r\\n                    let half := div(b, 2)  // for rounding.\\r\\n                    for { n := div(n, 2) } n { n := div(n,2) } {\\r\\n                        let xx := mul(x, x)\\r\\n                        if shr(128, x) { revert(0,0) }\\r\\n                        let xxRound := add(xx, half)\\r\\n                        if lt(xxRound, xx) { revert(0,0) }\\r\\n                        x := div(xxRound, b)\\r\\n                        if mod(n,2) {\\r\\n                            let zx := mul(z, x)\\r\\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\\r\\n                            let zxRound := add(zx, half)\\r\\n                            if lt(zxRound, zx) { revert(0,0) }\\r\\n                            z := div(zxRound, b)\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // top: initial price\\r\\n    // dur: seconds since the auction has started\\r\\n    // cut: cut encodes the percentage to decrease per second.\\r\\n    //   For efficiency, the values is set as (1 - (% value / 100)) * RAY\\r\\n    //   So, for a 1% decrease per second, cut would be (1 - 0.01) * RAY\\r\\n    //\\r\\n    // returns: top * (cut ^ dur)\\r\\n    //\\r\\n    function price(uint256 top, uint256 dur) override external view returns (uint256) {\\r\\n        return rmul(top, rpow(cut, dur, RAY));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"./contracts/frin.sol\": {\r\n      \"content\": \"/// token.sol -- ERC20 implementation with minting and burning\\n\\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.23;\\n\\ninterface DSAuthority {\\n    function canCall(\\n        address src, address dst, bytes4 sig\\n    ) external view returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n    event LogSetAuthority (address indexed authority);\\n    event LogSetOwner     (address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n    DSAuthority  public  authority;\\n    address      public  owner;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        emit LogSetOwner(msg.sender);\\n    }\\n\\n    function setOwner(address owner_)\\n        public\\n        auth\\n    {\\n        owner = owner_;\\n        emit LogSetOwner(owner);\\n    }\\n\\n    function setAuthority(DSAuthority authority_)\\n        public\\n        auth\\n    {\\n        authority = authority_;\\n        emit LogSetAuthority(address(authority));\\n    }\\n\\n    modifier auth {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"ds-auth-unauthorized\\\");\\n        _;\\n    }\\n\\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n        if (src == address(this)) {\\n            return true;\\n        } else if (src == owner) {\\n            return true;\\n        } else if (authority == DSAuthority(address(0))) {\\n            return false;\\n        } else {\\n            return authority.canCall(src, address(this), sig);\\n        }\\n    }\\n}\\n\\ncontract DSMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        return x <= y ? x : y;\\n    }\\n    function max(uint x, uint y) internal pure returns (uint z) {\\n        return x >= y ? x : y;\\n    }\\n    function imin(int x, int y) internal pure returns (int z) {\\n        return x <= y ? x : y;\\n    }\\n    function imax(int x, int y) internal pure returns (int z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint constant WAD = 10 ** 18;\\n    uint constant RAY = 10 ** 27;\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n    //rounds to zero if x*y < WAD / 2\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n    //rounds to zero if x*y < WAD / 2\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n    //rounds to zero if x*y < RAY / 2\\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint x, uint n) internal pure returns (uint z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\\ncontract DSToken is DSMath, DSAuth {\\n    bool                                              public  stopped;\\n    uint256                                           public  totalSupply;\\n    mapping (address => uint256)                      public  balanceOf;\\n    mapping (address => mapping (address => uint256)) public  allowance;\\n    string                                            public  symbol;\\n    uint8                                             public  decimals = 18; // standard token precision. override to customize\\n    string                                            public  name = \\\"\\\";     // Optional token name\\n\\n\\n    constructor(string memory symbol_) public {\\n        symbol = symbol_;\\n    }\\n\\n    event Approval(address indexed src, address indexed guy, uint wad);\\n    event Transfer(address indexed src, address indexed dst, uint wad);\\n    event Mint(address indexed guy, uint wad);\\n    event Burn(address indexed guy, uint wad);\\n    event Stop();\\n    event Start();\\n\\n    modifier stoppable {\\n        require(!stopped, \\\"ds-stop-is-stopped\\\");\\n        _;\\n    }\\n\\n    function approve(address guy) external returns (bool) {\\n        return approve(guy, type(uint256).max);\\n    }\\n\\n    function approve(address guy, uint wad) public stoppable returns (bool) {\\n        allowance[msg.sender][guy] = wad;\\n\\n        emit Approval(msg.sender, guy, wad);\\n\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint wad) external returns (bool) {\\n        return transferFrom(msg.sender, dst, wad);\\n    }\\n\\n    function transferFrom(address src, address dst, uint wad)\\n        public\\n        stoppable\\n        returns (bool)\\n    {\\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\\n            require(allowance[src][msg.sender] >= wad, \\\"ds-token-insufficient-approval\\\");\\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\\n        }\\n\\n        require(balanceOf[src] >= wad, \\\"ds-token-insufficient-balance\\\");\\n        balanceOf[src] = sub(balanceOf[src], wad);\\n        balanceOf[dst] = add(balanceOf[dst], wad);\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n\\n    function push(address dst, uint wad) external {\\n        transferFrom(msg.sender, dst, wad);\\n    }\\n\\n    function pull(address src, uint wad) external {\\n        transferFrom(src, msg.sender, wad);\\n    }\\n\\n    function move(address src, address dst, uint wad) external {\\n        transferFrom(src, dst, wad);\\n    }\\n\\n\\n    function mint(uint wad) external {\\n        mint(msg.sender, wad);\\n    }\\n\\n    function burn(uint wad) external {\\n        burn(msg.sender, wad);\\n    }\\n\\n    function mint(address guy, uint wad) public auth stoppable {\\n        balanceOf[guy] = add(balanceOf[guy], wad);\\n        totalSupply = add(totalSupply, wad);\\n        emit Mint(guy, wad);\\n    }\\n\\n    function burn(address guy, uint wad) public auth stoppable {\\n        if (guy != msg.sender && allowance[guy][msg.sender] != type(uint256).max) {\\n            require(allowance[guy][msg.sender] >= wad, \\\"ds-token-insufficient-approval\\\");\\n            allowance[guy][msg.sender] = sub(allowance[guy][msg.sender], wad);\\n        }\\n\\n        require(balanceOf[guy] >= wad, \\\"ds-token-insufficient-balance\\\");\\n        balanceOf[guy] = sub(balanceOf[guy], wad);\\n        totalSupply = sub(totalSupply, wad);\\n        emit Burn(guy, wad);\\n    }\\n\\n    function stop() public auth {\\n        stopped = true;\\n        emit Stop();\\n    }\\n\\n    function start() public auth {\\n        stopped = false;\\n        emit Start();\\n    }\\n\\n\\n    function setName(string memory name_) public auth {\\n        name = name_;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Start\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Stop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract DSAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"move\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"pull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"push\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DSAuthority\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DSToken","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000044652494e00000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"ipfs://780540f0938d325d7cbb843f51227fdc319aa11340808828c0a3396b00e830fb"}]