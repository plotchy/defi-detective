[{"SourceCode":"# @version 0.2.4\r\n\"\"\"\r\n@title Curve DAO Token\r\n@author Curve Finance\r\n@license MIT\r\n@notice ERC20 with piecewise-linear mining supply.\r\n@dev Based on the ERC-20 token standard as defined at\r\n     https://eips.ethereum.org/EIPS/eip-20\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\n\r\nevent Transfer:\r\n    _from: indexed(address)\r\n    _to: indexed(address)\r\n    _value: uint256\r\n\r\nevent Approval:\r\n    _owner: indexed(address)\r\n    _spender: indexed(address)\r\n    _value: uint256\r\n\r\nevent UpdateMiningParameters:\r\n    time: uint256\r\n    rate: uint256\r\n    supply: uint256\r\n\r\nevent SetMinter:\r\n    minter: address\r\n\r\nevent SetAdmin:\r\n    admin: address\r\n\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\ndecimals: public(uint256)\r\n\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowances: HashMap[address, HashMap[address, uint256]]\r\ntotal_supply: uint256\r\n\r\nminter: public(address)\r\nadmin: public(address)\r\n\r\n# General constants\r\nHOUR: constant(uint256) = 3600\r\nDAY: constant(uint256) = 86400\r\nWEEK: constant(uint256) = 86400 * 7\r\nYEAR: constant(uint256) = WEEK * 52\r\n\r\n# Allocation:\r\n# ===========\r\n# WE GIVE IT BACK TO YOU ... THE PEOPLE: 100%\r\n\r\n# Supply parameters\r\nINITIAL_SUPPLY: constant(uint256) = 0\r\nINFLATION_DELAY: constant(uint256) = 3 * HOUR # Three Hour delay before minting may begin\r\nRATE_DENOMINATOR: constant(uint256) = 10 ** 18\r\nRATE_TIME: constant(uint256) = 2 * WEEK # How often the rate goes to the next epoch\r\nINITIAL_RATE: constant(uint256) = 9_000_000 * 10 ** 18 / (2 * WEEK) # 9 million for the first 2 weeks\r\nEPOCH_INITIAL_RATE: constant(uint256) = 9_000_000 * 10 ** 18 / YEAR # 9 million for the first year thereafter\r\nLATE_RATE: constant(uint256) = 3_000_000 * 10 ** 18 / YEAR # 3 million per year after\r\nINITIAL_RATE_EPOCH_CUTTOF: constant(uint256) = 27 # After 52 Weeks use the late rate\r\nFINAL_INFLATION_EPOCH: constant(uint256) = 157 # No more inflation after 6 years (0 epoch is the 2 week period)\r\n\r\n# Supply variables\r\nmining_epoch: public(int128)\r\nstart_epoch_time: public(uint256)\r\nrate: public(uint256)\r\n\r\nstart_epoch_supply: uint256\r\n\r\n\r\n@external\r\ndef __init__(_name: String[64], _symbol: String[32], _decimals: uint256):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _name Token full name\r\n    @param _symbol Token symbol\r\n    @param _decimals Number of decimals for token\r\n    \"\"\"\r\n    init_supply: uint256 = INITIAL_SUPPLY * 10 ** _decimals\r\n    self.name = _name\r\n    self.symbol = _symbol\r\n    self.decimals = _decimals\r\n    self.balanceOf[msg.sender] = init_supply\r\n    self.total_supply = init_supply\r\n    self.admin = msg.sender\r\n    log Transfer(ZERO_ADDRESS, msg.sender, init_supply)\r\n\r\n    self.start_epoch_time = block.timestamp + INFLATION_DELAY - RATE_TIME\r\n    self.mining_epoch = -1\r\n    self.rate = 0\r\n    self.start_epoch_supply = init_supply\r\n\r\n\r\n@internal\r\ndef _update_mining_parameters():\r\n    \"\"\"\r\n    @dev Update mining rate and supply at the start of the epoch\r\n         Any modifying mining call must also call this\r\n    \"\"\"\r\n    _rate: uint256 = self.rate\r\n    _start_epoch_supply: uint256 = self.start_epoch_supply\r\n    \r\n    self.mining_epoch += 1\r\n    self.start_epoch_time += RATE_TIME\r\n\r\n    if self.mining_epoch == 0:\r\n        _rate = INITIAL_RATE\r\n    else:\r\n        _start_epoch_supply += _rate * RATE_TIME\r\n\r\n        if self.mining_epoch < INITIAL_RATE_EPOCH_CUTTOF:\r\n            _rate = EPOCH_INITIAL_RATE\r\n        elif self.mining_epoch >= FINAL_INFLATION_EPOCH:\r\n            _rate = 0\r\n        else:\r\n            _rate = LATE_RATE\r\n\r\n    self.start_epoch_supply = _start_epoch_supply\r\n    self.rate = _rate\r\n\r\n    log UpdateMiningParameters(block.timestamp, _rate, _start_epoch_supply)\r\n\r\n\r\n@external\r\ndef update_mining_parameters():\r\n    \"\"\"\r\n    @notice Update mining rate and supply at the start of the epoch\r\n    @dev Callable by any address, but only once per epoch\r\n         Total supply becomes slightly larger if this function is called late\r\n    \"\"\"\r\n    assert block.timestamp >= self.start_epoch_time + RATE_TIME  # dev: too soon!\r\n    self._update_mining_parameters()\r\n\r\n\r\n@external\r\ndef start_epoch_time_write() -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp of the current mining epoch start\r\n            while simultaneously updating mining parameters\r\n    @return Timestamp of the epoch\r\n    \"\"\"\r\n    _start_epoch_time: uint256 = self.start_epoch_time\r\n    if block.timestamp >= _start_epoch_time + RATE_TIME:\r\n        self._update_mining_parameters()\r\n        return self.start_epoch_time\r\n    else:\r\n        return _start_epoch_time\r\n\r\n\r\n@external\r\ndef future_epoch_time_write() -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp of the next mining epoch start\r\n            while simultaneously updating mining parameters\r\n    @return Timestamp of the next epoch\r\n    \"\"\"\r\n    _start_epoch_time: uint256 = self.start_epoch_time\r\n    if block.timestamp >= _start_epoch_time + RATE_TIME:\r\n        self._update_mining_parameters()\r\n        return self.start_epoch_time + RATE_TIME\r\n    else:\r\n        return _start_epoch_time + RATE_TIME\r\n\r\n\r\n@internal\r\n@view\r\ndef _available_supply() -> uint256:\r\n    return self.start_epoch_supply + (block.timestamp - self.start_epoch_time) * self.rate\r\n\r\n\r\n@external\r\n@view\r\ndef available_supply() -> uint256:\r\n    \"\"\"\r\n    @notice Current number of tokens in existence (claimed or unclaimed)\r\n    \"\"\"\r\n    return self._available_supply()\r\n\r\n\r\n@external\r\ndef set_minter(_minter: address):\r\n    \"\"\"\r\n    @notice Set the minter address\r\n    @dev Only callable once, when minter has not yet been set\r\n    @param _minter Address of the minter\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    assert self.minter == ZERO_ADDRESS  # dev: can set the minter only once, at creation\r\n    self.minter = _minter\r\n    log SetMinter(_minter)\r\n\r\n\r\n@external\r\ndef set_admin(_admin: address):\r\n    \"\"\"\r\n    @notice Set the new admin.\r\n    @dev After all is set up, admin only can change the token name\r\n    @param _admin New admin address\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    self.admin = _admin\r\n    log SetAdmin(_admin)\r\n\r\n\r\n@external\r\n@view\r\ndef totalSupply() -> uint256:\r\n    \"\"\"\r\n    @notice Total number of tokens in existence.\r\n    \"\"\"\r\n    return self.total_supply\r\n\r\n\r\n@external\r\n@view\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    \"\"\"\r\n    @notice Check the amount of tokens that an owner allowed to a spender\r\n    @param _owner The address which owns the funds\r\n    @param _spender The address which will spend the funds\r\n    @return uint256 specifying the amount of tokens still available for the spender\r\n    \"\"\"\r\n    return self.allowances[_owner][_spender]\r\n\r\n\r\n@external\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer `_value` tokens from `msg.sender` to `_to`\r\n    @dev Vyper does not allow underflows, so the subtraction in\r\n         this function will revert on an insufficient balance\r\n    @param _to The address to transfer to\r\n    @param _value The amount to be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\r\n    self.balanceOf[msg.sender] -= _value\r\n    self.balanceOf[_to] += _value\r\n    log Transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n     @notice Transfer `_value` tokens from `_from` to `_to`\r\n     @param _from address The address which you want to send tokens from\r\n     @param _to address The address which you want to transfer to\r\n     @param _value uint256 the amount of tokens to be transferred\r\n     @return bool success\r\n    \"\"\"\r\n    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\r\n    # NOTE: vyper does not allow underflows\r\n    #       so the following subtraction would revert on insufficient balance\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n    self.allowances[_from][msg.sender] -= _value\r\n    log Transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Approve `_spender` to transfer `_value` tokens on behalf of `msg.sender`\r\n    @dev Approval may only be from zero -> nonzero or from nonzero -> zero in order\r\n        to mitigate the potential race condition described here:\r\n        https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will spend the funds\r\n    @param _value The amount of tokens to be spent\r\n    @return bool success\r\n    \"\"\"\r\n    assert _value == 0 or self.allowances[msg.sender][_spender] == 0\r\n    self.allowances[msg.sender][_spender] = _value\r\n    log Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef mint(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Mint `_value` tokens and assign them to `_to`\r\n    @dev Emits a Transfer event originating from 0x00\r\n    @param _to The account that will receive the created tokens\r\n    @param _value The amount that will be created\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.minter  # dev: minter only\r\n    assert _to != ZERO_ADDRESS  # dev: zero address\r\n\r\n    if block.timestamp >= self.start_epoch_time + RATE_TIME:\r\n        self._update_mining_parameters()\r\n\r\n    _total_supply: uint256 = self.total_supply + _value\r\n    assert _total_supply <= self._available_supply()  # dev: exceeds allowable mint amount\r\n    self.total_supply = _total_supply\r\n\r\n    self.balanceOf[_to] += _value\r\n    log Transfer(ZERO_ADDRESS, _to, _value)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef burn(_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Burn `_value` tokens belonging to `msg.sender`\r\n    @dev Emits a Transfer event with a destination of 0x00\r\n    @param _value The amount that will be burned\r\n    @return bool success\r\n    \"\"\"\r\n    self.balanceOf[msg.sender] -= _value\r\n    self.total_supply -= _value\r\n\r\n    log Transfer(msg.sender, ZERO_ADDRESS, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef set_name(_name: String[64], _symbol: String[32]):\r\n    \"\"\"\r\n    @notice Change the token name and symbol to `_name` and `_symbol`\r\n    @dev Only callable by the admin account\r\n    @param _name New token name\r\n    @param _symbol New token symbol\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Only admin is allowed to change name\"\r\n    self.name = _name\r\n    self.symbol = _symbol","ABI":"[{\"name\":\"Transfer\",\"inputs\":[{\"type\":\"address\",\"name\":\"_from\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_to\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_spender\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateMiningParameters\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"time\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"rate\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"supply\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetMinter\",\"inputs\":[{\"type\":\"address\",\"name\":\"minter\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetAdmin\",\"inputs\":[{\"type\":\"address\",\"name\":\"admin\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_name\"},{\"type\":\"string\",\"name\":\"_symbol\"},{\"type\":\"uint256\",\"name\":\"_decimals\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"update_mining_parameters\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":150926},{\"name\":\"start_epoch_time_write\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":151781},{\"name\":\"future_epoch_time_write\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":151984},{\"name\":\"available_supply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":4018},{\"name\":\"set_minter\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_minter\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38668},{\"name\":\"set_admin\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_admin\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37807},{\"name\":\"totalSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1391},{\"name\":\"allowance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"},{\"type\":\"address\",\"name\":\"_spender\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1729},{\"name\":\"transfer\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":75109},{\"name\":\"transferFrom\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":111403},{\"name\":\"approve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":39258},{\"name\":\"mint\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":230178},{\"name\":\"burn\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":74969},{\"name\":\"set_name\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_name\"},{\"type\":\"string\",\"name\":\"_symbol\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":178240},{\"name\":\"name\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":8033},{\"name\":\"symbol\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":7086},{\"name\":\"decimals\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1691},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1875},{\"name\":\"minter\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1751},{\"name\":\"admin\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1781},{\"name\":\"mining_epoch\",\"outputs\":[{\"type\":\"int128\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1811},{\"name\":\"start_epoch_time\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1841},{\"name\":\"rate\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1871}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.4","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000105377657276652044414f20546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000045357525600000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]