[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.10;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable is a contract the provides contract ownership functionality, including a two-\r\n * phase transfer.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n    address private _authorizedNewOwner;\r\n\r\n    /**\r\n     * @notice Emitted when the owner authorizes ownership transfer to a new address\r\n     * @param authorizedAddress New owner address\r\n     */\r\n    event OwnershipTransferAuthorization(address indexed authorizedAddress);\r\n\r\n    /**\r\n     * @notice Emitted when the authorized address assumed ownership\r\n     * @param oldValue Old owner\r\n     * @param newValue New owner\r\n     */\r\n    event OwnerUpdate(address indexed oldValue, address indexed newValue);\r\n\r\n    /**\r\n     * @notice Sets the owner to the sender / contract creator\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the owner of the contract\r\n     * @return The contract owner\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the authorized new owner of the contract\r\n     * @return The authorized new contract owner\r\n     */\r\n    function authorizedNewOwner() public view returns (address) {\r\n        return _authorizedNewOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Authorizes the transfer of ownership from owner to the provided address.\r\n     * NOTE: No transfer will occur unless authorizedAddress calls assumeOwnership().\r\n     * This authorization may be removed by another call to this function authorizing the zero\r\n     * address.\r\n     * @param _authorizedAddress The address authorized to become the new owner\r\n     */\r\n    function authorizeOwnershipTransfer(address _authorizedAddress) external {\r\n        require(msg.sender == _owner, \"Invalid sender\");\r\n\r\n        _authorizedNewOwner = _authorizedAddress;\r\n\r\n        emit OwnershipTransferAuthorization(_authorizedNewOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of this contract to the _authorizedNewOwner\r\n     * @dev Error invalid sender.\r\n     */\r\n    function assumeOwnership() external {\r\n        require(msg.sender == _authorizedNewOwner, \"Invalid sender\");\r\n\r\n        address oldValue = _owner;\r\n        _owner = _authorizedNewOwner;\r\n        _authorizedNewOwner = address(0);\r\n\r\n        emit OwnerUpdate(oldValue, _owner);\r\n    }\r\n}\r\n\r\nabstract contract ERC1820Registry {\r\n    function setInterfaceImplementer(\r\n        address _addr,\r\n        bytes32 _interfaceHash,\r\n        address _implementer\r\n    ) external virtual;\r\n\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash)\r\n        external\r\n        virtual\r\n        view\r\n        returns (address);\r\n\r\n    function setManager(address _addr, address _newManager) external virtual;\r\n\r\n    function getManager(address _addr) public virtual view returns (address);\r\n}\r\n\r\n/// Base client to interact with the registry.\r\ncontract ERC1820Client {\r\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(\r\n        0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\r\n    );\r\n\r\n    function setInterfaceImplementation(\r\n        string memory _interfaceLabel,\r\n        address _implementation\r\n    ) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        ERC1820REGISTRY.setInterfaceImplementer(\r\n            address(this),\r\n            interfaceHash,\r\n            _implementation\r\n        );\r\n    }\r\n\r\n    function interfaceAddr(address addr, string memory _interfaceLabel)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n    function delegateManagement(address _newManager) internal {\r\n        ERC1820REGISTRY.setManager(address(this), _newManager);\r\n    }\r\n}\r\n\r\ncontract ERC1820Implementer {\r\n    /**\r\n     * @dev ERC1820 well defined magic value indicating the contract has\r\n     * registered with the ERC1820Registry that it can implement an interface.\r\n     */\r\n    bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(\r\n        abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\")\r\n    );\r\n\r\n    /**\r\n     * @dev Mapping of interface name keccak256 hashes for which this contract\r\n     * implements the interface.\r\n     * @dev Only settable internally.\r\n     */\r\n    mapping(bytes32 => bool) internal _interfaceHashes;\r\n\r\n    /**\r\n     * @notice Indicates whether the contract implements the interface `_interfaceHash`\r\n     * for the address `_addr`.\r\n     * @param _interfaceHash keccak256 hash of the name of the interface.\r\n     * @return ERC1820_ACCEPT_MAGIC only if the contract implements `Ã¬nterfaceHash`\r\n     * for the address `_addr`.\r\n     * @dev In this implementation, the `_addr` (the address for which the\r\n     * contract will implement the interface) is always `address(this)`.\r\n     */\r\n    function canImplementInterfaceForAddress(\r\n        bytes32 _interfaceHash,\r\n        address // Comments to avoid compilation warnings for unused variables. /*addr*/\r\n    ) external view returns (bytes32) {\r\n        if (_interfaceHashes[_interfaceHash]) {\r\n            return ERC1820_ACCEPT_MAGIC;\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internally set the fact this contract implements the interface\r\n     * identified by `_interfaceLabel`\r\n     * @param _interfaceLabel String representation of the interface.\r\n     */\r\n    function _setInterface(string memory _interfaceLabel) internal {\r\n        _interfaceHashes[keccak256(abi.encodePacked(_interfaceLabel))] = true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title IAmpTokensSender\r\n * @dev IAmpTokensSender token transfer hook interface\r\n */\r\ninterface IAmpTokensSender {\r\n    /**\r\n     * @dev Report if the transfer will succeed from the pespective of the\r\n     * token sender\r\n     */\r\n    function canTransfer(\r\n        bytes4 functionSig,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Hook executed upon a transfer on behalf of the sender\r\n     */\r\n    function tokensToTransfer(\r\n        bytes4 functionSig,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title IAmpTokensRecipient\r\n * @dev IAmpTokensRecipient token transfer hook interface\r\n */\r\ninterface IAmpTokensRecipient {\r\n    /**\r\n     * @dev Report if the recipient will successfully receive the tokens\r\n     */\r\n    function canReceive(\r\n        bytes4 functionSig,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Hook executed upon a transfer to the recipient\r\n     */\r\n    function tokensReceived(\r\n        bytes4 functionSig,\r\n        bytes32 partition,\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @notice Partition strategy validator hooks for Amp\r\n */\r\ninterface IAmpPartitionStrategyValidator {\r\n    function tokensFromPartitionToValidate(\r\n        bytes4 _functionSig,\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external;\r\n\r\n    function tokensToPartitionToValidate(\r\n        bytes4 _functionSig,\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external;\r\n\r\n    function isOperatorForPartitionScope(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _tokenHolder\r\n    ) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title PartitionUtils\r\n * @notice Partition related helper functions.\r\n */\r\n\r\nlibrary PartitionUtils {\r\n    bytes32 public constant CHANGE_PARTITION_FLAG = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n     * @notice Retrieve the destination partition from the 'data' field.\r\n     * A partition change is requested ONLY when 'data' starts with the flag:\r\n     *\r\n     *   0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n     *\r\n     * When the flag is detected, the destination partition is extracted from the\r\n     * 32 bytes following the flag.\r\n     * @param _data Information attached to the transfer. Will contain the\r\n     * destination partition if a change is requested.\r\n     * @param _fallbackPartition Partition value to return if a partition change\r\n     * is not requested in the `_data`.\r\n     * @return toPartition Destination partition. If the `_data` does not contain\r\n     * the prefix and bytes32 partition in the first 64 bytes, the method will\r\n     * return the provided `_fromPartition`.\r\n     */\r\n    function _getDestinationPartition(bytes memory _data, bytes32 _fallbackPartition)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        if (_data.length < 64) {\r\n            return _fallbackPartition;\r\n        }\r\n\r\n        (bytes32 flag, bytes32 toPartition) = abi.decode(_data, (bytes32, bytes32));\r\n        if (flag == CHANGE_PARTITION_FLAG) {\r\n            return toPartition;\r\n        }\r\n\r\n        return _fallbackPartition;\r\n    }\r\n\r\n    /**\r\n     * @notice Helper to get the strategy identifying prefix from the `_partition`.\r\n     * @param _partition Partition to get the prefix for.\r\n     * @return 4 byte partition strategy prefix.\r\n     */\r\n    function _getPartitionPrefix(bytes32 _partition) internal pure returns (bytes4) {\r\n        return bytes4(_partition);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper method to split the partition into the prefix, sub partition\r\n     * and partition owner components.\r\n     * @param _partition The partition to split into parts.\r\n     * @return The 4 byte partition prefix, 8 byte sub partition, and final 20\r\n     * bytes representing an address.\r\n     */\r\n    function _splitPartition(bytes32 _partition)\r\n        internal\r\n        pure\r\n        returns (\r\n            bytes4,\r\n            bytes8,\r\n            address\r\n        )\r\n    {\r\n        bytes4 prefix = bytes4(_partition);\r\n        bytes8 subPartition = bytes8(_partition << 32);\r\n        address addressPart = address(uint160(uint256(_partition)));\r\n        return (prefix, subPartition, addressPart);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper method to get a partition strategy ERC1820 interface name\r\n     * based on partition prefix.\r\n     * @param _prefix 4 byte partition prefix.\r\n     * @dev Each 4 byte prefix has a unique interface name so that an individual\r\n     * hook implementation can be set for each prefix.\r\n     */\r\n    function _getPartitionStrategyValidatorIName(bytes4 _prefix)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return string(abi.encodePacked(\"AmpPartitionStrategyValidator\", _prefix));\r\n    }\r\n}\r\n\r\n/**\r\n * @title ErrorCodes\r\n * @notice Amp error codes.\r\n */\r\ncontract ErrorCodes {\r\n    string internal EC_50_TRANSFER_FAILURE = \"50\";\r\n    string internal EC_51_TRANSFER_SUCCESS = \"51\";\r\n    string internal EC_52_INSUFFICIENT_BALANCE = \"52\";\r\n    string internal EC_53_INSUFFICIENT_ALLOWANCE = \"53\";\r\n\r\n    string internal EC_56_INVALID_SENDER = \"56\";\r\n    string internal EC_57_INVALID_RECEIVER = \"57\";\r\n    string internal EC_58_INVALID_OPERATOR = \"58\";\r\n\r\n    string internal EC_59_INSUFFICIENT_RIGHTS = \"59\";\r\n\r\n    string internal EC_5A_INVALID_SWAP_TOKEN_ADDRESS = \"5A\";\r\n    string internal EC_5B_INVALID_VALUE_0 = \"5B\";\r\n    string internal EC_5C_ADDRESS_CONFLICT = \"5C\";\r\n    string internal EC_5D_PARTITION_RESERVED = \"5D\";\r\n    string internal EC_5E_PARTITION_PREFIX_CONFLICT = \"5E\";\r\n    string internal EC_5F_INVALID_PARTITION_PREFIX_0 = \"5F\";\r\n    string internal EC_60_SWAP_TRANSFER_FAILURE = \"60\";\r\n}\r\n\r\ninterface ISwapToken {\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256 remaining);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool success);\r\n}\r\n\r\n/**\r\n * @title Amp\r\n * @notice Amp is an ERC20 compatible collateral token designed to support\r\n * multiple classes of collateralization systems.\r\n * @dev The Amp token contract includes the following features:\r\n *\r\n * Partitions\r\n *   Tokens can be segmented within a given address by \"partition\", which in\r\n *   pracice is a 32 byte identifier. These partitions can have unique\r\n *   permissions globally, through the using of partition strategies, and\r\n *   locally, on a per address basis. The ability to create the sub-segments\r\n *   of tokens and assign special behavior gives collateral managers\r\n *   flexibility in how they are implemented.\r\n *\r\n * Operators\r\n *   Inspired by ERC777, Amp allows token holders to assign \"operators\" on\r\n *   all (or any number of partitions) of their tokens. Operators are allowed\r\n *   to execute transfers on behalf of token owners without the need to use the\r\n *   ERC20 \"allowance\" semantics.\r\n *\r\n * Transfers with Data\r\n *   Inspired by ERC777, Amp transfers can include arbitrary data, as well as\r\n *   operator data. This data can be used to change the partition of tokens,\r\n *   be used by collateral manager hooks to validate a transfer, be propagated\r\n *   via event to an off chain system, etc.\r\n *\r\n * Token Transfer Hooks on Send and Receive\r\n *   Inspired by ERC777, Amp uses the ERC1820 Registry to allow collateral\r\n *   manager implementations to register hooks to be called upon sending to\r\n *   or transferring from the collateral manager's address or, using partition\r\n *   strategies, owned partition space. The hook implementations can be used\r\n *   to validate transfer properties, gate transfers, emit custom events,\r\n *   update local state, etc.\r\n *\r\n * Collateral Management Partition Strategies\r\n *   Amp is able to define certain sets of partitions, identified by a 4 byte\r\n *   prefix, that will allow special, custom logic to be executed when transfers\r\n *   are made to or from those partitions. This opens up the possibility of\r\n *   entire classes of collateral management systems that would not be possible\r\n *   without it.\r\n *\r\n * These features give collateral manager implementers flexibility while\r\n * providing a consistent, \"collateral-in-place\", interface for interacting\r\n * with collateral systems directly through the Amp contract.\r\n */\r\ncontract Amp is IERC20, ERC1820Client, ERC1820Implementer, ErrorCodes, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    /**************************************************************************/\r\n    /********************** ERC1820 Interface Constants ***********************/\r\n\r\n    /**\r\n     * @dev AmpToken interface label.\r\n     */\r\n    string internal constant AMP_INTERFACE_NAME = \"AmpToken\";\r\n\r\n    /**\r\n     * @dev ERC20Token interface label.\r\n     */\r\n    string internal constant ERC20_INTERFACE_NAME = \"ERC20Token\";\r\n\r\n    /**\r\n     * @dev AmpTokensSender interface label.\r\n     */\r\n    string internal constant AMP_TOKENS_SENDER = \"AmpTokensSender\";\r\n\r\n    /**\r\n     * @dev AmpTokensRecipient interface label.\r\n     */\r\n    string internal constant AMP_TOKENS_RECIPIENT = \"AmpTokensRecipient\";\r\n\r\n    /**\r\n     * @dev AmpTokensChecker interface label.\r\n     */\r\n    string internal constant AMP_TOKENS_CHECKER = \"AmpTokensChecker\";\r\n\r\n    /**************************************************************************/\r\n    /*************************** Token properties *****************************/\r\n\r\n    /**\r\n     * @dev Token name (Amp).\r\n     */\r\n    string internal _name;\r\n\r\n    /**\r\n     * @dev Token symbol (AMP).\r\n     */\r\n    string internal _symbol;\r\n\r\n    /**\r\n     * @dev Total minted supply of token. This will increase comensurately with\r\n     * successful swaps of the swap token.\r\n     */\r\n    uint256 internal _totalSupply;\r\n\r\n    /**\r\n     * @dev The granularity of the token. Hard coded to 1.\r\n     */\r\n    uint256 internal constant _granularity = 1;\r\n\r\n    /**************************************************************************/\r\n    /***************************** Token mappings *****************************/\r\n\r\n    /**\r\n     * @dev Mapping from tokenHolder to balance. This reflects the balance\r\n     * across all partitions of an address.\r\n     */\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    /**************************************************************************/\r\n    /************************** Partition mappings ****************************/\r\n\r\n    /**\r\n     * @dev List of active partitions. This list reflects all partitions that\r\n     * have tokens assigned to them.\r\n     */\r\n    bytes32[] internal _totalPartitions;\r\n\r\n    /**\r\n     * @dev Mapping from partition to their index.\r\n     */\r\n    mapping(bytes32 => uint256) internal _indexOfTotalPartitions;\r\n\r\n    /**\r\n     * @dev Mapping from partition to global balance of corresponding partition.\r\n     */\r\n    mapping(bytes32 => uint256) public totalSupplyByPartition;\r\n\r\n    /**\r\n     * @dev Mapping from tokenHolder to their partitions.\r\n     */\r\n    mapping(address => bytes32[]) internal _partitionsOf;\r\n\r\n    /**\r\n     * @dev Mapping from (tokenHolder, partition) to their index.\r\n     */\r\n    mapping(address => mapping(bytes32 => uint256)) internal _indexOfPartitionsOf;\r\n\r\n    /**\r\n     * @dev Mapping from (tokenHolder, partition) to balance of corresponding\r\n     * partition.\r\n     */\r\n    mapping(address => mapping(bytes32 => uint256)) internal _balanceOfByPartition;\r\n\r\n    /**\r\n     * @notice Default partition of the token.\r\n     * @dev All ERC20 operations operate solely on this partition.\r\n     */\r\n    bytes32\r\n        public constant defaultPartition = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n    /**\r\n     * @dev Zero partition prefix. Parititions with this prefix can not have\r\n     * a strategy assigned, and partitions with a different prefix must have one.\r\n     */\r\n    bytes4 internal constant ZERO_PREFIX = 0x00000000;\r\n\r\n    /**************************************************************************/\r\n    /***************************** Operator mappings **************************/\r\n\r\n    /**\r\n     * @dev Mapping from (tokenHolder, operator) to authorized status. This is\r\n     * specific to the token holder.\r\n     */\r\n    mapping(address => mapping(address => bool)) internal _authorizedOperator;\r\n\r\n    /**************************************************************************/\r\n    /********************** Partition operator mappings ***********************/\r\n\r\n    /**\r\n     * @dev Mapping from (partition, tokenHolder, spender) to allowed value.\r\n     * This is specific to the token holder.\r\n     */\r\n    mapping(bytes32 => mapping(address => mapping(address => uint256)))\r\n        internal _allowedByPartition;\r\n\r\n    /**\r\n     * @dev Mapping from (tokenHolder, partition, operator) to 'approved for\r\n     * partition' status. This is specific to the token holder.\r\n     */\r\n    mapping(address => mapping(bytes32 => mapping(address => bool)))\r\n        internal _authorizedOperatorByPartition;\r\n\r\n    /**************************************************************************/\r\n    /********************** Collateral Manager mappings ***********************/\r\n    /**\r\n     * @notice Collection of registered collateral managers.\r\n     */\r\n    address[] public collateralManagers;\r\n    /**\r\n     * @dev Mapping of collateral manager addresses to registration status.\r\n     */\r\n    mapping(address => bool) internal _isCollateralManager;\r\n\r\n    /**************************************************************************/\r\n    /********************* Partition Strategy mappings ************************/\r\n\r\n    /**\r\n     * @notice Collection of reserved partition strategies.\r\n     */\r\n    bytes4[] public partitionStrategies;\r\n\r\n    /**\r\n     * @dev Mapping of partition strategy flag to registration status.\r\n     */\r\n    mapping(bytes4 => bool) internal _isPartitionStrategy;\r\n\r\n    /**************************************************************************/\r\n    /***************************** Swap storage *******************************/\r\n\r\n    /**\r\n     * @notice Swap token address. Immutable.\r\n     */\r\n    ISwapToken public swapToken;\r\n\r\n    /**\r\n     * @notice Swap token graveyard address.\r\n     * @dev This is the address that the incoming swapped tokens will be\r\n     * forwarded to upon successfully minting Amp.\r\n     */\r\n    address\r\n        public constant swapTokenGraveyard = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    /**************************************************************************/\r\n    /** EVENTS ****************************************************************/\r\n    /**************************************************************************/\r\n\r\n    /**************************************************************************/\r\n    /**************************** Transfer Events *****************************/\r\n\r\n    /**\r\n     * @notice Emitted when a transfer has been successfully completed.\r\n     * @param fromPartition The partition the tokens were transfered from.\r\n     * @param operator The address that initiated the transfer.\r\n     * @param from The address the tokens were transferred from.\r\n     * @param to The address the tokens were transferred to.\r\n     * @param value The amount of tokens transferred.\r\n     * @param data Additional metadata included with the transfer. Can include\r\n     * the partition the tokens were transferred to (if different than\r\n     * `fromPartition`).\r\n     * @param operatorData Additional metadata included with the transfer on\r\n     * behalf of the operator.\r\n     */\r\n    event TransferByPartition(\r\n        bytes32 indexed fromPartition,\r\n        address operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a transfer has been successfully completed and the\r\n     * tokens that were transferred have changed partitions.\r\n     * @param fromPartition The partition the tokens were transfered from.\r\n     * @param toPartition The partition the tokens were transfered to.\r\n     * @param value The amount of tokens transferred.\r\n     */\r\n    event ChangedPartition(\r\n        bytes32 indexed fromPartition,\r\n        bytes32 indexed toPartition,\r\n        uint256 value\r\n    );\r\n\r\n    /**************************************************************************/\r\n    /**************************** Operator Events *****************************/\r\n\r\n    /**\r\n     * @notice Emitted when a token holder specifies an amount of tokens in a\r\n     * a partition that an operator can transfer.\r\n     * @param partition The partition of the tokens the holder has authorized the\r\n     * operator to transfer from.\r\n     * @param owner The token holder.\r\n     * @param spender The operator the `owner` has authorized the allowance for.\r\n     */\r\n    event ApprovalByPartition(\r\n        bytes32 indexed partition,\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a token holder has authorized an operator for their\r\n     * tokens.\r\n     * @dev This event applies to the token holder address across all partitions.\r\n     * @param operator The address that was authorized to transfer tokens on\r\n     * behalf of the `tokenHolder`.\r\n     * @param tokenHolder The address that authorized the `operator` to transfer\r\n     * their tokens.\r\n     */\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    /**\r\n     * @notice Emitted when a token holder has de-authorized an operator from\r\n     * transferring their tokens.\r\n     * @dev This event applies to the token holder address across all partitions.\r\n     * @param operator The address that was de-authorized from transferring tokens\r\n     * on behalf of the `tokenHolder`.\r\n     * @param tokenHolder The address that revoked the `operator`'s permission\r\n     * to transfer their tokens.\r\n     */\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    /**\r\n     * @notice Emitted when a token holder has authorized an operator to transfer\r\n     * their tokens of one partition.\r\n     * @param partition The partition the `operator` is allowed to transfer\r\n     * tokens from.\r\n     * @param operator The address that was authorized to transfer tokens on\r\n     * behalf of the `tokenHolder`.\r\n     * @param tokenHolder The address that authorized the `operator` to transfer\r\n     * their tokens in `partition`.\r\n     */\r\n    event AuthorizedOperatorByPartition(\r\n        bytes32 indexed partition,\r\n        address indexed operator,\r\n        address indexed tokenHolder\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a token holder has de-authorized an operator from\r\n     * transferring their tokens from a specific partition.\r\n     * @param partition The partition the `operator` is no longer allowed to\r\n     * transfer tokens from on behalf of the `tokenHolder`.\r\n     * @param operator The address that was de-authorized from transferring\r\n     * tokens on behalf of the `tokenHolder`.\r\n     * @param tokenHolder The address that revoked the `operator`'s permission\r\n     * to transfer their tokens from `partition`.\r\n     */\r\n    event RevokedOperatorByPartition(\r\n        bytes32 indexed partition,\r\n        address indexed operator,\r\n        address indexed tokenHolder\r\n    );\r\n\r\n    /**************************************************************************/\r\n    /********************** Collateral Manager Events *************************/\r\n\r\n    /**\r\n     * @notice Emitted when a collateral manager has been registered.\r\n     * @param collateralManager The address of the collateral manager.\r\n     */\r\n    event CollateralManagerRegistered(address collateralManager);\r\n\r\n    /**************************************************************************/\r\n    /*********************** Partition Strategy Events ************************/\r\n\r\n    /**\r\n     * @notice Emitted when a new partition strategy validator is set.\r\n     * @param flag The 4 byte prefix of the partitions that the stratgy affects.\r\n     * @param name The name of the partition strategy.\r\n     * @param implementation The address of the partition strategy hook\r\n     * implementation.\r\n     */\r\n    event PartitionStrategySet(bytes4 flag, string name, address indexed implementation);\r\n\r\n    // ************** Mint & Swap **************\r\n\r\n    /**\r\n     * @notice Emitted when tokens are minted as a result of a token swap\r\n     * @param operator Address that executed the swap that resulted in tokens being minted\r\n     * @param to Address that received the newly minted tokens.\r\n     * @param value Amount of tokens minted\r\n     * @param data Empty bytes, required for interface compatibility\r\n     */\r\n    event Minted(address indexed operator, address indexed to, uint256 value, bytes data);\r\n\r\n    /**\r\n     * @notice Indicates tokens swapped for Amp.\r\n     * @dev The tokens that are swapped for Amp will be transferred to a\r\n     * graveyard address that is for all practical purposes inaccessible.\r\n     * @param operator Address that executed the swap.\r\n     * @param from Address that the tokens were swapped from, and Amp minted for.\r\n     * @param value Amount of tokens swapped into Amp.\r\n     */\r\n    event Swap(address indexed operator, address indexed from, uint256 value);\r\n\r\n    /**************************************************************************/\r\n    /** CONSTRUCTOR ***********************************************************/\r\n    /**************************************************************************/\r\n\r\n    /**\r\n     * @notice Initialize Amp, initialize the default partition, and register the\r\n     * contract implementation in the global ERC1820Registry.\r\n     * @param _swapTokenAddress_ The address of the ERC20 token that is set to be\r\n     * swappable for Amp.\r\n     * @param _name_ Name of the token.\r\n     * @param _symbol_ Symbol of the token.\r\n     */\r\n    constructor(\r\n        address _swapTokenAddress_,\r\n        string memory _name_,\r\n        string memory _symbol_\r\n    ) public {\r\n        // \"Swap token cannot be 0 address\"\r\n        require(_swapTokenAddress_ != address(0), EC_5A_INVALID_SWAP_TOKEN_ADDRESS);\r\n        swapToken = ISwapToken(_swapTokenAddress_);\r\n\r\n        _name = _name_;\r\n        _symbol = _symbol_;\r\n        _totalSupply = 0;\r\n\r\n        // Add the default partition to the total partitions on deploy\r\n        _addPartitionToTotalPartitions(defaultPartition);\r\n\r\n        // Register contract in ERC1820 registry\r\n        ERC1820Client.setInterfaceImplementation(AMP_INTERFACE_NAME, address(this));\r\n        ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, address(this));\r\n\r\n        // Indicate token verifies Amp and ERC20 interfaces\r\n        ERC1820Implementer._setInterface(AMP_INTERFACE_NAME);\r\n        ERC1820Implementer._setInterface(ERC20_INTERFACE_NAME);\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /** EXTERNAL FUNCTIONS (ERC20) ********************************************/\r\n    /**************************************************************************/\r\n\r\n    /**\r\n     * @notice Get the total number of issued tokens.\r\n     * @return Total supply of tokens currently in circulation.\r\n     */\r\n    function totalSupply() external override view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the balance of the account with address `_tokenHolder`.\r\n     * @dev This returns the balance of the holder across all partitions. Note\r\n     * that due to other functionality in Amp, this figure should not be used\r\n     * as the arbiter of the amount a token holder will successfully be able to\r\n     * send via the ERC20 compatible `transfer` method. In order to get that\r\n     * figure, use `balanceOfByParition` and to get the balance of the default\r\n     * partition.\r\n     * @param _tokenHolder Address for which the balance is returned.\r\n     * @return Amount of token held by `_tokenHolder` in the default partition.\r\n     */\r\n    function balanceOf(address _tokenHolder) external override view returns (uint256) {\r\n        return _balances[_tokenHolder];\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer token for a specified address.\r\n     * @dev This method is for ERC20 compatibility, and only affects the\r\n     * balance of the `msg.sender` address's default partition.\r\n     * @param _to The address to transfer to.\r\n     * @param _value The value to be transferred.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function transfer(address _to, uint256 _value) external override returns (bool) {\r\n        _transferByDefaultPartition(msg.sender, msg.sender, _to, _value, \"\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer tokens from one address to another.\r\n     * @dev This method is for ERC20 compatibility, and only affects the\r\n     * balance and allowance of the `_from` address's default partition.\r\n     * @param _from The address which you want to transfer tokens from.\r\n     * @param _to The address which you want to transfer to.\r\n     * @param _value The amount of tokens to be transferred.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external override returns (bool) {\r\n        _transferByDefaultPartition(msg.sender, _from, _to, _value, \"\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Check the value of tokens that an owner allowed to a spender.\r\n     * @dev This method is for ERC20 compatibility, and only affects the\r\n     * allowance of the `msg.sender`'s default partition.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the value of tokens still available for the\r\n     * spender.\r\n     */\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        override\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowedByPartition[defaultPartition][_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve the passed address to spend the specified amount of\r\n     * tokens from the default partition on behalf of 'msg.sender'.\r\n     * @dev This method is for ERC20 compatibility, and only affects the\r\n     * allowance of the `msg.sender`'s default partition.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function approve(address _spender, uint256 _value) external override returns (bool) {\r\n        _approveByPartition(defaultPartition, msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Atomically increases the allowance granted to `_spender` by the\r\n     * for caller.\r\n     * @dev This is an alternative to {approve} that can be used as a mitigation\r\n     * problems described in {IERC20-approve}.\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     * Requirements:\r\n     * - `_spender` cannot be the zero address.\r\n     * @dev This method is for ERC20 compatibility, and only affects the\r\n     * allowance of the `msg.sender`'s default partition.\r\n     * @param _spender Operator allowed to transfer the tokens\r\n     * @param _addedValue Additional amount of the `msg.sender`s tokens `_spender`\r\n     * is allowed to transfer\r\n     * @return 'true' is successful, 'false' otherwise\r\n     */\r\n    function increaseAllowance(address _spender, uint256 _addedValue)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _approveByPartition(\r\n            defaultPartition,\r\n            msg.sender,\r\n            _spender,\r\n            _allowedByPartition[defaultPartition][msg.sender][_spender].add(_addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Atomically decreases the allowance granted to `_spender` by the\r\n     * caller.\r\n     * @dev This is an alternative to {approve} that can be used as a mitigation\r\n     * for bugs caused by reentrancy.\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     * Requirements:\r\n     * - `_spender` cannot be the zero address.\r\n     * - `_spender` must have allowance for the caller of at least\r\n     * `_subtractedValue`.\r\n     * @dev This method is for ERC20 compatibility, and only affects the\r\n     * allowance of the `msg.sender`'s default partition.\r\n     * @param _spender Operator allowed to transfer the tokens\r\n     * @param _subtractedValue Amount of the `msg.sender`s tokens `_spender`\r\n     * is no longer allowed to transfer\r\n     * @return 'true' is successful, 'false' otherwise\r\n     */\r\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _approveByPartition(\r\n            defaultPartition,\r\n            msg.sender,\r\n            _spender,\r\n            _allowedByPartition[defaultPartition][msg.sender][_spender].sub(\r\n                _subtractedValue\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /** EXTERNAL FUNCTIONS (AMP) **********************************************/\r\n    /**************************************************************************/\r\n\r\n    /******************************** Swap  ***********************************/\r\n\r\n    /**\r\n     * @notice Swap tokens to mint AMP.\r\n     * @dev Requires `_from` to have given allowance of swap token to contract.\r\n     * Otherwise will throw error code 53 (Insuffient Allowance).\r\n     * @param _from Token holder to execute the swap for.\r\n     */\r\n    function swap(address _from) public {\r\n        uint256 amount = swapToken.allowance(_from, address(this));\r\n        require(amount > 0, EC_53_INSUFFICIENT_ALLOWANCE);\r\n\r\n        require(\r\n            swapToken.transferFrom(_from, swapTokenGraveyard, amount),\r\n            EC_60_SWAP_TRANSFER_FAILURE\r\n        );\r\n\r\n        _mint(msg.sender, _from, amount);\r\n\r\n        emit Swap(msg.sender, _from, amount);\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************** Holder information ****************************/\r\n\r\n    /**\r\n     * @notice Get balance of a tokenholder for a specific partition.\r\n     * @param _partition Name of the partition.\r\n     * @param _tokenHolder Address for which the balance is returned.\r\n     * @return Amount of token of partition `_partition` held by `_tokenHolder` in the token contract.\r\n     */\r\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _balanceOfByPartition[_tokenHolder][_partition];\r\n    }\r\n\r\n    /**\r\n     * @notice Get partitions index of a token holder.\r\n     * @param _tokenHolder Address for which the partitions index are returned.\r\n     * @return Array of partitions index of '_tokenHolder'.\r\n     */\r\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[] memory) {\r\n        return _partitionsOf[_tokenHolder];\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************** Advanced Transfers ****************************/\r\n\r\n    /**\r\n     * @notice Transfer tokens from a specific partition on behalf of a token\r\n     * holder, optionally changing the parittion and optionally including\r\n     * arbitrary data with the transfer.\r\n     * @dev This can be used to transfer an address's own tokens, or transfer\r\n     * a different addresses tokens by specifying the `_from` param. If\r\n     * attempting to transfer from a different address than `msg.sender`, the\r\n     * `msg.sender` will need to be an operator or have enough allowance for the\r\n     * `_partition` of the `_from` address.\r\n     * @param _partition Name of the partition to transfer from.\r\n     * @param _from Token holder.\r\n     * @param _to Token recipient.\r\n     * @param _value Number of tokens to transfer.\r\n     * @param _data Information attached to the transfer. Will contain the\r\n     * destination partition (if changing partitions).\r\n     * @param _operatorData Information attached to the transfer, by the operator.\r\n     * @return Destination partition.\r\n     */\r\n    function transferByPartition(\r\n        bytes32 _partition,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external returns (bytes32) {\r\n        return\r\n            _transferByPartition(\r\n                _partition,\r\n                msg.sender,\r\n                _from,\r\n                _to,\r\n                _value,\r\n                _data,\r\n                _operatorData\r\n            );\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************** Operator Management ***************************/\r\n\r\n    /**\r\n     * @notice Set a third party operator address as an operator of 'msg.sender'\r\n     * to transfer and redeem tokens on its behalf.\r\n     * @dev The msg.sender is always an operator for itself, and does not need to\r\n     * be explicitly added.\r\n     * @param _operator Address to set as an operator for 'msg.sender'.\r\n     */\r\n    function authorizeOperator(address _operator) external {\r\n        require(_operator != msg.sender, EC_58_INVALID_OPERATOR);\r\n\r\n        _authorizedOperator[msg.sender][_operator] = true;\r\n        emit AuthorizedOperator(_operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove the right of the operator address to be an operator for\r\n     * 'msg.sender' and to transfer and redeem tokens on its behalf.\r\n     * @dev The msg.sender is always an operator for itself, and cannot be\r\n     * removed.\r\n     * @param _operator Address to rescind as an operator for 'msg.sender'.\r\n     */\r\n    function revokeOperator(address _operator) external {\r\n        require(_operator != msg.sender, EC_58_INVALID_OPERATOR);\r\n\r\n        _authorizedOperator[msg.sender][_operator] = false;\r\n        emit RevokedOperator(_operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Set `_operator` as an operator for 'msg.sender' for a given partition.\r\n     * @dev The msg.sender is always an operator for itself, and does not need to\r\n     * be explicitly added to a partition.\r\n     * @param _partition Name of the partition.\r\n     * @param _operator Address to set as an operator for 'msg.sender'.\r\n     */\r\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator)\r\n        external\r\n    {\r\n        require(_operator != msg.sender, EC_58_INVALID_OPERATOR);\r\n\r\n        _authorizedOperatorByPartition[msg.sender][_partition][_operator] = true;\r\n        emit AuthorizedOperatorByPartition(_partition, _operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove the right of the operator address to be an operator on a\r\n     * given partition for 'msg.sender' and to transfer and redeem tokens on its\r\n     * behalf.\r\n     * @dev The msg.sender is always an operator for itself, and cannot be\r\n     * removed from a partition.\r\n     * @param _partition Name of the partition.\r\n     * @param _operator Address to rescind as an operator on given partition for\r\n     * 'msg.sender'.\r\n     */\r\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external {\r\n        require(_operator != msg.sender, EC_58_INVALID_OPERATOR);\r\n\r\n        _authorizedOperatorByPartition[msg.sender][_partition][_operator] = false;\r\n        emit RevokedOperatorByPartition(_partition, _operator, msg.sender);\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************** Operator Information **************************/\r\n    /**\r\n     * @notice Indicate whether the `_operator` address is an operator of the\r\n     * `_tokenHolder` address.\r\n     * @dev An operator in this case is an operator across all of the partitions\r\n     * of the `msg.sender` address.\r\n     * @param _operator Address which may be an operator of `_tokenHolder`.\r\n     * @param _tokenHolder Address of a token holder which may have the\r\n     * `_operator` address as an operator.\r\n     * @return 'true' if operator is an operator of 'tokenHolder' and 'false'\r\n     * otherwise.\r\n     */\r\n    function isOperator(address _operator, address _tokenHolder)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _isOperator(_operator, _tokenHolder);\r\n    }\r\n\r\n    /**\r\n     * @notice Indicate whether the operator address is an operator of the\r\n     * `_tokenHolder` address for the given partition.\r\n     * @param _partition Name of the partition.\r\n     * @param _operator Address which may be an operator of tokenHolder for the\r\n     * given partition.\r\n     * @param _tokenHolder Address of a token holder which may have the\r\n     * `_operator` address as an operator for the given partition.\r\n     * @return 'true' if 'operator' is an operator of `_tokenHolder` for\r\n     * partition '_partition' and 'false' otherwise.\r\n     */\r\n    function isOperatorForPartition(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _tokenHolder\r\n    ) external view returns (bool) {\r\n        return _isOperatorForPartition(_partition, _operator, _tokenHolder);\r\n    }\r\n\r\n    /**\r\n     * @notice Indicate when the `_operator` address is an operator of the\r\n     * `_collateralManager` address for the given partition.\r\n     * @dev This method is the same as `isOperatorForPartition`, except that it\r\n     * also requires the address that `_operator` is being checked for MUST be\r\n     * a registered collateral manager, and this method will not execute\r\n     * partition strategy operator check hooks.\r\n     * @param _partition Name of the partition.\r\n     * @param _operator Address which may be an operator of `_collateralManager`\r\n     * for the given partition.\r\n     * @param _collateralManager Address of a collateral manager which may have\r\n     * the `_operator` address as an operator for the given partition.\r\n     */\r\n    function isOperatorForCollateralManager(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _collateralManager\r\n    ) external view returns (bool) {\r\n        return\r\n            _isCollateralManager[_collateralManager] &&\r\n            (_isOperator(_operator, _collateralManager) ||\r\n                _authorizedOperatorByPartition[_collateralManager][_partition][_operator]);\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /***************************** Token metadata *****************************/\r\n    /**\r\n     * @notice Get the name of the token (Amp).\r\n     * @return Name of the token.\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the symbol of the token (AMP).\r\n     * @return Symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of decimals of the token.\r\n     * @dev Hard coded to 18.\r\n     * @return The number of decimals of the token (18).\r\n     */\r\n    function decimals() external pure returns (uint8) {\r\n        return uint8(18);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the smallest part of the token thatâs not divisible.\r\n     * @dev Hard coded to 1.\r\n     * @return The smallest non-divisible part of the token.\r\n     */\r\n    function granularity() external pure returns (uint256) {\r\n        return _granularity;\r\n    }\r\n\r\n    /**\r\n     * @notice Get list of existing partitions.\r\n     * @return Array of all exisiting partitions.\r\n     */\r\n    function totalPartitions() external view returns (bytes32[] memory) {\r\n        return _totalPartitions;\r\n    }\r\n\r\n    /************************************************************************************************/\r\n    /******************************** Partition Token Allowances ************************************/\r\n    /**\r\n     * @notice Check the value of tokens that an owner allowed to a spender.\r\n     * @param _partition Name of the partition.\r\n     * @param _owner The address which owns the tokens.\r\n     * @param _spender The address which will spend the tokens.\r\n     * @return The value of tokens still for the spender to transfer.\r\n     */\r\n    function allowanceByPartition(\r\n        bytes32 _partition,\r\n        address _owner,\r\n        address _spender\r\n    ) external view returns (uint256) {\r\n        return _allowedByPartition[_partition][_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve the `_spender` address to spend the specified amount of\r\n     * tokens in `_partition` on behalf of 'msg.sender'.\r\n     * @param _partition Name of the partition.\r\n     * @param _spender The address which will spend the tokens.\r\n     * @param _value The amount of tokens to be tokens.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function approveByPartition(\r\n        bytes32 _partition,\r\n        address _spender,\r\n        uint256 _value\r\n    ) external returns (bool) {\r\n        _approveByPartition(_partition, msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Atomically increases the allowance granted to `_spender` by the\r\n     * caller.\r\n     * @dev This is an alternative to {approveByPartition} that can be used as\r\n     * a mitigation for bugs caused by reentrancy.\r\n     * Emits an {ApprovalByPartition} event indicating the updated allowance.\r\n     * Requirements:\r\n     * - `_spender` cannot be the zero address.\r\n     * @param _partition Name of the partition.\r\n     * @param _spender Operator allowed to transfer the tokens\r\n     * @param _addedValue Additional amount of the `msg.sender`s tokens `_spender`\r\n     * is allowed to transfer\r\n     * @return 'true' is successful, 'false' otherwise\r\n     */\r\n    function increaseAllowanceByPartition(\r\n        bytes32 _partition,\r\n        address _spender,\r\n        uint256 _addedValue\r\n    ) external returns (bool) {\r\n        _approveByPartition(\r\n            _partition,\r\n            msg.sender,\r\n            _spender,\r\n            _allowedByPartition[_partition][msg.sender][_spender].add(_addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Atomically decreases the allowance granted to `_spender` by the\r\n     * caller.\r\n     * @dev This is an alternative to {approveByPartition} that can be used as\r\n     * a mitigation for bugs caused by reentrancy.\r\n     * Emits an {ApprovalByPartition} event indicating the updated allowance.\r\n     * Requirements:\r\n     * - `_spender` cannot be the zero address.\r\n     * - `_spender` must have allowance for the caller of at least\r\n     * `_subtractedValue`.\r\n     * @param _spender Operator allowed to transfer the tokens\r\n     * @param _subtractedValue Amount of the `msg.sender`s tokens `_spender` is\r\n     * no longer allowed to transfer\r\n     * @return 'true' is successful, 'false' otherwise\r\n     */\r\n    function decreaseAllowanceByPartition(\r\n        bytes32 _partition,\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    ) external returns (bool) {\r\n        // TOOD: Figure out if safe math will panic below 0\r\n        _approveByPartition(\r\n            _partition,\r\n            msg.sender,\r\n            _spender,\r\n            _allowedByPartition[_partition][msg.sender][_spender].sub(_subtractedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************ Collateral Manager Admin ************************/\r\n\r\n    /**\r\n     * @notice Allow a collateral manager to self-register.\r\n     * @dev Error 0x5c.\r\n     */\r\n    function registerCollateralManager() external {\r\n        // Short circuit a double registry\r\n        require(!_isCollateralManager[msg.sender], EC_5C_ADDRESS_CONFLICT);\r\n\r\n        collateralManagers.push(msg.sender);\r\n        _isCollateralManager[msg.sender] = true;\r\n\r\n        emit CollateralManagerRegistered(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the status of a collateral manager.\r\n     * @param _collateralManager The address of the collateral mananger in question.\r\n     * @return 'true' if `_collateralManager` has self registered, 'false'\r\n     * otherwise.\r\n     */\r\n    function isCollateralManager(address _collateralManager)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _isCollateralManager[_collateralManager];\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************ Partition Strategy Admin ************************/\r\n    /**\r\n     * @notice Sets an implementation for a partition strategy identified by prefix.\r\n     * @dev This is an administration method, callable only by the owner of the\r\n     * Amp contract.\r\n     * @param _prefix The 4 byte partition prefix the strategy applies to.\r\n     * @param _implementation The address of the implementation of the strategy hooks.\r\n     */\r\n    function setPartitionStrategy(bytes4 _prefix, address _implementation) external {\r\n        require(msg.sender == owner(), EC_56_INVALID_SENDER);\r\n        require(!_isPartitionStrategy[_prefix], EC_5E_PARTITION_PREFIX_CONFLICT);\r\n        require(_prefix != ZERO_PREFIX, EC_5F_INVALID_PARTITION_PREFIX_0);\r\n\r\n        string memory iname = PartitionUtils._getPartitionStrategyValidatorIName(_prefix);\r\n\r\n        ERC1820Client.setInterfaceImplementation(iname, _implementation);\r\n        partitionStrategies.push(_prefix);\r\n        _isPartitionStrategy[_prefix] = true;\r\n\r\n        emit PartitionStrategySet(_prefix, iname, _implementation);\r\n    }\r\n\r\n    /**\r\n     * @notice Return if a partition strategy has been reserved and has an\r\n     * implementation registered.\r\n     * @param _prefix The partition strategy identifier.\r\n     * @return 'true' if the strategy has been registered, 'false' if not.\r\n     */\r\n    function isPartitionStrategy(bytes4 _prefix) external view returns (bool) {\r\n        return _isPartitionStrategy[_prefix];\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /*************************** INTERNAL FUNCTIONS ***************************/\r\n    /**************************************************************************/\r\n\r\n    /**************************************************************************/\r\n    /**************************** Token Transfers *****************************/\r\n\r\n    /**\r\n     * @dev Transfer tokens from a specific partition.\r\n     * @param _fromPartition Partition of the tokens to transfer.\r\n     * @param _operator The address performing the transfer.\r\n     * @param _from Token holder.\r\n     * @param _to Token recipient.\r\n     * @param _value Number of tokens to transfer.\r\n     * @param _data Information attached to the transfer. Contains the destination\r\n     * partition if a partition change is requested.\r\n     * @param _operatorData Information attached to the transfer, by the operator\r\n     * (if any).\r\n     * @return Destination partition.\r\n     */\r\n    function _transferByPartition(\r\n        bytes32 _fromPartition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data,\r\n        bytes memory _operatorData\r\n    ) internal returns (bytes32) {\r\n        require(_to != address(0), EC_57_INVALID_RECEIVER);\r\n\r\n        // If the `_operator` is attempting to transfer from a different `_from`\r\n        // address, first check that they have the requisite operator or\r\n        // allowance permissions.\r\n        if (_from != _operator) {\r\n            require(\r\n                _isOperatorForPartition(_fromPartition, _operator, _from) ||\r\n                    (_value <= _allowedByPartition[_fromPartition][_from][_operator]),\r\n                EC_53_INSUFFICIENT_ALLOWANCE\r\n            );\r\n\r\n            // If the sender has an allowance for the partition, that should\r\n            // be decremented\r\n            if (_allowedByPartition[_fromPartition][_from][_operator] >= _value) {\r\n                _allowedByPartition[_fromPartition][_from][msg\r\n                    .sender] = _allowedByPartition[_fromPartition][_from][_operator].sub(\r\n                    _value\r\n                );\r\n            } else {\r\n                _allowedByPartition[_fromPartition][_from][_operator] = 0;\r\n            }\r\n        }\r\n\r\n        _callPreTransferHooks(\r\n            _fromPartition,\r\n            _operator,\r\n            _from,\r\n            _to,\r\n            _value,\r\n            _data,\r\n            _operatorData\r\n        );\r\n\r\n        require(\r\n            _balanceOfByPartition[_from][_fromPartition] >= _value,\r\n            EC_52_INSUFFICIENT_BALANCE\r\n        );\r\n\r\n        bytes32 toPartition = PartitionUtils._getDestinationPartition(\r\n            _data,\r\n            _fromPartition\r\n        );\r\n\r\n        _removeTokenFromPartition(_from, _fromPartition, _value);\r\n        _addTokenToPartition(_to, toPartition, _value);\r\n        _callPostTransferHooks(\r\n            toPartition,\r\n            _operator,\r\n            _from,\r\n            _to,\r\n            _value,\r\n            _data,\r\n            _operatorData\r\n        );\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        emit TransferByPartition(\r\n            _fromPartition,\r\n            _operator,\r\n            _from,\r\n            _to,\r\n            _value,\r\n            _data,\r\n            _operatorData\r\n        );\r\n\r\n        if (toPartition != _fromPartition) {\r\n            emit ChangedPartition(_fromPartition, toPartition, _value);\r\n        }\r\n\r\n        return toPartition;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer tokens from default partitions.\r\n     * @dev Used as a helper method for ERC20 compatibility.\r\n     * @param _operator The address performing the transfer.\r\n     * @param _from Token holder.\r\n     * @param _to Token recipient.\r\n     * @param _value Number of tokens to transfer.\r\n     * @param _data Information attached to the transfer, and intended for the\r\n     * token holder (`_from`). Should contain the destination partition if\r\n     * changing partitions.\r\n     */\r\n    function _transferByDefaultPartition(\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data\r\n    ) internal {\r\n        _transferByPartition(defaultPartition, _operator, _from, _to, _value, _data, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a token from a specific partition.\r\n     * @param _from Token holder.\r\n     * @param _partition Name of the partition.\r\n     * @param _value Number of tokens to transfer.\r\n     */\r\n    function _removeTokenFromPartition(\r\n        address _from,\r\n        bytes32 _partition,\r\n        uint256 _value\r\n    ) internal {\r\n        if (_value == 0) {\r\n            return;\r\n        }\r\n\r\n        _balances[_from] = _balances[_from].sub(_value);\r\n\r\n        _balanceOfByPartition[_from][_partition] = _balanceOfByPartition[_from][_partition]\r\n            .sub(_value);\r\n        totalSupplyByPartition[_partition] = totalSupplyByPartition[_partition].sub(\r\n            _value\r\n        );\r\n\r\n        // If the total supply is zero, finds and deletes the partition.\r\n        // Do not delete the _defaultPartition from totalPartitions.\r\n        if (totalSupplyByPartition[_partition] == 0 && _partition != defaultPartition) {\r\n            _removePartitionFromTotalPartitions(_partition);\r\n        }\r\n\r\n        // If the balance of the TokenHolder's partition is zero, finds and\r\n        // deletes the partition.\r\n        if (_balanceOfByPartition[_from][_partition] == 0) {\r\n            uint256 index = _indexOfPartitionsOf[_from][_partition];\r\n\r\n            if (index == 0) {\r\n                return;\r\n            }\r\n\r\n            // move the last item into the index being vacated\r\n            bytes32 lastValue = _partitionsOf[_from][_partitionsOf[_from].length - 1];\r\n            _partitionsOf[_from][index - 1] = lastValue; // adjust for 1-based indexing\r\n            _indexOfPartitionsOf[_from][lastValue] = index;\r\n\r\n            _partitionsOf[_from].pop();\r\n            _indexOfPartitionsOf[_from][_partition] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add a token to a specific partition.\r\n     * @param _to Token recipient.\r\n     * @param _partition Name of the partition.\r\n     * @param _value Number of tokens to transfer.\r\n     */\r\n    function _addTokenToPartition(\r\n        address _to,\r\n        bytes32 _partition,\r\n        uint256 _value\r\n    ) internal {\r\n        if (_value == 0) {\r\n            return;\r\n        }\r\n\r\n        _balances[_to] = _balances[_to].add(_value);\r\n\r\n        if (_indexOfPartitionsOf[_to][_partition] == 0) {\r\n            _partitionsOf[_to].push(_partition);\r\n            _indexOfPartitionsOf[_to][_partition] = _partitionsOf[_to].length;\r\n        }\r\n        _balanceOfByPartition[_to][_partition] = _balanceOfByPartition[_to][_partition]\r\n            .add(_value);\r\n\r\n        if (_indexOfTotalPartitions[_partition] == 0) {\r\n            _addPartitionToTotalPartitions(_partition);\r\n        }\r\n        totalSupplyByPartition[_partition] = totalSupplyByPartition[_partition].add(\r\n            _value\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Add a partition to the total partitions collection.\r\n     * @param _partition Name of the partition.\r\n     */\r\n    function _addPartitionToTotalPartitions(bytes32 _partition) internal {\r\n        _totalPartitions.push(_partition);\r\n        _indexOfTotalPartitions[_partition] = _totalPartitions.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a partition to the total partitions collection.\r\n     * @param _partition Name of the partition.\r\n     */\r\n    function _removePartitionFromTotalPartitions(bytes32 _partition) internal {\r\n        uint256 index = _indexOfTotalPartitions[_partition];\r\n\r\n        if (index == 0) {\r\n            return;\r\n        }\r\n\r\n        // move the last item into the index being vacated\r\n        bytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\r\n        _totalPartitions[index - 1] = lastValue; // adjust for 1-based indexing\r\n        _indexOfTotalPartitions[lastValue] = index;\r\n\r\n        _totalPartitions.pop();\r\n        _indexOfTotalPartitions[_partition] = 0;\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /********************************* Hooks **********************************/\r\n    /**\r\n     * @notice Check for and call the 'AmpTokensSender' hook on the sender address\r\n     * (`_from`), and, if `_fromPartition` is within the scope of a strategy,\r\n     * check for and call the 'AmpPartitionStrategy.tokensFromPartitionToTransfer'\r\n     * hook for the strategy.\r\n     * @param _fromPartition Name of the partition to transfer tokens from.\r\n     * @param _operator Address which triggered the balance decrease (through\r\n     * transfer).\r\n     * @param _from Token holder.\r\n     * @param _to Token recipient for a transfer.\r\n     * @param _value Number of tokens the token holder balance is decreased by.\r\n     * @param _data Extra information, pertaining to the `_from` address.\r\n     * @param _operatorData Extra information, attached by the operator (if any).\r\n     */\r\n    function _callPreTransferHooks(\r\n        bytes32 _fromPartition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data,\r\n        bytes memory _operatorData\r\n    ) internal {\r\n        address senderImplementation;\r\n        senderImplementation = interfaceAddr(_from, AMP_TOKENS_SENDER);\r\n        if (senderImplementation != address(0)) {\r\n            IAmpTokensSender(senderImplementation).tokensToTransfer(\r\n                msg.sig,\r\n                _fromPartition,\r\n                _operator,\r\n                _from,\r\n                _to,\r\n                _value,\r\n                _data,\r\n                _operatorData\r\n            );\r\n        }\r\n\r\n        // Used to ensure that hooks implemented by a collateral manager to validate\r\n        // transfers from it's owned partitions are called\r\n        bytes4 fromPartitionPrefix = PartitionUtils._getPartitionPrefix(_fromPartition);\r\n        if (_isPartitionStrategy[fromPartitionPrefix]) {\r\n            address fromPartitionValidatorImplementation;\r\n            fromPartitionValidatorImplementation = interfaceAddr(\r\n                address(this),\r\n                PartitionUtils._getPartitionStrategyValidatorIName(fromPartitionPrefix)\r\n            );\r\n            if (fromPartitionValidatorImplementation != address(0)) {\r\n                IAmpPartitionStrategyValidator(fromPartitionValidatorImplementation)\r\n                    .tokensFromPartitionToValidate(\r\n                    msg.sig,\r\n                    _fromPartition,\r\n                    _operator,\r\n                    _from,\r\n                    _to,\r\n                    _value,\r\n                    _data,\r\n                    _operatorData\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Check for 'AmpTokensRecipient' hook on the recipient and call it.\r\n     * @param _toPartition Name of the partition the tokens were transferred to.\r\n     * @param _operator Address which triggered the balance increase (through\r\n     * transfer or mint).\r\n     * @param _from Token holder for a transfer (0x when mint).\r\n     * @param _to Token recipient.\r\n     * @param _value Number of tokens the recipient balance is increased by.\r\n     * @param _data Extra information related to the token holder (`_from`).\r\n     * @param _operatorData Extra information attached by the operator (if any).\r\n     */\r\n    function _callPostTransferHooks(\r\n        bytes32 _toPartition,\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data,\r\n        bytes memory _operatorData\r\n    ) internal {\r\n        bytes4 toPartitionPrefix = PartitionUtils._getPartitionPrefix(_toPartition);\r\n        if (_isPartitionStrategy[toPartitionPrefix]) {\r\n            address partitionManagerImplementation;\r\n            partitionManagerImplementation = interfaceAddr(\r\n                address(this),\r\n                PartitionUtils._getPartitionStrategyValidatorIName(toPartitionPrefix)\r\n            );\r\n            if (partitionManagerImplementation != address(0)) {\r\n                IAmpPartitionStrategyValidator(partitionManagerImplementation)\r\n                    .tokensToPartitionToValidate(\r\n                    msg.sig,\r\n                    _toPartition,\r\n                    _operator,\r\n                    _from,\r\n                    _to,\r\n                    _value,\r\n                    _data,\r\n                    _operatorData\r\n                );\r\n            }\r\n        } else {\r\n            require(toPartitionPrefix == ZERO_PREFIX, EC_5D_PARTITION_RESERVED);\r\n        }\r\n\r\n        address recipientImplementation;\r\n        recipientImplementation = interfaceAddr(_to, AMP_TOKENS_RECIPIENT);\r\n\r\n        if (recipientImplementation != address(0)) {\r\n            IAmpTokensRecipient(recipientImplementation).tokensReceived(\r\n                msg.sig,\r\n                _toPartition,\r\n                _operator,\r\n                _from,\r\n                _to,\r\n                _value,\r\n                _data,\r\n                _operatorData\r\n            );\r\n        }\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /******************************* Allowance ********************************/\r\n    /**\r\n     * @notice Approve the `_spender` address to spend the specified amount of\r\n     * tokens in `_partition` on behalf of 'msg.sender'.\r\n     * @param _partition Name of the partition.\r\n     * @param _tokenHolder Owner of the tokens.\r\n     * @param _spender The address which will spend the tokens.\r\n     * @param _amount The amount of tokens to be tokens.\r\n     */\r\n    function _approveByPartition(\r\n        bytes32 _partition,\r\n        address _tokenHolder,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) internal {\r\n        require(_tokenHolder != address(0), EC_56_INVALID_SENDER);\r\n        require(_spender != address(0), EC_58_INVALID_OPERATOR);\r\n\r\n        _allowedByPartition[_partition][_tokenHolder][_spender] = _amount;\r\n        emit ApprovalByPartition(_partition, _tokenHolder, _spender, _amount);\r\n\r\n        if (_partition == defaultPartition) {\r\n            emit Approval(_tokenHolder, _spender, _amount);\r\n        }\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /************************** Operator Information **************************/\r\n    /**\r\n     * @dev Indicate whether the operator address is an operator of the\r\n     * tokenHolder address. An operator in this case is an operator across all\r\n     * partitions of the `msg.sender` address.\r\n     * @param _operator Address which may be an operator of '_tokenHolder'.\r\n     * @param _tokenHolder Address of a token holder which may have the '_operator'\r\n     * address as an operator.\r\n     * @return 'true' if `_operator` is an operator of `_tokenHolder` and 'false'\r\n     * otherwise.\r\n     */\r\n    function _isOperator(address _operator, address _tokenHolder)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (_operator == _tokenHolder ||\r\n            _authorizedOperator[_tokenHolder][_operator]);\r\n    }\r\n\r\n    /**\r\n     * @dev Indicate whether the operator address is an operator of the\r\n     * tokenHolder address for the given partition.\r\n     * @param _partition Name of the partition.\r\n     * @param _operator Address which may be an operator of tokenHolder for the\r\n     * given partition.\r\n     * @param _tokenHolder Address of a token holder which may have the operator\r\n     * address as an operator for the given partition.\r\n     * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition\r\n     * `_partition` and 'false' otherwise.\r\n     */\r\n    function _isOperatorForPartition(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _tokenHolder\r\n    ) internal view returns (bool) {\r\n        return (_isOperator(_operator, _tokenHolder) ||\r\n            _authorizedOperatorByPartition[_tokenHolder][_partition][_operator] ||\r\n            _callPartitionStrategyOperatorHook(_partition, _operator, _tokenHolder));\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the `_partition` is within the scope of a strategy, and\r\n     * call it's isOperatorForPartitionScope hook if so.\r\n     * @dev This allows implicit granting of operatorByPartition permissions\r\n     * based on the partition being used being of a strategy.\r\n     * @param _partition The partition to check.\r\n     * @param _operator The address to check if is an operator for `_tokenHolder`.\r\n     * @param _tokenHolder The address to validate that `_operator` is an\r\n     * operator for.\r\n     */\r\n    function _callPartitionStrategyOperatorHook(\r\n        bytes32 _partition,\r\n        address _operator,\r\n        address _tokenHolder\r\n    ) internal view returns (bool) {\r\n        bytes4 prefix = PartitionUtils._getPartitionPrefix(_partition);\r\n\r\n        if (!_isPartitionStrategy[prefix]) {\r\n            return false;\r\n        }\r\n\r\n        address strategyValidatorImplementation;\r\n        strategyValidatorImplementation = interfaceAddr(\r\n            address(this),\r\n            PartitionUtils._getPartitionStrategyValidatorIName(prefix)\r\n        );\r\n        if (strategyValidatorImplementation != address(0)) {\r\n            return\r\n                IAmpPartitionStrategyValidator(strategyValidatorImplementation)\r\n                    .isOperatorForPartitionScope(_partition, _operator, _tokenHolder);\r\n        }\r\n\r\n        // Not a partition format that imbues special operator rules\r\n        return false;\r\n    }\r\n\r\n    /**************************************************************************/\r\n    /******************************** Minting *********************************/\r\n    /**\r\n     * @notice Perform the minting of tokens.\r\n     * @dev The tokens will be minted on behalf of the `_to` address, and will be\r\n     * minted to the address's default partition.\r\n     * @param _operator Address which triggered the issuance.\r\n     * @param _to Token recipient.\r\n     * @param _value Number of tokens issued.\r\n     */\r\n    function _mint(\r\n        address _operator,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        require(_to != address(0), EC_57_INVALID_RECEIVER);\r\n\r\n        _totalSupply = _totalSupply.add(_value);\r\n        _addTokenToPartition(_to, defaultPartition, _value);\r\n        _callPostTransferHooks(\r\n            defaultPartition,\r\n            _operator,\r\n            address(0),\r\n            _to,\r\n            _value,\r\n            \"\",\r\n            \"\"\r\n        );\r\n\r\n        emit Minted(_operator, _to, _value, \"\");\r\n        emit Transfer(address(0), _to, _value);\r\n        emit TransferByPartition(bytes32(0), _operator, address(0), _to, _value, \"\", \"\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ApprovalByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"toPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ChangedPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralManager\",\"type\":\"address\"}],\"name\":\"CollateralManagerRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizedAddress\",\"type\":\"address\"}],\"name\":\"OwnershipTransferAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"flag\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"PartitionStrategySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferByPartition\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowanceByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approveByPartition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assumeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"authorizeOperatorByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorizedAddress\",\"type\":\"address\"}],\"name\":\"authorizeOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authorizedNewOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOfByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_interfaceHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canImplementInterfaceForAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collateralManagers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowanceByPartition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPartition\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowanceByPartition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralManager\",\"type\":\"address\"}],\"name\":\"isCollateralManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralManager\",\"type\":\"address\"}],\"name\":\"isOperatorForCollateralManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorForPartition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_prefix\",\"type\":\"bytes4\"}],\"name\":\"isPartitionStrategy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"partitionStrategies\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"partitionsOf\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerCollateralManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperatorByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_prefix\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"setPartitionStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapToken\",\"outputs\":[{\"internalType\":\"contract ISwapToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokenGraveyard\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPartitions\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"totalSupplyByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"transferByPartition\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Amp","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004a57e687b9126435a9b19e4a802113e266adebde000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000003416d7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003414d500000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://46f1197cc0a6e3d6399ed22c3480b4059302d3180614e1c23cf41dc5ac022197"}]